(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';

exports.grid = [
'.hypergrid-input {',
'	position: absolute;',
'	display: none;',
'	outline: 0;',
'	padding: 0;',
'	border: solid 2px black;',
'	box-sizing: border-box;',
'	box-shadow: white 0 0 1px 1px;',
'	background-color: ivory;',
'	color: black;',
'	font-size: 7pt;',
'	line--height: 0;',
'}',
'div.hypergrid-input > input {',
'	position: absolute;',
'	height: 100%;',
'	right: 20px;',
'	left: 0;',
'	width: 100%;',
'	outline: 0;',
'	padding: 0;',
'',
'	border: 5px solid transparent;',
'	border-right-width: 20px;',
'	border-bottom-width: 0;',
'	border-top-width: 0;',
'	box-sizing: border-box;',
'',
'	font-size: 7pt;',
'	line--height: 0;',
'	color: black;',
'	background-color: transparent;',
'}',
'div.hypergrid-input > span {',
'	position: absolute;',
'	box-sizing: border-box;',
'	width: 20px;',
'	height: 100%;',
'	right: 0;',
'	text-align: center;',
'	font-size: 15px;',
'	line-height: 11px;',
'}',
'div.hypergrid-input span[title] {',
'	color: lightgrey;',
'	cursor: pointer;',
'}',
'div.hypergrid-input span[title]:hover {',
'	color: grey;',
'}',
'div.hypergrid-input span[title]:active, div.hypergrid-input span[title].active {',
'	color: blue;',
'}',
'div.hypergrid-input > span::after {',
'	content: \'\\25BE\';',
'	font-size: 20px;',
'}',
'div.hypergrid-input > div {',
'	position: absolute;',
'	height: 137px;',
'	left: -2px;',
'	right: -2px;',
'	top: 13px;',
'	height: 0;',
'	transition: height .25s;',
'	visibility: hidden;',
'	box-shadow: white 0 0 1px 1px;',
'	box-sizing: border-box;',
'	border: 2px solid black;',
'	background-color: ivory;',
'	-webkit-user-select: none;',
'	-moz-user-select: none;',
'	-ms-user-select: none;',
'}',
'div.hypergrid-input > div > div {',
'	position: absolute;',
'	height: 13px;',
'	width: 100%;',
'	text-align: center;',
'}',
'div.hypergrid-input > div span[title] {',
'	font-weight: bold;',
'	font-size: 10px;',
'	font-family: verdana, geneva, sans-serif;',
'	margin-left: 6px;',
'	margin-right: 6px;',
'}',
'div.hypergrid-input > div span:not([title]) {',
'	font-style: italic;',
'	padding-top: 1px;',
'}',
'div.hypergrid-input > div select {',
'	position: absolute;',
'	border: 0;',
'	outline: 0;',
'	border-top: 2px solid black;',
'	width: 100%;',
'	bottom: 0;',
'	top:14px;',
'	background-color: transparent;',
'}'
].join('\n');

exports['list-dragon-addendum'] = [
'div.dragon-list, li.dragon-pop {',
'	font-family: Roboto, sans-serif;',
'	text-transform: capitalize; }',
'div.dragon-list {',
'	position: absolute;',
'	top: 4%;',
'	left: 4%;',
'	height: 92%;',
'	width: 20%; }',
'div.dragon-list:nth-child(2) { left: 28%; }',
'div.dragon-list:nth-child(3) { left: 52%; }',
'div.dragon-list:nth-child(4) { left: 76%; }',
'div.dragon-list > div, div.dragon-list > ul > li, li.dragon-pop { line-height: 46px; }',
'div.dragon-list > ul { top: 46px; }',
'div.dragon-list > ul > li:not(:last-child)::before, li.dragon-pop::before {',
'	content: \'\\2b24\';',
'	color: #b6b6b6;',
'	font-size: 30px;',
'	margin: 8px 14px 8px 8px; }',
'li.dragon-pop { opacity:.8; }'
].join('\n');

},{}],2:[function(require,module,exports){
'use strict';

exports.CQL = [
'<li>',
'	<label title="${1}">',
'		<a type="button" class="filter-copy"></a>',
'		<div class="filter-tree-remove-button" title="delete conditional"></div>',
'		<strong>%{0}:</strong>',
'		<input name="${1}" class="filter-text-box ${3}" value="%{2}">',
'	</label>',
'	<div class="filter-tree-warn"></div>',
'</li>'
].join('\n');

exports.SQL = [
'<li>',
'	<label title="${1}">',
'		<a type="button" class="filter-copy"></a>',
'		<div class="filter-tree-remove-button" title="delete conditional"></div>',
'		<strong>%{0}:</strong>',
'		<textarea name="${1}" rows="1" class="filter-text-box ${3}">%{2}</textarea>',
'	</label>',
'	<div class="filter-tree-warn"></div>',
'</li>'
].join('\n');

exports.dialog = [
'<div id="hypergrid-dialog">',
'',
'	<style>',
'		#hypergrid-dialog {',
'			position: absolute;',
'			top: 0;',
'			left: 0;',
'			bottom: 0;',
'			right: 0;',
'			background-color: white;',
'			font: 10pt sans-serif;',
'			opacity: 0;',
'			transition: opacity 1s;',
'			box-shadow: rgba(0, 0, 0, 0.298039) 0px 19px 38px, rgba(0, 0, 0, 0.219608) 0px 15px 12px;',
'		}',
'		#hypergrid-dialog.hypergrid-dialog-visible {',
'			opacity: 1;',
'			transition: opacity 1s;',
'		}',
'',
'		#hypergrid-dialog .hypergrid-dialog-control-panel {',
'			position: absolute;',
'			top: 0px;',
'			right: 12px;',
'		}',
'		#hypergrid-dialog .hypergrid-dialog-control-panel a {',
'			color: #999;',
'			font-size: 33px;',
'			transition: text-shadow .35s, color .35s;',
'			text-decoration: none;',
'		}',
'		#hypergrid-dialog .hypergrid-dialog-close:after {',
'			content: \'\\D7\';',
'		}',
'		#hypergrid-dialog .hypergrid-dialog-settings:after {',
'			font-family: Apple Symbols;',
'			content: \'\\2699\';',
'		}',
'		#hypergrid-dialog .hypergrid-dialog-control-panel a:hover {',
'			color: black;',
'			text-shadow: 0 0 6px #337ab7;',
'			transition: text-shadow .35s, color .35s;',
'		}',
'		#hypergrid-dialog .hypergrid-dialog-control-panel a:active {',
'			color: #d00;',
'			transition: color 0s;',
'		}',
'	</style>',
'',
'	<span class="hypergrid-dialog-control-panel">',
'		<a class="hypergrid-dialog-settings" title="(There are no settings for Manage Filters at this time.)"></a>',
'		<a class="hypergrid-dialog-close"></a>',
'	</span>',
'',
'</div>'
].join('\n');

exports.filterTrees = [
'<style>',
'	#hypergrid-dialog > div {',
'		position: absolute;',
'		top: 0;',
'		left: 0;',
'		bottom: 0;',
'		right: 0;',
'	}',
'	#hypergrid-dialog > div:first-of-type {',
'		padding: 1em 1em 1em 0.5em;',
'		margin-left: 50%;',
'	}',
'	#hypergrid-dialog > div:last-of-type {',
'		padding: 1em 0.5em 1em 1em;',
'		margin-right: 50%;',
'	}',
'	#hypergrid-dialog > div > p:first-child {',
'		margin-top: 0;',
'	}',
'	#hypergrid-dialog > div > p > span:first-child {',
'		font-size: larger;',
'		letter-spacing: 2px;',
'		font-weight: bold;',
'		color: #666;',
'		margin-right: 1em;',
'	}',
'	#hypergrid-dialog input, #hypergrid-dialog textarea {',
'		outline: 0;',
'		line-height: initial;',
'	}',
'',
'	.tabz { z-index: 0 }',
'	.tabz > p:first-child, .tabz > section > p:first-child, .tabz > section > div > p:first-child { margin-top: 0 }',
'',
'	#hypergrid-dialog a.more-info { font-size: smaller; }',
'	#hypergrid-dialog a.more-info::after { content: \'(more info)\'; }',
'	#hypergrid-dialog a.more-info.hide-info { color: red; }',
'	#hypergrid-dialog a.more-info.hide-info::after { content: \'(hide info)\'; }',
'	#hypergrid-dialog div.more-info {',
'		border: 1px tan solid;',
'		border-radius: 8px;',
'		padding: 0 8px .2em;',
'		display: none;',
'		background-color: ivory;',
'		box-shadow: 3px 3px 5px #707070;',
'		margin-bottom: 1em;',
'	}',
'	#hypergrid-dialog div.more-info > p { margin: .5em 0; }',
'',
'	#hypergrid-dialog .tabz ul {',
'		padding-left: 1.5em;',
'		list-style-type: circle;',
'		font-weight: bold;',
'	}',
'	#hypergrid-dialog .tabz ul > li > ul {',
'		list-style-type: disc;',
'		font-weight: normal;',
'	}',
'	#hypergrid-dialog .tabz li {',
'		margin: .3em 0;',
'	}',
'	#hypergrid-dialog .tabz li > code {',
'		background: #e0e0e0;',
'		margin: 0 .1em;',
'		padding: 0 5px;',
'		border-radius: 4px;',
'	}',
'',
'	#hypergrid-dialog .tabz > section.filter-expression-syntax > div:last-child ol {',
'		padding-left: 1.6em;',
'	}',
'	#hypergrid-dialog .tabz > section.filter-expression-syntax > div:last-child ol > li > label {',
'		width: 100%;',
'		font-weight: normal;',
'		display: inline;',
'	}',
'	#hypergrid-dialog .tabz .filter-tree-warn {',
'		color: darkred;',
'		font-size: smaller;',
'		font-style: italic;',
'		line-height: initial;',
'	}',
'	#hypergrid-dialog .tabz > section.filter-expression-syntax > textarea,',
'	#hypergrid-dialog .tabz > section.filter-expression-syntax > div:last-child textarea,',
'	#hypergrid-dialog .tabz > section.filter-expression-syntax > div:last-child input {',
'		display: block;',
'		position: relative;',
'		min-width: 100%;',
'		max-width: 100%;',
'		box-sizing: border-box;',
'		border: 1px solid black;',
'		padding: .4em .7em;',
'		font-family: monospace;',
'		font-size: 9pt;',
'		margin-top: 3px;',
'	}',
'	#hypergrid-dialog .tabz > section.filter-expression-syntax > textarea {',
'		height: 96%;',
'	}',
'	#hypergrid-dialog .tabz a.filter-copy {',
'		display: block;',
'		float: right;',
'		font-size: smaller;',
'	}',
'	#hypergrid-dialog .tabz a.filter-copy:before {',
'		content: \'(copy\';',
'	}',
'	#hypergrid-dialog .tabz a.filter-copy:after {',
'		content: \')\';',
'	}',
'	#hypergrid-dialog .tabz a.filter-copy:active {',
'		color: red;',
'	}',
'</style>',
'',
'<div>',
'	<select id="add-column-filter-subexpression" style="float:right; margin-left:1em; margin-right:4em;">',
'		<option value="">New column filter&hellip;</option>',
'	</select>',
'',
'	<p>',
'		<span>Column Filters</span>',
'		<a class="more-info"></a>',
'	</p>',
'	<div class="more-info">',
'		<p>The table filter can be viewed in the Query Builder or as SQL WHERE clause syntax. Both interfaces manipulate the same underlying filter data structure.</p>',
'		<p>All column filters are AND&rsquo;d together. Each grid row is first qualified by the table filter and then successively qualified by each column filter subexpression.</p>',
'	</div>',
'',
'	<div class="tabz" id="columnFiltersPanel">',
'',
'		<header id="columnsQB" class="default-tab">',
'			Query Builder',
'		</header>',
'',
'		<section>',
'		</section>',
'',
'		<header id="columnsSQL" class="tabz-bg2">',
'			SQL',
'		</header>',
'',
'		<section class="filter-expression-syntax tabz-bg2">',
'			<div>',
'				<p>',
'					<span></span>',
'					<a type="button" class="filter-copy" title="The state of the column filters subtree expressed in SQL syntax (all the column filter subexpressions shown below AND&rsquo;d together).">',
'						all</a>',
'				</p>',
'				<ol></ol>',
'			</div>',
'		</section>',
'',
'		<header id="columnsCQL" class="tabz-bg1">',
'			CQL',
'		</header>',
'',
'		<section class="filter-expression-syntax tabz-bg1">',
'			<p>',
'				<em>',
'					<small>Column filter cells accept a simplified, compact, and intuitive syntax, which is however not as flexible or concise as SQL syntax or using the Query Builder.</small>',
'					<a class="more-info"></a>',
'				</em>',
'			</p>',
'			<div class="more-info">',
'				<ul>',
'					<li>',
'						Simple expressions',
'						<ul>',
'							<li>All simple expressions take the form <i>operator literal</i> or <i>operator identifier</i>. The (left side) column is always implied and is the same for all simple expressions in a compound expression. This is because column filters are always tied to a known column.</li>',
'',
'							<li>If the operator is an equals sign (=), it may be omitted.</li>',
'',
'							<li>Besides operators, no other punctuation is permitted, meaning that no quotation marks and no parentheses.</li>',
'',
'							<li>If a literal exactly matches a column name or alias, the operand is not taken literally and instead refers to the value in that column. (There are properties to control what constitutes such a match: Column name, alias, or either; and the case-sensitivity of the match.)</li>',
'',
'							<li>As literals are unquoted, any operator symbol or operator word (including logical operators for compound expressions) terminates a literal.</li>',
'',
'							<li>An important corollary to the above features is that operators may not appear in literals.</li>',
'						</ul>',
'					</li>',
'',
'					<li>',
'						Compound expressions',
'						<ul>',
'							<li>Compound expressions are formed by connecting simple expressions with the logical operators <code>AND</code>, <code>OR</code>, <code>NOR</code>, or <code>NAND</code> ("not and").</li>',
'',
'							<li>However, all logical operators used in a compound column filter expression must be homogeneous. You may not mix the above logical operators in a single column. (If you need to do this, create a table filter expression instead.)</li>',
'						</ul>',
'					</li>',
'',
'					<li>',
'						Hidden logic',
'						<ul>',
'							<li>If the column is also referenced in a table filter expression (on the left side of a simple expression), the column filter is flagged in its grid cell with a special star character. This is just a flag; it is not part of the syntax. <span style="color:red; font-style:italic">Not yet implemented.</span></li>',
'						</ul>',
'					</li>',
'				</ul>',
'			</div>',
'',
'			<div>',
'				<p><span></span></p>',
'				<ol></ol>',
'			</div>',
'		</section>',
'	</div>',
'</div>',
'',
'<div>',
'	<p>',
'		<span>Table Filter</span>',
'		<a class="more-info"></a>',
'	</p>',
'	<div class="more-info">',
'		<p>The table filter can be viewed in the Query Builder or as SQL WHERE clause syntax. Both interfaces manipulate the same underlying filter data structure.</p>',
'		<p>',
'			These filter subexpressions are both required (<code>AND</code>&rsquo;d together), resulting in a subset of <em>qualified rows</em> which have passed through both filters.',
'			It\'s called a <dfn>tree</dfn> because it contains both <dfn>branches</dfn> and <dfn>leaves</dfn>.',
'			The leaves represent <dfn>conditional expressions</dfn> (or simply <dfn>conditionals</dfn>).',
'			The branches, also known as <dfn>subtrees</dfn>, contain leaves and/or other branches and represent subexpressions that group conditionals together.',
'			Grouped conditionals are evaluated together, before conditionals outside the group.',
'		</p>',
'	</div>',
'',
'	<div class="tabz" id="tableFilterPanel">',
'		<header id="tableQB">',
'			Query Builder',
'		</header>',
'',
'		<section>',
'		</section>',
'',
'		<header id="tableSQL" class="tabz-bg2">',
'			SQL',
'		</header>',
'',
'		<section class="filter-expression-syntax tabz-bg2">',
'			<div>',
'				<p>',
'					SQL WHERE clause syntax with certain restrictions.',
'					<a class="more-info"></a>',
'				</p>',
'				<div class="more-info">',
'					<ul>',
'						<li>',
'							Simple expressions',
'							<ul>',
'								<li>All simple expressions must be of the form <i>column operator literal</i> or <i>column operator identifier</i>. That is, the left side must refer to a column (may not be a literal); whereas the right side may be either.</li>',
'',
'								<li>Column names may be quoted with the currently set quote characters (typically double-quotes). If unquoted, they must consist of classic identifier syntax (alphanumerics and underscore, but not beginning with a numeral).</li>',
'',
'								<li>All literals must be quoted strings (using single quotes). (In a future release we expect to support unquoted numeric syntax for columns explicitly typed as numeric.)</li>',
'							</ul>',
'						</li>',
'',
'						<li>',
'							Compound expressions',
'							<ul>',
'								<li>Compound expressions are formed by connecting simple expressions with the logical operators <code>AND</code> or <code>OR</code>.</li>',
'',
'								<li>However, all logical operators at each level in a complex expression (each parenthesized subexpression) must be homogeneous, <i>i.e.,</i> either <code>AND</code> or <code>OR</code> but not a mixture of the two. In other words, there is no implicit operator precedence; grouping of expressions must always be explicitly stated with parentheses.</li>',
'',
'								<li>The unary logical operator <code>NOT</code> is supoorted before parentheses only. While the Query Builder and the Column Filter allow they syntax <code>&hellip; NOT <i>operator</i> &hellip;</code> (where <code><i>operator</i></code> is <code>IN</code>, <code>LIKE</code>, <i>etc.</i>), these must be expressed here with parenthethes: <code>NOT (&hellip; <i>operator</i> &hellip;)</code>.</li>',
'',
'								<li>While the Query Builder and Column Filter syntax support the pseudo-operators <code>NOR</code> and <code>NAND</code>, in SQL these must be expressed as <code>NOT (&hellip; OR &hellip;)</code> and <code>NOT (&hellip; AND &hellip;)</code>, respectively.</li>',
'',
'								<li>The Query Builder and Column Filter syntax also support the pseudo-operators <code>BEGINS abc</code>, <code>ENDS xyz</code>, and <code>CONTAINS def</code>. These are expressed in SQL by <code>LIKE \'abc%\'</code>, <code>LIKE \'%xyz\'</code>, and <code>LIKE \'%def%\'</code>, respectively.</li>',
'							</ul>',
'						</li>',
'					</ul>',
'				</div>',
'			</div>',
'			<div class="filter-tree-warn"></div>',
'			<textarea></textarea>',
'		</section>',
'',
'	</div>',
'</div>'
].join('\n');

},{}],3:[function(require,module,exports){
module.exports = { // This file generated by gulp-imagine-64 at 11:54:25 PM on 7/17/2016
	"Hyperblotter Tabled Reduced Rows": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAtQAAADnCAYAAAA+XMHaAAAMF2lDQ1BJQ0MgUHJvZmlsZQAASImVVwdYU8kWnltSCAktEAEpoTdBepXeBQHpYCMkAUIJIRBU7MiigmsXC1Z0BUTBtQCyVkSxsAjY6wYRFWVdLNhQeZME0HVf+d75vrnz58w5Z/5z7szNDACK9iyBIBNVAiCLnyeMDPRhxickMkligABlQAJugMFi5wq8IyJCAZTR/u/y7ia0hnLNUhLrn+P/VZQ53Fw2AEgExMmcXHYWxEcBwDXZAmEeAIQOqDeYnSeQ4LcQqwohQQCIZAlOlWEtCU6WYWupTXSkL8R+AJCpLJYwFQAFSXxmPjsVxlEQQGzN5/D4EO+C2IOdxuJALIZ4QlZWNsSKVIhNk7+Lk/q3mMljMVms1DEsy0UqZD9eriCTNff/LMf/lqxM0egc+rBR04RBkZKcYd2qMrJDJBhyR07wk8PCIVaB+CKPI7WX4LtpoqCYEft+dq4vrBlgAIACDssvBGJYS5QhyojxHsG2LKHUF9qjYby84OgRnCzMjhyJj+bzM8NCR+IsT+MGj+Id3Fz/qFGbFF5AMMRwpaFHC9Ki42Q80ZZ8XmwYxAoQd+RmRIWM+D4sSPMNG7URiiIlnA0hfpsiDIiU2WDqWbmjeWFWbJZ0LnWIvfLSooNkvlg8Nzc+dJQDh+vnL+OAcbj8mBFuGFxdPpEjvsWCzIgRe2wHNzMwUlZn7FBuftSob1ceXGCyOmCP0lmTI2T8sXeCvIhoGTccB6HAF/gBJhDBlgyyQTrgtfc39MNfspEAwAJCkAq4wHJEM+oRJx3hw2cUKAB/QsQFuWN+PtJRLsiH+i9jWtnTEqRIR/OlHhngCcRZuCbugbvhofDpBZst7oy7jPoxFUdnJfoT/YhBxACi2RgPNmSdCZsQ8P6NLgT2XJidhAt/NIdv8QhPCJ2ER4QbBDHhDogFj6VRRqxm8QqFPzBngilADKMFjGSXDGP2jdrgxpC1A+6Du0P+kDvOwDWBJW4PM/HGPWFuDlD7PUPRGLdvtfxxPgnr7/MZ0SuYKziMsEgeezO+Y1Y/RvH9rkYc2If8aIktx45grdhZ7BJ2AmsATOw01oi1YScleGwlPJauhNHZIqXcMmAc3qiNdY11n/Xnf8zOGmEglL5vkMedkyfZEL7ZgrlCXmpaHtMbfpG5zGA+22oC09baxhEAyfdd9vl4w5B+txHG5W+6nDMAuJRAZeo3HcsAgONPAKC/+6YzeA231xoATnawRcJ8mQ6XPAiAAhThztAAOsAAmMKcbIEj/B/xAv5gMggH0SABzIRVTwNZkPVsMB8sAcWgFKwBG8FWsBPsAVXgIDgMGsAJcBZcAFdAB7gB7sG10QtegAHwDgwhCEJCaAgd0UB0ESPEArFFnBEPxB8JRSKRBCQJSUX4iAiZjyxFSpF1yFZkN1KN/IocR84il5BO5A7SjfQhr5FPKIZSUVVUGzVGJ6LOqDcagkajM9BUNActQIvQVehmtAI9gNajZ9Er6A1UjL5ABzGAyWMMTA+zxJwxXywcS8RSMCG2ECvByrAKrBZrgu/6GibG+rGPOBGn40zcEq7PIDwGZ+M5+EJ8Jb4Vr8Lr8Rb8Gt6ND+BfCTSCFsGC4EoIJsQTUgmzCcWEMsI+wjHCebh3egnviEQig2hCdIJ7M4GYTpxHXEncTqwjniF2EnuIgyQSSYNkQXInhZNYpDxSMWkL6QDpNKmL1Ev6QJYn65JtyQHkRDKfXEguI+8nnyJ3kZ+Sh+SU5IzkXOXC5Thyc+VWy+2Va5K7KtcrN0RRpphQ3CnRlHTKEspmSi3lPOU+5Y28vLy+vIv8VHme/GL5zfKH5C/Kd8t/pKpQzam+1OlUEXUVtZJ6hnqH+oZGoxnTvGiJtDzaKlo17RztIe2DAl3BSiFYgaOwSKFcoV6hS+GlopyikaK34kzFAsUyxSOKVxX7leSUjJV8lVhKC5XKlY4r3VIaVKYr2yiHK2cpr1Ter3xJ+ZkKScVYxV+Fo1KkskflnEoPHaMb0H3pbPpS+l76eXqvKlHVRDVYNV21VPWgarvqgJqKmr1arNoctXK1k2piBsYwZgQzMhmrGYcZNxmfxmmP8x7HHbdiXO24rnHv1cere6lz1UvU69RvqH/SYGr4a2RorNVo0HigiWuaa07VnK25Q/O8Zv941fFu49njS8YfHn9XC9Uy14rUmqe1R6tNa1BbRztQW6C9Rfucdr8OQ8dLJ11ng84pnT5duq6HLk93g+5p3edMNaY3M5O5mdnCHNDT0gvSE+nt1mvXG9I30Y/RL9Sv039gQDFwNkgx2GDQbDBgqGs4xXC+YY3hXSM5I2ejNKNNRq1G741NjOOMlxk3GD8zUTcJNikwqTG5b0oz9TTNMa0wvW5GNHM2yzDbbtZhjpo7mKeZl5tftUAtHC14FtstOicQJrhM4E+omHDLkmrpbZlvWWPZbcWwCrUqtGqwejnRcGLixLUTWyd+tXawzrTea33PRsVmsk2hTZPNa1tzW7Ztue11O5pdgN0iu0a7V/YW9lz7Hfa3HegOUxyWOTQ7fHF0chQ61jr2ORk6JTltc7rlrOoc4bzS+aILwcXHZZHLCZePro6uea6HXf9ys3TLcNvv9mySySTupL2Tetz13Vnuu93FHkyPJI9dHmJPPU+WZ4XnIy8DL47XPq+n3mbe6d4HvF/6WPsIfY75vPd19V3ge8YP8wv0K/Fr91fxj/Hf6v8wQD8gNaAmYCDQIXBe4JkgQlBI0NqgW8Hawezg6uCByU6TF0xuCaGGRIVsDXkUah4qDG2agk6ZPGX9lPthRmH8sIZwEB4cvj78QYRJRE7Eb1OJUyOmlk99EmkTOT+yNYoeNStqf9S7aJ/o1dH3YkxjRDHNsYqx02OrY9/H+cWtixPHT4xfEH8lQTOBl9CYSEqMTdyXODjNf9rGab3THaYXT785w2TGnBmXZmrOzJx5cpbiLNasI0mEpLik/UmfWeGsCtZgcnDytuQBti97E/sFx4uzgdPHdeeu4z5NcU9Zl/Is1T11fWpfmmdaWVo/z5e3lfcqPSh9Z/r7jPCMyozhzLjMuixyVlLWcb4KP4Pfkq2TPSe7U2AhKBaIc1xzNuYMCEOE+3KR3Bm5jXmq8KjTJjIV/STqzvfIL8//MDt29pE5ynP4c9rmms9dMfdpQUDBL/Pweex5zfP15i+Z373Ae8HuhcjC5IXNiwwWFS3qXRy4uGoJZUnGkt8LrQvXFb5dGre0qUi7aHFRz0+BP9UUKxQLi28tc1u2czm+nLe8fYXdii0rvpZwSi6XWpeWlX5eyV55+Webnzf/PLwqZVX7asfVO9YQ1/DX3FzrubZqnfK6gnU966esr9/A3FCy4e3GWRsvldmX7dxE2STaJN4curlxi+GWNVs+b03beqPcp7xum9a2Fdveb+ds79rhtaN2p/bO0p2fdvF23d4duLu+wriibA9xT/6eJ3tj97b+4vxL9T7NfaX7vlTyK8VVkVUt1U7V1fu19q+uQWtENX0Hph/oOOh3sLHWsnZ3HaOu9BA4JDr0/NekX28eDjncfMT5SO1Ro6PbjtGPldQj9XPrBxrSGsSNCY2dxycfb25yazr2m9VvlSf0TpSfVDu5+hTlVNGp4dMFpwfPCM70n00929M8q/neufhz11umtrSfDzl/8ULAhXOt3q2nL7pfPHHJ9dLxy86XG644Xqlvc2g79rvD78faHdvrrzpdbexw6WjqnNR5qsuz6+w1v2sXrgdfv3Ij7EbnzZibt29NvyW+zbn97E7mnVd38+8O3Vt8n3C/5IHSg7KHWg8r/jD7o07sKD7Z7dfd9ijq0b0eds+Lx7mPP/cWPaE9KXuq+7T6me2zE30BfR3Ppz3vfSF4MdRf/Kfyn9temr48+pfXX20D8QO9r4Svhl+vfKPxpvKt/dvmwYjBh++y3g29L/mg8aHqo/PH1k9xn54Ozf5M+rz5i9mXpq8hX+8PZw0PC1hClvQogMGGpqQA8LoSAFoCPDvAexxFQXb/kgoiuzNKEfhPWHZHkwo8uVR6ARCzGIBQeEbZAZsRxFTYS47f0V4AtbMbayOSm2JnK4tFhbcYwofh4TfaAJCaAPgiHB4e2j48/GUvJHsHgDM5snufRIjwjL/LTILa2yjgR/kXHo1sePUmjJ0AAEAASURBVHgB7J0FfFTHE8d/F4cEdw/u0OLu7u4uLdqiLbTQ0qKlFOePtlCgaIEWLVpci7u7BAuSEE/+MxvuuAuX5HK5JHe52Q/h3r23u2/3++69Nzs7M6spXbFFGCQJASEgBISAEBACQkAICAEhYBYBB7NKSSEhIASEgBAQAkJACAgBISAEFAERqOWHIASEgBAQAkJACAgBISAEYkFABOpYwJOiQkAICAEhIASEgBAQAkJABGr5DQgBISAEhIAQEAJCQAgIgVgQEIE6FvCkqBAQAkJACAgBISAEhIAQEIFafgNCQAgIASEgBISAEBACQiAWBJyiK5s5U3o0qFcNGo1GZX367AW27diHwIAgLPttCs6ev4Ip0xZFV40cFwJCQAgIASEgBISAEBACVknAwUGD7FlS48nTN/AnGVebMqZPjoCAYHi/fqfdZfQzWg01C9Tdu7RE8mQeCAsLQ9/e7dGvd0ejlRnbOX7MEPxv5g/qUN48ObB/10qUKlHEWFbZJwSEgBAQAkJACAgBISAE4pWAhoTpYoWyoXCBLChbMjfc3JzV+T2zpkGJYp4oUzIXUqdyj7JN0WqouXRISCg2btmF6zfuIm2aVChpRCBOntwDDetVhbu7O85duILjJ86hQvkSyJ0rO9ySuNKxasifPxecnBxRv25V3L7zAO/e+aFh/epIlSoFfb+PXXsOI18eT6q/KAnvobh77xGOHDsdZQfkoBAQAkJACAgBISAEhIAQMJeAA1lhpEqZVBX3cHdB2RK58eiJN/LmykAWGoCTowNSp/TAS2/fSE8RrYZav2TKlMmRL19O3Lp9X383SfKumPnLaNSrU1Vpsn+e8DXq1KqEd75+8PP3J1V5IN76+OLVq7dKy/3q9VsEh4Rg5Fd90bhRDTg4OGDE8M/RqH41sBZ78BfdULtmJaROndzgPPJFCAgBISAEhIAQEAJCQAhYkgArjk+cvg1//3BTDxaq8+UOF6b5PPcevsTNu0+jPKVJGmoXFycsWThZSemBQcGY/b+lBpUWKZwPnp5Z0avPN7hx8y6Skba6VfN6+Kz/KDx69BSpUqfA/oMn8PjJU3Tr3AJHjp6CI0n7Fcp9itE/TFda6Dykya5WpRz+3XcEb9744IuhY+HrG7W9ikEj5IsQEAJCQAgIASEgBISAEDCDgI9vAI6duoXypfPAxdlRV8P9h964cOUhwkLDdPuMbZikoQ4MDEa33l+hQrW22LZ9H4YO6mlQV9IkbkoLzcI0p4uXrpN2OYVBnohf0qROiSRUbsqkETj072plHuLi6qKyhYSGijAdEZh8FwJCQAgIASEgBISAEIgzAmnTJIczmSbrp1Qp3eFKiuXoUvQ5ItRw4cJV1KhWPsJeKI2zh0dS+Pi8QzIPdwQGfvCQ/Cgz7WAHx6DgYAwaOg5nzl3WZWE7bElCQAgIASEgBISAEBACQiC+CHhmT4dC+TIpaww+ZyjJqWxbrbWpPnbqps4kxFibTNJQawsqM43yJfHihbd2l/q8ffeBCqtXr3ZlckpMiiqVSuHCxevqWEBgIBlzh0v7wSRAh5KzoSN9f/z4GZl2vEWliqVUviqVSqNQwTwG9coXISAEhIAQEAJCQAgIASEQlwScycQjfwSb6QNHrusEaBaqc5HAHVUySaDW2lAf2L0KxYsVxPTZSwzqvH//MebMXY6+n3XEjs2LVVSQhb+tVnn2HTiGQoXy4MfvvsQ9ysdmIZMnfo1MFI5vNpVp3KAGDu9djRHDPkf6dGkM6pUvQkAICAEhIASEgBAQAkIgLgkEBYXg3KX7CCU7aXZAZJtpH19/ZVPNjoqv3rzDjdteUTZBU7pii6itrKMsLgeFgBAQAkJACAgBISAEhIDtE2BLDDb10HdA5Eh0ZKishO2oehhjG+qoKpNjQkAICAEhIASEgBAQAkLAFglw+LyIKZQCZZiSTDL5MKUiySMEhIAQEAJCQAgIASEgBOyRgAjU9njVpc9CQAgIASEgBISAEBACFiMgArXFUEpFQkAICAEhIASEgBAQAvZIQARqe7zq0mchIASEgBAQAkJACAgBixEQgdpiKKUiISAEhIAQEAJCQAgIAXskIAK1PV516bMQEAJCQAgIASEgBISAxQiIQG0xlFKREBACQkAICAEhIASEgD0ScPJ6/Mge+y19FgJCQAgIASEgBISAEBACFiGgcXXLZicrJWoImJ101SI/DalECAgBISAEhIAQEAJCwBQCYvJhCiXJIwSEgBAQAkJACAgBISAEIiEgAnUkYGS3EBACQkAICAEhIASEgBAwhYAI1KZQkjxCQAgIASEgBISAEBACQiASAiJQRwJGdgsBISAEhIAQEAJCQAgIAVMIiEBtCiXJIwSEgBAQAkJACAgBISAEIiEgAnUkYGS3EBACQkAICAEhIASEgBAwhYAI1KZQkjxCQAgIASEgBISAEBACQiASAiJQRwJGdgsBISAEhIAQEAJCQAgIAVMIJKhA7ejsgQzF2pvSTqTKVR1J0uQ1Ka9kEgJCQAgIgYQlkKFwS7gkSZOwjZCzCwELEdA4OCLTJ53g4OBioRrtt5qYyH62RMlsgTpZ5hL4tPsOlOixG3nr/QQHJ7cY99vR1QMZTRWoc1ZD0jR5YnwOKWB/BLKV/wIFmsyhjvPqmECumj8gTb76alv+EwJCIGYEkqTIjuJdtqBEz39RdsBpte1ZdWS0laQjgdoxSepo80mGhCXAws0nXbeZJSjygIkHToktObomQ8HmC+k3v0fJOSzvaOCIDMU7QuMoArWx652+cAslC2qPJc9aCkXbrYZGE/4e1u7nz5jIfvrlrH3bbIHas8oIXN86FKd+q6X6mDZfgwTta+ZPm6Py0B1IXyi8PQnaGDl5ghPgGQ2PDEUSvB3SACFg6wT8Xt/D2aUNcXP7SLy6c1Bt39k30da7Je23AAEeMPHAKbGl7BUH4+2D/3Dq1xq48c/X8Kz2LTQOZotLiQ2P0f68unsIHhk/1Q3MUmavgpc3diEsLMxo/sS408n8ToXByS0VFQ/D/SNz1Kgtf+NZeHbpLzDY4p3+xsU/u6Jwq6UI9PVC0rT58PzKZvBIzyVZRlzd2B8Bbx7ByT2NGsW4pswOfkg/v7yRtIn1kKPScICmWB4enw+vcyujbGbGYg2Qp2Z/0mBnQ766Q0lb7oIn57ZGWUYOJm4Czy79jaxl++Lqpv66jvKUXa5aPyJ55lJ0k4fi6t/9EBLsh6LtVyPw7RMkSeUJrwvrkSpnVTg4J8GltR0RQPtzVB2BlJ5VVT3XN38B3+dXdXXKhhCwVwLGntN8b+VtNB3Bvs/h5JFeoXFJmgb5Gs2EU9K0CHzzEFfo2V+ItH93D/4CP+/b6vl/7o9mCAnys1eUVtdvY89K/zcPkIdmoz3SF0FwwCtc3zIEnlWGqXd7hqJt4XV+tdX1w9wG8e/4Gj3rOfl6XcQLkl2gcSKRxAUFmv5P9fke/X69LqxVs5/ZKw4lgZvklWNzaN+fNIuzGUF0DyRNlw9PTi3Fg+Pz1HtHe2/w++XKxgEIC/FHvobTSWObHD6PT+HGjm8QFhpibrMTtFygz1MEvXtGbPLC99llpMxZGde3DQPPgORrNA1uKT0R5PcC16jf+ql4p424/NdnCAnwQdEOa3FuWVPkbfALnJOkgmuqHPB5dAaOLu5Imr4gHh2bh0enf1fv6BxVv1HX4/HJX/H4zHL9KhNs2+wh1529E5Gzxndqap0FZL+XN/Dixk6kyFERSVPnJmH5IYLfvaQfoYY02UNwYW1npM5bBxfWdMDtPT8gXYEmqtNhQf5K8L6wsg2ylOxJ8N2Rrfwgle/s7w2QqUQ3uLiHP5gjo/Ts8l6cWNgZz67ux/GFncDfJdk3Ad+nFxEaEohkWUrpQPBv6/W9Izi9pB6e0UMvdd7a6lhoUAD93jrh5u7vkTxLCZxd1gjPLrJgXQPu6QrALUU2nKEy9w9NRcYSXXT1yYYQsFcCbOJn7DmdtVw/9bw/t6Ilgny8FB5HMgu4d3gG3UN1SVgIhnva/Hh5czdSZq9As0iF4fP0ggjTVvZDMvasdEuehZQOOXHm93p4dHIxnEjgubN/Ct49v5aohGntpQgJ9leboaGBeHRqMQm/ger7rV2j6X3REemLtFLfWZA+v6IFLv3ZBRmKtgvfRwYi9+k3z8JhWpJ1NA7OyFLmM9zYOgx8b4QEvVP5Mpf+DPcOzcDpxXXg4pGJ7o0Car9t/hcG71t7SflUGa7JMpHo5wD/V3eIU0v4Pb9BfaxNA5MtyFymj0ndY+anF9WEe6ZiuHdwKs4tb460ZFbCLLOW7Y9LJEueW95UmeGYY3JsUiNimMlsDfXbJ2foAVlHwWOt3+1dY/Dm7mFkIhujwOyP8Or2PtUUfoCGBJLmQeNIArY3QkkLEfzuFZxJa8EpJNAXofTDDfJ9Rg/bULA2g3+4ge8fxsHvXtDoLYXKG9l//OMM8A2merjci8iyyX57IkDTTA+PzUX2ysOUlpm7HhLkq2ZIMn3SmTTQ7jQdtUMR4d9fWGiQ+l3yKJu118F+L0mjlgauKXMgedYySuPAmV/fPajKyH9CwJ4JOLmlNPqcdiYttP+re3QPhahnPTMKIa1UzmojAHqRJqEBKr/8vG/9i5w1v1czQbwtyboIGHtW+pOSzPfZJRRpt5YEzF/hSwMht1R5rKvhcdwaVtIE+rJM4kG/4yTqbCyvFG69nLSzz+n3nDR8H2mZA94+fi/7aEi81pDATIpHEjD17w1WPqaoUZ6UPwGqnIbkJFtOL2/tQe5aPxCjZ8o8jLXtSVLnwuv7R1W33j2/rt6npvQxJIBkQxrMhPi9RiCxZQ02zxA4kX17kjS5UajVMrKPCCPGPkp4N6XOuM5jlkDt5JaCjM9/JrONAfAmwTlpmnxInq0MXj84Rp17i7QFm+DapvDpElM7oHF0ph+oKz2kg9TUCY/6+GLwKIc2TK1G8gkBHQE2zQj290aKbOVIM32YtM2FkISmnc6vakcDvw5KYNZljmSDH5beN3fhOtnRSRICQuA9ARqA8jM64nOaFSgODoavlbQFm+HN/eNq2jt/o1mqAv/X9+nl6EbTwlXx+NQSwWplBIw9Kx2c3UjrOpOuryOZfkxR7+V3z29aWcst05xg/1dwS56NFHRPyPQgNZkFkinCH80/qlxpS8sNwOX1PZXSsGCzBR/l0e7gd4ljBIdG3neDfNHeep3VZrPpT9ZIaxxcka5gU5qVmq76wgorJzJx4aRxJLmOBtuxSiQPsjnN+ZWtdJr+WNVnwcKGTz4TKw4JeEPa4HfwrDEaPg9PkADdlKZ+2EmFVP6395OKvw34gWnKaMstZVZkLkFmHTx6875BmuYnNLJ7SNOJX5LGkLTNZDISQHVJEgLmEHhwdB5plzepojyT4ZIiKzLQVB070njf3httlT6PzyqHlAxF2yhzJNZcP738d7TlJIMQSMwEgug+MPac5oFrtgpf4A29F9xSeyoE/L5ISU7rGQPe0uC2DJ6c+UO9VN+QAoZ9agL5OS8pQQmwTW/qvLVII8gzyr7KpyTis9KNTBLy1J+ChycWKHM6bjAr0Jzd05HpTjH4eJ1L0D5Y8uRsbpCD7MMfn16GVJ4V1bsilMxTP0o8ExMcgHSFmtNsZnYSGJ0/yqLdwVrarOUHqHuD7Yw5ed/ZT/fLQHhdXEea29J4eHSOTd8PrAR98+A40hZqAt8nF1QfX17fQbNRYxBCylI2//A6t0rt1/7nT07PGUnBxYNz1vxHl9jiwd/7FnH7kszFLpKZTEEym5miFLDRlY3r445OTinGmHOSlzd2w5kM6flH9OT0UoJ4TFXjxOYZdFO+uneQhGH+FwafJ+dUZ1l97+t1gXeTU8Nbsqu5TrbWD8KnBgnm/SOzqKg/aQR3K1st1ljf2f+TmqpnwdrP+46aijfWXr4YGYvUi8IZ8ePQLcbqkX22T4Cn19iGn51hWUPNjlCsrWY7f//Xd9Vv6+nlDTRF9wL+L++oaSWD3+WL61SDhrQTT/HuxTVysj1I3svF1bTc8yub6LccZPuQpAdCIIYEdM9tuj84GXtOc2QEF/e0SpnCdtL+ZF/79slpNVXLmuvn17aATQd4YOpKvjdsZ/328ekYtkSyW5IAX1eeSncmXyWXpOngSO9dnnmO+Kx88+gk3j29TIOgT2g6fz9eXt+uhG92UOTIaP6v7lqyWQlalz/JGv4vb8MjU3HllPiIHN9YYRhRnvHxOk+zL0fIUbOwMgcMeP2ATGEu0oAxTAmUrIEmgUgNNt7cP6G7N1w8MpAfwR4yjf1XDWKS0hobr+8dovfUtQTttyVOzg7+/N5kx0RObPryjt6/yWjQ9eL6P/Tc2MMode/dtzT4Tkp+FX4vb+IdOYDywIz5+dFzJpgG45xYONdnyc8WNwrnyb/X51c2qne5ypjA/2lc3bJZLKaJR/qiNKobjrsHpsT7aJUF6gxKoN4SCVJ+bFisq5GcQ3YLASEgBIRAdAQ4ikKOysNxY/tXZFeaeASx6Potx+2XQMoclcieODcpZvyR6dPu5MjIzom+9gskEfbcogJ1qpxVVPg8jj1ofUkEauu7JtIiISAE7JEAh9xjJyOe/ZEkBOyBAM+4pyP/Muek6UmruolmAO7ZQ7ftqo8WFaitm5wI1NZ9faR1QkAICAEhIASEgBCwTQJmx6G2ze5Kq4WAEBACQkAICAEhIASEgGUJiEBtWZ5SmxAQAkJACAgBISAEhICdERCB2s4uuHRXCAgBISAEhIAQEAJCwLIERKC2LE+pTQgIASEgBISAEBACQsDOCIhAbWcXXLorBISAEBACQkAICAEhYFkCIlBblqfUJgSEgBAQAkJACAgBIWBnBESgtrMLLt0VAkJACAgBISAEhIAQsCwBTZFmK+1k+UCJQ23Zn47UJgSEgBAQAkJACAgBIcAEnNIVbikkhIAQEAJCQAgIASEgBISAEDCTgJh8mAlOigkBISAEhIAQEAJCQAgIASbgdP/wzHgnERLwBsH0F79JTD7il7ecTQgIASEgBGJEgFVcouYyDVkoZeM/SUIgEgKuybNGciRudmtc3bKJDXXcsJVahYAQEAJCQAiYToCFaUfTs9t1zhDqvQjUdv0TsLbOy1jY2q6ItEcICAEhIASEgBAQAkLApgiIQG1Tl0saKwSEgBAQAkJACAgBIWBtBESgtrYrIu0RAkJACAgBISAEhIAQsCkCIlDb1OWSxgoBISAEhIAQEAJCQAhYGwERqK3tikh7hIAQEAJCQAgIASEgBGyKgAjUNnW5pLFCQAgIASEgBISAEBAC1kZABGpruyLSHiEgBISAEBACQkAICAGbIiACtU1dLmmsEBACQkAICAEhIASEgLUREIHa2q6ItEcICAEhEAMCw4b2x9o1i5A2TeoYlJKsQkAICAEhYEkCjk5OKcZYskLrrYuXHpckBISAEEg8BDw8PLB06UyUKFEM1apVxLNnL3D12k2r6WCO7NkwcsQX8PZ+hcePvaymXVbbEH5NiZrLtMvDazzbyTrPpgGRXAlNQJYeT+grIOcXAkJACJhBoHixQpg1ayKWLFkNHx8f7NlzEMOG9UeFCqUxbtxU7Ni514xaTSvi5uaK1q2a4Ny5izh77pIqlCVLJuTInhU5cvBfNuTO7anakjt3Dnh5PcfFi1dw9+6D93/3cfPmHbXt9fQZuGyN6pWwbdtuPH/x0rRGJMZcLEzL0uOmXVlZetw0TpIr3ghYrUBdr251lCr1CVat/gs3btyOFIgnPbg7dmyFCxcu4e+N2yPNB/DQX4azUQCSQ3ZIILr758H9MySs+aJAwYoJSif8efApNm78B+fOhwtwCdqgBD75wAE9UadOdfTtNxwPHjw2aE3GDOmVYJ0/f278/PMc7D9wxOC4Jb40aVwXa9YsxIsX3rh06RocHR3x8OFjJSTfu/cQd+7cw917D+Dr8w4jRgzE4sWrcJHy5ciRBblzecLTMxuyvxe+M2ZMh1y0L0uWjFi+/E/06j3EEk20zTqsSKB2dXNB21bNcPTYSVy7/vGsR8MGtfBJsSIIDQ3F4SMnsM+E31nqVCnQoX0rpEyRHI8ePcEfq9chwD/Q4Fply5YZbVo1hZurK65cvYF1GzYbHNd9iQeBOixjEBxyBiEsiCSIy0kQ5mvCTDdfw4L+0KQMRegzR2huuAKhulaHbzjTRyE/aNzDEPrYCZo7LjYnngzo3xMpU6aI0LHwr3z/L//jT/XFyckRbds0Q86c2dW7ZNWqv/DE66lBOVe61h07tETmzBnh5+dPsty2KOU+LszvhE8/LQYHB43Ku279ZgQH84/iQ2rZohEKFMgLf/8Ael79jfsPHn44GGGrcaM6KF68CP75Zzf+O3k2wlHTvlqtQH3wwCYSqIuTpmUaxo2fFmlvBn35OSZN+pa0H9dQslStSPOJQB0FGjlktwSiu3+sRaCeNnUs+vbtil69BtODep3dXi+2k164cCoOHz6BadMX0AuE3vSRJBasR5C5BQvWEyfOJKHnPzg5OaiXSyRFTN7NA7FDhzZj5MjxWLpsjcnlIsvYoH5N9O7dWWms+QU8aPB3UfYtsnpsfr8VCNQsSHfp2AbDh/RH9mxZ0KpdD2zeussA7bgxIzB0cF/1W+LBlKOjA0aOnoCZsxca5NP/koWEpV3b/lSCVVBQEJydndVgr3nrbvB956eyflK8MP7ZtAopSOAODgmBs5MTfl28Av2/HKFfVfh2HAvUmk/94FqHBN43YXAgmZiT30pXaLycwr8Y+58EZad2vnDKBIR402RDKiD4ZhiCN3h8EKrdwuDc6R0cU9KuN2Thk0qDoAthCNnqblNCNcto2bNnMaDAv4M09IzatGkHWrfpRc8bR6xZvQgNGtREUFCw+v748VPUrNUSt2/fU2Xd3ZNiw/rFqFKlPN6+9YW7exL4+r5Dw4YdcfzEaYP6tV9mTB+Pzz7rRHUGISQkFEmSuGHDhq3o3KW/TqheRM/JTp1a6c776tVr1KrVmgb2V7XV6D7Tp0uLEye2I0OGdBg0aDTmzf9ddywmG3z7Wl0qVDAfChfOp9rVrFn9KNvXokUDdTxvXk+UJDtCSUJACJhOQO4f01kldE42iVhPL55Jk2bi5ylzohU4WQs0aPAoDBg4El26tIHXk/O4e+ck2O46tqly5XKqHZYQprktW8nUo3mLbqq9V0kruWzpbHr5shpPUnwSyJ8vDy6c2o9Z0yaQYETSoJHEefp+3g3nLlxG7oJlUbBYRTx6/ARDv+yD1KmNl+FqRn8zRJkCDfv6B6RKnxfLV/yJKpXLo1vX9rqzTJsyloSjJGhGQna2XJ/i2IlT6NqlLWrXrKrLEy8bScLgUiUUQafCEDjPHf5z3ZXw61zZP1w3F0kjNEX84JSeBO+lLgha6A6/9U5wyk1a7VwBuhKaUn5wpFvQ71c3BC6gurc4wLkwydKZIh8c6wpb0Ualyo2RPUcJg79Jk2YhLCwMK1asVy1lDXH9+jXwBylBUqXOi+HDfwTPSP00abSuJ40a1gY/T377bSXSpS+Ixo07w8XFBWPGDNfl0d+oXasqevbsQAP64yTQl6ABWimcPHkOTZvWAx/jVKd2NbRv3wLbt+9FxkxF0KPHICRL5oGZM8frV6XbHjiwlxKmdTvM3LBKgZpHKjwFwFqYPHly4hNSwxtLfKxw4fwqn6OjE2rWrGIsm+wTAkLACAG5f4xAsbJdGdKnU4LlpImj6KXQAU2adMax46di1Eq2Ve7VezDZMT8jYdodnTu1jlF5Y5nbtGmKlSs3GDsU632zZv+KtWv/xsoV8ywi/Me6QXZUQUbS0LFNe5sOvbF0ufGZh7JlSpAWMSnmL1yKly+98ZBMN9au24z06dOidMnikdKqWaMKHjx8hN9+/4O0z6GYNnO+mt5v2ayhKpMntyeKFy2EEydPY/uOf8EaxUmTZ8FBo0GLZuGKs0grt/CBsGyB0JBWOvi0W7jWmOThoPMOcMpKwrFr5KajDvlICH8YBs2T8MGg5pYrQllTnTs4vIUkcTnloTy3SC73fm8sf9UNoe9IU53LtgRqY8g7d26tnjP//ntIHW7VqrHSEM+du0RpjufNX0LmGXdQqVJZpEpJKnpKLVs2UnkWL16pvu/ec4AsDq6So3VRpEuXRu3T/69x4zpqRuSXX+bi1es36m/evN/J9MMBhQrlV1lZuKafDQnQC5W2e+WqDTh9+gKZiBRF3jy59KtTMya9e3fEnTv3Dfab88UqBepWrRrh+fOXYEguLs7Ke91Y5/gGTZo0CebPX4onT7zoZVPXWDbZJwSEgBEC5tw/qVOlxG+/Tof3y2vw97uHJ48vUBSHLw1qZ1u4G9ePqeNvXt/E+nWLkS1rZoM8PMV//txe+L27C5+3t/HPtlXKoc0gUxRfWKvB558/bwrVs09tez25gN69OhmU+vqrgXj08Jw6/vrVDSxZPBPcB1tIs8nh8O7dkzh1cieuXbuFTp37qZeHuW0vVrwG2SkXR+vWjc2tQpXLk8dT2ULGpfPgepq+XblynZoKtoRGPVYdtqPCbAddqVpjbNy8PdJef/pJUaWF1LdHvXTpCgkwGmTJbHifaythR1W2m37w4BHevSMtLyWeen9Cg7ycntnV9yyZM5EizY3stUnafJ8uX7lK+d+hUMFwQUm7P64/HVKFAoEaaN6+F3rphKEvaduV5Otkhna6uraQNOWYgr7p+9RSNSGvSADXyoVUhUNyDUJfkLSnTSRHh7HpRzrKbMOpXNmSKFgwLzkW02Do9WvVk6z03Pf19dVFHmIb53PkxJw8eTJlisaZ2JeCr7H+db91644aTOf0zPERkV279uO77yYbmG74+YWbDLH9NSf2yeBt9ufQpv/+O6tMQ9iWWz8NHtRHacTXr9+qv9usbasTqNnbu1ixwjh27BS2/bNHjXa009IRe8ijkJcvX4EB7917RJmJsLmIJCEgBKInYM79M2PGeJpKa44tW3bS9N0P4On50aOH6LSebVo3oQHuFLJrCyH73XFKi1mXnEdWr16oBr/cKraTXLZsjpraZRtcnh7kWalffvkh+kZHyMEakbNnL2Dq1Pn0Qncgn4uRKmIEZ+vXtztNGw7DrVt38dVXP+Kvv7aBNauT9KYbI1RnFV9Z8GCNdI0alRAQEKg4/kZ2pLFNbG/NGp3jx0+rKVFz6+Mp+iVLVppb3ORyLFSPGTOZYmwvBNuDS7IOAmnJFCQ0lEwhAj9oVLUCFCvAokoa0iLqp9ckeLEttX5iTaM23aGoMP7ktOjqSk578Zg0SUMQRn00cCZ8914IdopEQ03CsoYV2h+whLfYTwMH5/dlnEOh4e6+V1hruxTqR8ejMM3W5rPmT9ZG87VbvXqDQTN5oKV/TTm0J+9jKwROKVOSvTwJ2q/p2aRNz569VHnYNjpi2rhpuzJ50xeWa9Wqpuo4r+ewzufgP23idxV/1/+NFi1SkOysW9KM2CZyrr6izWr254dfrtlVWLZgdYqlmjy5h+rg27c+OHr0lDLr4Olp/ZQ5UwZyWixGhuRn8IKmndj7383NTb2Y9fPJthAQAh8TMOf+4amyhg1r4dSp86Qt7Q+emu/ZaxBpAvzQoUMLdRK2RQsODqbIO/0wfcYCfN5nGD1g/6aptiI6+7aGpF3ml+iIEWNVnn79v6KB81MaSBf6uKHR7Nm+fY9qyzffjld2eilSJENxGpBz6tWrIz2k3yrnmJmzFqFrt4G4fPmasuljezprSyxIj/p2CD37flVmbIUKV0aKlHnIvniXRZs6b94ScujpbFadbNdctWp57N5zyKzyMS10iMz+OAQg245bWqjm0H+8IM6ypXPEXjumFyaG+TlcIg/mcpE2OgVpJzlxhIh0abWqW5DpyGMaQPqjGJl9aFPBAvl0A3HtPvm0PgKscW7RoqFSXhw8dEzXQJ6R4BmmYkUL6vZF1BDrDpi5wb+X1q0b4cyZ8zhwMPzcrOFmYTxfvly6WksaMUf69tvBShCf9NNMXb7YbFidQM2jnDdvfHDo8HHVr3Vkm8X2Wjw9rZ8qVSqnpg3Wr9+idh8kkK9evQGbi0gSAkIgagLm3D/8IOSH1NmzF3WVsz0ce0UvXLhMeebnzZtT2aL9d/KMLs8m0iiwZqAsTQlyGj9hOpKnyI0/6d7mxNoJ1sSy+VZM0507D3RFWAPBKRWF5kqZIgWFYMpAodyeGCwowlOF3333k66MNWxoBemNG5eruM6167QGa2HiKt25e19N2efO7RnjU9SpXVXFu44qukiMK42mAAvV3bt/SbMas5E/X+5ockd/mAcFbHK0+LcZ5ABVR5nA1KheMfqCkiNWBHbu3qccv74aNpBMQzJixi/jdLNJXPENsvU/TbNNxUhr+HmvLshFz5t5s38y67kQq4ZK4RgTqFmjMjJlSo9Vq/5Wz3NtBWvWbFT2ziPILJCvOZsH1qplKMtp85rzybLh3LmTaUDspGbytHXwbCRH/xg58ksyN8xCs5Xd0LZtE+1h9Vm+XCmKPlJDherURhwxyGDGF6uaZEhDHsJly5agl2sAundrr7rDRums8eLp6fkLftd1sV27Zir+ZfnypZQNDh9gTRmbi7DZCMdElSQEhIBxAubcPzxVxoIxC7/6adnyteorh1LjEFoc81M/sVmWNrSRdn+Xzm3oYfeFWgREOx3IfhOWSDzLx9OI3BYOq6Sftmzdqf81QbazZs2E5uRkxZEtWLBjzQ7Haa5RsyU96wzbG1cNZP+U3r06Y8TIsTE6BZvYjBw5LkZlLJH56rUbGDDgGwrHtYzst99RCMXh5Jx52uSqWYiuUrksCc9NaMazAHbu3ItRoydhOoUeZE01RxTYQ45U8cXf5IYnoozjJvyCShXKYCjZrPIfOzM+fvKUTEc+PE++GPwttm9ZjRlTw39jF2kankOovaHZaknWS6Bbt7bqvbB58w6DRm74awuZ2jVA8+YNKEb9cWXXfIls5zk29Js3H0w8DArF4MvYH79GyZLF8NNPs3GQon5o085d+8gsbZWKBnL9+hHl9HiBotIUJ3ND/j1x+v774WS77UczrYu0xWL9aVUCNU8lau1pvvqqv65zbBvJ5h08Tf2Ilq9lpyIWvCk6C00tt9TLp6GpZCew2Yg2qLjuoGwIASGgCMT3/cOCOAff1yZ2Wpw3b7LyuuY487xwE9tUm6Oh1tZpS5+9epIgO2IACYg9MX78dNSu0zbeBTn2pB81arASJiMOgCJjyTGwPTySgjXcCZFYqOYZB1aijBo1hGYu3WmABxW7lk0K7tFCMnepbeytz4ve8AqNCxcuV+Gz+EX6778HlaP7WVrdUZs4AgqnjRt3kBKnLRYuWq6+y3+RE2BHQr6f9W1RtREb9O2qI9bwiOIPV67eBA0bhJt8HT32H/bt/kstBqTNy46KJcvWQv16tWjBlwA8ffYcf6/7nZxyb2qzxMtnqA8tyOJAAob+HL77e6fB4A/PMoPGhJDJNfnGKRtp/QNJaX/Q+zJBDgjj8UMEycuB88RevtQ/a7xt58njiYoVy+D8+cu0auqHe4sbwLOP7Tv0oWteSy3awpYE7GPDK7veeh+HmhUuLPdx7HGtHXX69GnULJrWydBYZ9q1bUqma12we/cBjB33y0dZOFwoa6p5ZvW//84oAVo5Kt5/iHJlS1GbSyt58fKlgwZlp08fS7Oun5m1mFmEy2pQb7x/ad26qRpJVK/eHCdPndOdf8jgPpgw4RsKtVIOayicEscsTJ06JX744Rfo276wgfmBA3+T2UdjEah19GRDCBgSMPf+YQ0yPyAzZjR0EONIG97er5W2k82uOM4o29S9efNWnZhXv2LNNtu1cWrZsrHSWH/55ShakSrcNIRXW7NkYqGPV3hk8w/9xFOOBQrkwdCh38doiWsOJ8Y2oKYKn/rnjLgdEhJMz6mjJBROinEIvIh1xeY7h73jEHqmCpHsjLpy5V+xOWWsy7Zu3UtFBzh2/IxuEMIa5hzZs6nZjty5c1K4rWK0SEwnZSrINvTsQKn/PjHWCPYH2LP7T7Jf36ius7E8si+cwBkyy+D7OX/e3GBNIKeCFIWD4w8/fPQoPFMk/7+mZ8KKVevV0e5d25E9dXJs3mY4a+T19DmWLF2l8kz48RsS3h2x9R/L+hFE0rwPu1VED1ohMUUwNE/DxSQV+YMm3/Qjf3woQFv0CAujiB6adCQ8s/zMfogkkHPkj5B773MGUzYKgOGQPhQkf4cnclLUJKPIHzffC93a/Tby2ahhXRpouyvTiciavOX9wkBFaHaoSJECKoa0Vnhmp/FixQqiIGmteVVOTjlz5lBC9+07d41WyT51U2mxryc0w9GbVlbl95KxtGv3frWbrRbKlv2UfGiuqwEcC9ZDhnynfsfacryQIMfrZzOVrVt3a3fH6FN//BWjgpbOzC/gChVKqTAnER9+HMCbp255mppTCwoWzlPIPNrRT+dJpc82lay9ZvMRSUJACHxMwNz7h7VHbEpVmabOC+TPoypuS1EzeJaInQE57dy5TwncHIqIEzuSDRzYU02taWOThoWFKrs6raNxh/YtVQxbVcCC/x0noYsfpJ06tlK15sqVA/37d0dRcpDhkG+8itdntDpfu7bNozwra2B27FhD4eti/1JnHhy9o36DjgkqTHOHV5BArXUmjRLA+4McIWV9ZMtAm1KBBfLwdWOban3TDB7ksPZ6x869mDtvMQ3sxql43T16DFYLxUR8nxhrBtfHi1KwraekqAmwto+nzXt27wiO+MG2sW3JlOYpCcIn3i/ZzIPqIbTQS8XypT+qzIlW0+vQrgUmjh2lFoRZvWbDR3ncyZ9i+JB+GNCvB06fOYe9++PHCVbXkEfOCKMIbE4lWYKmvRSQwrlYKIIfkJQc8F7w5XjUxUklrReXOuSGo1olEVnCTbfCaEEXBxJFQm6+111SkWASnJ09NQhLS9I1pwL+UBrqWyRZ22Di1Qh54LqZIj9FlSrQb4FnIvm5yzGktYlXOGTzvJ49O6pjvDhLkSL5lfM7RwThxM9pXtWXtdhsN/37klnKn6cbOZqz1UJUicM8rlo5nxZ2SabiUnNeXvaeFQkLyPdH+7d//xFVDa9/sipCpJKo6tc/ZjUCdcUKpSmId1oVLk+/gbx98tRZAuClBOUcFLOwSpWyFKf6BU6d/qDF1pbZt++Imj5g8xFJQkAIGBLg6Bbm3j8cdYftZ/mBdurULjx+dI60fzPVctEsjHDiiAw89Tdy5EBame8iTdUeUfZyY8dOxYWL4WGJFixYSgJRMJWdgbdvbpFTyU9K4GbHEu3UsWGrzfv2zbfj6CX/DIsWTVXxss+d/VeF3xo1aqKqsGSJ4ipU36xZ46OMgR0cFK79YE3oQDLTiE1iW90xY342EAhjU19syvK0K68wVqN65Wir4VVo2RnVEhr6aE9mgQwsdK+gONYxSRxNhVfoNcdZMybnsfW8V6/fxOy5v6lB9fVLx3Dp7AE1cP5pyiy10Av3r0HdWpgw9htM+ekHg+7+POl7vHp2A78tmK5iD7ft8Jmyo9bPtHnDcjx9dBljaXnza3Sujl37Ut7w+ML6+eJ0m0LdBe6nFQyLAi59fOHW1xcajzAE7eO4eOFn1hTyh1s9CoNX/EPbwi4kQfATwK1DIJx7+SBJi2AEXacCtMCLNoWdTIIQMu9I0i0ALr2p7ga00AuJMprHtidQVySb+AIFcivlZmR+aw3q16Ln/E1yZl4HT89sarXEvfsOa3FQeOTdYLmtc+dWtGbAeTLT+J1srQMMnMeHDOmDb7/9kt4PKcChWdlummdJVtDiT/funtL9nT71QbNchSwZXnlfx5EjW8h2upCyaFhDM1BxmazG5IPXeZ8wYQYiGrVz51mdzy8hDtbNF2Thwj+UpowNyiMmflnzqCai41TEfPJdCNgjATaBiMn9w/Gd9Z2GODbw1as3Ua9eTaUhYDOQNWv+wkvvVwonawuqkclWazK74qD+fF/v3XvIQBu7fcde1K7dBtVpKW1+KO6jh2vevLmUNpltdL1fhdelf304PN6LF94UBeOy2s0LnYwbN51s407rsrHmjPdp89y8eRdlytRTsad5SWSe5vt74zZls82FeEbrm2/Gq/13yf42ssTmI8WKVyftiTO2bV1B2up9SiMaWf7I9rNQyv3b914TElm++Nw/d94SjBs7khzyDkR52u7d25N2Kdz5NMqMNn6QY6dzDPDWbXrZeE9i33xerZDvuWvXb39U2fc/TsaRo/+hBK08x6Yeh4+cAC8Ko0279uzDmLE/44xeRCA+tnvPfvWsuE/324a/t8LXyDt81dq/cIBCr125eh1btu5Qqypq643Pz7DTSeD3IBgOuQMRRspkzeWk0Pi+105zQ665IcCFZJBLH4RlkGI6eIU7gvP7Q5M6FIHPyBb7Bh3Xt2jz1yBoqTuCOE/yUIQ+doLmDsXZfi+ox2cfY3su1ixPmjSb5LbtkVbFPjKscGFb6b/+3mYQdYkLsRzXtFlX8Gxn9uxZlDCt/5zmPKxsefvWV/lvsMKGn/PGkr5MyHGqJ0+eo0wP+Xd0+3bUvh/83gh/p5wxVrVJ+zSubtls8DKa1LcImfhGsJOuRui5fBUCQsAyBFh7Ofd/P6NBww4x1jLv3LGWYmMPwd17UT/YLdNS02vhWMyDh4ymVeweGy3EmvltW1eieo0WRo8ntp28QiWHY91DTozxnnjO2DHez2qbJ+SJI31B1TZ7Ia2OhkDVKhVoIbE/SHHzN3r0HBRN7oQ97OjklGJMwjYhvs6uN7KMr1PKeYSAEEhUBLxJE88LFXA85v16GrnoOsnOf+yEE5fxpaNrQ2TH31C7WrZoHKkA2aZ1MxVd4yhpJO0h8UqSs2dPpIWC1qvQrPHaZ35NWY0hZrz2POYnY/2Y6Mhizs3GSjRtUhfsb9P7syHKVtuamy8aamu+OtI2ISAErJLAhvVkKkH24qY4vPHCLRs3LkOdum2s1gZ5/76N1L7WRtvH2unOtDImOwTaS2KnWrYxNzUCisW4iIbadJSioTadleSMFwIyFo4XzHISISAEEhOBgV+MpEVBxqo4ztH1a9iw/qTx/NWosBpd2fg6vpbCkbZv9yGmv/a8vFgPh0K0J2Ga+85h9HgRGx4MxUXiMIyShIAQSFwERKBOXNdTeiMEhEA8EGB741mzflUOfVGdjm2u2cM8rr3Lo2qDKcfY4bBLl/Dwgvr5Wai0B2dE/T7zdlyG0RtOA6w7d05i1LdDIp5WvgsBIWDDBESgtuGLJ00XAkIg4QiwkMzLiFetEnmIzik/j6HYxuMSrpEmnpkXrTl79hLKlilhUKJOnWoU33mfwT57+WLpMHoc5WXxbzNoHYUGCiGv7ChJCAiBxENABOrEcy2lJ0JACMQzgQEDRqolbY2ZBtSpXU3F6OYFcWwhzZ27RC2Hrm0rt5/jw+ovoqI9Zi+fvJolh9EzN3GoRY6bu2P7WnTv3gFTpvwP5Ss0hFuS7Fi6bI251Uo5ISAErJCACNRWeFGkSUJACNgGAbYtnjJlDv2NMWgwh5obNWowxc+fbLDfmr/waoO8hDCv5siJzT2W/L7Smpsc5207e+6iisVcg2KmR5dYeC5T+lMVBSZD+nQYPWoI/qXFLHi1zjZtemLAwBGwlcFVdH2V40JACHxMQKJ8fMxE9ggBISAEYkRg+rRxtBLYAV1YPLaTffXqdfxHiYhRqz/O3KRxXZSgFSRnz16klgmu36D9x5nsbA+vqLljx2qsJROfFSvWq97zgCnD+4EHD0LSpEmN/Plzo3XrxvDyekaLC12iBZSWY+u2PTHT8LOKS+JQm/YLkygfpnGSXPFGwCneziQnEgJCQAgkUgKjRk+iaf3VOExLXvOqXg0a1ETtOm1trrc7du6lpeAno2zZT7Fy5Qaba39cNNjJyRHu7klRhWzlHzygdaUpBQQEKMGZt728nuLixau4deuOckCdO3cp5s5bzIckCQEhYEcERENtRxdbuioEhEDcEejQviUWLJhCi6A8Ro8eX+IQCde2lvLny0POiXtIYAxElqyfqFjMttaHuGgvO2s+fPQ40tUkLXZO0VCbjlI01KazkpzxQkA01PGCWU4iBIRAYifw+vVr0k474tKlazYpTPP1YTvqHj0GK7tfXthEUjiBY8dPCQohIASEQJQEREMdJR45KASEgBAwnQBreH3f+ca9JtP0JpmVk22E/f0DzCorhWJBQDTUpsMTDbXprCRnvBAQgTpeMMtJhIAQEAJCQAhEQ0AE6mgA6R0WgVoPhmxaAwGK9MN3sB0kBw0QGmYHHZUuCgEhIASEgE0S4NcxvaokmUCAWYWakE+yCAELEAgJCUNYNDKkU3CQvfwi+SklArUFfldShRAQAkJACAgBISAEhIAeATtRT+v1WDaFgBAQAkJACAgBISAEhIAFCYhAbUGYUpUQEAJCQAgIASEgBISA/REQgdr+rrn0WAgIASEgBISAEBACQsCCBESgtiBMqUoICAEhIASEgBAQAkLA/giIQG1/11x6LASEgA0QyJ3bEwMH9ISHh4cNtFaaKASEgBCwbwKyUqJ9X3/pvRAQAlZKYMrPY1C/fg0lUE+cNMNKWynNEgJCQAgIASYgGmr5HQgBISAEoiBAwfqVprhG9UpR5LL8oYcPH+PAgaNKqLZ87VKjEBACQkAIWJKACNSWpCl1CQEhkOgIlCxRFE2a1MWGDYvBS3LHR0qZIjlKlCiG+g06Yv/+o6hTu1p8nFbOIQSEgBAQAmYSEIHaTHBSTAgIAfsgcPbcRVy9ehMbN+5A716d4qXTAwb0wrx5vyM4OAiLFi3HZ591jpfzykmEgBAQAkLAPAIiUJvHTUoJASFgJwT8/QMwYOBIdO8xCC1aNIxzLTVrpxs0qIkVKzcownfu3kdYWBiyZs1kJ8Slm0JACAgB2yPg6OSUYoztNducFvPS45KEgBAQAuYRCA0NRVhoGCpUKI3jx0+bV4kJpYYN64/duw/g9Jnzuty+Pu/QvHlD7Pn3oG6fPW6w6cvAgT1x9OhJ+AcE2CMC6bMQEAJWSkA01FZ6YaRZQkAIWB8B1hrHpZY6onZaS2Drtl2oWrU82EHSntOoUYPRp09XdO7c2p4xSN/jgACr3PKGhsRBzTGrMhe1wTFmRSS3lRAQgdpKLoQ0QwgkdgK9enYE/9lyYpvmxYtXxZkttb7tdEROGzduR5PGdSPutpvvLZo3wIsX3hg/fjqZxNSym35LR+OHQNewAEx2CEZCz2X3cgjCjwhI8HbED/XEdZZ4FagPH9qCt29uomyZElFS7NSxFfz97mH+vClG8z24fwavvK+jxKfFDI5XrVIBvj53sGzpHIP98kUI2BOBiRO+VfdPv77drarbvcihr2vXdma1adrUsapPnTq2NKu8JQvFlZY6Mu20tu3Llq1F9+7m8dPWYaufLEw3b94Irdv0xthxU/H8+UvkyeMZ6+5079YObVo3iXU9XAEvwDPi6y9QuFB+i9SXUJXUrVMN58/thd+7u/Q+vY39+zYiX97cBs35/LOu6n7k97T+X3T355dffIYnjy+oMrduHkezpvUM6tX/UrxYYXi/vIZnTy/BM0c2/UMW386LEIxwcsTXoU4Ie197BtpaofHHK+dQ3HMKwagwf7hEc2bWLPchwfwiCeY+VO6oQyAahAYalOI6RlBdd6hOrnsjCc/59DTjU+CKJg6OqBGhnEElNvRl6i8/GvxGtL+XRg1rG/SiYoUy2LljLd68voGjR7YZHIv4hctq69H/5PeENuXPlwcsc2p/x/9sW4Uc2bNqD6tPU9tmUCiKL/G2sAs/ZAoWzAtnZ2fUqlUFx46firRZbdqEP+CqV6+IpEmT4N07v4/ycviq4cP7oX2HPh8dkx1CwJ4JNGoU/qBq0aIB/jd3sVWh8PV9Z1XtMacx+lrqWbN/NacKo2W6d++gi+xhLMMTr6d49eo1+EVx9doNY1kS5T6tMN29x5cq6gl3cu3ajWjdqilis+BNxgzpMHfuZMXs4sWruHjpaqz4de7UGmPGDEPfvl2xbNmfFO7wMA4fOQkfH59Y1RufhUt8WhQrVsxT79zvvpuMHDmyqkHc2rWLULlKE7x581Y1J3/+3AgJCcVvv62Al9dzXRPPnbus24640b5dc0yc+A0uXLiCmTP/UZx+/XU67t1rjVOnP/gLaMuNHPklkiRxw9u3ccuPNdKjNcHYHByKaw5J1OlZMJ6PQOTSOKFvQDCyaEIxwsUZbwP8McPBTdvEjz77hAZggqszZgUF4QTV190hDEtdnVCb6jjtEC5ujSRhug/VNTkgCHdpKZB+jhpscCLfjFDgNdX4knTT80JCMNZJg4O0z9Y9BdKmTY3AwEAsWLCcnl9vdMyuXbul2+aZt99/nwX2U/n997X4778zumPGNlKQ4zanNWs2Qr+e//4L921huXHVqvnw9MyGqVPnqcFuz54dqA2/oG69troqTWmbLrMJG/EmUFetWgGuri4KaNOm9TF+wnSjzUuTOhVKl/4UL1++QpYsmZQ2+9+9h4zm5Wk/1nZHJZwbLSg7hUAiJcD3Az9EvL1fo3jxIsiZMztu375nNb198eKF1bQlNg1hLfXOHauxkELacRSQ2CZWEDRpUge163x42Burc968JSSIdMOgwaOMHU50+zq0b0EL29SiCCsfhGnu5I6dezF48OexEqifeD3D06fPsZKu5ZQpY9C4SRedwG4OyJQpk2Pnzn0kpC8BDxyrVClPbexDdQYrJ9Z9+w7j+InT6veSP19uGhTdNOc0cVqmf/+eSojt2nUgNm/Zqc7FQnXNmpVRutQn2L3ngNrHgoi/vz8Jxotw/cYHwSiqxvXr1x1+fv5k/z5ADQivXLmB5cvngM/Zs9cgg6KsreRIN5a4twwqNvIlF2mn6zo5oWYA6abf23sUCA1GDRKMWwUGY4dDuF46c5A/upAWey4JuYY65/BKk9JHP2dHLAoMIAE9CcJo/v8wablPhoWiLWmsT8MJLAZ2oXPNDgzCtPeC+RUSno+7alA+JBD/aMLPtY4+RzuGomJIEPZonI202nZ2pUuXVt0PP/w4xejgiIXfCTSrGkBOxnXrtsXZc5ei7RzPBoWSg/jSpWuwa/f+j/JXpXsvf/486l78dtREddzTMyuqVatIlg1FdQO46Nr2UcXR7Ig3gbply4Z49uwFtm7djfbtm6NY0UI4d/5jcFWrVgQ/mObMWUKxVzuhTp1qMCZQ84PQw8OdtNT90ap1z2i6KYeFgH0QqF27KjQaB9IyrUe/ft3ALyZjAjU/cCrQMQcHDW7cuI116zfTiz9EQWI75+TJk+P06XMqz8aN/+D8hXDNE0+1FaOpWE4XL17B33RMm0qVLI569Wrin392kzBfGJkyZcCjR174Y8U69bDkeMovX3prs6vp3sKFC6gH4wkSNIw9GHWZI2zwFHSbNk1JgNmrBhB58+bC69dv8Mcf6/DS+5Uud9o0qVW+1DRQ5wf2P//s0fVFl8mMDUtrqTm+Ndtmc71RpUOHT2DcuJEqdF98CBtRtSWujw0c0FP9/jp3GfARF+47xwZnswCOE25OKkkL57Bd+tcjxqJvn+5krjEQ48ZPNacqZeZRpUo5A6F83/4jqi4eLFWpXJ6EheoYPXoIMmRIj3z5ctF1nG72+cxqpAmF2IyGtYisRdamQ4eOg58ryZIl0+5C+vTplNaRZ01MSaxRzJs3p3rWaGdXdu7aSzbxL0mBVvyjKr77bqiSF1gxkCNHlo+OW3JHg7BgPAxxIO30B8G1BAnZ/iRdn9UTZv8NdUA3EpjTkiD3SCt56zUkFWlXHUm1vT/MEWHvBfMXlO82mXOke5+PbWx/pQHWX2Eker3P88z2TlWSAABAAElEQVTBAW8RCg8Kjand50Ub/9HzuDVpxvfgQ7v0Tmczm6lSpSCB2s+oMM2d4HdRrlw5aFD7P5OEaS5ToEAemiEhkxmasTOWPvmkqHq3HTx4THd4y5Zd6h7MndtTJ1BH1zZdYRM34kWgZi0Zv4Q5FNTff28jO8o2qFGjklGBunXrxmo0M+d/v5IwXQU8fT3ym/EfdYfNQLZv34t27ZqS0FAa/KKRJATsnUCTJvXAS1b//PMcdOzYgoTJJlj+x58GWH784WsMG9YPQUHhehZXV1fl5NW120CVj22d+YHFwraLiwvu3r2Hy1euYe7/JqvoCiyYcuJy69ZtBpdjYbwUabBGjRqEbt3aKmGa8zg6OpCmrhy6df8Ci379g3ep9L85P6FHj/ZqatmJNDb8x23+fkz4FLw2X2SfLJDwuXr0aIeMGdMrodyJtEdt2zZDterNVHv4Ic02eVmyZFRT1e7uSfHNN1/S82cgNm7aHlnVJu+3lJaaBS6OHBKddlrbsDVrNoHNC1g7HheJXzivSah6TsJOQqWohGltm9jsg7mZK1B3796eBjErVXVz5y3Gpo3LSUAvZPJLXdsOjrwya9ZEMo0w1KJrj7Pwzxp1/uPUpXMb+q1/T1PV1me2U7VaM9VG/f/y0uCV7+/nzz/MLrHSi7XNHdq3RLp0qfH4sRfW/rlJZxKiX563U6VMQc8CR5o5+zDlz6YcT5++oAFGWoPsPGivWLE02OSEB81xnWqQEHyBtMj6WudMmjC8JsH5rVbCpUY8pW1X+kxH2utHesK3tn0PSTAuQII5WXHoEudPSzt2Uv1cFQ/1J2jIZOS9MM0ZC5NA705xPW7qxfYg0RpHSUBvRc80F9Jz6LeNy9hS4t+Kj48vBtBMBG/fu/cQq9f8rRQc3I8SJYqTEgj03nqCYUP7qXfOqVNn8c/2fyPtJs+QBJFZDVs+1KtXQylT2PzD6+kzVSZXruzKJIktHbSJHZo5pSElizZF1zZtPlM/9S69qUVinq9ypXI0unXHn3TDHT7ynxp5NmtW/6OKUqZIoW4kHh2zVo1HFDx9HZkTI9vGBAQEgm2tJAkBeyfwCZl4sKC5d+9hsObo5MlzynyKzai0qWiRQhTHtxfOnr1Imp+SyJa9BC5duobGjeuQk1dObTalAV269E+UK9cAmzfvQvNmDUhAb6Xq5jL8t23bbiXQdOzQSleON1irlDdfOeTOXYaE8Qc0ZV8TmUjo1aZPPylCdbXE4cP/IVPmYihYqBI9TB+p1QAzpDd8uWrLRPbpQM47pUrVQeYsxVR9n1Dd5cqWUtknThhFL+t0ZCIxAukzFEbJkrXVQ/y774ZFVl2M9utrqWNUMEJmU7XT2mIrV66LM0GDF4+5eGE//XZ2YjjFw2bBvQ5pJ1mbyw492rB9PAjgdrMAaulkijDN59xHS7Kzn405iaeMeUr45KlzuuJ9+w3H7NkTY7xwz6hvB5G95gbcvXdfV1dUG0uXrUGGjIWxhgYE1p54lql27SrKTvXosf90zWXNXubMGTFjxlga2A6mGeVJ+JPsrHnQaix5kyaRNYoRhWe2mdVPPCjmQe+DB4/JPjt8sKN/3NLbbA2dmwTZSyQ866dwS2r9PSCNdcxTdXIszExKhXV6mm6uhSkNI1vq8VTrUmcHTCMb4zPvbay1Z7lOau6s9HxLrXOT1B6xnU++nsmSeSgFzZQp36vfyoIFU7CU7KX5GKdChfKqhasmTBiJMWOGK0XJ+vWLMYTMpSJL6ek9waYi48ePVHXyAHX37nXITL9XTm5ufGUNk1YRpN1rStu0eU39jBeBulWrRjSCeItDh46pEeyxY6dQtGhBgxc4N7h8+ZJImzaNmobj77t27VejWp5uMpZYa8bOHzxKYaFdkhCwZwLVqoX7KbCJBideKptH4GxGpU1+/n7kGDSDpp4n4RWZSLCTETtksSY6Pdm6aRPbgE6bPg9nzl6gfK+VAMcvv/Hjp6kyXG7SpFmkuQpWQrW2HH/OnLmATD2eKKH+1Knz9JJNgmzZPkzburi4kvbbgV6wwaoYa9QHDfpOtUlrdqJfX1TbPON16fI11aYtZPPJD0kWojmVKfOJ0tYvXrJCfb9y9QY5ih0jG1FXJQyonbH8L7YRP7Taaa7H1MTX7Sr1hYVcSyeedWDBh53L2KRHQ6qjkiU/QWuKhDFq1BDS4i7Fv3vW48D+jaSVnUBOQYt0QnZs2sKzjCvJGW7c2JF0vuIwZuYRsX4e0PACO2zWFNPUvl0z5dioX46FuFmzfsWY77/S3x3lNit7ChfOjwULl0WZz1YPjvl+OL2TU2PatLlKS63tByu7tm3bQ4PhisiTtxz4Pq9CU/fNyD/KWGJzrOvXbyufDm10rupkz5o/fy6D7O3aNgdP10+fvlA9dwwOxsGXpCSspqaZuNdaGw0LniMl1T2JHAv/JE3qFT3tM5+CLaUrkTNiCxKinUk7e09fZf2+DawRZ8E+pV4EkPeHbObD3d2dFDI7lTI1Z67SJPdVU4MzVuDUIxMoTmnSpFHvA1YEsWKkWPHqyodu6NC+NPuRxmhfWTY8cOAYmYQ1omd5MbqXN6moP6wsMjWZ0jZT69Lmi3OBmoGUKfOp0og9fvJUnffPPzerkWylioYPwpYtG6sXNDtvcGIHjidUhqexI0szZy2kqSc/fPvt4MiyyH4hYBcEePqbp7UOHQo3fzpw4IhyHGIzKm1ie+nJP89WD7CvvxqIUd8OUQIBC04cgUebWHgOeW9TzfuyZs2s7rP79x9psygbVha8tQKs9gAvk61NLHCzTXeSJB90PidPnSFN9yFUrlwOly7uV6HGjh07qUxCXujZWGvriOqTHVO0SRtBhAVmDrPFPhasLddPbdr2QuEiVZTAr7/f3O3Yaqljqp3WtnPhwuXKOVH73VKfLNA2aNCBbIE7YSvNQLA2lSNpjBg5Dr0/G4L6Ddqjeo0WNKPRWb3EWKDt26dLrE/fnpwPm1NovIwZ0ynzoOhsybUn3LBhqyqn/W7qJ5sSGBvEsNaYnZfYrjO6xFruSZNGYfCQ0dFltcnjPXt0UDNJbFq5bLmh2diQod+heYtuNJN8n7TJj9RgmJ8ZTaMIgzdrFg++nOh3s0iZj/FgjCOFaAfRyZMnw9dkx37nzj26NuvihRkLQPwXbihguVOy7vUnis+RhJ6r35H4/OEpFX4ONkRoFuqKQhSm7ztyUJxKUT9KhwYZNODdeyHb9aPSBtms+gsPpD7vMwydOvdXZkHswDqGzPr4fcP+NtoUFBRMip6ZSjHC7yhWjqROnRKlaDBvLP08ZQ6ZyHF0mHPKZ+aHH39WpsJ16lQzlt3oPlPbZrRwJDvjXKCuXKk82CGB7Si18QKXLp2lmtOmTTNds1h9X7VqOdKUOZNAsFnl5fiTPK3E09g8nW0ssWnI8uXrUKlSaWWXbSyP7BMCiZ0Am2uwpoy1SU+enFf3z6lTu5Qgy/aIbE7FiTW4q1bOJ+31UuW0WK1aeZOmuPkBGDGx5lr7Mox4LKrvXKZV614YMuR75cXPocYuXz6Ibl2jjnARVZ0JecxcLbU52mltP9lumKMvcOxqS6UWFOfZiyJfaJ3poqqXTYo6d+lP0TcGKfv7jORoF5vEEZ1++OEX0oJPilE1hw4fR9myJWKkJWfN/t279yMNZzdgwEh8T5pZFpijSuPGjiCN9m/KPCGqfLZ4jMPcsvMrm2z17/91tF24dfuu8oeIOLjWL8iDlaFDxyizKw6dy05obOOqdVRm23J2XOTZrS8G9laDffaP4OhgA8hBlZ2e4yoljfB4e2fkRBS3w8he47u6UCzqVs4u6BUUhsdGtM/aUlzjSrKpfkyDkRoaMpbWSw4xOJ9eMavfvHnzDtk/UyhCuuc5sQKG//RNMnigzu+cNGlSmtSfGzfuqNj0LIRziizUcnSVRWxbdPkjHo9zgbpt2ybKeHzq1PnKyYAdDfjv+vVbZIxeVGdbWb5cKRKeMykvfG0e/ly2bJ164fN0dmRpxowFyuidNRyShIA9EqhZo7Ka9VmxYoPBfbZp0w5lRsXmVJwaNqittEhsKpU7TxnUqt1a2VpHx4wdq9ipiE1DtImd/jhOLD8cY5r44ckxsllb3IUEMzYzYDs4fTvumNapn58jFXCd+lp3Pp6NNO0sLGjt9/TLmLvN2tT167fEaPVEbgNHljAlskdk7Vq8eDU5wnWI7HCM9nM0lGHD+mIUmQLFJHHfx4z5mbRL5ofx44VVrlEIOdaEmxo1Qr+Ne/YcJI2y6SZ/7IzIGv7IEjtjTiEN2PRpP0aWBXy/pU2bCus3bI40j60eSJ0qJf0uZyjl1uefD8UjcjjUTwUL5FXCrr6Sy4Vmt/j5wI6KUaX5C35HocKVlY/Fbgp3xjPYp09fUEV4nQqO3pWPQgpyhC/+Y1tt1mq3bduUFAYFoqrarGMcycOPhLmUerNqXNF9MgFJRWZpyfWEWjYkY3fsZxFsnTm/fvqEnBYnuDhhItlF74/gvJiJ6htHttP6S5yzXtqfzs8OjPqJh8oscL+OYC6in8fat/k3wrOg/JvRJldXNzVD6uvrq3bx4Jad17XCMO9MSU6snPi9EzFlISXrN+Q3F3FhGH7Ws08dJxaMuU5WMGkTR3rixJFlOJnSNpUxBv/FqUDNWrHy5Uvh1q17+Obb8Wqqmaeb+e+PP9Yr+87KFE6IE6vqWQn2v/8tNsg3YeI0JSzzdHZk6e69B8qBgTXZDFGSELA3AhzbnUflkyfPMrh/+H7ixzKbU3FiJyMe+R84cFSnXWbTiOgShx/iWSSOR6tNHLKMTTlOnjyr3WXSZ/9+PWk1rJvk8NZK5V9D9m8cAShp0qTgh6UlEmvPOWQfR/jQtw1fvXohhdpbAw/3qLWPMW0DR9zo3Ll1tNp+1ihP+XmMcvrr3bujUbMDU8/NwhzbIloicZSKkWTWYc4iJLwOAA+Q2A46pol5DBr0Oa1+OC2mRXX5eTDDNt6mJJ4V4JCO0a1dwOYu/DJvQA61ERO3+fvvh5HWdGTEQ4niO2umixQpSP4SM3CQQuZFTOGmGf1J29xPd4jf88z2lJ6Tp+6gkQ221R8x4gslWLFDJ6f+A0Yge44SBn+XL19XU/mVKzfB70tXG6kpdrv8qPhDisCRPYLYcIZiRrPqQN8MoyaFsLtNg/TnUWic2W56kVMoDpB/yEzSPEfUafP3z0kpUV/zwbwjI4Xoy0KDkescuFovcaSR5yRoe5Ngb6spffo05GT6BXpSKFZtqly5rFJosN09p+0UzYN9apqR47s2ceQOFo5ZMI6Y+L5kW2l2htUqRtiPgqPNsLkIpzNnzqtFYmrXrqa+83/8rNSv05S26QqbuOFkYj6zslWoUEppxzZs2PZReX5B89Qv23fyi4GDuPP0z/HjZwzysknH1au31HQ2a6+0wAwy0ZfZc36jcFhtaYogfBQS8bh8FwKJlQB7NvNsz82bd8GOd/rpPxJ2Of47m1OxQHz//kP1oBkxYqASrsuVK0mxOavRlJt+qY+3Fy9ZqcLc/fjjVypMHWuiBgzoQc7Gr2kQ/NvHBaLYc+jQUTVrxcH8OSYvaxZq1qxC7XyO8+cvR1EyZocWLfoDv/wyhmw2f6W/jcoRmqOALCd7UBa4s2fPgn17/yY7a2+yC26pQi/F7AwfcvNDnpcGZ23MpJ9mKcGUI2IUJg92jvddgswM8uQJj/HL2nPl9DltPj0DP7xYP9Rm2hafk6dGa1SvjD3/HjCtkJFcMTH1MFJc7RpFiyewbSyH/otJnyZNGq003OYI8tq2sPkLr9zHAh0ziSq1btWEYrSHC3BR5eNjI0aOx47tqxVj/RCC06ePI/OUKcqpN7o6bO04L8XOYW21JjGf9e6s6wKHzVtPNus8GNlPEVaaN6+PmTPGq4HroEG9leJryZJVKj87nPGKi3/9tQ09eg7S1VGL7nN+5rRs2UitnPzrryuwc9c+3fH43mAji9MkUBciPw+SX3UC8HWKrrE7KACTyUTOIzgQmUiY7kTmqGNoxcPA9/JtRbJ5XkhOhwOCw7CHNNFau+kcji6YQPnKwfDe/o/ycHzptVTvCHrmhQX64yF9/4LqeErh9ra8X0BGy+ATahAv+vLWhjXUPCDjGQiebWB/mnBhuKd6J3HoPE4cTpKdoHv2bK9im3NgiorkX7djx16cPhM+e3Hu7F4l21Wo0JCi6TxQ6yz0798dSxbPovvzFJkl9VCKojkkB3Li8/LCQR06NFPPd55JrV69klIkaVflNKVtqrIY/BenAjVrxVjr/O+/hz5qEhuTe5EdHo9s69WtAU/P7DhCIfX4RRcxbd++hzy/i6pptsgEara74hfo118PiFhcvguBRE2gWrVKarZn9erwB5R+ZznWK4fPq0svODar2rJ1F5lW/I8eQN1JKBhOtsvXSBDapKZUM2fOoF/UYJs1BeyINmfORFpMKVwzxeH2Bg78BtfIfCsm6QyF7OvQoQ9p07/H2LFfK/s5bV36i7LEpE5jedmkhEM2ffllb5rC/15NR/9KsbC1K2clodBKLISxt7cmCq2TsbqN7bt1664yW2FNCD+PuG5mz5qYST/NNNC2sH1udMKfsXNE3Ldw0TIVGcNcgVpr6lGHViiLTWKBkxcTYgdFU5djZ8c/ZqSNzxyb8+/YsY/C+1WLNr54ly5tSInT06RTsZA/fPgYFWO6fYfPVRkefPCASLtioEkV2VCmGmTKwqYbvHbEzJnjDVp+5sxFJVDzzp49B9NAOjyWPOfn9/Lgwd/pngVubkmUyQhrs/VTQ4ox/dlnndXAftiwHzBv/hL9wwmyvZUWbPmNFmxJRYIxL/vNiQXtz0lH/RPZQs8mG25f0jj8Qs6D8/WWHU9KAm9amhFPSkuMc2KTjRqOTiok3jJabjxiKhgQinukiR0GN3gH+2M4CejJSUDaToPqXiEUaURPEe1MhctR3pXktBka3qSI1dnEd5415Wf9/PlT6F3RU2miOapU375fqQhM3AlWLrRr/xl+XzJL5WHnVg7J2q/f17o+sm8dWx9wtDhO333/k/p9daJZTo4i9/jxU3zxxShso4W7OPF527X7nGTCaer5zzbaHBXks8+GquPaPNG1TZfZxA2Nq1u2aHRTJtZk9dn4V2knXbX6ayENFAKJjwCbwGzcuExpqnnFPUsIzKZQ2rB+CQl9i0hLfdCU7AZ5Vq6YD17O3BRHRIOCRr6wRp7D6vECJ9HZQrMgvXPHGtJydrfIAjIc1YXtuLWCr5HmKdt5Xq68V+8hxg5Huu8n0qL7+QXQS36XiurBS5THRqMe6YnkQIIQSEpnPeoYhLFBoVjrwGJxwqciZIe9w0WDMsEaPNBfKSbhmxbvLWCTvXPn9qoFYcqUrRvv54/JCfXGRDEpJnmFgBAQAkJAn4CKvOFZghz7JsabMM3nZzvxrVtXYPCgPmRTyLot0xJrW+/R9KklhGk+Y0wcFIcN7U+OgX9YRJjmc98hxyaOuR5VZI7eZL4QlTMi12Ms8fLkI0YMwJ496+jTPDtzY/XKPusgwBE9ppKWuR+ZXnxwuU64trHqr59DMJZQ/Gp7F6b5KvDKvcmTe5DSYGHCXRQTzywCtYmgJJsQEAJCwBoJ7NlzSJmVcMiyPbv/RJPG0Wtx2NRj4MAeJi/1bmq/TXFQzJ8vj1oRl2NcWzJtJXOmyPrOGnG2Y4/OGdFYe+7SCohstsMDAHPKG6tT9lkXgRUaVzLrIOGNTDwS2sKiWlggypIN9xRqkySoGb/evYd+FAvdGtmIyYc1XhVpkxAQAkLADAIcgYI94DnuP6/6t3HTdqO1LFs6h5bZ/jVOBEQW1qNyUNy5Y62KkHH1mqEDrdGGxmAnx8JeuHCqWpQmYjFeQp2dnXj1T0lCwBiBjGQS2o9C2n2viUnEaWM1xW7fEGrD9jBnXCShWpJtERANtW1dL2mtEBACQiBSArws+dhxU8nxrpeKLrJ/30blrKdfgE092GkyrrSt+g6K+uflbV4ZkuNGW1qY5rrD7bbJUYwE+oipQ4cWpOmyrEY84jnku20TeEK66e8SWJhmglMp3J4I07b5WxINtW1eN2m1EBACQiBaAqy1HTasvworx+GlOG5rFYquwUuIx6XTpDEHxaxZM4GdIDlEYUxC60XbSb0MPWihG44GwHHBtYlNTDhmLa/sKEkICAEhEFcERKCOK7JSrxAQAkLASgiwMHv1ymEVEq1q1WZxpp3W727ZMiXQp083Wp78C7Wbhenp0+fH6bnZKXHtmoVqwKBty6SJo1WEDks5X2rrlU8hIASEgD4BMfnQpyHbQkAICIFESODBg8fo3XsYrYY4Pk4FWn10WgfFviRU8/LiXl7P4vzcHM7Ox8cXPIDgxM6IZct+arFIJvr9k20hIASEgD4BRyenFGP0dyTe7YT23U28ZKVnQkAIWD+B8xcu4+jRk/HaUF4g5JdffkAZ0lZ3oMVR/GmJ8rhOIRQCjc1aDh8+gRbNG6pFH44e/S+uTyv1CwEhYOcERENt5z8A6b4QEAJCIK4InDt3iRZluITx46fH21LdW7ftRIMGNVWXundvL86IcXVxpV4hIAQMCIgNtQEO+SIEhIAQEAK2TmDb1pU4S0vc56AVFKNaPdHW+yntFwJCwHoIfLzgvPW0TVoiBISAEBACQiDGBHgRl+rVK6Jp0y4xLisFhIAQEALmEBAbanOoSRkhIASEgBCwWgJPvZ4jICAQP0+ZY7VtlIYJASGQuAiIyUfiup7SGyEgBISAECACHOEjLmNtC2QhIASEgD4BcUrUpyHbQkAICAEhkCgIiDCdKC6jdEII2AwBWtDKTmRqBwqbFxpmMxdGGioEhIAQEAJCQAgIASGQ8ARCQsIQFo0M6RQcFJrwLY2XFnAcahGo4wW1nEQICAEhIASEgBAQAnZEwE7U03Z0RaWrQkAICAEhIASEgBAQAvFKQATqeMUtJxMCQkAICAEhIASEgBBIbAREoE5sV1T6IwSEgBAQAkJACAgBIRCvBESgjlfccjIhIASEgBCwNQIeHh621mRprxAQAvFMQBZ2iWfgcjohIASEgBCwHQJ58nji6pVDaFC/FoKDQ5A2TWpky5aZljXPCidnJyRP5oGUKZIjbdrUmPrLDwgKDML1G7dtp4PSUiEgBCxCQJYetwhGqUQICAEhIAQSIwFXF1e4urpCo9Gov7JlS8LR0VF1NWvWjLQd/hotWbIYChXKh7JlS2Drtt2JEYX0SQgIgSgIiEAdBRw5JASEgBCwJwK0MAEWLpiCu3cfYMwPP9tT1yPta4MGtTB8+I+YNXtRpHn4AGupO3dujYoVy6BsmRI4dvxUlPnloBAQAomLgCw9nriup/RGCAgBIWA2ATZvuHB+P0JCQrBjxz4sXLjMrrWtbN6xdu0i1K7Tlsw9gkziWrJEMXTv3h4DBo40Kb9kEgJCIHEQEKfExHEdpRdCQAgIgVgTqF+vJpYsWY06ddpg4BcjUaFCGezf9zcGDuipNLCxPoGNVTBq1BBMnDjTZGGau3fy1DkULpwfbm6uNtZbaa4QEAKxISACdWzoSVkhIASEQCIhULxYIbB5w4CB3+DQ4RN48OAxRo2eiDp128DX1w8bNizBtKljkT9f7kTS46i7kTu3p3I83LFzb9QZjRzduHEHmjSua+SI7BICQiCxEhCTj8R6ZaVfQkAICAETCXBYuE0bl6Jzl/5KkI6sWMUKpTFgQC94eCRFGjKH2Lp1N8aNnxpZdpvev3bNIowZ8zMuXroa435kzJAec+dORvMW3WJcVgoIASFgmwREQ22b101aLQSEgBCwGIHp037EtGnzoxSm+WSsuW7f4XMsW7YWJUoUxYgRA9GieQOLtcNaKqpSuTxevPA2S5jmPjzxeqq6kjVrJmvpkrQjGgIaOp43NCSaXHF/OBe1ITyGTNyfS85gWQIiUFuWp9QWBwSGDO6LXj07xkHNUqUQEAJtWjeBj887bNy03WQYa9ZuRN26bVH8k+ro27d7ohOqf/hhuNJOmwzESMbFi1eic6c2Ro7ILmsk0DUsAJMdgsGCdUKmXg5B+BEBCd6OhGRgq+eOd4H69yWz4e93D61aNo6SWaOGteH37i7Wr1tsNN/RI9tUPVyX9u+p10X8PPl7JE+ezGgZ2ZnwBIoVLYRX3tdx5vQekxszZMjn6NWrk8n5rT1j5kwZwL/VmzeOIWnSJAna3H+2rdbdP9r76MXzK5j7v8lqAYsEbZzeydl2l9vXqWNLvb2yGVsCObJnQ58+3TBi5NgYV7Vv/xHcvHmHzBq6o3fvzmBzkMSQOndqjT17Duq0zOb2aeu2Pahfv4a5xeO0XNMm9XDi+Hb0+bzrR+fJny8PDh/aot6/vj638c+2VciRPetH+bJlzYIli2fi2dNL6s8zR7aP8mh3VK1SAb4+dz561mifOcbu6+LFCsP75bVo69aeIzafeRGCEU6O+DrUCWF6FbFwXSc0EJscApHW4IhepgibjSn/GRKKfZxDsZ/KVQ41jA7DdXYMDcBlEt7fUp4dmkB8qpdnClzRxMERNaiexJa2blmhfgPGfnfcV5bdzp/bp/KwDGgsGXtnaX9HVy4f0hUpXeoTnD61W/2O+Xc0aeJoONE11k+tWzXGtatHVB6ft5H/1vXLRLUdr3Gok9GKUlWqlFXtadOmCf5ctynStjVv3vB9EP0SSJ0qJV56v/oob0BAIObMWYxXr16rvM2a1cfAgT2RIUM6dOk64KP8siPhCdSoUUl5v+fKlQOlShbHfyfPJnyj4rkFlSuXUw8ODw93lC9XCrv3HIhxC/ihUrJkUZQuXRd37t6PcXn9AiEhoZg373d4eT2j3RrSPFajsF/tkD17FjRsFLuZAX7JnjixHSdPnke9+m31T2vX24UL5cfVa7diFD3C0sBUzOmFU0nD/BX8/QPMrt7Hxwet2/TGyhXzMGnSDGUWYnZlCVyQI3P07dsNNWq2iHVLOMze8eOnaaBRhpgcj3V9lqiAzXNGjvwSRYsWNFodD/BXrZoPT89smDp1HtnKe6Bnzw5YsOAX1K334f7lgdiePeuQMWM6/PPPvzhw4Bi86T0cWbp+4xYGDRql3tP6ebp2bavaco3uhYiJ25kkiRvevvWJeMii31nAHa0JxubgUFxzCFdw/L+9q4CP6njCkxCk/ZfiToGW4hR3dye4e5EiRYJLgFC0QAst7h7cCykOoVhxdyguxQstEvnPN8m73F3uLneXy+VCdn6Ee7K7b9/3bHb2mxlYGiuzQjuINaTCnA3zZTCr2UERH/aboABaED8Orf8QQMMCgqm1ezAtj+dORbjt+xRivyzFyvO0+HFpwYf3tC/AnTqzjrcirhsVZbYJtJxn/A6eyWErR3q40R98TPufzIj768wSlSqWYf2vmMVDtm7VmLJk+dJimSlT5tK6db8ZlEmXLg316dOZzp27JNvTpk3N4S7nyf0zYcJ0KlWqKN9/HenVq39ozNjJUqZc2RI0b94kevz4KQ0ePIYj82Sn5s3r09Kl06l8hXqSFdXgIFasOFWhLl6soCi7z569oOLFC3EYpkT04mX4hxAPdblyxQnlkiZNTFBANm76PdzpvH//nh/0xTqFAjFTDx7cQrVrVyF8sOxxJgl3ELXBoQhg0IOb+n//+5Qq8gMWGxXqJk3q0r///iej5docCcAehdqRFwUxhxcuXEFnz12UZqdNn0d796ynsmWLU4nihengoaOOPFysbQsKbLasX4nC1qFDC5o8eY5dlmFHAThq5EBWntazYn8t0k1CqW7WvHOMV6p79fxOBpeRGWDogwmuORR0V1CoMbidNWuifFfXrt1KDRrU0O+qLJctU5yyZfuaHSoX0hDvsbItU6b0/D0uSQXyf0MnTp6VbSNHDhBlumdPb5o7b1m4dow33L//kObMXWqwGd//wYN70qVLV+nPoycN9mEQUqNGxUgN9AwatLDyFVunq3p4UMV3rDRDu2ZJHxREK+N7kC8rvccC31HzuPFCdkTwfzu2Ot8KjEPd2cr8lvXnP9iqfYo18QbBH2iKW0gYxU5xgug4K9v9KAGxPk3Hg4PoBP9W+/COVriHlFnrFo+GcrmSgR9ot1vcCI7q+rthGR4+vK8oqR6MtSlBzHcvr+/kmlsKObll645w1fv26SrZS/G8QUBjw2CvX78RnJBpHqVMkZyOHdvOM2ktJEETBmm9e3eWAV6bNt11z2eOHFkob95clD/fN3T02Klwx4log+kzi6iWnfs9PasTlGBf33XUrVs7HjUUod+2hAcHH/E0PC0+deoCHh03o/r1a5lUqI27ASv23r0HqW3bJvTllxmUQm0MUDSvf/31l2KN2LJlJxXjwVWdOtXox/FTwvUKL3XEvw1mq8DOnfsM9tevV4uyZ/+anaJW0Z2792UfRr7F2NK7evVGVg6uy7a63DZGnEFBwXTy5Bn6fdseXTvgY3/++efMGf2d6tapTvHixaPDh4/R7j1/6MpgAR+QSpXKyv4nT57RqlUbDGZKkBmtceM6lDJlCn4JvCU/Tjcc0SAuWdIkkpr4IDt34R6vVKmMKNYBAWHOMOCMv3r1SvehSsXtf/ttc7p8+SqdOHGWWrRoKBak+PHjccSF9oKRdn5ffZWB6njWkAHLc34e1qzZTI8ew/Jsvbx58y+HSPOTa4XnSFOocf3q8DMMq5ExHphtqMYxjA+yJa4QT7Xdu/eAnbqeCX7oJyxeQwZ70bJla3QDYP1rdJQ/qDt3+VvdyaxZMgv2O3bslbazZPmKXr58xe2vNbhGeEnjGiVl3N+9e8fWtN26gYPVB7OyIBzQcI6bmYt8/vxleTFDOcnD4ejwcodcvnxdPipwePP0rEJTp82N0BHQysPbVKxqlXKEtNn2UD3MHUhTqrdvW8kfMp8YZ6lGZI6KFUtT9RrNzZ2izdtPnznPCmpmmZVzlJJucydCK7x48YqV+wG0YeNWasqDelMKdT5WJNzd2TL6xxHdYfC+rlq1PCGMIBTqNKlTcpzycvIuskaZ1jVktFC+fEkxsE2aNNtoD9GwYX3o77+f0vPnLzl0Ybpw+x25oUZwAN0LdGfrdJji+sLdnfJ8CKLbrPR2DX5r1eFYJ6ZCXO8kOxW+pZC2nrOGfjYwgIqwpRqMEajLebnMZjZiBIS2+oAt11cC31Nh9yBaEbrtEdc7xt+ERm5BtDu0rdBdMfIH3w04MYNKVblyWZPn0LlzG0qRIhnt23fQbBmTFXlj06b16MGDx7Rn7wEpAiMsGAz79x+W9cd/PyF//8MEgx6MrYePHKcvvkgv37Ejfx7XNXv69HnKnz83gU1hjzhNocYIpVKl0nT16l80f76vKMqgdZhSqGvVqiIfnZUr17OiVEBoIjjBqJ76sQdAVcd6BEpxSl7MPqxbt5UHVh/4hV4z3EzCd51a81TjCH6pu/M9EEADBnxvME0IxWTYsN50+/ZdWsrKGaRPny6ipK5Zs0mU0yWLp1E9ntqEYghlLk6cODRq1GQaPWaSlAcfOytbCvv378qK5/+kDmgPLVp00Q3coHRPmjRSPi5oB9yurl3bSsILePCDB/377yulHVjcQd+AtaVRow4WLc6YesKsCxTdL7/MKNNURQoX0Cmt6CA444gBrH2sUqZMztO0PWjjxt/5pfE388lbUOLEn3O/PahJkzpi7YZCXY0/ekuWTJO+vH79Rl4KwK969WYRKvoCjIX/wLlcuPBXHlzEpf/+eyvH6NKlNZUvX18UWCjR3t69mH71Svq2d+8hnu4+If1DP1OlSi79xgsVFJXp037kQUKzUEu9h5zLhAnTaLjPeAu9CNuF64fjffttU1ZWU8rACe8YWP/Lla8r7w/QinZsX03p0qXWzYrgGsEiYYsDXthRLS9VqVxeqDKenlVDBlfnr7BifYmWr1gXTmnu5eUt6anHjvGWUHWWW3bsXiiOw4f34/jSYVP4jjoClOr6zKlet25BjFOqvb29OInLL3zvfHAUHNLOunVbqFFDT1qyNMR65tDGbWgMs8GWaJZoCgNyvAsxO6wJBn8QhEmE5M6dgxIlSih0li6d28p2vI9Xrtoog1YpZMV/7fkdi3erscUR3NmSJQvze368DIataCpSRSow5eIcW4n1GcuvuMVXoRQNaxuHDTsJK8J3WHHmHxEswpyRPrQtEEoSubnTPUQTgQbOAsX6KRt+vtAq8TrqHWYreUN+p8Xjovp9410xSjAbjQRJoPVs2rTNpLIMyga+rzt3+tOtW3dNljF30qX5mwojG2ZZ8S2G4LsO4y2+R5qc4xnYhg1rUfLkIfdx/gIVtF26X/QD9TCYs0dCL6k9VW2rU6J4ER4RpBXrzYWLV+jixWsEWoexUxY+ilWqlKUbN25JxqkNG36XUSzoIhEJuNblypWQD/7Nm7cjKq72OxmBxo3ryg2+f/8h2rBhq1htyjKPSRMMmqAA4iVbpkwdSvh5ZhoyZKwoW1oZjDhhDcagC4I6uXNnl/vp0uVrrFRWYMt3dVq7dgulSp2LsmUvKR8HzFroC+67JUvWUpKkWahVq26yq2PHlvKLUbKPTz9+qJ6wlbsMpUyVixXaMcLtwkcAMmRIb4LFtlevYbK/QoUGovhDUbEkjXgqCgrp4cPHQ63vbmKltlRHf9+hw0fpy68K0ZEjJwWn0qU9adjwH0Xhnzx5tAxEEH0hRcqcPL3Vm5LwMzFzpnVKqnYcvADr1asuAxo8R3gmR48eJB/LvPkqUPIUOZh7tlymhsuVK6VVk19YppFlr0vXvtIv9A/XE/1Fv9H//Ply8+ClAVuzj1GatHkoR85SbNG+T506taJUPHiwRdzZeadQoSqUNl0eaS8ft12saCFpAsoq/Cm6dBko16hgwcpyDsOG9bXlEFaXvcz3H+5PT89W1IGxnzR5pqTtxuDIlBzhAQes5s5y5oNlpmiR/JxO/Gf2NRnEkT1em+pWpLdhwAmleuxY7xiTBAaOeLhXjGepIg0GN7B8+XqnKIaO6GuCBAnCNYN7VF9g1HBzc+P3ZiP66ScfCZ04e/ZEWrQw/Gyjfj39ZSQHKl68IL8HT9C1azd1u/CuwaAXz8z8+ct126NqAWebmYPUXWCFNrICZSoB42Is78C/DhW4PIbZwbWtxBbtsDLa1qvBbpSe329JTezTysSE3xbNG4jhCVzm//77z2SXvXp9x7rgpzKgNVnAwsbm3D5k5coNulJv3rxh/SIBzx6HfU8+MK/dkmTOnIlnxgvzjPY5u2cxnaZQY4oI9xUsVJAtTPXAlDfoHfoCax2cobZu3Smb/f0PirUJdBFj0aa8vVm5GTtmCB048JtM/2IUFNHUu3Fbaj1qEcA0IaZ8jrMT4tNnz1n5OSqKLqzUmuT5JofQJ/btO6TjL02fEeJ0qpUBzxezHIUK5RVFD7QMWHy3hvKq7t17yMrwhFBLU6BQD+7cuc8K52diVdbagQV3+oz5cm9tZaoGKBYYnULAn0qWLAn99tsOHT1h/fotMnIGxwpSoUJJdmb4mxYvWSnrmEK6ePGqvDhAMzAlUP5hecFgEso/UhSDW4gBQGQFHs0ZMqTlPu8k/9BpriVL1wjesChBmTInsOBDmcVzNPKHgXTgj9+E7gH6FOgeGO3PnevLg51Ruo/foUN/SnNJkyYyaPaXX+bI8W/eNO8oGS9efFH8A3kqFAIlHAOToUPHyfUwaDCClY0b/QgDdFgm8E7BBxmKEaRIkRDqyYKFvrIOzP39jzBlJT7BacXRgpmPvn1HyHW1tm1v73EyeAO/OqrF338jT6dulHcw7r2oFCjVjdlRcerUsTRq5CCXV6zHjfNmK9q4KIHkCVOf8L6xFAUjSg4cRY3ifQAB7StnztJMHcor1mr4LlVmipw1UrduDTGmLeV3lL40bVKPQDuBf4Ep/yr9so5Y/pSV1aRMcXnJyquryWO2WH/CnUrsArGx7cUGPPm+fbuKs+Cq1WEKr357ObJnFZoukkTZyluGERVc+6tXb7Kx5piuWRg24sb1YEt3OdmGcnCANSf4bkyc4CPfhvHjp5orFuF2p1E+wBfEh/PwkZCThmI9cGAPsTTqcyfB1cJ0/44dIdxZOK399ddtoYvgpPW5puC+QhGAgG8L5WTEiJ/o50kzIzxxVcC5CJTmRAmgKYDqAAHf/ejRU6xgFhG+OyyhsKbiGpuz6Gk9xmALtIiCBfIy1aOgDNSghENOnjrLo8sLVI9f2HD4g7IISgDuKdwvmuB+CQ61SsBBEFxrcIMhKVMmEwvMhQtXtOKiWGfPUVLW0UdQQIJ4Sg58Z03A04XlGwNFfESNBZZIKHuzZi2RXTgueF2NGtU2cPgxrmfNunaOh4wcCMHZLVw4P09zJTPbTJw47rqXDXB5/PgJgX4xYeJ0qQNu8uRfZtE3rJh79eos/Ow8eXLIPmMHkyArXv7HT5yivcx1A5fuwnl/tpguY4V9qUnMzHY6dAeumyawhEOgMEN5AQ3n+vVb2m75bdykg8G6o1ZAo4DlDpxZWwSK5/bt+6gdz6AYO23Z0k5EZWF9AacdUSfgpOMM0c4NzkitWjXka7yMBz07mYcbtcq8tecmUU7Yspo4cSL5NjnCOdPcseEsBYvuyFEfT1bJn3+eoTM4/PrrHImOAA76DiO/F1OYgKoGKsn27Xt0u/FOHTCgu3zvfZev1W2PygVYFPEHWoaryb+hFJD4MdhC3blzWx5wpWFdb6SB7qaPNZJD4TsyMfR7o78vouXy5UuJFRrfVH3dEPQjRHwbMKCbGGhhyAL1D983/XJa+716dhY/gcWLV5Ef+9nYK05RqGE9y5Qpg/AvEetPX0Dv0FeUMZUP5cfPz3C6B5EIQBvxZ7qAJuBUOyJsmNae+o06BKA0QmbOnCB/+kcqXaoY2ULR2bVrP496u7AFMr84EekP1ODNu379Qg4pl4d51vfEoor7y5GSPl1auZdDBnQtDZoGTQTcb1NSq1ZVubd9fPqyVdKQdgDnR82D3lTdiLaZmGmUKlDaIxLw2UuWrGVxmqtf327ipQ26yhV2/MRgwl7BC60hc83bs6MlnJOBBUIewSN74aKV9jYbrfXatWsmkRHs6cSkybNp96417FS7ia1yr+xpwmIdhD5buOAXHmC2dkhED4sHM9q5jmd28CFbv36rDG5bt24sNIFLl64J/c+fw61FFfXEqCvhVhMzD7hZs3pMu3nP9KUw6lm4gg7YsJ0NRFAcXF2hNvW+MI64wDqJCKh3msAIgudam+XTtpv6hdN5VqZ8rFq1ycCBWAuZBofIHt07SlUYCrSZaESkiaqoUJ86wECNN+J/YeN73al/ovdy/sBKsimG/ie8/T8jxdndaF3XYAxZgGGpS5c2MjuTh2OK58yZnR20Qwwx1apVECX6CM/sIjgBOMs1alSSv8KF88kZwpkcg13NV8rUaSOkI5x94V+kLw8ePGLa2bc80zGSneUrEAxNp0+fZzpeNTEs6JeFb9egQd3Zin6R6Uaj9XfZvOwUhRpmd5jf589fIaNPrZdVq5YTZzLNKatggTzMU83EfMsTYsnQyoECAgemKlXKGSjU2n7169oIYLoFYRJv3LgtjgNabxMmTEg9enwrjgKLOWoHFDuMIPECtSTHjp+ihw8fs7NdReY4Z5M4qNqoE4oNlOkffvhZF28SSYAyZ85oqUmDfZo3Pizq+pIjexZ6++4tK/935CN8+/Z9Kliokn4Rs8uwXFeuXIadCh+x4rXIoFz//t0k1OP4CfZPNWl9hpVcX2ARB6YfPph6jeuXNL+MSB/9+3/P02o3+BwaiSUZiRi0F5/5mub3gJcJOg/+GvNg69dfx7BVfDj9ceBPHa3EfO2I98AZBYPwuHENqRRfpE8rswuwRmr3TMStWS4BhQPTjppF33Lp8HvhBDdq1CT+G0TfM7fZkQIr7JLFU3nQMtHpyjTOA4lfenkN1Z2SxlEGBQkft+7dO/C9GUAXLlyWGLUYVCG9uTOkfv2abFVdy45Sv0c6iUtE/cU1hs8AlEkkxHFVwfXCjJXmuIV+au8UzHBAnj4NcdhKnTqVrOM/vN8QHcSUQq4rFLrQrFl9mQFcvnydwS7Q6TA7BmUbf5BEHElJc74+e/aiwxXqt1Bk+f2YGKOESCrV77m/TzhEXkaYvEMVazSJucEHoUGsYd54wsYIKcPLEChhoJ3ACVFf8PVBMy9jaCLyTBkziOEF3ybobxA4tUNKlCgk99jDh4+ErodvfqdOIcYp3EsQRMCKy+EKzSnU8HsoWrSAcJ7PX7gkdfT/w2xh+Qr1dZuOH9vBNKWnQrfUNiK4wKxZP4nu0a5dT4MBnlbGll9cyygXeL3jAzd06Fjhz2oHhNcnSOCgeYCribjEsPpNmTLPwBsZPByEOwFtxJvbUBKzEEBkC3CSZ89eQsZKY7Vq5cXSDEdAWKlhAUXECG3WAlxXYwUbL+39+/+U+wH3C8KUaQIHRVhPEQYPgnaMLSxaWXO/8DKGco9BgCbI8AgOKqhIjRp34Cnih+IRjwxit9jDHYJp/08+TWDS2l6oYD6Z+sIH3BgDvDgKF85LOXNkFT4wjg36AF4sOFcoxaCuGAtmcjSFEfxtYIfR/vgJU0RZhHNhvnycbYzpNfr0FeN2IlrPwOGF0BdYFTUqS+LEiSOqZrBfe5FiY7eu7ZnjPpit0wM48sEaWrV6s/DIwatMx9db30nJoBEbVsC/vH//kVhHMWuBsEmQlSvn8GxZeraWlHEYR7Ne3VoSuSYy0SG279gr8YqhaDrS/2Pc2CHijxLdsc6NLx3OEX9jOREMfA5mzBjPPhZ5aCTzrR2RVMX4eMbreTmUISIB1fZszc+K/YNN43YtrSPUZ79+3VxaoT7FlDm8P2EEWxuaPAPcaFjxoWxDTrGlD5xwOFiDCoaBacmSRWX2DQ7nlgTGFWSPRFQQ49jc3b4fSPjTF80YAufmyCaw0m9XW4aCe48jfGSAEhxJgTp8nLGrGseDPg0kAgEN2RW/4fUJcIhj7RpK95lgnm3Hu5sr4M5Lx3Gws3KZKRybWov8wZspjVswPWFF/zk7JsZE0Rzo9fsOQ8zcuZMkgsvMWSGGpTVrf9MvQsiKC8t2p059TEaB0wpDJ8Q3znhgpu3X/+3EmVwxYFu4cJUuWhx0g8mTR3FYxvTipO2I964DbiP9bodfzsVmfsThxOgSzmj6coT51K9evdZFbIDijQf1+InT+sXkw3fq1DmhjYA+oiRmIQBFCVZSOAoYC+IIwwpRulRxQjatPXsOyLTQiuWzqX8/Dm+2cbHJmJAbNvgJ5xm0H/2YqSc5TioUzREj+tOA/t15Kn2dhNQxPq6ldThGHDp0TEbISMHdreu3QlOBpWReaBIDcH7hnLOR+9ezRycCJQIK9xrOzhQ/fvxwzWPgEEJl2h1uH2Ijf/LJJ2yhKy77wC3HVOcczk4GJ0GEq4PVSF9Ac4GSC+t2Ff744WUAZ9y8eXPSyhVzpc9r18xnpT8jc5SXRkp5vHr1uryEwI8cM3oITZ0ylhWfAfrdMbsMRRbc5ty5s9GggT05hfEX7Dx8WCzmY9iRGAH5sR2DadBl8J5wlICzi/BeyJj1fbf2NGvmRB5g5BbHTSjcmPm6eeMYnTi+Q+5Be4/bqVMLWrAgxPHR3jZQry/Hbh43LsyaG5m2UPfbds1lMBmV3OzI9hH1MUhDRBpEBsHULKb+o1JAgYGzZMdOvZ2mTON88Izi443ju6pghggD5+bN64qj/2QOHQqeKpzINUoaBry+vuvlXbNwwRQazTMrXl6dCM7f8AeAIITns6eXaf68yQanWqVKeeG8ruZBtDXWbIPKUbDCei+dZIU6J4eygzXZFinJGQ8vcCKXCnppwxdz6vK0bG2e7vaOanGmxRmhAe/W6iVnmceJX/KwAv0zx/ZAmvJZboH0hEMV+rkbfjfysUJ9iWfZ/rGlUx9p2TOn99K9u6f5+5FezhDKMGJPw1BrTPfQIMD7Hd9lfAcnTfpBZshHjfpJ2820ok4yMww/IximoHRrfzVrVNaVs2XB8CttS00ry8L6BmcvLbqHfrUHPG1/kT30QfPASxTT95hON8WnhQcorFwYOSuJOQjA0QShDBHXFOFojAXOaVC2mzTxlF0I57Vt216xYgwb5iXeu3hRG8uBg0ckkccJjlagP1CbxZkzkTgIiiWcoTDdBMc/KJ/pebrfWkGsYkT5aNGivnA+wQf7/vtBugQxUFIQ0g+W9x9/9OYp9b7Snx49hkgoNP3j4OGHbwAUy9NnwmNwgD9ioGQ0aFBLqiHZxvHjZ1jBqEk9e3aQAYNG6dDahUMQaC8tWzaUDx62d+8xmKevFjPexaXPUB5Hj/5FR33R6tr6e59pKj17DpH+wxkUVvBFi1bLdcMMkyXBRxMe+5glAIcUfFpYuJpzVj3cE1DMhw71YkfU+8xn5W1sTXeUgE4CqgNS2U6cOJyjTnjKgAiKK+QTDquEfmFg5Gbz51SakFjSp09fcAj3GRbAMzxNiSxfkRVQC2CB7eU1LLJNOaU+uOOItgOOscRZ50F2VMmM6T8KxSYi5+eoOD5C6CEmtasKntemTb+jU6cu8DPfkQc6LeX9A2uhvmCmeNmydTJLiIxzuHcxINJmghIk+ES+13j/60vr1o3kXQeajavI1iB3ysszgEk0noaVHfuUFd7kcdwIkUI0OevuQa3fBYqCvoIzLaZk5brp+7C04yh3gBPIdHr3gcqw5dmXy0AJa8IG7JdaI/wLYkQxNgz5scUblu/YLtD9YFR6+TJkeIFMmniv+zN9SrvnjDH6MlNG0QHgkLho0SqOu9+Y8C3TpEqVckI9ypUrK1MORxv8gYpmj7jFT/BF2N1gTwsxpg7Gn7HkVGPMNVEdVQjEbASW+85ipX2Cw/jJsF5u3bJMXv7GgyhrkcqcORPPbvzMCk5bhyj61h7XUeUqsEUUDkmdu/RzVJO6drpzZlFEvLE2gZCuooMWkF11+fJZnI0xhFPqoGZVM5FA4FOuezjOBxrJmRFXG1mJI9FspKrmDgqg7fHcqEiAG93V54FEqtWYWRmUvTNn9kqQgSJFq7r0SUS5hdqlz151TiGgEFAI2IkAwkHBwu3IcGuIeDFz5mKmwnSzq1dQyOdy4pYuXfrHSGUaJw3Hxc8++1Ss/3aBYKYSnN5BORjJDqDRJbDEI37z119niq4uqOMaIQCu888BQdTVw40su8MbVYyiVZj+ujKVZCHPWsZ2ZRoQI74/8khMmTInihB3XLNKoXYclqolhYBCIBYh0Pm7tsJPd/QpIwZv2bLFhW9uS9thET0cZzG35fiOLIsEOUi24qiEN7AMT2I+MLjaznJCNIcHHJunTxvPyW6+NldEbXcyAr5u8ekNT2B3CH5nJ/nLcR0uF/yeijIdZCL3SQlxRuPV/Nz2EQd2V8dDKdSufoVU/xQCCgGXQwCWaTiRbvXbGSV9QyIEKJTWCCJWtGvblCaz483mzdtdOoqENeeDMkgKs2rVZk4k1MnaKhbLzZgxgR2VJ0Z5eDyLnQjdiWgmZcoUk6gu1pRXZaIeAUTf6BAcl1K7AGM5P/ehdYA7PYt21T7qcbfmCHfu3qNlvmutKRrtZRSHOtovgeqAQkAhENMQ6MjTkLCezpi5IMq6vmTxNHGqRYzqN2/eUCKOi46wgogAg8g4qThMI0IqNm5cW9anTp0vkUKirENObhj4+m315Snf3hya8o7dRwdvGgkiXCWpCizTcPZDeNjInJfdgKiKCgGFQJQgoBTqKIFVNaoQUAh8zAjs2b1OYhhHZZa/1avmSlgnxOs/f/4ye7i/5GgoDyVlM5JrPHz4Nz169DfzgstyPP8iEktVixP+sWAP3nNfDn3VrPl3dp0S6vv49Kd6HIEiuqkedp2AqqQQUAjEGAQ8Di1aEQAAIlVJREFUYkxPVUcVAgoBhYALIFChfGkJaxiVyjROE9FDTpw4S1OmzrOYnhtOkSjzMcpxDouJQYNn7aq0SS+BU0TnOmhgD8m2h4gnjRt3VMp0RICp/QoBhUCkEVAW6khDqBpQCCgEYhMCKzjs2RDvsbrMcbHp3KPjXOFQuGnTEqpRs4XFgYXWtzKlmdvOVBHEf6/JdVwtS6TWT/WrEFAIfFwIKAv1x3U91dkoBBQCUYgALJ5IA6+lYY7CQ6mmQxFAqLmpbIEfOKA7IaGIOYFzJugdT58+l8RBCCGolGlzaKntCgGFgKMRUAq1oxFV7SkEFAIfLQJdOrflONGLPtrzc9UTW7V6E7Vq1Yhy5cwmKbz1+wlFeiCnr0cmUmTBVIMdfXTUskJAIeAsBBTlw1lIq+MoBBQCMRoBWDw3b1pM5SvUj9HnEVM7j9mBqVPGUiPmRIO/jvVxY0NCC3p7j3Nogp2YipHqt0JAIRB9CCgLdfRhr46sEFAIxAAEEHN6wngfQmbEJUvWxIAef5xdhOUZvOiHD86Sn98udjQMJIQUPH3m/Md5wuqsFAIKgRiFgFKoY9TlUp1VCCgEnI1A3jy5KHv2zJST6Qb2hm9zdp8/1uM9efKc3Dg385w5S2n7jr0f62mq81IIKARiIAKK8hEDL5rqskJAIeA8BJBgpGOHFhQYGEiz5yxx3oHVkUwigKgfcFRUohBQCCgEXAkBtwSfZuAM9rFB2KxBseRUY8PlVOeoEFAIKAQUAgoBhYBCwBkIBAcT/7MoHu5xLO5XOxUCCgGFgEJAIaAQUAgoBBQCsRaBoICIjbIegR8iULk/Kvhi07l+VBdOnYxCQCGgEFAIKAQUAgoBl0XA3WV7pjqmEFAIKAQUAgoBhYBCQCGgEIgBCCiFOgZcJNVFhYBCQCGgEFAIKAQUAgoB10VAKdSue21UzxQCCgGFgELADgQQmQWJeJQoBBQCCgFnIaAUamchrY6jEFAIxFgEKpQvJZn5HHECRYsUoFUr51LJEoUd0VysaiNdujRUpXJZTvASN9x5Z8yQnpCGvEzpYnTi+Ha6d/ekw65ZuIOpDQoBhYBCwAgBldjFCBC1qhBQCCgE9BEoWCAv+fj0Z+UsI2XMVIgz9H3Q323zsqdnVfL0rEJff52JSpSsSW/fvrO5jdhYAUr0ct+ZVKRIfvL3PywQuCHLC4dDRTire/ce0tOnz+jFi1eM6XvBdcH8X2jixOm0afO22AiZOmeFgELAiQioxC5OBFsdSiGgEIh5CIA6sHrVHEl7vX37PpowcVqkTmLqlLGi9D169Ddly5aZvu8+KFLtRUdlpGGfPesnSQE+Zeq8KO1C8mRJqV27ZjwIqUrXrv0lA5vu3QdHmHIcKeOhhE+cMJyV67c0cNAoNXiJ0iulGlcIxG4ElEIdu6+/OnuFgELASgSgnPlt9aV23/agu3cfWFnLsFguTl/u49OPGjXuIDugXPv7H6JVqzcZFnTxtUEDe9Lw4X3YIvycrly5zlb7ABkk3Lp1l27dusN/d+n69b9YofVgZbgpLV++no78ecKmsypYIA917tyWoLzPmbNMrMz2zg40buRJHTu2pF69htL5C5dt6kemjF/QkSN+YhXXrptNDajCCgGFQKxAQCnUseIyq5NUCCgEHIEA+M/ff9+eWrXuZldzmzctpV5e3qJsogFYUTdtXEpevM1WRc+uDkSyEtJ+T5zoI5SK3bv96fz5K3T5yjVpFfsysvKZMWN6tiJ/yb/pqESJIpQnTw569OgJK97XZCBy/fqtUKU7RPG+dfsugf9co0YlWr9+K5UpU4w6dGhFN278RTNmLIzQEm3tKWXM8AXNnDme1q3bQnPmLo2wGizjzZrV47/6VKDAN1K+aNHqDutPhB1QBRQCCoEYhYBSqGPU5VKdVQgoBKIbgZkzJtCqVRtp954/bOoKrKR58+aiId5jDepB0Vu48Beq7dmaXr9+bbDPlVbKlC5Oo0YNpHHjfqWtfrus6lrqVCllALJkyWpRvKE4Q+nOlOkLysDLmTNnonTpUut+wYOeOXMRLViwnJ4wH9rRglmGET595djdmWrz4uUrg0Ngf4XyJcWq/tln/2PL+gZat/43SpwoESVLlsRgdsGgolpRCCgEYj0CSqGO9beAAkAhoBCwBQFYLtevX0DlKzS02kERlujdu9ZRlapNTCrNnrXhqFiVOnTsbUtXnFIWHPJRIwdQ6tQpmYLRL5wS6ohOlC1TXOgdo0b97BRLfcUKpWnIEC/azM6KoKgcP36Gvv22GVXg7bt3/yEK/V+83VjmzvmZFi9eTf77DxnvUusKAYVALEdAKdSx/AZQp68QUAjYjkDHDi0pceJEVjso+gzvL1xj3+VrzR5s4gQfOnPmAi1esspsGWfvAMVl7Fhvmjp1vlhqnX38qDwe+OzHj+/gQVEgK9bbRYneveeAxUESZhOmTh3Lswkto7Jrqm2FgEIgBiKgFOoYeNFUlxUCCoHoRcAWB0WNu1u9RjOLnUabW7f4RjufetDAEKfLbNm+5igkX5NXb2+7nTAtnrAL7Bw1cjC9fPnS6oERuoyBz6ZN25SV2gWunyO7kJrDL3YOfkcj3BLwUvSJV9Bb2k5x6bx7nOjrhDqyXQhEi0LdoX0LSpIkMc2ctYj++ceQM1ioYF6qVq2iwcm8evWKrSNb+aV+X7e9ZYuGzMPLoFsP5kCk9+8/oLXscPLq1T+67WELIfFKw9bVkkJAIWANAuCPdurUip48eUbzF/iGq2Lts4jnPnXqVLr6wcFBdJsd0lat3kzv3r3TbTde6O3Vhd6/f09Tp0UuPFutmpVpzZp5EukB757IirUOikuXTKdJk2bS8RNnIjxkdPOpc+XMzlbb7Xw93hNC07mStTxC8JxUALzw1avnUukynk46YvQcJn78+NSkcR06fPg4Xbl63WQncmTPQlWqlKf48ePR7NlLmA700mQ5Uxu/69SGkidPSsuWrSF9eo1Xr870v/99alDlxYuXkX7+DRo0WonH6+vd3tGeoGD6SU+h/iYogKq7BdCrYDda6x6P/iboEdbJ51wsb9AH2u8eloQoU1AgNXczHcf+NWvxM9wTUMWg9zTOw40qBHnQMxuOZ12vHFvKwyMONahfi2Pqf0lBjN3Jk2fo9217DA6CMk0a16Uvv8zAdLc3tGLFBnr46LFBGW0FdLpG7GuCqEDW3ks5smelBg1q0V9/3aalfC8Zi6X72Ja+Gbdrat3pCnXaNKnoxIld9PnnnzFnsDXt3OVv0K/O37WhyZNH0ocPARysP5gQtz9u3LhsRXhFdeq0ocNHjkv53/1WUrlyxflDG3Jzuru7S5zYixevUvXqzUxcMKVQGwCtVhQCViJQo3pFVkTn0/PnLzhiQzl6+uy5QU1rn8XDh/woX75cumc2Thx3ihMnDh09eopq125l9gV6984peRFnz1HS4Ljaiqbw37//0OQLVSvnaIUa7UbkoIgMi41ZKencpZ/WjQh/waeuV6+mhOeLsLCDC2TL+jV/zGbyO3i2UqYtYDt61CAOpXfio0wYAwWkdatG1K9fN3beTEcNG7an37bsCIeGz/B+1KdPF/4+s+LH74TixWsSIrZYI+XLlWSazRL+vrtzdJfmtM//oFRLxJFiLl86IHQq/Xb++usOmXv+9cvZu/wtW6bbxnGjykHxSBvat+VtU+LFpZuBQZTYPUSRrvE+mM65e1g8DBTprsFvqTvj8huHk/yOEujKF2IFe3Sc8PbvLKy//MN28SKBcek9l17Myv0DVlD7s3LvqoJBz8oVc6hSpdL077//yX2AMJkTJ86gocPGSbehsCIrbI0aFUWnw/qDB4+pYqUGdPPmbd2pQZHu2bMT+1G04W3BVLhwVYNBlq6giQXt+7N37yGqVr2JrkRE97G1fdM1aMWC01OPlypVjB+WzwkKcJ061c12sQt/gD5PlJkSfp6Z+vf/gRImTEgjRvQ3KA9lumTJWlIuWfLsPNJdRzlyZKE2bcJANaigVhQCCgGbEajPFgh3/qAkTZqYQ5oVN1nf2mcRM1JQyvFsp0mbh7Zv38svz3xUt241k+1asxHvk379ulLLlo2sKe7QMt4csWPEiH6SQMS4YVA4hg7tTShjiyCrH2bbOnVsZUs1h5RFSLxmzTorZToCNCdMmMYW/PYRlIp5uzGgOnd2H02ZMkaimpg7g/bfNufv8vd06tQ5UaTTpstrtTKNNocP7ysxyo3bT5UyBcWLF0+smAk+yUDaX1Qq07CF9/JwpykBwTplOjFvG8bK35QP79nK7EE5A+LQHbYue8cJtGgzrsvW5YseAdSBFUt3yeJpeIbH2FpdNTiewV8tXr/Hs3WbWXGHMg91e3qgO7VmZT49BRk24EJrbds0E2V60aKVlDJVTsqZszS/tx5Rt27tCP4JEFivq1evwLrZWkqSNAu/p3/gWcoU9OO4obozqcnhMi/xIKpPn85iFNXtsGKhWtUKVKpUkXAlrbmPrelbuIYj2OB0hbpRo9qcAOClxC+tWLGUVQAuWryKaRyvJLSSufPBlPGKFevFql2QaSNKFAIKgcgj8Omnn1DZssX4w3mercT/ytRaRK1a+yyCmrVoUYgDXhF2fouJgtBuiPrg1atTuO536dxaYh7bE/5tuM9EiYGM1NmggThDENbvzJnzurjSzjhmTD0Gwu0h/XmraBjERSVmUHaQwbNx445yX5s6Fix73bq1lzTvTZp2opOnzpoqZnZb3TrVZBB982b4KCpw9IVC/fffT83Wd/SOUsHvKRlbyncxpUOTorwtORv9FgTFFQUXxNTFrPAWj+NBibRCJn5TugWR94dAyhfoQXe4vDUCWkkebndVUBhn+iQr3g+4fgPuh6tKnTpVJQPplCnzxLH3DlNyt/BMBr4ZoIBAGjasLZbpGTMWSpmZsxZKttNSpYpSksQYthClYdbCzp37qXRpT7p82TS1SAoa/Yf7cNiw3vTw4WM5hv5ua+5ja/qm36Y1y05VqJMyb7pEicJM+ThHGzf6yXRS0SIFI+xnAuZnwaKN9LGWBABD3rx5Y6mY2qcQUAhYiUDxYoU4TnAaUQzPn7/EM0KFma6VMMLa1j6LWjnTfg8RHoYm/TxSrBsJE35GoIC9ef0XlS1TQirC8nHl8iF6+99tevTwPDVvXj/iBu0osWDhSuaRlpOMflp1TGGC6jFj5mJtk02/yAj44sUrUaphfY9qQWg8JKwZO25KVB/qo2l/ypS5kn0RMxEfi+zjrJ2lSte2SGXJlzc3K0yZaNeuP9gi+dCmU4eyhXCFSCF/woRPAWabQAW7evWGTe1GpnBN9yA6HRhIz/Vsz5mZbvqM/x7rOQZeCY5DydnqnIot1eZkNlM0FrjF11m6zZXT397MPYDOBAbQBT0qCTSdI3yc6qz3OFVJ0+9YBMuwOvv4/ERQpDV5/PiJLCJyDiR9+rSij13mbKoQbEckI3xDsmXLLNvmzltGTZt1ssrHRCqE/te4UV2O65+bVq7cKIZU/X3W3MfW9E2/TWuWnXqtMCrBtPGmTb/ziMRf+ocPkSWBEj5sWF+5AL6+680WzZolszyoHz58YKvXSrPl1A6FgELAegTwfOIluIeTmGzY4EepUqWgEsULWWzA2mcxb55cNJAjSrx5868kSrHYqJmda9Zs4unjCTLYvnjxGjscetPVazfEAWYOxwxOkSIZT1/Po3nzfHl6soyZViK3GcovaB1jx3jrGho1ahD3azxjF+Ljodthw8LAgaN4inSERNqAwhuVMnBAdw4HN89kjOyoPG5MbhtW6tWcMr5Z07ox+TRs7juS8sRjOgIS3dy7e1oGrBi4VqoY8fPVtEk9ypUrG4EyExQU3oIL3yo3Vlp79+7Mg+Ob9PqfG7Rm9TyCHhAVAhNcfrZOX2DKhT6zOYVbMH1ghVr/6dXSDCVwIA0DfGtPWKfZGh1gdIInuEPZWKGO2iff6KA2rC5avJIm/zJL/Nu0anjHvnz5D506fU7bJNcTBlFNMPuAawyOs70C/vbAgd3ZmHJN9El720E/HNm3sLO0t0c21GvQoLZ8+Px5FPzn0RMSiqlWrSomW5g7d5I8qPfvn6H27ZvTgQN/0vgJhtYTPNRHj26TcmfO7KFChfJyqtrFtHffQZNtqo0KAYWA9QjAelyTI2PAe/rosVM8xX1IptZq1aoarhFrn0VYksGXg9X4yBE/yp79axoz5hc6cfJsuDat2XDg4FG2UGyQfmGqGimlYTWrzpGCMHifOHE69es/ggYPGU2DBo22pkm7yhz584QMDEABKMmzcHjh25pJ0fjASOk9hZVceLy3axt1fiHgG+bNm5OjrWwy7oJajwAB3G9durSVFPIRFNXtzpY1MyfKGWSRwqgr7IILcByEVKhQSqb44cCKaB0LF/5KadOmNttjOA9jtuXcucu0YqVp49jnn4e0jag+EyZMp+vX/6JatSrTTz+NMNtuZHaAP52eFerb4XX7yDRrdd0KzLlOxv4pG9zC6CZa5bvB7pSCFdHEJgYeWhlX+q3NulyhQvnknrh374F0DZHZYAzI800OXVcR7SOy0q5tM5klGTNmsjhE2tNeVPTNsruqPb00Uwcf0tKlizBH5gZduHhFSu3bd0imNBEq79jx0wY1167dQqdPn5dteHDLlStBQ7370HCf8bpygTyqQ5pafEgx0mjduhG/3Fpzpit/2sbOTkoUAgoB+xEoXCg/p4lOT9OnL5BGoPTCM7tKlbLCk4NntybWPosIxzZt2gLxo4BHePv2zWjw4J60f/9hHmSf1JqL9G/+/LkljBMiMWiC90RUyvbt+8jXd7oo1gUKVHbYoZAMZvu2VaJcO6xRvYbgiNi3r4/eFrVoLQJv376jJUvWEBL9YPBjjfj49OcoLtVFCe/bz8eaKi5VBlG3IPPn+1L3HoNlGTjAYliXAw1MnxHyvpAdev916NBC3ictW3aVWS+9XbrFxUtW0o0bfwkt4BlHFcK75/DhrRwlohKl4UydD5gv60iJz3bpBKw7vOA/ZwuO2MojmPyZ7nGXwltr/2UKCsokoUC67bLEjxDUEL0N0dkQjc1nxAQdlKtWbZIB0cCBPelGp96sozWJ9Ewh6HS9enWks2cv0sZNfoSwefZIVPTNaQp18WIFJXUtODbeQ3rL+YNHA8sW0r0aK9R+fjs5BFZIVrFp0+fTSQ6116FDc/r11zm6sF2BzHtauHAFnT13Udrbs2c/U0nW8ij4e6VQ23OHqToKAT0EKlcuK6GQwDXTnllQqtKl+5IKFcxnkNjC2mcRlqfZsxfrQiL9yZbdTZsWs0LXlRo36ah39MgtJkjAyRkwZcvhN50lt27dFmV6wYIVHPHgjsMOC2UFDnA1qleirfxedKQoR8TIowkr9Y7tK2V2BNfKnJQpXZw5p/3oIM+qIPPknDlLzRWNEduPhIawRWf/+OMID2C/JwxkTUnKFMklKgqigiCKjTkBvUx/hvnx308Ihjf4I2Rly76jFWqtH/+C7+FknRoRPMrEiUtd330gNkaHkxfhtrjmBsxkgl6XiuOzd+nSn3ML3NN1dP2GLUwVrMEDyBo82/An/fffW7pw4TLPTGaRQBO6gjYsfMehlTETAiOAxtW2obquaFT0zWkKtadnNeGq5ORwKvjTBB+9unWrM51jqrYp3C84lrCMFWfuJoA0joOrVYAFDWG50qdPo21SvwoBhYCdCNRhb3zwHGvXriJ/WjOIHY1QSP77D2mbwv1a+yxeZ2sULN0ZMqQP10ZM24DELQjfmSBBeGtTZM8F/OYZM8Y7VKHWHBFr1GwR2e7F6vrgyWMQ1avndzTux1/DYSEUD+bUP336nB1jO5vIkRCuiktv0JIwues57CFhB94VGMiaElA74X+Bv9f/3DQosm3bCuaib6ZWrbsZbNdW4JyLsJ2R4dxqbRn/BrAWjSF3CqMdD3g9LlutQ2zxITuThbKs3zrIWlyfI3j8FxzXILqIfjeShB7vg7M1ff1OWLE8cEAPqlixNM8mLKQlS1cb1IDC24zveTiIQ3fDwGvWrIniq3FDLw61QaUIVkABBu95xYrZBiXhlP7q5XUJpawZWQ0KGK1ERd+colBjBAOy+q1bdylX7tIGo4rfNi+VyAE5c2TVUUGMzltWQRnBAwtLmDlJkTyZJIFxplXKXF/UdoVATEagQP5vJPTRpk3bxQNbOxc8h4hTW7NmJRo0eLS2Odyvtc9iQubXgfrh6GcWUQQQLSAZTw86WyxZKe3tCzKLQWlBfNfzbOFxhChHREegGNKGL/Pc/fdtYAriQk5Q9Eo2IqYy4pAjSg6cVh113RzXa/tagnEL3+KyZUvo4pUjAyqeNziJmRJYs3v0GGKwqxUnj0GI219/nUs7duyVfQcPbKEvvkjLekIZXcbjr77KKO8HJI9xtCCaxgtOoJKInRD15SqFRPRIy5E2XoYOHLJwSLwnbAB8pDeQ0K9jyzIU9SaMlx8Pxp7pJX7RbyMJr6B/zx1wPP12HbkMR9T+/btJci4tmYup9rdsDZlZy50rO+XOnV184kAPsUfg7P3JJ2EDt9RMBUJM9KtXbzKdcJ7NkWcc2TcTEw32nKLlOgi9hWnjQ4eOGyjTqLV16y4G5xPmSJc020gb5t18w6T2Gzdum02BitFr377dJAMjHBiVKAQUAvYjUK5cKUknjPCW+oIZoOPHz0gUDaTeNiXWPotw3OvZs6NYdHcZZUw11a65baCR4AOfOnVyXVz7gwf/5MF3kEwzI0IA6GVtjRz7MNBH8hREHogJAis1HOAcIcoR0REohrUBK/XkybNk6rtggTwEq93SpdMl3GS9+m0/GmUaZwxfBwxYPT2rUN48OSkxOyl6eX0nxq79obNWSM/e26uLOOiiDgYTs+csMfhD9kPMUPv57aJdu/ejmCzDwbFr6H1etkxx9r0qKjPU+pEjpLAD/oPCep05yjlDMyFqTZ50i0uP+Z3SidOEQ0lCpI22rAAfYr7zy9BCifi3ZdA7i3GpQ4uG+8nHGRMRe9pXL/a0caGvWYFHMhmOiWG8yyXWYXGGtfn581fUus33Qnez1LESxQuzv8E0eUf/9NMMS0XD7cN7GjNAcIiFFVz/Xlq/fqu8/+EjgxB85hgM4RrV2xCZvuk1Q06xUFflbDb4eIEXbSwYuSLLWv36NQycGWbMmMBTCOOlOHjW+JB7eXkbKOTYfuDAb1IGTolIgXrt2k0aM3ay8WHUukJAIWADAnCaAt8NMUONBWEvkUoWs06IbgGx9lmEhfvMmb1SB9N2eC8gaYzm+Cg7TPwH50hM5+kLPsh58paj+w8e0cWLV6kY+2k8+fsSZ2BtQzt27uPUxtslA+OdOyf5w02SHhkfcE0KFsgr0QMQ3/7QoaM2ZXrT2nDmL7AeN85bFBjNCmrv8ZUjor3Ima8HCg3oUWXKFJOMcNU5pXZkwiaaP1L07gFFq2fPIbRmzTzmg2+RbzKe/1mzljAN7LB0Dk6EY8YMopMnOZNiiRpWd3jatPlMJ6soXHOEzvvss//Je8jLa6jBt9/qBq0ouCcwmJXlOBSPXw3vQ8uDv+zDdIUpnGSmYuAH+pzfVcRW63ZcQOM71+HU5DPix6WEnFRuhrttNK/m7oF0gyOL/MkJXEwJVOiinAr9EM/IvzcgnpgqHT3bhnM443TpUsvM2b69Gww6ce7cJapRs7lsg+/HypWzhD2AbwqyJerz5A0qmlnBvYAwjRs2bDUI02emuNWbHdE3/YM5RaG+efMW/fDDT8Kf0T84lsE7HDZsvEwXIej7MQ7PNWqUoUL8+vVr8ebUz6y0lEcp4OOESbBkzFmzZrNuyi1sn1pSCCgErEUA1txNm7ZJjF1T09S7du3n5/lnDnt5X5q09lmcy85bmBrWBMrtnTv3aO263yxaN37+eZZEFdHqab/IuKpJy1bdqHmz+hLt5xrHoYa0bNWFmjSuK9Z0TC8ePnycI5SUl3cM9oNnN5hpK3jJ37p9F5tcXpBxrF275jRp8ky7+6ocEe2GzmLFrTytDSd58IE1i6vFCi6+c9u23cL7vnIl5HnS7+6evQd4VrmeKL8wZCHp04aNv+uK7Ny1j5XiiTxYNh8Oc/36LUIRuXUrzIEXkT2qVW9KjTjDXpo0qeXZRCQHGMqiSrawNXoIB6TOGhBA5/SSqyzmBC1/vgugGm4B9G+AO63lTIp/61my/TjU3RBWpteZUKZZV6Y5rJA/hH3biAfAh6JLXGAPU03+M9qnnSP404W5L215ls1FDdSE++POnZBvgNZv7ffhw0faoly7cZww6tmzF3yP+NEDNoCYE3wjkiZNIkmt9MuAFvjPP290zuz6+xDoYuzYX+Vbor9dW7Z0H+O+srZvWnuWft3iJ/gizGRjqWSM34cxXyw51Rh/rdQJKAQUAqYQQFY+cHXLlK1rs/UT8bHhFNar13dsPWqhkriYAlhti3UIQDNY5PaOHvAAf4AZPrOzQWnO8am7srmzYlA8m7IuOrufzjgeMt9u2bJMkn99276XMw5p9zHMjI/sbk9VVAgoBBQCCoEoQgAUAlBZPGtXtekIUMS3cSxrX9+ZKiOiTcipwh87AjCz/RDsQZ5sEc7CfOroloTcAS8PNxrK4UfeRXdnXOD4SDqFWQz9+NYu0C2TXVAWapOwqI0KAYWAQsA1EYDD14IFv1D1Gs2s7iCs0/BLuXLlOjVs1N7qeqqgQiC2INCGOdHV2cTYPDi+A5OL247eKI7tgZQu3pzsRc2p245fdNZwCoc6Ok9QHVshoBBQCHxMCCCEHkKQ5s2Ti06fCckma+n8oEwPH96fSpSspWgeloBS+2I1AuBMH2QnwKBonrdfGBSXbnKoPKVMx7zbMZpvnZgHmOqxQkAhoBCIbgTgnAgudESCpCJjx3pzyt9uSpmOCCy1P1YjAAX2qgvEfL7GfYh+4kmsvhXsPnmlUNsNnaqoEFAIKASiBwFYplOnTkGgf5gTKNNICdy4cccYn53P3Dmq7QoBhYBCwFUQiOPhkcjHVToTtf1wzeDoUXvOqnWFgELgY0Xgn1evJQygYfjQkLOFoo0kCh079uGQgGFhyT5WLNR5KQQUAgqB6EZAWaij+wqo4ysEFAIKATsQ2Oq3WxLsJEhgmFQCyvTq1XNEmb58xXQqaDsOp6ooBBQCCgGFgAUElIXaAjhql0JAIaAQcFUEkG49caJE9EX69HSOk9RAkK1v2bLpnCzrRzp56pyrdl31SyGgEFAIfHQIKAv1R3dJ1QkpBBQCsQWBBQt8qVOnFnK6UKbXr1vAmb9+pQMHj8YWCNR5KgQUAgoBl0BAxaF2icugOqEQUAgoBOxDYPWqufT27TtKkCABLV++ltat32pfQ6qWQkAhoBBQCNiNgIpDbTd0qqJCQCGgEIh+BDJnzkQ5c2alrl0HKmU6+i+H6oFCQCEQSxFQFupYeuHVaSsEFAIfBwJFixSgAgXy0IKFy8VS/XGclToLhYBCQCEQsxBQCnXMul6qtwoBhYBCQCGgEFAIKAQUAi6GgEecuLElPnNsOU8Xu8NUdxQCCgGFgEJAIaAQUAjEYASCAoiCgy0nhPcIUjkuY/AlVl1XCCgEFAIKAYWAQkAhoBCIWgQsK9M4tkdwUMSForaTzmw9Np2rM3FVx1IIKAQUAgoBhYBCQCEQexFQcahj77VXZ64QUAgoBBQCCgGFgEJAIeAABJRC7QAQVRMKAYWAQkAhoBBQCCgEFAKxF4H/Awoux9iWM/CZAAAAAElFTkSuQmCC"
	},
	"calendar": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAYAAACNMs+9AAAAc0lEQVR4nIXQwQkCMRSE4U9ZLMCT9Xjaq2AfNhfYU5oQLMAOtoN48EWei5iBIRPe/yYQ3qrhf1lFG7iKcEaJxSfukUvMWgdHavt0uWHtg2QwxXnAnJZ2uOLyVZtybzzhgWNmfoFl0/YB87NbzR1cjP9xeQHSDC6mcL1xFQAAAABJRU5ErkJggg=="
	},
	"checked": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAA0AAAAPCAYAAAA/I0V3AAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAOwgAADsIBFShKgAAAABh0RVh0U29mdHdhcmUAcGFpbnQubmV0IDQuMC41ZYUyZQAAAYJJREFUOE+NkstLglEQxf0fahG0iFrUxm2ElFDYLohCqCDaCAkWPaxIRbFFEJEaGEKLDCoMETRFUAMLyaIHBUG6sSKIMtKFqEhLT818ZUgmDhzu3DPn9z0uV1RrmUwmyGQyqNVqfFvViwBxu5RFPZuLSyGMKhz/qlEsRV19K8xm6y+w7bpBPFnAferjj3bdQX6DpHcAUwavAHUN2RGIZxBJZHH2mC/TUeydwwTZvBegLENNgw7sX6Wh1FswNmPEmjPCDyGRRwCtW9E3tMgdAtQw7GZjYcNX+gza2wJ3ZXsSZUuQ0vWCOV8SHfJJ/uluhbHUj1v8PKNMszIoQNRMHCShD6Wh8zyhrbOPwz8w+STKlCCJ7oRNUzQH63kBs5thBghePXxlj2aUoSxDPcuXPNiLAc5EEZ6HIkbmV2DYiXBPHs0o079+K0DTVj/s11mE00A0L+g4VcDp10qKZMAzytBhMaTRaPmYg885DlcSzSij0eoEiIouoUqlqqqaL2rlEok+Ad4vlfzPoVDsAAAAAElFTkSuQmCC"
	},
	"dialog": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAH4AAAAUCAMAAAB8knmGAAAAXVBMVEXn4tfm4dfn4tjn49no5Nrp5dzp5Nvm4dbi3NDg2s3o5Nvl4NTh287k39Pp5dvh3M/j3dHk39Tl4NXg287k3tPi3dHh3NDm4tfj3tLh28/o49ro49ng2s7l4dbl4Nb6VbEyAAAC1ElEQVR4AXVV0YKDKAwE4AAVK6SwC9bt/3/mnYJ2tF7ewMEJyWRgjHMuhFT/nEMb261hxbrqh23hRomYhxLrYfXATTm6DTv060q0vxh9+b+SYj3Muj3c5IORAFMBEtD0rKgoAHIJLWLlfpIG8qAAIk3wk9tJKz2E84GrHUvbVhLbyvw0iA2/6ota/Qbbvv+YbUekbUV6R/Dg3YWN+ZyzT/a8X6KpBLpW3cta2FCOLFMkLuZe97PgFJM7joaG9bUHlVyZWM63tGllZp+yzIwipGFJQwJ5rqgX2e7/w9KrwuYMAtBkgTbS73z0r9JD9IJyy2GJEjSQD9kJwiIeTSNxyC9Dz2VcGiKT6IHplr7VynbA+UpVA+bxQYi/kNPknJtSDn9CfebBNPSrZdK0r+6ImE8p5RzDm4szgFtIQNqme3ZkcBsP1rRvJZBbfr6c4O8Qc04pgfJrY5rs4dJ5hhZ0z9z6+x0vys8Oyj5nKEMTP8oLBw+7OAh9TkCdJ8/5Nno4dt6d506dybUYbhTDmFjtxwxjTvjVDhITiJVNoe5LyoGIQk4Ftd+QEcnlYPF+KY+DWc1WgPSqJeXjXxPpT9uXoBqGx6m7jylyvRvm8hGApuNAyWis98rXYvevZVSguzgfw8kGf3aR4gd2DNUcQX1qXHavvLFrpv6L/nt/d+9RXV8OFDCFEAhHBt+qSr6/FN+37JVS7BC9zwOXj6/JW04JLB7m984v/HIiX77m7iH5kL1198ov8OI0ziX01b32Fo9c3VHzce9xdcs+LC0TeHPKRfmulOLcZfTyW2ICz6Dr5Fl4F41o1q1nYeAts6buhieSy3e+kqzM7PP885AtfB0FJOCoUZnUQSyllAU3kmk4ckAuRqC2OXAh1b3ylaBj9Ka3PidQQxJcBEtGrWRncv2ejrEjVCnSX9tYOuBk07YI4J6MYppcBU0pEgOvDtv+xCCTrtwL5l87wVO3O/g5GQAAAABJRU5ErkJggg=="
	},
	"down-rectangle": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAAkAAAAECAYAAABcDxXOAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAadEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My41LjExR/NCNwAAABpJREFUGFdjgIL/eDAKIKgABggqgAE0BQwMAPTlD/Fpi0JfAAAAAElFTkSuQmCC"
	},
	"filter-off": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAA4AAAAMCAYAAABSgIzaAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAYdEVYdFNvZnR3YXJlAHBhaW50Lm5ldCA0LjAuNWWFMmUAAAChSURBVChTzZHBCoUgFET9TqEiskgyWoutQvRLRIr+cR7XQAjiJW/1BgZmMUevXsY5xy9OoDEGMcYiUzeB67qibVuwQjVNA6311V+WBeM4vsLDMEApde/1fY9pmtI453neHEKAlBJd1z0fXtc16PbjODK07zvmeUZVVd8nooc75zJIOX3Gm6i0bVsGKf8xKIRIuyJTLgJJ3nvQzsjW2geIsQ/pr9hMVrSncAAAAABJRU5ErkJggg=="
	},
	"filter-on": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAA4AAAAMCAYAAABSgIzaAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAYdEVYdFNvZnR3YXJlAHBhaW50Lm5ldCA0LjAuNWWFMmUAAACoSURBVChTY3BqfP2fHAzWmDbj7f8p294RhVOBasEa02e+/e/VBmQQCTxaX/9PnvYGoj5ywpv/Qd2ENft3vv4f1gfVBAP+nW/+h/a+ATtn1q73KHjytvdgg3070DTBgHvL6/8g22fsQGiaDmSHA21xaybgIpDHixa8hWssnA8NDEIApCh3LkIjiD2INYJCL2X6W3B8gdhEaQQBUOCA4gyE8+e9xaKJgQEA/74BNE3cElkAAAAASUVORK5CYII="
	},
	"unchecked": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAA0AAAAPCAYAAAA/I0V3AAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAOwgAADsIBFShKgAAAABh0RVh0U29mdHdhcmUAcGFpbnQubmV0IDQuMC41ZYUyZQAAARBJREFUOE+9krtug1AQRPldSio7FQ1tZImOkoKOBomGT0EURC5ino54yTw90WywQhTkIkVWGoF2zuxdrlD+t0zThKZpT0Vmxb8CQRCg6zr0fb8rer7vfwcPxxdcrx+YpgnzPGNZlh9ibxxHlGUJshLSdV0at9tNpg7DIBrX5+OkPM9BVkKGYSBJEtR1jbZrBdiqbVtUVYU0TUFWQq+nE+I4xvvlImGaW7FHjwxZCVmWhbfzGVmWoSgKWXUr9uiRISshx3FkEldomubXauzRI0NWQp7nyUR+NG/rfr/jUXxnjx5vmKyEbNuWox9Xvid6ZMhK6HA4wnVdhGGIKIp2RY8MWQmx+JuoqvpUZFb8L6UonyYL3uOtrFH+AAAAAElFTkSuQmCC"
	},
	"up-down-spin": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAA4AAAAPCAYAAADUFP50AAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAOwQAADsEBuJFr7QAAABh0RVh0U29mdHdhcmUAcGFpbnQubmV0IDQuMC41ZYUyZQAAAGJJREFUOE+lkwEKACEIBH2Zb/PnHsoGeaVJDUjGOgRRpKpkiIj+y4MME3eDR7kaKOVNsJyMNjIHzGy9YnW6J7qIcrriQimeCqORNABd0fpRTkt8uVUj7EsxC6vs/q3e/Q6iD2bwnByjPXHNAAAAAElFTkSuQmCC"
	},
	"up-down": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAA4AAAAPCAYAAADUFP50AAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAOwQAADsEBuJFr7QAAABh0RVh0U29mdHdhcmUAcGFpbnQubmV0IDQuMC41ZYUyZQAAAGFJREFUOE+lkkEKQCEIRD2ZJ3Ph3iN4WD9GflpYhj0YYowpGgJmbikd3gjMDFokwbuT1iAiurG5nomgqo5QaPo9ERQRI6Jf7sfGjudy2je23+i0Wl2oQ85TOdlfrJQOazF8br+rqTXQKn0AAAAASUVORK5CYII="
	},
};

},{}],4:[function(require,module,exports){
/* eslint-env browser */

'use strict';

var _ = require('object-iterators');

var images = require('./images'); // this is the file generated by gulpfile.js (and ignored by git)

_(images).each(function(image, key) {
    var element = new Image();
    element.src = 'data:' + image.type + ';base64,' + image.data;
    images[key] = element;
});

images.checkbox = function(state) {
    return images[state ? 'checked' : 'unchecked'];
};

images.filter = function(state) {
    return images[state ? 'filter-on' : 'filter-off'];
};

module.exports = images;

},{"./images":3,"object-iterators":46}],5:[function(require,module,exports){
/* eslint-env browser */

'use strict';

/** @module automat */

var ENCODERS = /%\{(\d+)\}/g; // double $$ to encode

var REPLACERS = /\$\{(.*?)\}/g; // single $ to replace


/**
 * @summary String formatter.
 *
 * @desc String substitution is performed on numbered _replacer_ patterns like `${n}` or _encoder_ patterns like `%{n}` where n is the zero-based `arguments` index. So `${0}` would be replaced with the first argument following `text`.
 *
 * Encoders are just like replacers except the argument is HTML-encoded before being used.
 *
 * To change the format patterns, assign new `RegExp` patterns to `automat.encoders` and `automat.replacers`.
 *
 * @param {string|function} template - A template to be formatted as described above. Overloads:
 * * A string primitive containing the template.
 * * A function to be called with `this` as the calling context. The template is the value returned from this call.
 *
 * @param {...*} [replacements] - Replacement values for numbered format patterns.
 *
 * @return {string} The formatted text.
 *
 * @memberOf module:automat
 */
function automat(template, replacements/*...*/) {
    var hasReplacements = arguments.length > 1;

    // if `template` is a function, convert it to text
    if (typeof template === 'function') {
        template = template.call(this); // non-template function: call it with context and use return value
    }

    if (hasReplacements) {
        var args = arguments;
        template = template.replace(automat.replacersRegex, function(match, key) {
            key -= -1; // convert to number and increment
            return args.length > key ? args[key] : '';
        });

        template = template.replace(automat.encodersRegex, function(match, key) {
            key -= -1; // convert to number and increment
            if (args.length > key) {
                var htmlEncoderNode = document.createElement('DIV');
                htmlEncoderNode.textContent = args[key];
                return htmlEncoderNode.innerHTML;
            } else {
                return '';
            }
        });
    }

    return template;
}

/**
 * @summary Replace contents of `el` with `Nodes` generated from formatted template.
 *
 * @param {string|function} template - See `template` parameter of {@link automat}.
 *
 * @param {HTMLElement} [el] - Node in which to return markup generated from template. If omitted, a new `<div>...</div>` element will be created and returned.
 *
 * @param {...*} [replacements] - Replacement values for numbered format patterns.
 *
 * @return {HTMLElement} The `el` provided or a new `<div>...</div>` element, its `innerHTML` set to the formatted text.
 *
 * @memberOf module:automat
 */
function replace(template, el, replacements/*...*/) {
    var elOmitted = typeof el !== 'object',
        args = Array.prototype.slice.call(arguments, 1);

    if (elOmitted) {
        el = document.createElement('DIV');
        args.unshift(template);
    } else {
        args[0] = template;
    }

    el.innerHTML = automat.apply(null, args);

    return el;
}

/**
 * @summary Append or insert `Node`s generated from formatted template into given `el`.
 *
 * @param {string|function} template - See `template` parameter of {@link automat}.
 *
 * @param {HTMLElement} el
 *
 * @param {Node} [referenceNode=null] Inserts before this element within `el` or at end of `el` if `null`.
 *
 * @param {...*} [replacements] - Replacement values for numbered format patterns.
 *
 * @returns {Node[]} Array of the generated nodes (this is an actual Array instance; not an Array-like object).
 *
 * @memberOf module:automat
 */
function append(template, el, referenceNode, replacements/*...*/) {
    var replacementsStartAt = 3,
        referenceNodeOmitted = typeof referenceNode !== 'object';  // replacements are never objects

    if (referenceNodeOmitted) {
        referenceNode = null;
        replacementsStartAt = 2;
    }

    replacements = Array.prototype.slice.call(arguments, replacementsStartAt);
    var result = [],
        div = replace.apply(null, [template].concat(replacements));

    while (div.childNodes.length) {
        result.push(div.firstChild);
        el.insertBefore(div.firstChild, referenceNode); // removes child from div
    }

    return result;
}

/**
 * Use this convenience wrapper to return the first child node described in `template`.
 *
 * @param {string|function} template - If a function, extract template from comment within.
 *
 * @returns {HTMLElement} The first `Node` in your template.
 *
 * @memberOf module:automat
 */
function firstChild(template, replacements/*...*/) {
    return replace.apply(null, arguments).firstChild;
}

/**
 * Use this convenience wrapper to return the first child element described in `template`.
 *
 * @param {string|function} template - If a function, extract template from comment within.
 *
 * @returns {HTMLElement} The first `HTMLElement` in your template.
 *
 * @memberOf module:automat
 */
function firstElement(template, replacements/*...*/) {
    return replace.apply(null, arguments).firstElementChild;
}

/**
 * @summary Finds string substitution lexemes that require HTML encoding.
 * @desc Modify to suit.
 * @default %{n}
 * @type {RegExp}
 * @memberOf module:automat
 */
automat.encodersRegex = ENCODERS;

/**
 * @summary Finds string substitution lexemes.
 * @desc Modify to suit.
 * @default ${n}
 * @type {RegExp}
 * @memberOf module:automat
 */
automat.replacersRegex = REPLACERS;

automat.format = automat; // if you find using just `automat()` confusing
automat.replace = replace;
automat.append = append;
automat.firstChild = firstChild;
automat.firstElement = firstElement;

module.exports = automat;

},{}],6:[function(require,module,exports){
'use strict';

/* eslint-env browser */

/** @namespace cssInjector */

/**
 * @summary Insert base stylesheet into DOM
 *
 * @desc Creates a new `<style>...</style>` element from the named text string(s) and inserts it but only if it does not already exist in the specified container as per `referenceElement`.
 *
 * > Caveat: If stylesheet is for use in a shadow DOM, you must specify a local `referenceElement`.
 *
 * @returns A reference to the newly created `<style>...</style>` element.
 *
 * @param {string|string[]} cssRules
 * @param {string} [ID]
 * @param {undefined|null|Element|string} [referenceElement] - Container for insertion. Overloads:
 * * `undefined` type (or omitted): injects stylesheet at top of `<head>...</head>` element
 * * `null` value: injects stylesheet at bottom of `<head>...</head>` element
 * * `Element` type: injects stylesheet immediately before given element, wherever it is found.
 * * `string` type: injects stylesheet immediately before given first element found that matches the given css selector.
 *
 * @memberOf cssInjector
 */
function cssInjector(cssRules, ID, referenceElement) {
    if (typeof referenceElement === 'string') {
        referenceElement = document.querySelector(referenceElement);
        if (!referenceElement) {
            throw 'Cannot find reference element for CSS injection.';
        }
    } else if (referenceElement && !(referenceElement instanceof Element)) {
        throw 'Given value not a reference element.';
    }

    var container = referenceElement && referenceElement.parentNode || document.head || document.getElementsByTagName('head')[0];

    if (ID) {
        ID = cssInjector.idPrefix + ID;

        if (container.querySelector('#' + ID)) {
            return; // stylesheet already in DOM
        }
    }

    var style = document.createElement('style');
    style.type = 'text/css';
    if (ID) {
        style.id = ID;
    }
    if (cssRules instanceof Array) {
        cssRules = cssRules.join('\n');
    }
    cssRules = '\n' + cssRules + '\n';
    if (style.styleSheet) {
        style.styleSheet.cssText = cssRules;
    } else {
        style.appendChild(document.createTextNode(cssRules));
    }

    if (referenceElement === undefined) {
        referenceElement = container.firstChild;
    }

    container.insertBefore(style, referenceElement);

    return style;
}

/**
 * @summary Optional prefix for `<style>` tag IDs.
 * @desc Defaults to `'injected-stylesheet-'`.
 * @type {string}
 * @memberOf cssInjector
 */
cssInjector.idPrefix = 'injected-stylesheet-';

// Interface
module.exports = cssInjector;

},{}],7:[function(require,module,exports){
'use strict';

/** @namespace extend-me **/

/** @summary Extends an existing constructor into a new constructor.
 *
 * @returns {ChildConstructor} A new constructor, extended from the given context, possibly with some prototype additions.
 *
 * @desc Extends "objects" (constructors), with optional additional code, optional prototype additions, and optional prototype member aliases.
 *
 * > CAVEAT: Not to be confused with Underscore-style .extend() which is something else entirely. I've used the name "extend" here because other packages (like Backbone.js) use it this way. You are free to call it whatever you want when you "require" it, such as `var inherits = require('extend')`.
 *
 * Provide a constructor as the context and any prototype additions you require in the first argument.
 *
 * For example, if you wish to be able to extend `BaseConstructor` to a new constructor with prototype overrides and/or additions, basic usage is:
 *
 * ```javascript
 * var Base = require('extend-me').Base;
 * var BaseConstructor = Base.extend(basePrototype); // mixes in .extend
 * var ChildConstructor = BaseConstructor.extend(childPrototypeOverridesAndAdditions);
 * var GrandchildConstructor = ChildConstructor.extend(grandchildPrototypeOverridesAndAdditions);
 * ```
 *
 * This function (`extend()`) is added to the new extended object constructor as a property `.extend`, essentially making the object constructor itself easily "extendable." (Note: This is a property of each constructor and not a method of its prototype!)
 *
 * @param {string} [extendedClassName] - This is simply added to the prototype as $$CLASS_NAME. Useful for debugging because all derived constructors appear to have the same name ("Constructor") in the debugger.
 *
 * @param {extendedPrototypeAdditionsObject} [prototypeAdditions] - Object with members to copy to new constructor's prototype. Most members will be copied to the prototype. Some members, however, have special meanings as explained in the {@link extendedPrototypeAdditionsObject|type definition} (and may or may not be copied to the prototype).
 *
 * @property {boolean} [debug] - See parameter `extendedClassName` _(above)_.
 *
 * @property {object} Base - A convenient base class from which all other classes can be extended.
 *
 * @memberOf extend-me
 */
function extend(extendedClassName, prototypeAdditions) {
    switch (arguments.length) {
        case 0:
            prototypeAdditions = {};
            break;
        case 1:
            switch (typeof extendedClassName) {
                case 'object':
                    prototypeAdditions = extendedClassName;
                    extendedClassName = undefined;
                    break;
                case 'string':
                    prototypeAdditions = {};
                default:
                    throw 'Single-parameter overload must be either string or object.';
            }
            break;
        case 2:
            if (typeof extendedClassName !== 'string' || typeof prototypeAdditions !== 'object') {
                throw 'Two-parameter overload must be string, object.';
            }
            break;
        default:
            throw 'Too many parameters';
    }

    function Constructor() {
        if (prototypeAdditions.preInitialize) {
            prototypeAdditions.preInitialize.apply(this, arguments);
        }

        initializePrototypeChain.apply(this, arguments);

        if (prototypeAdditions.postInitialize) {
            prototypeAdditions.postInitialize.apply(this, arguments);
        }
    }

    Constructor.extend = extend;

    var prototype = Constructor.prototype = Object.create(this.prototype);
    prototype.constructor = Constructor;

    if (extendedClassName) {
        prototype.$$CLASS_NAME = extendedClassName;
    }

    for (var key in prototypeAdditions) {
        if (prototypeAdditions.hasOwnProperty(key)) {
            var value = prototypeAdditions[key];
            switch (key) {
                case 'initializeOwn':
                    // already called above; not needed in prototype
                    break;
                case 'aliases':
                    for (var alias in value) {
                        if (value.hasOwnProperty(alias)) {
                            makeAlias(value[alias], alias);
                        }
                    }
                    break;
                default:
                    if (typeof value === 'string' && value[0] === '#') {
                        makeAlias(value, key.substr(1));
                    } else if (isDescriptor(value)) {
                        Object.defineProperty(prototype, key, value);
                    } else {
                        prototype[key] = value;
                    }
            }
        }
    }

    return Constructor;

    function makeAlias(value, key) { // eslint-disable-line no-shadow
        prototype[key] = prototypeAdditions[value];
    }
}

function isDescriptor(value) {
    var result;
    if(typeof value === 'object' && value) {
        var len = Object.keys(value).length,
            hasSetter = typeof value.set === 'function' && value.set.length === 1,
            hasGetter = typeof value.get === 'function' && value.get.length === 0;

        result = typeof value.configurable === 'boolean' ||
            typeof value.enumerable === 'boolean' ||
            len === 1 && (hasSetter || hasGetter) ||
            len === 2 && hasSetter && hasGetter;
    }
    return result;
}

function Base() {}
Base.prototype = {
    constructor: Base.prototype.constructor,
    get super() {
        return Object.getPrototypeOf(Object.getPrototypeOf(this));
    }
};
Base.extend = extend;
extend.Base = Base;

/** @typedef {function} extendedConstructor
 * @property prototype.super - A reference to the prototype this constructor was extended from.
 * @property [extend] - If `prototypeAdditions.extendable` was truthy, this will be a reference to {@link extend.extend|extend}.
 */

/** @typedef {object} extendedPrototypeAdditionsObject
 * @property {function} [initialize] - Additional constructor code for new object. This method is added to the new constructor's prototype. Gets passed new object as context + same args as constructor itself. Called on instantiation after similar function in all ancestors called with same signature.
 * @property {function} [initializeOwn] - Additional constructor code for new object. This method is added to the new constructor's prototype. Gets passed new object as context + same args as constructor itself. Called on instantiation after (all) the `initialize` function(s).
 * @property {object} [aliases] - Hash of aliases for prototype members in form `{ key: 'member', ... }` where `key` is the name of an alieas and `'member'` is the name of an existing member in the prototype. Each such key is added to the prototype as a reference to the named member. (The `aliases` object itself is *not* added to prototype.) Alternatively:
 * @property {string} [keys] - Arbitrary property names defined here with string values starting with a `#` character will alias the actual properties named in the strings (following the `#`). This is an alternative to providing an `aliases` hash, perhaps simpler (though subtler). (Use your own identifiers here; don't use the name `keys`!)
 * @property {descriptorObject} [descriptors] - Will be run through `Object.defineProperty()`. Use your own identifiers here; don't use the name `descriptors`!)
 * Detected by duck-typing:
 * * It has a `configurable` property.
 * * It has an `enumerable` property.
 * * It has only: a `set` function that takes exactly one parameter and/or only a `get` function that takes no parameters.
 * @property {*} [arbitraryProperties] - Any additional arbitrary properties defined here will be added to the new constructor's prototype. (Use your own identifiers here; don't use the name `aribitraryProperties`!)
 */

/** @summary Call all `initialize` methods found in prototype chain.
 * @desc This recursive routine is called by the constructor.
 * 1. Walks back the prototype chain to `Object`'s prototype
 * 2. Walks forward to new object, calling any `initialize` methods it finds along the way with the same context and arguments with which the constructor was called.
 * @private
 * @memberOf extend-me
 */
function initializePrototypeChain() {
    var term = this,
        args = arguments;
    recur(term);

    function recur(obj) {
        var proto = Object.getPrototypeOf(obj);
        if (proto.constructor !== Object) {
            recur(proto);
            if (proto.hasOwnProperty('initialize')) {
                proto.initialize.apply(term, args);
            }
        }
    }
}

module.exports = extend;

},{}],8:[function(require,module,exports){
'use strict';

exports['column-CQL-syntax'] = [
'<li>',
'	<button type="button" class="copy"></button>',
'	<div class="filter-tree-remove-button" title="delete conditional"></div>',
'	{1}:',
'	<input name="{2}" class="{4}" value="{3:encode}">',
'</li>'
].join('\n');

exports['column-SQL-syntax'] = [
'<li>',
'	<button type="button" class="copy"></button>',
'	<div class="filter-tree-remove-button" title="delete conditional"></div>',
'	{1}:',
'	<textarea name="{2}" rows="1" class="{4}">{3:encode}</textarea>',
'</li>'
].join('\n');

exports.columnFilter = [
'<span class="filter-tree">',
'	 <strong><span>{2} </span>column filter subexpression:</strong><br>',
'	 Match',
'	 <label><input type="radio" class="filter-tree-op-choice" name="treeOp{1}" value="op-or">any</label>',
'	 <label><input type="radio" class="filter-tree-op-choice" name="treeOp{1}" value="op-and">all</label>',
'	 <label><input type="radio" class="filter-tree-op-choice" name="treeOp{1}" value="op-nor">none</label>',
'	 of the following:',
'	 <select>',
'		 <option value="">New expression&hellip;</option>',
'	 </select>',
'	 <ol></ol>',
' </span>'
].join('\n');

exports.columnFilters = [
'<span class="filter-tree filter-tree-type-column-filters">',
'	 Match <strong>all</strong> of the following column filters:',
'	 <ol></ol>',
' </span>'
].join('\n');

exports.lockedColumn = [
'<span>',
'	 {1:encode}',
'	 <input type="hidden" value="{2}">',
' </span>'
].join('\n');

exports.note = [
'<div class="footnotes">',
'	<div class="footnote"></div>',
'	<p>Select a new value or delete the expression altogether.</p>',
'</div>'
].join('\n');

exports.notes = [
'<div class="footnotes">',
'	<p>Note the following error conditions:</p>',
'	<ul class="footnote"></ul>',
'	<p>Select new values or delete the expression altogether.</p>',
'</div>'
].join('\n');

exports.optionMissing = [
'The requested value of <span class="field-name">{1:encode}</span>',
'(<span class="field-value">{2:encode}</span>) is not valid.'
].join('\n');

exports.removeButton = [
'<div class="filter-tree-remove-button" title="delete conditional"></div>'
].join('\n');

exports.subtree = [
'<span class="filter-tree">',
'	 Match',
'	 <label><input type="radio" class="filter-tree-op-choice" name="treeOp{1}" value="op-or">any</label>',
'	 <label><input type="radio" class="filter-tree-op-choice" name="treeOp{1}" value="op-and">all</label>',
'	 <label><input type="radio" class="filter-tree-op-choice" name="treeOp{1}" value="op-nor">none</label>',
'	 of the following:',
'	 <select>',
'		 <option value="">New expression&hellip;</option>',
'		 <option value="subexp" style="border-bottom:1px solid black">Subexpression</option>',
'	 </select>',
'	 <ol></ol>',
' </span>'
].join('\n');

},{}],9:[function(require,module,exports){
'use strict';

var _ = require('object-iterators');
var popMenu = require('pop-menu');

var FilterTree = require('./js/FilterTree');
FilterTree.Node = require('./js/FilterNode'); // aka: Object.getPrototypeOf(FilterTree.prototype).constructor
FilterTree.Leaf = require('./js/FilterLeaf'); // aka: FilterTree.prototype.editors.Default

// expose some objects for plug-in access

FilterTree.Conditionals = require('./js/Conditionals');

// FOLLOWING PROPERTIES ARE *** TEMPORARY ***,
// FOR THE DEMO TO ACCESS THESE NODE MODULES.

FilterTree._ = _;
FilterTree.popMenu = popMenu;


module.exports = FilterTree;

},{"./js/Conditionals":10,"./js/FilterLeaf":11,"./js/FilterNode":12,"./js/FilterTree":13,"object-iterators":46,"pop-menu":47}],10:[function(require,module,exports){
/** @module conditionals */

'use strict';

var Base = require('extend-me').Base;
var _ = require('object-iterators');
var regExpLIKE = require('regexp-like');

var IN = 'IN',
    NOT_IN = 'NOT ' + IN,
    LIKE = 'LIKE',
    NOT_LIKE = 'NOT ' + LIKE,
    LIKE_WILD_CARD = '%',
    NIL = '';

var toString;

var defaultIdQts = {
    beg: '"',
    end: '"'
};


/**
 * @constructor
 */
var Conditionals = Base.extend({
    /**
     * @param {sqlIdQtsObject} [options.sqlIdQts={beg:'"',end:'"'}]
     * @memberOf Conditionals.prototype
     */
    initialize: function(options) {
        var idQts = options && options.sqlIdQts;
        if (idQts) {
            this.sqlIdQts = idQts; // only override if defined
        }
    },

    sqlIdQts: defaultIdQts,
    /**
     * @param id
     * @returns {string}
     * @memberOf Conditionals.prototype
     */
    makeSqlIdentifier: function(id) {
        return this.sqlIdQts.beg + id + this.sqlIdQts.end;
    },

    /**
     * @param string
     * @returns {string}
     * @memberOf Conditionals.prototype
     */
    makeSqlString: function(string) {
        return '\'' + sqEsc(string) + '\'';
    },

    /**
     * @memberOf Conditionals.prototype
     */
    makeLIKE: function(beg, end, op, originalOp, c) {
        var escaped = c.operand.replace(/([_\[\]%])/g, '[$1]'); // escape all LIKE reserved chars
        return this.makeSqlIdentifier(c.column) +
            ' ' + op +
            ' ' + this.makeSqlString(beg + escaped + end);
    },

    /**
     * @memberOf Conditionals.prototype
     */
    makeIN: function(op, c) {
        return this.makeSqlIdentifier(c.column) +
            ' ' + op +
            ' ' + '(\'' + sqEsc(c.operand).replace(/\s*,\s*/g, '\', \'') + '\')';
    },

    /**
     * @memberOf Conditionals.prototype
     */
    make: function(op, c) {
        return this.makeSqlIdentifier(c.column) +
            ' ' + op +
            ' ' + c.makeSqlOperand();
    }
});

var ops = Conditionals.prototype.ops = {
    undefined: {
        test: function() { return true; },
        make: function() { return ''; }
    },

    /** @type {relationalOperator}
     * @memberOf Conditionals.prototype
     */
    '<': {
        test: function(a, b) { return a < b; },
        make: function(c) { return this.make('<', c); }
    },
    /** @type {relationalOperator}
     * @memberOf Conditionals.prototype
     */
    '<=': {
        test: function(a, b) { return a <= b; },
        make: function(c) { return this.make('<=', c); }
    },

    /** @type {relationalOperator}
     * @memberOf Conditionals.prototype
     */
    '=': {
        test: function(a, b) { return a === b; },
        make: function(c) { return this.make('=', c); }
    },

    /** @type {relationalOperator}
     * @memberOf Conditionals.prototype
     */
    '>=': {
        test: function(a, b) { return a >= b; },
        make: function(c) { return this.make('>=', c); }
    },

    /** @type {relationalOperator}
     * @memberOf Conditionals.prototype
     */
    '>': {
        test: function(a, b) { return a > b; },
        make: function(c) { return this.make('>', c); }
    },

    /** @type {relationalOperator}
     * @memberOf Conditionals.prototype
     */
    '<>': {
        test: function(a, b) { return a !== b; },
        make: function(c) { return this.make('<>', c); }
    },

    /** @type {relationalOperator}
     * @memberOf Conditionals.prototype
     */
    LIKE: {
        test: function(a, b) { return regExpLIKE.cached(b, true).test(a); },
        make: function(c) { return this.make(LIKE, c); },
        type: 'string'
    },

    /** @type {relationalOperator}
     * @memberOf Conditionals.prototype
     */
    'NOT LIKE': {
        test: function(a, b) { return !regExpLIKE.cached(b, true).test(a); },
        make: function(c) { return this.make(NOT_LIKE, c); },
        type: 'string'
    },

    /** @type {relationalOperator}
     * @memberOf Conditionals.prototype
     */
    IN: { // TODO: currently forcing string typing; rework calling code to respect column type
        test: function(a, b) { return inOp(a, b) >= 0; },
        make: function(c) { return this.makeIN(IN, c); },
        operandList: true,
        type: 'string'
    },

    /** @type {relationalOperator}
     * @memberOf Conditionals.prototype
     */
    'NOT IN': { // TODO: currently forcing string typing; rework calling code to respect column type
        test: function(a, b) { return inOp(a, b) < 0; },
        make: function(c) { return this.makeIN(NOT_IN, c); },
        operandList: true,
        type: 'string'
    },

    /** @type {relationalOperator}
     * @memberOf Conditionals.prototype
     */
    CONTAINS: {
        test: function(a, b) { return containsOp(a, b) >= 0; },
        make: function(c) { return this.makeLIKE(LIKE_WILD_CARD, LIKE_WILD_CARD, LIKE, 'CONTAINS', c); },
        type: 'string'
    },

    /** @type {relationalOperator}
     * @memberOf Conditionals.prototype
     */
    'NOT CONTAINS': {
        test: function(a, b) { return containsOp(a, b) < 0; },
        make: function(c) { return this.makeLIKE(LIKE_WILD_CARD, LIKE_WILD_CARD, NOT_LIKE, 'NOT CONTAINS', c); },
        type: 'string'
    },

    /** @type {relationalOperator}
     * @memberOf Conditionals.prototype
     */
    BEGINS: {
        test: function(a, b) { b = toString(b); return beginsOp(a, b.length) === b; },
        make: function(c) { return this.makeLIKE(NIL, LIKE_WILD_CARD, LIKE, 'BEGINS', c); },
        type: 'string'
    },

    /** @type {relationalOperator}
     * @memberOf Conditionals.prototype
     */
    'NOT BEGINS': {
        test: function(a, b) { b = toString(b); return beginsOp(a, b.length) !== b; },
        make: function(c) { return this.makeLIKE(NIL, LIKE_WILD_CARD, NOT_LIKE, 'NOT BEGINS', c); },
        type: 'string'
    },

    /** @type {relationalOperator}
     * @memberOf Conditionals.prototype
     */
    ENDS: {
        test: function(a, b) { b = toString(b); return endsOp(a, b.length) === b; },
        make: function(c) { return this.makeLIKE(LIKE_WILD_CARD, NIL, LIKE, 'ENDS', c); },
        type: 'string'
    },

    /** @type {relationalOperator}
     * @memberOf Conditionals.prototype
     */
    'NOT ENDS': {
        test: function(a, b) { b = toString(b); return endsOp(a, b.length) !== b; },
        make: function(c) { return this.makeLIKE(LIKE_WILD_CARD, NIL, NOT_LIKE, 'NOT ENDS', c); },
        type: 'string'
    }
};

// some synonyms
ops['\u2264'] = ops['<='];  // UNICODE 'LESS-THAN OR EQUAL TO'
ops['\u2265'] = ops['>='];  // UNICODE 'GREATER-THAN OR EQUAL TO'
ops['\u2260'] = ops['<>'];  // UNICODE 'NOT EQUAL TO'

function inOp(a, b) {
    return b
        .trim() // remove leading and trailing space chars
        .replace(/\s*,\s*/g, ',') // remove any white-space chars from around commas
        .split(',') // put in an array
        .indexOf((a + '')); // search array whole matches
}

function containsOp(a, b) {
    return toString(a).indexOf(toString(b));
}

function beginsOp(a, length) {
    return toString(a).substr(0, length);
}

function endsOp(a, length) {
    return toString(a).substr(-length, length);
}

function sqEsc(string) {
    return string.replace(/'/g, '\'\'');
}

var groups = {
    equality: {
        label: 'Equality',
        submenu: ['=']
    },
    inequalities: {
        label: 'Inequalities',
        submenu: [
            '<',
            '\u2264', // UNICODE 'LESS-THAN OR EQUAL TO'; on a Mac, type option-comma ()
            '\u2260', // UNICODE 'NOT EQUALS'; on a Mac, type option-equals ()
            '\u2265', // UNICODE 'GREATER-THAN OR EQUAL TO'; on a Mac, type option-period ()
            '>'
        ]
    },
    sets: {
        label: 'Set scans',
        submenu: ['IN', 'NOT IN']
    },
    strings: {
        label: 'String scans',
        submenu: [
            'CONTAINS', 'NOT CONTAINS',
            'BEGINS', 'NOT BEGINS',
            'ENDS', 'NOT ENDS'
        ]
    },
    patterns: {
        label: 'Pattern scans',
        submenu: ['LIKE', 'NOT LIKE']
    }
};

// add a `name` prop to each group
_(groups).each(function(group, key) { group.name = key; });

/**
 * @memberOf Conditionals
 */
Conditionals.groups = groups;

/** Default operator menu when consisting of all of the groups in {@link module:conditionals.groups|groups}. This menu is used when none of the following is otherwise defined:
 * * The `opMenu` property of the column schema.
 * * The entry in the node's `typeOpMap` hash corresponding to the `type` property of the column schema.
 * * The node's `treeOpMenu` object.
 * @type {menuItem[]}
 * @memberOf Conditionals
 */
Conditionals.defaultOpMenu = [ // hierarchical menu of relational operators
    groups.equality,
    groups.inequalities,
    groups.sets,
    groups.strings,
    groups.patterns
];


// Meant to be called by FilterTree.prototype.setSensitivity only
Conditionals.setToString = function(fn) {
    return (toString = fn);
};

module.exports = Conditionals;

},{"extend-me":7,"object-iterators":46,"regexp-like":49}],11:[function(require,module,exports){
/* eslint-env browser */
/* eslint-disable key-spacing */

'use strict';

var popMenu = require('pop-menu');

var FilterNode = require('./FilterNode');
var Conditionals = require('./Conditionals');


var toString; // set by FilterLeaf.setToString() called from ../index.js


/** @typedef {object} converter
 * @property {function} toType - Returns input value converted to type. Fails silently.
 * @property {function} failed - Tests input value against type, returning `false if type or `true` if not type.
 */

/** @type {converter} */
var numberConverter = {
    toType: Number,
    failed: isNaN
};

/** @type {converter} */
var dateConverter = {
    toType: function(s) { return new Date(s); },
    failed: isNaN
};

/**
 * @typedef {object} filterLeafViewObject
 *
 * @property {HTMLElement} column - A drop-down with options from the `FilterLeaf` instance's schema. Value is the name of the column being tested (i.e., the column to which this conditional expression applies).
 *
 * @property operator - A drop-down with options from {@link columnOpMenu}, {@link typeOpMap}, or {@link treeOpMenu}. Value is the string representation of the operator.
 *
 * @property operand - An input element, such as a drop-down or a text box.
 */

/** @constructor
 * @summary An object that represents a conditional expression node in a filter tree.
 * @desc This object represents a conditional expression. It is always a terminal node in the filter tree; it has no child nodes of its own.
 *
 * A conditional expression is a simple dyadic expression with the following syntax in the UI:
 *
 * > _column operator operand_
 *
 * where:
 * * _column_ is the name of a column from the data row object
 * * _operator_ is the name of an operator from the node's operator list
 * * _operand_ is a literal value to compare against the value in the named column
 *
 * **NOTE:** The {@link ColumnLeaf} extension of this object has a different implementation of _operand_ which is: The name of a column from which to fetch the compare value (from the same data row object) to compare against the value in the named column. See *Extending the conditional expression object* in the {@link http://joneit.github.io/filter-tree/index.html|readme}.
 *
 * The values of the terms of the expression above are stored in the first three properties below. Each of these three properties is set either by `setState()` or by the user via a control in `el`. Note that these properties are not dynamically bound to the UI controls; they are updated by the validation function, `invalid()`.
 *
 * **See also the properties of the superclass:** {@link FilterNode}
 *
 * @property {string} column - Name of the member in the data row objects against which `operand` will be compared. Reflects the value of the `view.column` control after validation.
 *
 * @property {string} operator - Operator symbol. This must match a key in the `this.root.conditionals.ops` hash. Reflects the value of the `view.operator` control after validation.
 *
 * @property {string} operand - Value to compare against the the member of data row named by `column`. Reflects the value of the `view.operand` control, after validation.
 *
 * @property {string} name - Used to describe the object in the UI so user can select an expression editor.
 *
 * @property {string} [type='string'] - The data type of the subexpression if neither the operator nor the column schema defines a type.
 *
 * @property {HTMLElement} el - A `<span>...</span>` element that contains the UI controls. This element is automatically appeneded to the parent `FilterTree`'s `el`. Generated by {@link FilterLeaf#createView|createView}.
 *
 * @property {filterLeafViewObject} view - A hash containing direct references to the controls in `el`. Added by {@link FilterLeaf#createView|createView}.
 */
var FilterLeaf = FilterNode.extend('FilterLeaf', {

    name: 'column = value', // display string for drop-down

    destroy: function() {
        if (this.view) {
            for (var key in this.view) {
                this.view[key].removeEventListener('change', this.onChange);
            }
        }
    },

    /** @summary Create a new view.
     * @desc This new "view" is a group of HTML `Element` controls that completely describe the conditional expression this object represents. This method creates the view, setting `this.el` to point to it, and the members of `this.view` to point to the individual controls therein.
     * @memberOf FilterLeaf.prototype
     */
    createView: function(state) {
        var el = this.el = document.createElement('span');

        el.className = 'filter-tree-editor filter-tree-default';

        if (state && state.column) {
            // State includes column:
            // Operator menu is built later in loadState; we don't need to build it now. The call to
            // getOpMenu below with undefined columnName returns [] resulting in an empty drop-down.
        } else {
            // When state does NOT include column, it's because either:
            // a. column is unknown and op menu will be empty until user chooses a column; or
            // b. column is hard-coded when there's only one possible column as inferable from schema:
            var schema = this.schema && this.schema.length === 1 && this.schema[0],
                columnName = schema && schema.name || schema;
        }

        this.view = {
            column: this.makeElement(this.schema, 'column', this.sortColumnMenu),
            operator: this.makeElement(getOpMenu.call(this, columnName), 'operator'),
            operand: this.makeElement()
        };

        el.appendChild(document.createElement('br'));
    },

    loadState: function(state) {
        if (state) {
            var value, el, i, b, selected, notes = [];
            for (var key in state) {
                if (!FilterNode.optionsSchema[key]) {
                    value = this[key] = state[key];
                    el = this.view[key];
                    switch (el.type) {
                        case 'checkbox':
                        case 'radio':
                            el = document.querySelectorAll('input[name=\'' + el.name + '\']');
                            for (i = 0; i < el.length; i++) {
                                el[i].checked = value.indexOf(el[i].value) >= 0;
                            }
                            break;
                        case 'select-multiple':
                            el = el.options;
                            for (i = 0, b = false; i < el.length; i++, b = b || selected) {
                                selected = value.indexOf(el[i].value) >= 0;
                                el[i].selected = selected;
                            }
                            FilterNode.setWarningClass(el, b);
                            break;
                        default:
                            el.value = value;
                            if (FilterNode.setWarningClass(el) !== value) {
                                notes.push({ key: key, value: value });
                            } else if (key === 'column') {
                                makeOpMenu.call(this, value);
                            }
                    }
                }
            }
            if (notes.length) {
                var multiple = notes.length > 1,
                    templates = this.templates,
                    footnotes = templates.get(multiple ? 'notes' : 'note'),
                    inner = footnotes.querySelector('.footnote');
                notes.forEach(function(note) {
                    var footnote = multiple ? document.createElement('li') : inner;
                    note = templates.get('optionMissing', note.key, note.value);
                    while (note.length) { footnote.appendChild(note[0]); }
                    if (multiple) { inner.appendChild(footnote); }
                });
            }
            this.notesEl = footnotes;
        }
    },

    /**
     * @property {converter} number
     * @property {converter} int - synonym of `number`
     * @property {converter} float - synonym of `number`
     * @property {converter} date
     * @property {converter} string
     */
    converters: {
        number: numberConverter,
        int: numberConverter,
        float: numberConverter,
        date: dateConverter
    },

    /**
     * Called by the parent node's {@link FilterTree#invalid|invalid()} method, which catches the error thrown when invalid.
     *
     * Also performs the following compilation actions:
     * * Copies all `this.view`' values from the DOM to similarly named properties of `this`.
     * * Pre-sets `this.op` and `this.converter` for use in `test`'s tree walk.
     *
     * @param {boolean} [options.throw=false] - Throw an error if missing or invalid value.
     * @param {boolean} [options.focus=false] - Move focus to offending control.
     * @returns {undefined} This is the normal return when valid; otherwise throws error when invalid.
     * @memberOf FilterLeaf.prototype
     */
    invalid: function(options) {
        var elementName, type, focused;

        for (elementName in this.view) {
            var el = this.view[elementName],
                value = controlValue(el).trim();

            if (value === '') {
                if (!focused && options && options.focus) {
                    clickIn(el);
                    focused = true;
                }
                if (options && options.throw) {
                    throw new this.Error('Missing or invalid ' + elementName + ' in conditional expression. Complete the expression or remove it.', this);
                }
            } else {
                // Copy each controls's value as a new similarly named property of this object.
                this[elementName] = value;
            }
        }

        this.op = this.root.conditionals.ops[this.operator];

        type = this.getType();

        this.converter = type && type !== 'string' && this.converters[type];
    },

    getType: function() {
        return (
            this.op.type // the expression's operator's type (because some operators only work with strings)
            ||
            (this.schema.lookup(this.column) || {}).type // the expression's column schema type
            ||
            this.type // the expression node's type
        );
    },

    valOrFunc: function(dataRow, columnName) {
        var vf = dataRow[columnName];
        var result = (typeof vf)[0] === 'f' ? vf(dataRow, columnName) : vf;
        return result || result === 0 ? result : '';
    },

    p: function(dataRow) {
        return this.valOrFunc(dataRow, this.column);
    },

    // To be overridden when operand is a column name (see columns.js).
    q: function() {
        return this.operand;
    },

    test: function(dataRow) {
        var p, q, // untyped versions of args
            P, Q, // typed versions of p and q
            converter;

        // TODO: If a literal (i.e., when this.q is not overridden), q only needs to be fetched ONCE for all rows
        return (
            (p = this.p(dataRow)) === undefined ||
            (q = this.q(dataRow)) === undefined
        )
            ? false // data inaccessible so exclude row
            : (
                (converter = this.converter) &&
                !converter.failed(P = converter.toType(p)) && // attempt to convert data to type
                !converter.failed(Q = converter.toType(q))
            )
                ? this.op.test(P, Q) // both conversions successful: compare as types
                : this.op.test(toString(p), toString(q)); // one or both conversions failed: compare as strings
    },

    toJSON: function() {
        var state = {};
        if (this.editor) {
            state.editor = this.editor;
        }
        for (var key in this.view) {
            state[key] = this[key];
        }
        if (this.schema !== this.parent.schema) {
            state.schema = this.schema;
        }
        return state;
    },

    /**
     * For `'object'` and `'JSON'` note that the subtree's version of `getState` will not call this leaf version of `getState` because the former uses `unstrungify()` and `JSON.stringify()`, respectively, both of which recurse and call `toJSON()` on their own.
     *
     * @param {object} [options='object'] - See the subtree version of {@link FilterTree#getState|getState} for more info.
     *
     * @memberOf FilterLeaf.prototype
     */
    getState: function getState(options) {
        var result = '',
            syntax = options && options.syntax || 'object';

        switch (syntax) {
            case 'object': // see note above
                result = this.toJSON();
                break;
            case 'JSON': // see note above
                result = JSON.stringify(this, null, options && options.space) || '';
                break;
            case 'SQL':
                result = this.getSyntax(this.root.conditionals);
        }

        return result;
    },

    makeSqlOperand: function() {
        return this.root.conditionals.makeSqlString(this.operand); // todo: this should be a number if type is number instead of a string -- but we will have to ensure it is numeric!
    },

    getSyntax: function(conditionals) {
        return this.root.conditionals.ops[this.operator].make.call(conditionals, this);
    },

    /** @summary HTML form controls factory.
     * @desc Creates and appends a text box or a drop-down.
     * > Defined on the FilterTree prototype for access by derived types (alternate filter editors).
     * @returns The new element.
     * @param {menuItem[]} [menu] - Overloads:
     * * If omitted, will create an `<input/>` (text box) element.
     * * If contains only a single option, will create a `<span>...</span>` element containing the string and a `<input type=hidden>` containing the value.
     * * Otherwise, creates a `<select>...</select>` element with these menu items.
     * @param {null|string} [prompt=''] - Adds an initial `<option>...</option>` element to the drop-down with this value, parenthesized, as its `text`; and empty string as its `value`. Omitting creates a blank prompt; `null` suppresses.
     * @param [sort]
     * @memberOf FilterLeaf.prototype
     */
    makeElement: function(menu, prompt, sort) {
        var el, result, options,
            option = menu,
            tagName = menu ? 'SELECT' : 'INPUT';

        // determine if there would be only a single item in the dropdown
        while (option instanceof Array) {
            if (option.length === 1 && !popMenu.isGroupProxy(option[0])) {
                option = option[0];
            } else {
                option = undefined;
            }
        }

        if (option) {
            // hard text when single item
            el = this.templates.get(
                'lockedColumn',
                option.alias || option.name || option,
                option.name || option.alias || option
            );
            result = el.querySelector('input');
        } else {
            options = {
                prompt: prompt,
                sort: sort,
                group: function(groupName) { return Conditionals.groups[groupName]; }
            };

            // make an element
            el = popMenu.build(tagName, menu, options);

            // if it's a textbox, listen for keyup events
            if (el.type === 'text' && this.eventHandler) {
                this.el.addEventListener('keyup', this.eventHandler);
            }

            // handle onchange events
            this.onChange = this.onChange || cleanUpAndMoveOn.bind(this);
            this.el.addEventListener('change', this.onChange);

            FilterNode.setWarningClass(el);
            result = el;
        }

        this.el.appendChild(el);

        return result;
    }
});

/** `change` event handler for all form controls.
 * Rebuilds the operator drop-down as needed.
 * Removes error CSS class from control.
 * Adds warning CSS class from control if blank; removes if not blank.
 * Adds warning CSS class from control if blank; removes if not blank.
 * Moves focus to next non-blank sibling control.
 * @this Bound to this node.
 */
function cleanUpAndMoveOn(evt) {
    var el = evt.target;

    // remove `error` CSS class, which may have been added by `FilterLeaf.prototype.invalid`
    el.classList.remove('filter-tree-error');

    // set or remove 'warning' CSS class, as per el.value
    FilterNode.setWarningClass(el);

    if (el === this.view.column) {
        // rebuild operator list according to selected column name or type, restoring selected item
        makeOpMenu.call(this, el.value);
    }

    if (el.value) {
        // find next sibling control, if any
        if (!el.multiple) {
            while ((el = el.nextElementSibling) && (!('name' in el) || el.value.trim() !== '')); // eslint-disable-line curly
        }

        // and click in it (opens select list)
        if (el && el.value.trim() === '') {
            el.value = ''; // rid of any white space
            FilterNode.clickIn(el);
        }
    }

    // forward the event to the application's event handler
    if (this.eventHandler) {
        this.eventHandler(evt);
    }
}

function getOpMenu(columnName) {
    var column = this.schema.lookup(columnName) || {};
    return (
        column.opMenu
            ||
        this.typeOpMap && this.typeOpMap[column.type || this.type]
            ||
        this.opMenu
    );
}

function makeOpMenu(columnName) {
    var opMenu = getOpMenu.call(this, columnName);

    if (opMenu !== this.renderedOpMenu) {
        var newOpDrop = this.makeElement(opMenu, 'operator');

        newOpDrop.value = this.view.operator.value;
        this.el.replaceChild(newOpDrop, this.view.operator);
        this.view.operator = newOpDrop;

        FilterNode.setWarningClass(newOpDrop);

        this.renderedOpMenu = opMenu;
    }
}

function clickIn(el) {
    setTimeout(function() {
        el.classList.add('filter-tree-error');
        FilterNode.clickIn(el);
    }, 0);
}

function controlValue(el) {
    var value, i;

    switch (el.type) {
        case 'checkbox':
        case 'radio':
            el = document.querySelectorAll('input[name=\'' + el.name + '\']:enabled:checked');
            for (value = [], i = 0; i < el.length; i++) {
                value.push(el[i].value);
            }
            break;

        case 'select-multiple':
            el = el.options;
            for (value = [], i = 0; i < el.length; i++) {
                if (!el.disabled && el.selected) {
                    value.push(el[i].value);
                }
            }
            break;

        default:
            value = el.value;
    }

    return value;
}

// Meant to be called by FilterTree.prototype.setSensitivity only
FilterLeaf.setToString = function(fn) {
    toString = fn;
    return Conditionals.setToString(fn);
};


module.exports = FilterLeaf;

},{"./Conditionals":10,"./FilterNode":12,"pop-menu":47}],12:[function(require,module,exports){
/* eslint-env browser */

'use strict';

var _ = require('object-iterators');
var extend = require('extend-me'), Base = extend.Base; extend.debug = true;
var popMenu = require('pop-menu');

var cssInjector = require('./stylesheet');
var Templates = require('./Templates');
var Conditionals = require('./Conditionals');
var ParserSQL = require('./parser-SQL');


var CHILDREN_TAG = 'OL',
    CHILD_TAG = 'LI';

// JSON-detector: begins _and_ ends with either [ and ] _or_ { and }
var reJSON = /^\s*((\[[^]*\])|(\{[^]*\}))\s*$/;

function FilterTreeError(message, node) {
    this.message = message;
    this.node = node;
}
FilterTreeError.prototype = Object.create(Error.prototype);
FilterTreeError.prototype.name = 'FilterTreeError';

/** @typedef {object} FilterTreeSetStateOptionsObject
 *
 * @property {boolean} [syntax='auto'] - Specify parser to use on `state`. One of:
 * * `'auto'` - Auto-detect; see {@link FilterNode#parseStateString} for algorithm.
 * * `'object'` - A raw state object such as that produced by the [getState()]{@link FilterTree#getState} method.
 * * `'JSON'` - A JSON string version of a state object such as that produced by the [getState()]{@link FilterTree#getState} method.
 * * `'SQL'` - A SQL [search condition expression]{@link https://msdn.microsoft.com/en-us/library/ms173545.aspx} string.
 *
 * @param {Element} [context] If defined, the provided input string is used as a selector to an `HTMLElement` contained in `context`. The `value` property of this element is fetched from the DOM and is used as the input state string; proceed as above.
 */

/** @typedef {object} FilterTreeOptionsObject
 *
 * @property {menuItem[]} [schema] - A default list of column names for field drop-downs of all descendant terminal nodes. Overrides `options.state.schema` (see). May be defined for any node and pertains to all descendants of that node (including terminal nodes). If omitted (and no `ownSchema`), will use the nearest ancestor `schema` definition. However, descendants with their own definition of `types` will override any ancestor definition.
 *
 * > Typically only used by the caller for the top-level (root) tree.
 *
 * @property {menuItem[]} [ownSchema] - A default list of column names for field drop-downs of immediate descendant terminal nodes _only_. Overrides `options.state.ownSchema` (see).
 *
 * Although both `options.schema` and `options.ownSchema` are notated as optional herein, by the time a terminal node tries to render a schema drop-down, a `schema` list should be defined through (in order of priority):
 *
 * * Terminal node's own `options.schema` (or `options.state.schema`) definition.
 * * Terminal node's parent node's `option.ownSchema` (or `option.state.nodesFields`) definition.
 * * Terminal node's parent (or any ancestor) node's `options.schema` (or `options.state.schema`) definition.
 *
 * @property {FilterTreeStateObject} [state] - A data structure that describes a tree, subtree, or leaf (terminal node). If undefined, loads an empty filter, which is a `FilterTree` node consisting the default `operator` value (`'op-and'`).
 *
 * @property {function} [editor='Default'] - The name of the conditional expression's UI "editor." This name must be registered in the parent node's {@link FilterTree#editors|editors} hash, where it maps to a leaf constructor (`FilterLeaf` or a descendant thereof). (Use {@link FilterTree#addEditor} to register new editors.)
 *
 * @property {FilterTree} [parent] - Used internally to insert element when creating nested subtrees. The only time it may be (and must be) omitted is when creating the root node.
 *
 * @property {string|HTMLElement} [cssStylesheetReferenceElement] - passed to cssInsert
 */

/** @typedef {object|string} FilterTreeStateObject
 *
 * @summary State with which to create a new node or replace an existing node.
 *
 * @desc A string or plain object that describes a filter-tree node. If a string, it is parsed into an object by {@link FilterNode~parseStateString}. (See, for available overloads.)
 *
 * The resulting object may be a flat object that describes a terminal node or a childless root or branch node; or may be a hierarchical object to define an entire tree or subtree.
 *
 * In any case, the resulting object may have any of the following properties:
 *
 * @property {menuItem[]} [schema] - See `schema` property of {@link FilterTreeOptionsObject}.
 *
 * @property {string} [editor='Default'] - See `editor` property of {@link FilterTreeOptionsObject}.
 *
 * @property misc - Other miscellaneous properties will be copied directly to the new `FitlerNode` object. (The name "misc" here is just a stand-in; there is no specific property called "misc".)
 *
 * * May describe a non-terminal node with properties:
 *   * `schema` - Overridden on instantiation by `options.schema`. If both unspecified, uses parent's definition.
 *   * `operator` - One of {@link treeOperators}.
 *   * `children` -  Array containing additional terminal and non-terminal nodes.
 *
 * The constructor auto-detects `state`'s type:
 *  * JSON string to be parsed by `JSON.parse()` into a plain object
 *  * SQL WHERE clause string to be parsed into a plain object
 *  * CSS selector of an Element whose `value` contains one of the above
 *  * plain object
 */

/**
 * @constructor
 *
 * @summary A node in a filter tree.
 *
 * @description A filter tree represents a _complex conditional expression_ and consists of a single instance of a {@link FilterTree} object as the _root_ of an _n_-ary tree.
 *
 * Filter trees are comprised of instances of `FilterNode` objects. However, the `FilterNode` constructor is an "abstract class"; filter node objects are never instantiated directly from this constructor. A filter tree is actually comprised of instances of two "subclasses" of `FilterNode` objects:
 * * {@link FilterTree} (or subclass thereof) objects, instances of which represent the root node and all the branch nodes:
 *   * There is always exactly one root node, containing the whole filter tree, which represents the filter expression in its entirety. The root node is distinguished by having no parent node.
 *   * There are zero or more branch nodes, or subtrees, which are child nodes of the root or other branches higher up in the tree, representing subexpressions within the larger filter expression. Each branch node has exactly one parent node.
 *   * These nodes point to zero or more child nodes which are either nested subtrees, or:
 * * {@link FilterLeaf} (or subclass thereof) objects, each instance of which represents a single simple conditional expression. These are terminal nodes, having exactly one parent node, and no child nodes.
 *
 * The programmer may extend the semantics of filter trees by extending the above objects.
 *
 * @property {FilterNode} [parent] - Undefined means this is the root node.
 *
 * @property {FilterNode} root - Convenience reference to the root node.
 *
 * @property {menuItem[]} schema - Column schema used by descendant leaf nodes (including this node if it is a leaf node) to render a column choice drop-down.
 *
 * @property {string} [editor] - Name of filter editor used by descendant leaf nodes (including this node if it is a leaf node).
 *
 * @property {function} [eventHandler] - Event handler for UI events. See *Events* in the {@link http://joneit.github.io/filter-tree/index.html|readme} for more information.
 *
 * @property {menuItem[]} [treeOpMenu=Conditionals.defaultOpMenu] - Default operator menu for all descendant leaf nodes. Only used if the leaf node has no defined `opMenu` property _and_ there is no menu defined in `typeOpMenus` keyed to the column's `type`.
 *
 * @property {object} [typeOpMap] - A hash of type names. Each member thus defined contains a specific operator menu for all descendant leaf nodes that:
 * 1. do not have their own operator menu (`opMenu` property) of their own; and
 * 2. whose columns resolve to that type.
 *
 * The type is determined by (in priority order):
 * 1. the `type` property of the {@link FilterLeaf}; or
 * 2. the `type` property of the element in the nearest node (including the leaf node itself) that has a defined `ownSchema` or `schema` array property with an element having a matching column name.
 *
 * @property {sqlIdQtsObject} [sqlIdQts={beg:'"',end:'"'}] - Quote characters for SQL identifiers. Used for both parsing and generating SQL. Should be placed on the root node.
 *
 * @property {HTMLElement} el - The DOM element created by the `render` method to represent this node. Contains the `el`s for all child nodes (which are themselves pointed to by those nodes). This is always generated but is only in the page DOM if you put it there.
 */

var FilterNode = Base.extend('FilterNode', {

    /**
     * @summary Create a new node or subtree.
     * @desc Typically used by the application layer to create the entire filter tree; and internally, recursively, to create each node including both subtrees and leaves.
     *
     * **Node properties and options:** Nodes are instantiated with:
     * 1. Certain **required properties** which differ for subtrees and leaves.
     * 2. Arbitrary **non-standard option properties** are defined on the `options` object (so long as their names do not conflict with any standard options) and never persist.
     * 3. Certain **standard options properties** as defined in the {@link FilterNode~optionsSchema|optionsSchema} hash, come from various sources, as prioritized as follows:
     *    1. `options` object; does not persist
     *    2. `state`; object; persists
     *    3. `parent` object; persists
     *    4. `default` object; does not persist
     *
     * Notes:
     * 1. "Persists" means output by {@link FilterTree#getState|getState()}.
     * 2. The `parent` object is generated internally for subtrees. It allows standard options to inherit from the parent node.
     * 3. The `default` object comes from the `default` property, if any, of the {@link FilterNode~optionsSchema|schema object} for the standard option in question. Note that once defined, subtrees will then inherit this value.
     * 4. If not defined by any of the above, the standard option remains undefined on the node.
     *
     * **Query Builder UI support:** If your app wants to make use of the generated UI, you are responsible for inserting the top-level `.el` into the DOM. (Otherwise just ignore it.)
     *
     * @param {FilterTreeOptionsObject} [options] - The node state; or an options object possibly containing `state` among other options. Although you can instantiate a filter without any options, this is generally not useful. See *Instantiating a filter* in the {@link http://joneit.github.io/filter-tree/index.html|readme} for a practical discussion of minimum options.
     *
     * * @memberOf FilterNode.prototype
     */
    initialize: function(options) {
        options = options || {};

        var parent = this.parent = this.parent || options.parent,
            root = parent && parent.root;

        if (!root) {
            root = this;

            this.stylesheet = this.stylesheet ||
                cssInjector(options.cssStylesheetReferenceElement);

            this.conditionals = new Conditionals(options); // .sqlIdQts

            this.ParserSQL = new ParserSQL(options); // .schema, .caseSensitiveColumnNames, .resolveAliases

            var keys = ['name'];
            if (options.resolveAliases) {
                keys.push('alias');
            }

            this.findOptions = {
                caseSensitive: options.caseSensitiveColumnNames,
                keys: keys
            };
        }

        this.root = root;

        this.dontPersist = {}; // hash of truthy values

        this.setState(options.state, options);
    },

    /** Insert each subtree into its parent node along with a "delete" button.
     * > The root tree (which has no parent) is inserted into the DOM by the instantiating code (without a delete button).
     * @memberOf FilterNode.prototype
     */
    render: function() {
        if (this.parent) {
            var newListItem = document.createElement(CHILD_TAG);

            if (this.notesEl) {
                newListItem.appendChild(this.notesEl);
            }

            if (!this.keep) {
                var el = this.templates.get('removeButton');
                el.addEventListener('click', this.remove.bind(this));
                newListItem.appendChild(el);
            }

            newListItem.appendChild(this.el);

            this.parent.el.querySelector(CHILDREN_TAG).appendChild(newListItem);
        }
    },

    /**
     *
     * @param {FilterTreeStateObject} state
     * @param {FilterTreeSetStateOptionsObject} [options]
     * @memberOf FilterNode.prototype
     */
    setState: function(state, options) {
        var oldEl = this.el;

        state = this.parseStateString(state, options);

        this.mixInStandardOptions(state, options);
        this.mixInNonstandardOptions(options);
        this.createView(state);
        this.loadState(state);
        this.render();

        if (oldEl) {
            var newEl = this.el;
            if (this.parent && oldEl.parentElement.tagName === 'LI') {
                oldEl = oldEl.parentNode;
                newEl = newEl.parentNode;
            }
            oldEl.parentNode.replaceChild(newEl, oldEl);
        }
    },

    /**
     * @summary Convert a string to a state object.
     *
     * @desc They string's syntax is inferred as follows:
     * 1. If state is undefined or already an object, return as is.
     * 2. If `options.context` is defined, `state` is assumed to be a CSS selector string (auto-detected) pointing to an HTML form control with a `value` property, such as a {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLInputElement HTMLInputElement} or a {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLTextAreaElement HTMLTextAreaElement}. The element is selected and if found, its value is fetched from the DOM and assigned to `state`.
     * 3. If `options.syntax` is `'auto'`, JSON syntax is detected if `state` begins _and_ ends with either `[` and `]` _or_ `{` and `}` (ignoring leading and trailing white space).
     * 4. If JSON syntax, parse the string into an actual `FilterTreeStateObject` using {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse|JSON.parse} and throw an error if unparsable.
     * 5. If not JSON, parse the string as SQL into an actual `FilterTreeStateObject` using parser-SQL's {@link ParserSQL#parser|parser} and throw an error if unparsable.
     *
     * @param {FilterTreeStateObject} [state]
     * @param {FilterTreeSetStateOptionsObject} [options]
     *
     * @returns {FilterTreeStateObject} The unmolested `state` parameter. Throws an error if `state` is unknown or invalid syntax.
     *
     * @memberOf FilterNode
     * @inner
     */
    parseStateString: function(state, options) {
        if (state) {
            if (typeof state === 'string') {
                var context = options && options.context,
                    syntax = options && options.syntax || 'auto'; // default is 'auto'

                if (context) {
                    state = context.querySelector(state).value;
                }

                if (syntax === 'auto') {
                    syntax = reJSON.test(state) ? 'JSON' : 'SQL';
                }

                switch (syntax) {
                    case 'JSON':
                        try {
                            state = JSON.parse(state);
                        } catch (error) {
                            throw new FilterTreeError('JSON parser: ' + error);
                        }
                        break;
                    case 'SQL':
                        try {
                            state = this.root.ParserSQL.parse(state);
                        } catch (error) {
                            throw new FilterTreeError('SQL WHERE clause parser: ' + error);
                        }
                        break;
                }
            }

            if (typeof state !== 'object') {
                throw new FilterTreeError('Unexpected input state.');
            }
        }

        return state;
    },

    /**
     * Create each standard option from when found on the `options` or `state` objects, respectively; or if not an "own" option, on the `parent` object or from the options schema default (if any)
     * @param state
     * @param options
     */
    mixInStandardOptions: function(state, options) {
        var node = this;

        _(FilterNode.optionsSchema).each(function(optionSchema, key) {
            if (!optionSchema.ignore && (this !== this.root || optionSchema.rootBound)) {
                var option;

                node.dontPersist[key] = // truthy if from `options` or `default`
                    (option = options && options[key]) !== undefined ||
                    (option = state && state[key]) === undefined &&
                    !(optionSchema.own || node.hasOwnProperty(key) && option !== null) &&
                    !(option = node.parent && node.parent[key]) &&
                    (option = optionSchema.default);

                if (option === null) {
                    delete node[key];
                    node.dontPersist[key] = false;
                } else if (option) {
                    if (key === 'schema' && !option.walk) {
                        // attach the `walk` and `find` convenience methods to the `schema` array
                        option.walk = popMenu.walk.bind(option);
                        option.lookup = popMenu.lookup.bind(option, node.root.findOptions);
                    }
                    node[key] = option;
                }
            }
        });
    },

    /**
     * @param options
     */
    mixInNonstandardOptions: function(options) {
        var node = this;

        // copy all remaining options directly to the new instance, overriding prototype members of the same name
        _(options).each(function(value, key) {
            if (!FilterNode.optionsSchema[key]) {
                node[key] = value;
            }
        });
    },

    /** Remove both:
     * * `this` filter node from it's `parent`'s `children` collection; and
     * * `this` filter node's `el`'s container (always a `<li>` element) from its parent element.
     * @memberOf FilterNode.prototype
     */
    remove: function() {
        var avert,
            parent = this.parent;

        if (parent) {
            if (this.eventHandler) {
                this.eventHandler.call(parent, {
                    type: 'delete',
                    preventDefault: function() { avert = true; }
                });
            }
            if (!avert) {
                if (
                    parent.keep || // never "prune" (remove if empty) this particular subexpression
                    parent.children.length > 1 // this node has siblings so will not be empty after this remove
                ) {
                    // proceed with remove
                    this.el.parentNode.remove(); // the parent is always the containing <li> tag
                    parent.children.splice(parent.children.indexOf(this), 1);
                } else {
                    // recurse to prune entire subexpression because it's prune-able and would end up empty (childless)
                    parent.remove();
                }
            }
        }
    },

    Error: FilterTreeError,

    templates: new Templates()
});

/** @typedef optionsSchemaObject
 * @summary Standard option schema
 * @desc Standard options are automatically added to nodes. Data sources for standard options include `options`, `state`, `parent` and `default` (in that order). Describes standard options through various properties:
 * @property {boolean} [ignore] - Do not automatically add to nodes (processed elsewhere).
 * @property {boolean} [own] - Do not automatically add from `parent` or `default`.
 * @property {boolean} [rootBound] - Automatically add to root node only.
 * @property {*} [default] - This is the default data source when all other strategies fail.
 */

/**
 * @summary Defines the standard options available to a node.
 * @desc The following properties bear the same names as the node options they define.
 * @type {pbject}
 * @memberOf FilterNode
 */
FilterNode.optionsSchema = {

    state: { ignore: true },

    cssStylesheetReferenceElement: { ignore: true },

    /** @summary Default column schema for column drop-downs of direct descendant leaf nodes only.
     * @desc > This docs entry describes a property in the FilterNode prototype. It does not describe the optionsSchema property (despite it's position in the source code).
     * @type {string[]}
     * @memberOf FilterNode.optionsSchema
     */
    ownSchema: { own: true },

    /** @summary Default column schema for column drop-downs of all descendant leaf nodes.
     * @desc > This docs entry describes a property in the FilterNode prototype. It does not describe the optionsSchema property (despite it's position in the source code).
     * @type {menuItem[]}
     * @memberOf FilterNode.optionsSchema
     */
    schema: {},

    /** @summary Type of filter editor.
     * @desc > This docs entry describes a property in the FilterNode prototype. It does not describe the optionsSchema property (despite it's position in the source code).
     * @type {string}
     * @memberOf FilterNode.optionsSchema
     */
    editor: {},

    /** @summary Event handler for UI events.
     * @desc > This docs entry describes a property in the FilterNode prototype. It does not describe the optionsSchema property (despite it's position in the source code).
     * @type {string}
     * @memberOf FilterNode.optionsSchema
     */
    eventHandler: {},

    type: { own: true },

    keep: { own: true },

    /** @summary Override operator list at any node.
     * @desc > This docs entry describes a property in the FilterNode prototype. It does not describe the optionsSchema property (despite it's position in the source code).
     * @type {string[]}
     * @memberOf FilterNode.optionsSchema
     */
    opMenu: { default: Conditionals.defaultOpMenu },

    typeOpMap: { rootBound: true },

    /** @summary Truthy will sort the column menus.
     * @type {boolean}
     * @memberOf FilterNode.optionsSchema
     */
    sortColumnMenu: {}
};

FilterNode.setWarningClass = function(el, value) {
    if (arguments.length < 2) {
        value = el.value;
    }
    el.classList[value ? 'remove' : 'add']('filter-tree-warning');
    return value;
};

FilterNode.clickIn = function(el) {
    if (el) {
        if (el.tagName === 'SELECT') {
            setTimeout(function() { el.dispatchEvent(new MouseEvent('mousedown')); }, 0);
        } else {
            el.focus();
        }
    }
};

module.exports = FilterNode;

},{"./Conditionals":10,"./Templates":14,"./parser-SQL":16,"./stylesheet":17,"extend-me":7,"object-iterators":46,"pop-menu":47}],13:[function(require,module,exports){
/* eslint-env browser */

// This is the main file, usable as is, such as by /test/index.js.

// For npm: require this file
// For CDN: gulpfile.js browserifies this file with sourcemap to /build/filter-tree.js and uglified without sourcemap to /build/filter-tree.min.js. The CDN is https://joneit.github.io/filter-tree.

'use strict';

var popMenu = require('pop-menu');
var unstrungify = require('unstrungify');

var _ = require('object-iterators');
var FilterNode = require('./FilterNode');
var FilterLeaf = require('./FilterLeaf');
var operators = require('./tree-operators');


var ordinal = 0;

/** @constructor
 * @summary An object that represents the root node or a branch node in a filter tree.
 * @desc A node representing a subexpression in the filter expression. May be thought of as a parenthesized subexpression in algebraic expression syntax. As discussed under {@link FilterNode}, a `FilterTree` instance's child nodes may be either:
 * * Other (nested) `FilterTree` (or subclass thereof) nodes representing subexpressions.
 * * {@link FilterLeaf} (or subclass thereof) terminal nodes representing conditional expressions.
 *
 * The `FilterTree` object also has methods, some of which operate on a specific subtree instance, and some of which recurse through all the subtree's child nodes and all their descendants, _etc._
 *
 * The recursive methods are interesting. They all work similarly, looping through the list of child nodes, recursing when the child node is a nested subtree (which will recurse further when it has its own nested subtrees); and calling the polymorphic method when the child node is a `FilterLeaf` object, which is a terminal node. Such polymorphic methods include `setState()`, `getState()`, `invalid()`, and `test()`.
 *
 * For example, calling `test(dataRow)` on the root tree recurses through any subtrees eventually calling `test(dataRow)` on each of its leaf nodes and concatenating the results together using the subtree's `operator`. The subtree's `test(dataRow)` call then returns the result to it's parent's `test()` call, _etc.,_ eventually bubbling up to the root node's `test(dataRow)` call, which returns the final result to the original caller. This result determines if the given data row passed through the entire filter expression successfully (`true`) and should be displayed, or was blocked somewhere (`false`) and should not be displayed.
 *
 * Note that in practice:
 * 1. `children` may be empty. This represents a an empty subexpression. Normally pointless, empty subexpressions could be pruned. Filter-tree allows them however as harmless placeholders.
 * 1. `operator` may be omitted in which case it defaults to AND.
 * 1. A `false` result from a child node will short-stop an AND operation; a `true` result will short-stop an OR or NOR operation.
 *
 * Additional notes:
 * 1. A `FilterTree` may consist of a single leaf, in which case the concatenation `operator` is not needed and may be left undefined. However, if a second child is added and the operator is still undefined, it will be set to the default (`'op-and'`).
 * 2. The order of the children is undefined as all operators are commutative. For the '`op-or`' operator, evaluation ceases on the first positive result and for efficiency, all simple conditional expressions will be evaluated before any complex subexpressions.
 * 3. A nested `FilterTree` is distinguished (duck-typed) from a leaf node by the presence of a `children` member.
 * 4. Nesting a `FilterTree` containing a single child is valid (albeit pointless).
 *
 * **See also the properties of the superclass:** {@link FilterNode}
 *
 * @property {string} [operator='op-and'] - The operator that concatentates the test results from all the node's `children` (child nodes). Must be one of:
 * * `'op-and'`
 * * `'op-or'`
 * * `'op-nor'`
 *
 * Note that there is only one `operator` per subexpression. If you need to mix operators, create a subordinate subexpression as one of the child nodes.
 *
 * @property {FilterNode[]} children - A list of descendants of this node. As noted, these may be other `FilterTree` (or subclass thereof) nodes; or may be terminal `FilterLeaf` (or subclass thereof) nodes. May be any length including 0 (none; empty).
 *
 * @property {boolean} [keep=false] - Do not automatically prune when last child removed.
 *
 * @property {fieldItem[]} [ownSchema] - Column menu to be used only by leaf nodes that are children (direct descendants) of this node.
 *
 * @property {string} [type='subtree'] - Type of node, for rendering purposes; names the rendering template to use to generate the node's UI representation.
 */
var FilterTree = FilterNode.extend('FilterTree', {

    /**
     * Hash of constructors for objects that extend from {@link FilterLeaf}, which is the `Default` member here.
     *
     * Add additional editors to this object (in the prototype) prior to instantiating a leaf node that refers to it. This object exists in the prototype and additions to it will affect all nodes that don't have their an "own" hash.
     *
     * If you create an "own" hash in your instance be sure to include the default editor, for example: `{ Default: FilterTree.prototype.editors.Default, ... }`. (One way of overriding would be to include such an object in an `editors` member of the options object passed to the constructor on instantiation. This works because all miscellaneous members are simply copied to the new instance. Not to be confused with the standard option `editor` which is a string containing a key from this hash and tells the leaf node what type to use.)
     */
    editors: {
        Default: FilterLeaf
    },

    /**
     * An extension is a hash of prototype overrides (methods, properties) used to extend the default editor.
     * @param {string} [key='Default'] - Nme of the new extension given in `ext` or name of an existing extension in `FilterTree.extensions`. As a constructor, should have an initial capital. If omitted, replaces the default editor (FilterLeaf).
     * @param {object} [ext] An extension hash
     * @param {FilerLeaf} [BaseEditor=this.editors.Default] - Constructor to extend from.
     * @returns {FillterLeaf} A new class extended from `BaseEditor` -- which is initially `FilterLeaf` but may itself have been extended by a call to `.addEditor('Default', extension)`.
     */
    addEditor: function(key, ext, BaseEditor) {
        if (typeof key === 'object') {
            // `key` (string) was omitted
            BaseEditor = ext;
            ext = key;
            key = 'Default';
        }
        BaseEditor = BaseEditor || this.editors.Default;
        ext = ext || FilterTree.extensions[key];
        return (this.editors[key] = BaseEditor.extend(key, ext));
    },

    /**
     * @param {string} key - The name of the existing editor to remove.
     * @memberOf FilterTree.prototype
     */
    removeEditor: function(key) {
        if (key === 'Default') {
            throw 'Cannot remove default editor.';
        }
        delete this.editors[key];
    },

    /**
     *
     * @memberOf FilterTree.prototype
     */
    createView: function() {
        this.el = this.templates.get(
            this.type || 'subtree',
            ++ordinal,
            this.schema[0] && popMenu.formatItem(this.schema[0])
        );

        // Add the expression editors to the "add new" drop-down
        var addNewCtrl = this.el.querySelector(':scope>select');
        if (addNewCtrl) {
            var submenu, optgroup,
                editors = this.editors;

            if (addNewCtrl.length === 1 && this.editors.length === 1) {
                // this editor is the only option besides the null prompt option
                // so make it th eonly item i the drop-down
                submenu = addNewCtrl;
            } else {
                // there are already options and/or multiple editors
                submenu = optgroup = document.createElement('optgroup');
                optgroup.label = 'Conditional Expressions';
            }
            Object.keys(editors).forEach(function(key) {
                var name = editors[key].prototype.name || key;
                submenu.appendChild(new Option(name, key));
            });
            if (optgroup) {
                addNewCtrl.add(optgroup);
            }
            this.el.addEventListener('change', onchange.bind(this));
        }

        this.el.addEventListener('click', onTreeOpClick.bind(this));
    },

    /**
     *
     * @memberOf FilterTree.prototype
     */
    loadState: function(state) {
        this.operator = 'op-and';
        this.children = [];

        if (!state) {
            this.add();
        } else {
            // Validate `state.children` (required)
            if (!(state.children instanceof Array)) {
                throw new this.Error('Expected `children` property to be an array.');
            }

            // Validate `state.operator` (if given)
            if (state.operator) {
                if (!operators[state.operator]) {
                    throw new this.Error('Expected `operator` property to be one of: ' + Object.keys(operators));
                }

                this.operator = state.operator;
            }

            state.children.forEach(this.add.bind(this));
        }
    },

    /**
     *
     * @memberOf FilterTree.prototype
     */
    render: function() {
        var radioButton = this.el.querySelector(':scope > label > input[value=' + this.operator + ']'),
            addFilterLink = this.el.querySelector('.filter-tree-add-conditional');

        if (radioButton) {
            radioButton.checked = true;
            onTreeOpClick.call(this, {
                target: radioButton
            });
        }

        // when multiple filter editors available, simulate click on the new "add conditional" link
        if (addFilterLink && !this.children.length && Object.keys(this.editors).length > 1) {
            this['filter-tree-add-conditional']({
                target: addFilterLink
            });
        }

        // proceed with render
        FilterNode.prototype.render.call(this);
    },

    /**
     * @summary Create a new node as per `state`.
     *
     * @param {object} [options={state:{}}] - May be one of:
     *
     * * an `options` object containing a `state` property
     * * a `state` object (in which case there is no `options` object)
     *
     * In any case, resulting `state` object may be either...
     * * A new subtree (has a `children` property):
     *   Add a new `FilterTree` node.
     * * A new leaf (no `children` property): add a new `FilterLeaf` node:
     *   * If there is an `editor` property:
     *     Add leaf using `this.editors[state.editor]`.
     *   * Otherwise (including the case where `state` is undefined):
     *     Add leaf using `this.editors.Default`.
     *
     * @param {boolean} [options.focus=false] Call invalid() after inserting to focus on first blank control (if any).
     *
     * @returns {FilterNode} The new node.
     *
     * @memberOf FilterTree.prototype
     */
    add: function(options) {
        var Constructor, newNode;

        options = options || {};

        if (!options.state) {
            options = { state: options };
        }

        if (options.state.children) {
            Constructor = this.constructor;
        } else {
            Constructor = this.editors[options.state.editor || 'Default'];
        }

        options.parent = this;
        newNode = new Constructor(options);
        this.children.push(newNode);

        if (options.focus) {
            // focus on blank control a beat after adding it
            setTimeout(function() { newNode.invalid(options); }, 750);
        }

        return newNode;
    },

    /** @typedef {object} FilterTreeValidationOptionsObject
     * @property {boolean} [throw=false] - Throw (do not catch) `FilterTreeError`s.
     * @property {boolean} [alert=false] - Announce error via window.alert() before returning.
     * @property {boolean} [focus=false] - Place the focus on the offending control and give it error color.
     */

    /**
     * @param {FilterTreeValidationOptionsObject} [options]
     * @returns {undefined|FilterTreeError} `undefined` if valid; or the caught `FilterTreeError` if error.
     * @memberOf FilterTree.prototype
     */
    invalid: function(options) {
        var result;

        options = options || {};

        try {
            result = invalid.call(this, options);
        } catch (err) {
            result = err;

            // Throw when unexpected (not a filter tree error)
            if (!(err instanceof this.Error)) {
                throw err;
            }
        }

        // Alter and/or throw when requested
        if (result) {
            if (options.alert) {
                window.alert(result.message || result); // eslint-disable-line no-alert
            }
            if (options.throw) {
                throw result;
            }
        }

        return result;
    },

    /**
     *
     * @param dataRow
     * @returns {boolean}
     * @memberOf FilterTree.prototype
     */
    test: function test(dataRow) {
        var operator = operators[this.operator],
            result = operator.seed,
            noChildrenDefined = true;

        this.children.find(function(child) {
            if (child) {
                noChildrenDefined = false;
                if (child instanceof FilterLeaf) {
                    result = operator.reduce(result, child.test(dataRow));
                } else if (child.children.length) {
                    result = operator.reduce(result, test.call(child, dataRow));
                }
                return result === operator.abort;
            }

            return false;
        });

        return noChildrenDefined || (operator.negate ? !result : result);
    },

    /**
     * @returns {number} Number of filters (terminal nodes) defined in this subtree.
     */
    filterCount: function filterCount() {
        var n = 0;

        this.children.forEach(function(child) {
            n += child instanceof FilterLeaf ? 1 : filterCount.call(child);
        });

        return n;
    },

    /** @typedef {object} FilterTreeGetStateOptionsObject
     *
     * @summary Object containing options for producing a state object.
     *
     * @desc State is commonly used for two purposes:
     * 1. To persist the filter state so that it can be reloaded later.
     * 2. To send a query to a database engine.
     *
     * @property {boolean} [syntax='object'] - A case-sensitive string indicating the expected type and format of a state object to be generated from a filter tree. One of:
     * * `'object'` (default) A raw state object produced by walking the tree using `{@link https://www.npmjs.com/package/unstrungify|unstrungify()}`, respecting `JSON.stringify()`'s "{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#toJSON()_behavior|toJSON() behavior}," and returning a plain object suitable for resubmitting to {@link FilterNode#setState|setState}. This is an "essential" version of the actual node objects in the tree.
     * * `'JSON'` - A stringified state object produced by walking the tree using `{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#toJSON()_behavior|JSON.stringify()}`, returning a JSON string by calling `toJSON` at every node. This is a string representation of the same "essential" object as that produced by the `'object'` option, but "stringified" and therefore suitable for text-based storage media.
     * * `'SQL'` - The subexpression in SQL conditional syntax produced by walking the tree and returning a SQL [search condition expression]{@link https://msdn.microsoft.com/en-us/library/ms173545.aspx}. Suitable for use in the WHERE clause of a SQL `SELECT` statement used to query a database for a filtered result set.
     *
     * @param {number|string} [space] - When `options.syntax === 'JSON'`, forwarded to `JSON.stringify` as the third parameter, `space` (see).
     *
     * NOTE: The SQL syntax result cannot accommodate node meta-data. While meta-data such as `type` typically comes from the column schema, meta-data can be installed directly on a node. Such meta-data will not be part of the resulting SQL expression. For this reason, SQL should not be used to persist filter state but rather its use should be limited to generating a filter query for a remote data server.
     */

    /**
     * @summary Get a representation of filter state.
     * @desc Calling this on the root will get the entire tree's state; calling this on any subtree will get just that subtree's state.
     *
     * Only _essential_ properties will be output:
     *
     * 1. `FilterTree` nodes will output at least 2 properties:
     *    * `operator`
     *    * `children`
     * 2. `FilterLeaf` nodes will output (via {@link FilterLeaf#getState|getState}) at least 3 properties, one property for each item in it's `view`:
     *    * `column`
     *    * `operator`
     *    * `operand`
     * 3. Additional node properties will be output when:
     *    1. When the property was **NOT** externally sourced:
     *       1. Did *not* come from the `options` object on node instantiation.
     *       2. Did *not* come from the options schema `default` object, if any.
     *    2. **AND** at least one of the following is true:
     *       1. When it's an "own" property.
     *       2. When its value differs from it's parent's.
     *       3. When this is the root node.
     *
     * @param {FilterTreeGetStateOptionsObject} [options]
     * @param {object} [options.sqlIdQts] - When `options.syntax === 'SQL'`, forwarded to `conditionals.pushSqlIdQts()`.
     * @returns {object|string} Returns object when `options.syntax === 'object'`; otherwise returns string.
     * @memberOf FilterTree.prototype
     */
    getState: function getState(options) {
        var result = '',
            syntax = options && options.syntax || 'object';

        switch (syntax) {
            case 'object':
                result = unstrungify.call(this);
                break;

            case 'JSON':
                result = JSON.stringify(this, null, options && options.space) || '';
                break;

            case 'SQL':
                var lexeme = operators[this.operator].SQL;

                this.children.forEach(function(child, idx) {
                    var op = idx ? ' ' + lexeme.op + ' ' : '';
                    if (child instanceof FilterLeaf) {
                        result += op + child.getState(options);
                    } else if (child.children.length) {
                        result += op + getState.call(child, options);
                    }
                });

                if (result) {
                    result = lexeme.beg + result + lexeme.end;
                }
                break;

            default:
                throw new this.Error('Unknown syntax option "' + syntax + '"');
        }

        return result;
    },

    toJSON: function toJSON() {
        var self = this,
            state = {
                operator: this.operator,
                children: []
            };

        this.children.forEach(function(child) {
            state.children.push(child instanceof FilterLeaf ? child : toJSON.call(child));
        });

        _(FilterNode.optionsSchema).each(function(optionSchema, key) {
            if (
                self[key] && // there is a standard option on the node which may need to be output
                !self.dontPersist[key] && (
                    optionSchema.own || // output because it's an "own" option (belongs to the node)
                    !self.parent || // output because it's the root node
                    self[key] !== self.parent[key] // output because it differs from its parent's version
                )
            ) {
                state[key] = self[key];
            }
        });

        return state;
    },

    /**
     * @summary Set the case sensitivity of filter tests against data.
     * @desc Case sensitivity pertains to string compares only. This includes untyped columns, columns typed as strings, typed columns containing data that cannot be coerced to type or when the filter expression operand cannot be coerced.
     *
     * NOTE: This is a shared property and affects all filter-tree instances constructed by this code instance.
     * @param {boolean} isSensitive
     * @memberOf Filtertree.prototype.prototype
     */
    setCaseSensitivity: function(isSensitive) {
        var toString = isSensitive ? toStringCaseSensitive : toStringCaseInsensitive;
        FilterLeaf.setToString(toString);
    }

});

function toStringCaseInsensitive(s) { return (s + '').toUpperCase(); }
function toStringCaseSensitive(s) { return s + ''; }

// Some event handlers bound to FilterTree object

function onchange(evt) { // called in context
    var ctrl = evt.target;
    if (ctrl.parentElement === this.el) {
        if (ctrl.value === 'subexp') {
            this.children.push(new FilterTree({
                parent: this
            }));
        } else {
            this.add({
                state: { editor: ctrl.value },
                focus: true
            });
        }
        ctrl.selectedIndex = 0;
    }
}

function onTreeOpClick(evt) { // called in context
    var ctrl = evt.target;

    if (ctrl.className === 'filter-tree-op-choice') {
        this.operator = ctrl.value;

        // display strike-through
        var radioButtons = this.el.querySelectorAll('label>input.filter-tree-op-choice[name=' + ctrl.name + ']');
        Array.prototype.forEach.call(radioButtons, function(ctrl) {
            ctrl.parentElement.style.textDecoration = ctrl.checked ? 'none' : 'line-through';
        });

        // display operator between filters by adding operator string as a CSS class of this tree
        for (var key in operators) {
            this.el.classList.remove(key);
        }
        this.el.classList.add(this.operator);
    }
}

/**
 * Throws error if invalid expression tree.
 * Caught by {@link FilterTree#invalid|FilterTree.prototype.invalid()}.
 * @param {boolean} [options.focus=false] - Move focus to offending control.
 * @returns {undefined} if valid
 * @private
 */
function invalid(options) { // called in context
    //if (this instanceof FilterTree && !this.children.length) {
    //    throw new this.Error('Empty subexpression (no filters).');
    //}

    this.children.forEach(function(child) {
        if (child instanceof FilterLeaf) {
            child.invalid(options);
        } else if (child.children.length) {
            invalid.call(child, options);
        }
    });
}

FilterTree.extensions = {
    Columns: require('./extensions/columns')
};

// module initialization
FilterTree.prototype.setCaseSensitivity(true);  // default is case-sensitive which is more efficient; may be reset at will


module.exports = FilterTree;

},{"./FilterLeaf":11,"./FilterNode":12,"./extensions/columns":15,"./tree-operators":18,"object-iterators":46,"pop-menu":47,"unstrungify":53}],14:[function(require,module,exports){
/* eslint-env browser */

'use strict';

var templex = require('templex');

var templates = require('../html');

var encoders = /\{(\d+)\:encode\}/g;

function Templates() {}
var constructor = Templates.prototype.constructor;
Templates.prototype = templates;
Templates.prototype.constructor = constructor; // restore it
Templates.prototype.get = function(templateName) { // mix it in
    var keys,
        matches = {},
        temp = document.createElement('div'),
        text = this[templateName],
        args = Array.prototype.slice.call(arguments, 1);

    encoders.lastIndex = 0;

    while ((keys = encoders.exec(text))) {
        matches[keys[1]] = true;
    }

    keys = Object.keys(matches);

    if (keys.length) {
        keys.forEach(function(key) {
            temp.textContent = args[key];
            args[key] = temp.innerHTML;
        });
        text = text.replace(encoders, '{$1}');
    }

    temp.innerHTML = templex.apply(this, [text].concat(args));

    // if only one HTMLElement, return it; otherwise entire list of nodes
    return temp.children.length === 1 && temp.childNodes.length === 1
        ? temp.firstChild
        : temp.childNodes;
};

module.exports = Templates;

},{"../html":8,"templex":52}],15:[function(require,module,exports){
'use strict';

var Conditionals = require('../Conditionals');
var FilterLeaf = require('../FilterLeaf');

/**
 * @summary Prototype additions object for extending {@link FilterLeaf}.
 * @desc Resulting object is similar to {@link FilterLeaf} except:
 * 1. The `operand` property names another column rather than contains a literal.
 * 2. Operators are limited to equality, inequalities, and sets (IN/NOT IN). Omitted are the string and pattern scans (BEGINS/NOT BEGINS, ENDS/NOT ENDS, CONTAINS/NOT CONTAINS, and LIKE/NOT LIKE).
 *
 * @extends FilterLeaf
 *
 * @property {string} identifier - Name of column (member of data row object) to compare against this column (member of data row object named by `column`).
 */
var ColumnLeaf = {
    name: 'column = column', // display string for drop-down

    createView: function() {
        // Create the `view` hash and insert the three default elements (`column`, `operator`, `operand`) into `.el`
        FilterLeaf.prototype.createView.call(this);

        // Replace the `operand` element from the `view` hash
        var oldOperand = this.view.operand,
            newOperand = this.view.operand = this.makeElement(this.root.schema, 'column', this.sortColumnMenu);

        // Replace the operand element with the new one. There are no event listeners to worry about.
        this.el.replaceChild(newOperand, oldOperand);
    },

    makeSqlOperand: function() {
        return this.conditionals.makeSqlIdentifier(this.operand);
    },

    opMenu: [
        Conditionals.groups.equality,
        Conditionals.groups.inequalities,
        Conditionals.groups.sets
    ],

    q: function(dataRow) {
        return this.valOrFunc(dataRow, this.operand);
    }
};

module.exports = ColumnLeaf;

},{"../Conditionals":10,"../FilterLeaf":11}],16:[function(require,module,exports){
'use strict';

var reOp = /^((=|>=?|<[>=]?)|(NOT )?(LIKE|IN)\b)/i, // match[1]
    reLit = /^'(\d+)'/,
    reLitAnywhere = /'(\d+)'/,
    reIn = /^\((.*?)\)/,
    reBool = /^(AND|OR)\b/i,
    reGroup = /^(NOT ?)?\(/i;

var SQT = '\'';

var defaultIdQts = {
    beg: '"',
    end: '"'
};

function ParserSqlError(message) {
    this.message = message;
}
ParserSqlError.prototype = Object.create(Error.prototype);
ParserSqlError.prototype.name = 'ParserSqlError';

/** @typedef {object} sqlIdQtsObject
 * @desc On a practical level, the useful characters are:
 * * SQL-92 standard: "double quotes"
 * * SQL Server: "double quotes" or \[square brackets\]
 * * mySQL: \`tick marks\`
 * @property {string} beg - The open quote character.
 * @property {string} end - The close quote character.
 */

/**
 * @constructor
 * @summary Structured Query Language (SQL) parser
 * @author Jonathan Eiten <jonathan@openfin.com>
 * @desc This is a subset of SQL conditional expression syntax.
 *
 * @see {@link https://msdn.microsoft.com/en-us/library/ms173545.aspx SQL Search Condition}
 *
 * @param {menuItem[]} [options.schema] - Column schema for column name validation. Throws an error if name fails validation (but see `resolveAliases`). Omit to skip column name validation.
 * @param {boolean} [options.resolveAliases] - Validate column aliases against schema and use the associated column name in the returned expression state object. Requires `options.schema`. Throws error if no such column found.
 * @param {boolean} [options.caseSensitiveColumnNames] - Ignore case while validating column names and aliases.
 * @param {sqlIdQtsObject} [options.sqlIdQts={beg:'"',end:'"'}]
 */
function ParserSQL(options) {
    options = options || {};

    this.schema = options.schema;

    var idQts = options.sqlIdQts || defaultIdQts;
    this.reName = new RegExp('^(' + idQts.beg + '(.+?)' + idQts.end + '|([A-Z_][A-Z_@\\$#]*)\\b)', 'i'); // match[2] || match[3]
}

ParserSQL.prototype = {

    constructor: ParserSQL.prototype.constructor,

    /**
     * @param {string} sql
     * @returns {*}
     * @memberOf module:sqlSearchCondition
     */
    parse: function(sql) {
        var state;

        // reduce all runs of white space to a single space; then trim
        sql = sql.replace(/\s\s+/g, ' ').trim();

        sql = stripLiterals.call(this, sql);
        state = walk.call(this, sql);

        if (!state.children) {
            state = { children: [ state ] };
        }

        return state;
    }
};

function walk(t) {
    var m, name, op, operand, bool, token, tokens = [];
    var i = 0;

    t = t.trim();

    while (i < t.length) {
        m = t.substr(i).match(reGroup);
        if (m) {
            var not = !!m[1];

            i += m[0].length;
            for (var j = i, v = 1; j < t.length && v; ++j) {
                if (t[j] === '(') {
                    ++v;
                } else if (t[j] === ')') {
                    --v;
                }
            }

            if (v) {
                throw new ParserSqlError('Expected ")"');
            }
            token = walk.call(this, t.substr(i, j - 1 - i));
            if (typeof token !== 'object') {
                return token;
            }

            if (not) {
                if (token.operator !== 'op-or') {
                    throw new ParserSqlError('Expected OR in NOT(...) subexpression but found ' + token.operator.substr(3).toUpperCase() + '.');
                }
                token.operator = 'op-nor';
            }

            i = j;
        } else {
            m = t.substr(i).match(this.reName);
            if (!m) {
                throw new ParserSqlError('Expected identifier or quoted identifier.');
            }
            name = m[2] || m[3];
            if (!/^[A-Z_]/i.test(t[i])) { i += 2; }
            i += name.length;

            if (t[i] === ' ') { ++i; }
            m = t.substr(i).match(reOp);
            if (!m) {
                throw new ParserSqlError('Expected relational operator.');
            }
            op = m[1].toUpperCase();
            i += op.length;

            if (t[i] === ' ') { ++i; }
            if (m[4] && m[4].toUpperCase() === 'IN') {
                m = t.substr(i).match(reIn);
                if (!m) {
                    throw new ParserSqlError('Expected parenthesized list.');
                }
                operand = m[1];
                i += operand.length + 2;
                while ((m = operand.match(reLitAnywhere))) {
                    operand = operand.replace(reLitAnywhere, this.literals[m[1]]);
                }
            } else {
                m = t.substr(i).match(reLit);
                if (!m) {
                    throw new ParserSqlError('Expected string literal.');
                }
                operand = m[1];
                i += operand.length + 2;
                operand = this.literals[operand];
            }

            if (this.schema) {
                var item = this.schema.lookup(name);
                if (item) {
                    name = item.name;
                } else {
                    throw new ParserSqlError(this.resolveAliases
                        ? 'Expected valid column name.'
                        : 'Expected valid column name or alias.'
                    );
                }
            }

            token = {
                column: name,
                operator: op,
                operand: operand
            };
        }

        tokens.push(token);

        if (i < t.length) {
            if (t[i] === ' ') { ++i; }
            m = t.substr(i).match(reBool);
            if (!m) {
                throw new ParserSqlError('Expected boolean opearator.');
            }
            bool = m[1].toLowerCase();
            i += bool.length;
            bool = 'op-' + bool;
            if (tokens.operator && tokens.operator !== bool) {
                throw new ParserSqlError('Expected same boolean operator throughout subexpression.');
            }
            tokens.operator = bool;
        }

        if (t[i] === ' ') { ++i; }
    }

    return (
        tokens.length === 1 ? tokens[0] : {
            operator: tokens.operator,
            children: tokens
        }
    );
}

function stripLiterals(t) {
    var i = 0, j = 0, k;

    this.literals = [];

    while ((j = t.indexOf(SQT, j)) >= 0) {
        k = j;
        do {
            k = t.indexOf(SQT, k + 1);
            if (k < 0) {
                throw new ParserSqlError('Expected ' + SQT + ' (single quote).');
            }
        } while (t[++k] === SQT);
        this.literals.push(t.slice(++j, --k).replace(/''/g, SQT));
        t = t.substr(0, j) + i + t.substr(k);
        j = j + 1 + (i + '').length + 1;
        i++;
    }

    return t;
}

module.exports = ParserSQL;

},{}],17:[function(require,module,exports){
'use strict';

var cssInjector = require('css-injector');

var css; // defined by code inserted by gulpfile between following comments
/* inject:css */
css = '.filter-tree{font-family:sans-serif;font-size:10pt;line-height:1.5em}.filter-tree label{font-weight:400}.filter-tree input[type=checkbox],.filter-tree input[type=radio]{margin-left:3px;margin-right:3px}.filter-tree ol{margin-top:0}.filter-tree>select{float:right;border:1px dotted grey;background-color:transparent;box-shadow:none}.filter-tree-remove-button{display:inline-block;width:15px;height:15px;border-radius:8px;background-color:#e88;font-size:11.5px;color:#fff;text-align:center;line-height:normal;font-style:normal;font-family:sans-serif;margin-right:4px;cursor:pointer}.filter-tree-remove-button:hover{background-color:transparent;color:#e88;font-weight:700;box-shadow:red 0 0 2px inset}.filter-tree-remove-button::before{content:\'\\d7\'}.filter-tree li::after{font-size:70%;font-style:italic;font-weight:700;color:#080}.filter-tree>ol>li:last-child::after{display:none}.op-and>ol,.op-nor>ol,.op-or>ol{padding-left:5px;margin-left:27px}.op-or>ol>li::after{margin-left:2.5em;content:\' OR \'}.op-and>ol>li::after{margin-left:2.5em;content:\' AND \'}.op-nor>ol>li::after{margin-left:2.5em;content:\' NOR \'}.filter-tree-editor>*{font-weight:700}.filter-tree-editor>span{font-size:smaller}.filter-tree-editor>input[type=text]{width:8em;padding:1px 5px 2px}.filter-tree-warning{background-color:#ffc!important;border-color:#edb!important;font-weight:400!important}.filter-tree-error{background-color:#fcc!important;border-color:#c99!important;font-weight:400!important}.filter-tree-default>:enabled{margin:0 .4em;background-color:#ddd;border:1px solid transparent}.filter-tree.filter-tree-type-column-filters>ol>li:not(:last-child){padding-bottom:.75em;border-bottom:3px double #080;margin-bottom:.75em}.filter-tree .footnotes{margin:0 0 6px;font-size:8pt;font-weight:400;line-height:normal;white-space:normal;color:#c00}.filter-tree .footnotes>p{margin:0}.filter-tree .footnotes>ul{margin:-3px 0 0;padding-left:17px;text-index:-6px}.filter-tree .footnotes>ul>li{margin:2px 0}.filter-tree .footnotes .field-name,.filter-tree .footnotes .field-value{font-weight:700;font-style:normal}.filter-tree .footnotes .field-value{font-family:monospace;color:#000;background-color:#ddd;padding:0 5px;margin:0 3px;border-radius:3px}';
/* endinject */

module.exports = cssInjector.bind(this, css, 'filter-tree-base');

},{"css-injector":6}],18:[function(require,module,exports){
'use strict';

/** @typedef {function} operationReducer
 * @param {boolean} p
 * @param {boolean} q
 * @returns {boolean} The result of applying the operator to the two parameters.
 */

/**
 * @private
 * @type {operationReducer}
 */
function AND(p, q) {
    return p && q;
}

/**
 * @private
 * @type {operationReducer}
 */
function OR(p, q) {
    return p || q;
}

/** @typedef {obejct} treeOperator
 * @desc Each `treeOperator` object describes two things:
 *
 * 1. How to take the test results of _n_ child nodes by applying the operator to all the results to "reduce" it down to a single result.
 * 2. How to generate SQL WHERE clause syntax that applies the operator to _n_ child nodes.
 *
 * @property {operationReducer} reduce
 * @property {boolean} seed -
 * @property {boolean} abort -
 * @property {boolean} negate -
 * @property {string} SQL.op -
 * @property {string} SQL.beg -
 * @property {string} SQL.end -
 */

/** A hash of {@link treeOperator} objects.
 * @type {object}
 */
var treeOperators = {
    'op-and': {
        reduce: AND,
        seed: true,
        abort: false,
        negate: false,
        SQL: {
            op: 'AND',
            beg: '(',
            end: ')'
        }
    },
    'op-or': {
        reduce: OR,
        seed: false,
        abort: true,
        negate: false,
        SQL: {
            op: 'OR',
            beg: '(',
            end: ')'
        }
    },
    'op-nor': {
        reduce: OR,
        seed: false,
        abort: true,
        negate: true,
        SQL: {
            op: 'OR',
            beg: 'NOT (',
            end: ')'
        }
    }
};

module.exports = treeOperators;

},{}],19:[function(require,module,exports){
'use strict';

/* eslint-env node, browser */

var cssInjector = require('css-injector');

/**
 * @constructor FinBar
 * @summary Create a scrollbar object.
 * @desc Creating a scrollbar is a three-step process:
 *
 * 1. Instantiate the scrollbar object by calling this constructor function. Upon instantiation, the DOM element for the scrollbar (with a single child element for the scrollbar "thumb") is created but is not insert it into the DOM.
 * 2. After instantiation, it is the caller's responsibility to insert the scrollbar, {@link FinBar#bar|this.bar}, into the DOM.
 * 3. After insertion, the caller must call {@link FinBar#resize|resize()} at least once to size and position the scrollbar and its thumb. After that, `resize()` should also be called repeatedly on resize events (as the content element is being resized).
 *
 * Suggested configurations:
 * * _**Unbound**_<br/>
 * The scrollbar serves merely as a simple range (slider) control. Omit both `options.onchange` and `options.content`.
 * * _**Bound to virtual content element**_<br/>
 * Virtual content is projected into the element using a custom event handler supplied by the programmer in `options.onchange`. A typical use case would be to handle scrolling of the virtual content. Other use cases include data transformations, graphics transformations, _etc._
 * * _**Bound to real content**_<br/>
 * Set `options.content` to the "real" content element but omit `options.onchange`. This will cause the scrollbar to use the built-in event handler (`this.scrollRealContent`) which implements smooth scrolling of the content element within the container.
 *
 * @param {finbarOptions} [options={}] - Options object. See the type definition for member details.
 */
function FinBar(options) {

    // make bound versions of all the mouse event handler
    var bound = this._bound = {};
    for (key in handlersToBeBound) {
        bound[key] = handlersToBeBound[key].bind(this);
    }

    /**
     * @name thumb
     * @summary The generated scrollbar thumb element.
     * @desc The thumb element's parent element is always the {@link FinBar#bar|bar} element.
     *
     * This property is typically referenced internally only. The size and position of the thumb element is maintained by `_calcThumb()`.
     * @type {Element}
     * @memberOf FinBar.prototype
     */
    var thumb = document.createElement('div');
    thumb.classList.add('thumb');
    thumb.onclick = bound.shortStop;
    thumb.onmouseover = bound.onmouseover;
    this.thumb = thumb;

    /**
     * @name bar
     * @summary The generated scrollbar element.
     * @desc The caller inserts this element into the DOM (typically into the content container) and then calls its {@link FinBar#resize|resize()} method.
     *
     * Thus the node tree is typically:
     * * A **content container** element, which contains:
     *    * The content element(s)
     *    * This **scrollbar element**, which in turn contains:
     *        * The **thumb element**
     *
     * @type {Element}
     * @memberOf FinBar.prototype
     */
    var bar = document.createElement('div');

    bar.classList.add('finbar-vertical');

    bar.appendChild(thumb);
    if (this.paging) {
        bar.onclick = bound.onclick;
    }
    this.bar = bar;

    options = options || {};

    // presets
    this.orientation = 'vertical';
    this._min = this._index = 0;
    this._max = 100;

    // options
    for (var key in options) {
        if (options.hasOwnProperty(key)) {
            var option = options[key];
            switch (key) {

            case 'index':
                this._index = option;
                break;

            case 'range':
                validRange(option);
                this._min = option.min;
                this._max = option.max;
                this.contentSize = option.max - option.min + 1;
                break;

            default:
                if (
                    key.charAt(0) !== '_' &&
                    typeof FinBar.prototype[key] !== 'function'
                ) {
                    // override prototype defaults for standard ;
                    // extend with additional properties (for use in onchange event handlers)
                    this[key] = option;
                }
                break;

            }
        }
    }

    cssInjector(cssFinBars, 'finbar-base', options.cssStylesheetReferenceElement);
}

FinBar.prototype = {

    /**
     * @summary The scrollbar orientation.
     * @desc Set by the constructor to either `'vertical'` or `'horizontal'`. See the similarly named property in the {@link finbarOptions} object.
     *
     * Useful values are `'vertical'` (the default) or `'horizontal'`.
     *
     * Setting this property resets `this.oh` and `this.deltaProp` and changes the class names so as to reposition the scrollbar as per the CSS rules for the new orientation.
     * @default 'vertical'
     * @type {string}
     * @memberOf FinBar.prototype
     */
    set orientation(orientation) {
        if (orientation === this._orientation) {
            return;
        }

        this._orientation = orientation;

        /**
         * @readonly
         * @name oh
         * @summary <u>O</u>rientation <u>h</u>ash for this scrollbar.
         * @desc Set by the `orientation` setter to either the vertical or the horizontal orientation hash. The property should always be synchronized with `orientation`; do not update directly!
         *
         * This object is used internally to access scrollbars' DOM element properties in a generalized way without needing to constantly query the scrollbar orientation. For example, instead of explicitly coding `this.bar.top` for a vertical scrollbar and `this.bar.left` for a horizontal scrollbar, simply code `this.bar[this.oh.leading]` instead. See the {@link orientationHashType} definition for details.
         *
         * This object is useful externally for coding generalized {@link finbarOnChange} event handler functions that serve both horizontal and vertical scrollbars.
         * @type {orientationHashType}
         * @memberOf FinBar.prototype
         */
        this.oh = orientationHashes[this._orientation];

        if (!this.oh) {
            error('Invalid value for `options._orientation.');
        }

        /**
         * @name deltaProp
         * @summary The name of the `WheelEvent` property this scrollbar should listen to.
         * @desc Set by the constructor. See the similarly named property in the {@link finbarOptions} object.
         *
         * Useful values are `'deltaX'`, `'deltaY'`, or `'deltaZ'`. A value of `null` means to ignore mouse wheel events entirely.
         *
         * The mouse wheel is one-dimensional and only emits events with `deltaY` data. This property is provided so that you can override the default of `'deltaX'` with a value of `'deltaY'` on your horizontal scrollbar primarily to accommodate certain "panoramic" interface designs where the mouse wheel should control horizontal rather than vertical scrolling. Just give `{ deltaProp: 'deltaY' }` in your horizontal scrollbar instantiation.
         *
         * Caveat: Note that a 2-finger drag on an Apple trackpad emits events with _both_ `deltaX ` and `deltaY` data so you might want to delay making the above adjustment until you can determine that you are getting Y data only with no X data at all (which is a sure bet you on a mouse wheel rather than a trackpad).

         * @type {object|null}
         * @memberOf FinBar.prototype
         */
        this.deltaProp = this.oh.delta;

        this.bar.className = this.bar.className.replace(/(vertical|horizontal)/g, orientation);

        if (this.bar.style.cssText || this.thumb.style.cssText) {
            this.bar.removeAttribute('style');
            this.thumb.removeAttribute('style');
            this.resize();
        }
    },
    get orientation() {
        return this._orientation;
    },

    /**
     * @summary Callback for scroll events.
     * @desc Set by the constructor via the similarly named property in the {@link finbarOptions} object. After instantiation, `this.onchange` may be updated directly.
     *
     * This event handler is called whenever the value of the scrollbar is changed through user interaction. The typical use case is when the content is scrolled. It is called with the `FinBar` object as its context and the current value of the scrollbar (its index, rounded) as the only parameter.
     *
     * Set this property to `null` to stop emitting such events.
     * @type {function(number)|null}
     * @memberOf FinBar.prototype
     */
    onchange: null,

    /**
     * @summary Add a CSS class name to the bar element's class list.
     * @desc Set by the constructor. See the similarly named property in the {@link finbarOptions} object.
     *
     * The bar element's class list will always include `finbar-vertical` (or `finbar-horizontal` based on the current orientation). Whenever this property is set to some value, first the old prefix+orientation is removed from the bar element's class list; then the new prefix+orientation is added to the bar element's class list. This property causes _an additional_ class name to be added to the bar element's class list. Therefore, this property will only add at most one additional class name to the list.
     *
     * To remove _classname-orientation_ from the bar element's class list, set this property to a falsy value, such as `null`.
     *
     * > NOTE: You only need to specify an additional class name when you need to have mulltiple different styles of scrollbars on the same page. If this is not a requirement, then you don't need to make a new class; you would just create some additional rules using the same selectors in the built-in stylesheet (../css/finbars.css):
     * *`div.finbar-vertical` (or `div.finbar-horizontal`) for the scrollbar
     * *`div.finbar-vertical > div` (or `div.finbar-horizontal > div`) for the "thumb."
     *
     * Of course, your rules should come after the built-ins.
     * @type {string}
     * @memberOf FinBar.prototype
     */
    set classPrefix(prefix) {
        if (this._classPrefix) {
            this.bar.classList.remove(this._classPrefix + this.orientation);
        }

        this._classPrefix = prefix;

        if (prefix) {
            this.bar.classList.add(prefix + '-' + this.orientation);
        }
    },
    get classPrefix() {
        return this._classPrefix;
    },

    /**
     * @name increment
     * @summary Number of scrollbar index units representing a pageful. Used exclusively for paging up and down and for setting thumb size relative to content size.
     * @desc Set by the constructor. See the similarly named property in the {@link finbarOptions} object.
     *
     * Can also be given as a parameter to the {@link FinBar#resize|resize} method, which is pertinent because content area size changes affect the definition of a "pageful." However, you only need to do this if this value is being used. It not used when:
     * * you define `paging.up` and `paging.down`
     * * your scrollbar is using `scrollRealContent`
     * @type {number}
     * @memberOf FinBar.prototype
     */
    increment: 1,

    /**
     * @name barStyles
     * @summary Scrollbar styles to be applied by {@link FinBar#resize|resize()}.
     * @desc Set by the constructor. See the similarly named property in the {@link finbarOptions} object.
     *
     * This is a value to be assigned to {@link FinBar#styles|styles} on each call to {@link FinBar#resize|resize()}. That is, a hash of values to be copied to the scrollbar element's style object on resize; or `null` for none.
     *
     * @see {@link FinBar#style|style}
     * @type {finbarStyles|null}
     * @memberOf FinBar.prototype
     */
    barStyles: null,

    /**
     * @name style
     * @summary Additional scrollbar styles.
     * @desc See type definition for more details. These styles are applied directly to the scrollbar's `bar` element.
     *
     * Values are adjusted as follows before being applied to the element:
     * 1. Included "pseudo-property" names from the scrollbar's orientation hash, {@link FinBar#oh|oh}, are translated to actual property names before being applied.
     * 2. When there are margins, percentages are translated to absolute pixel values because CSS ignores margins in its percentage calculations.
     * 3. If you give a value without a unit (a raw number), "px" unit is appended.
     *
     * General notes:
     * 1. It is always preferable to specify styles via a stylesheet. Only set this property when you need to specifically override (a) stylesheet value(s).
     * 2. Can be set directly or via calls to the {@link FinBar#resize|resize} method.
     * 3. Should only be set after the scrollbar has been inserted into the DOM.
     * 4. Before applying these new values to the element, _all_ in-line style values are reset (by removing the element's `style` attribute), exposing inherited values (from stylesheets).
     * 5. Empty object has no effect.
     * 6. Falsey value in place of object has no effect.
     *
     * > CAVEAT: Do not attempt to treat the object you assign to this property as if it were `this.bar.style`. Specifically, changing this object after assigning it will have no effect on the scrollbar. You must assign it again if you want it to have an effect.
     *
     * @see {@link FinBar#barStyles|barStyles}
     * @type {finbarStyles}
     * @memberOf FinBar.prototype
     */
    set style(styles) {
        var keys = Object.keys(styles = extend({}, styles, this._auxStyles));

        if (keys.length) {
            var bar = this.bar,
                barRect = bar.getBoundingClientRect(),
                container = this.container || bar.parentElement,
                containerRect = container.getBoundingClientRect(),
                oh = this.oh;

            // Before applying new styles, revert all styles to values inherited from stylesheets
            bar.removeAttribute('style');

            keys.forEach(function (key) {
                var val = styles[key];

                if (key in oh) {
                    key = oh[key];
                }

                if (!isNaN(Number(val))) {
                    val = (val || 0) + 'px';
                } else if (/%$/.test(val)) {
                    // When bar size given as percentage of container, if bar has margins, restate size in pixels less margins.
                    // (If left as percentage, CSS's calculation will not exclude margins.)
                    var oriented = axis[key],
                        margins = barRect[oriented.marginLeading] + barRect[oriented.marginTrailing];
                    if (margins) {
                        val = parseInt(val, 10) / 100 * containerRect[oriented.size] - margins + 'px';
                    }
                }

                bar.style[key] = val;
            });
        }
    },

    /**
     * @readonly
     * @name paging
     * @summary Enable page up/dn clicks.
     * @desc Set by the constructor. See the similarly named property in the {@link finbarOptions} object.
     *
     * If truthy, listen for clicks in page-up and page-down regions of scrollbar.
     *
     * If an object, call `.paging.up()` on page-up clicks and `.paging.down()` will be called on page-down clicks.
     *
     * Changing the truthiness of this value after instantiation currently has no effect.
     * @type {boolean|object}
     * @memberOf FinBar.prototype
     */
    paging: true,

    /**
     * @name range
     * @summary Setter for the minimum and maximum scroll values.
     * @desc Set by the constructor. These values are the limits for {@link FooBar#index|index}.
     *
     * The setter accepts an object with exactly two numeric properties: `.min` which must be less than `.max`. The values are extracted and the object is discarded.
     *
     * The getter returns a new object with `.min` and '.max`.
     *
     * @type {rangeType}
     * @memberOf FinBar.prototype
     */
    set range(range) {
        validRange(range);
        this._min = range.min;
        this._max = range.max;
        this.contentSize = range.max - range.min + 1;
        this.index = this.index; // re-clamp
    },
    get range() {
        return {
            min: this._min,
            max: this._max
        };
    },

    /**
     * @summary Index value of the scrollbar.
     * @desc This is the position of the scroll thumb.
     *
     * Setting this value clamps it to {@link FinBar#min|min}..{@link FinBar#max|max}, scroll the content, and moves thumb.
     *
     * Getting this value returns the current index. The returned value will be in the range `min`..`max`. It is intentionally not rounded.
     *
     * Use this value as an alternative to (or in addition to) using the {@link FinBar#onchange|onchange} callback function.
     *
     * @see {@link FinBar#_setScroll|_setScroll}
     * @type {number}
     * @memberOf FinBar.prototype
     */
    set index(idx) {
        idx = Math.min(this._max, Math.max(this._min, idx)); // clamp it
        this._setScroll(idx);
        // this._setThumbSize();
    },
    get index() {
        return this._index;
    },

    /**
     * @private
     * @summary Move the thumb.
     * @desc Also displays the index value in the test panel and invokes the callback.
     * @param idx - The new scroll index, a value in the range `min`..`max`.
     * @param [scaled=f(idx)] - The new thumb position in pixels and scaled relative to the containing {@link FinBar#bar|bar} element, i.e., a proportional number in the range `0`..`thumbMax`. When omitted, a function of `idx` is used.
     * @memberOf FinBar.prototype
     */
    _setScroll: function (idx, scaled) {
        this._index = idx;

        // Display the index value in the test panel
        if (this.testPanelItem && this.testPanelItem.index instanceof Element) {
            this.testPanelItem.index.innerHTML = Math.round(idx);
        }

        // Call the callback
        if (this.onchange) {
            this.onchange.call(this, Math.round(idx));
        }

        // Move the thumb
        if (scaled === undefined) {
            scaled = (idx - this._min) / (this._max - this._min) * this._thumbMax;
        }
        this.thumb.style[this.oh.leading] = scaled + 'px';
    },

    scrollRealContent: function (idx) {
        var containerRect = this.content.parentElement.getBoundingClientRect(),
            sizeProp = this.oh.size,
            maxScroll = Math.max(0, this.content[sizeProp] - containerRect[sizeProp]),
            //scroll = Math.min(idx, maxScroll);
            scroll = (idx - this._min) / (this._max - this._min) * maxScroll;
        //console.log('scroll: ' + scroll);
        this.content.style[this.oh.leading] = -scroll + 'px';
    },

    /**
     * @summary Recalculate thumb position.
     *
     * @desc This method recalculates the thumb size and position. Call it once after inserting your scrollbar into the DOM, and repeatedly while resizing the scrollbar (which typically happens when the scrollbar's parent is resized by user.
     *
     * > This function shifts args if first arg omitted.
     *
     * @param {number} [increment=this.increment] - Resets {@link FooBar#increment|increment} (see).
     *
     * @param {finbarStyles} [barStyles=this.barStyles] - (See type definition for details.) Scrollbar styles to be applied to the bar element.
     *
     * Only specify a `barStyles` object when you need to override stylesheet values. If provided, becomes the new default (`this.barStyles`), for use as a default on subsequent calls.
     *
     * It is generally the case that the scrollbar's new position is sufficiently described by the current styles. Therefore, it is unusual to need to provide a `barStyles` object on every call to `resize`.
     *
     * @returns {FinBar} Self for chaining.
     * @memberOf FinBar.prototype
     */
    resize: function (increment, barStyles) {
        var bar = this.bar;

        if (!bar.parentNode) {
            return; // not in DOM yet so nothing to do
        }

        var container = this.container || bar.parentElement,
            containerRect = container.getBoundingClientRect();

        // shift args if if 1st arg omitted
        if (typeof increment === 'object') {
            barStyles = increment;
            increment = undefined;
        }

        this.style = this.barStyles = barStyles || this.barStyles;

        // Bound to real content: Content was given but no onchange handler.
        // Set up .onchange, .containerSize, and .increment.
        // Note this only makes sense if your index unit is pixels.
        if (this.content) {
            if (!this.onchange) {
                this.onchange = this.scrollRealContent;
                this.contentSize = this.content[this.oh.size];
                this._min = 0;
                this._max = this.contentSize - 1;
            }
        }
        if (this.onchange === this.scrollRealContent) {
            this.containerSize = containerRect[this.oh.size];
            this.increment = this.containerSize / (this.contentSize - this.containerSize) * (this._max - this._min);
        } else {
            this.containerSize = 1;
            this.increment = increment || this.increment;
        }

        var index = this.index;
        this.testPanelItem = this.testPanelItem || this._addTestPanelItem();
        this._setThumbSize();
        this.index = index;

        if (this.deltaProp !== null) {
            container.addEventListener('wheel', this._bound.onwheel);
        }

        return this;
    },

    /**
     * @summary Shorten trailing end of scrollbar by thickness of some other scrollbar.
     * @desc In the "classical" scenario where vertical scroll bar is on the right and horizontal scrollbar is on the bottom, you want to shorten the "trailing end" (bottom and right ends, respectively) of at least one of them so they don't overlay.
     *
     * This convenience function is an programmatic alternative to hardcoding the correct style with the correct value in your stylesheet; or setting the correct style with the correct value in the {@link FinBar#barStyles|barStyles} object.
     *
     * @see {@link FinBar#foreshortenBy|foreshortenBy}.
     *
     * @param {FinBar|null} otherFinBar - Other scrollbar to avoid by shortening this one; `null` removes the trailing space
     * @returns {FinBar} For chaining
     */
    shortenBy: function (otherFinBar) { return this.shortenEndBy('trailing', otherFinBar); },

    /**
     * @summary Shorten leading end of scrollbar by thickness of some other scrollbar.
     * @desc Supports non-classical scrollbar scenarios where vertical scroll bar may be on left and horizontal scrollbar may be on top, in which case you want to shorten the "leading end" rather than the trailing end.
     * @see {@link FinBar#shortenBy|shortenBy}.
     * @param {FinBar|null} otherFinBar - Other scrollbar to avoid by shortening this one; `null` removes the trailing space
     * @returns {FinBar} For chaining
     */
    foreshortenBy: function (otherFinBar) { return this.shortenEndBy('leading', otherFinBar); },

    /**
     * @summary Generalized shortening function.
     * @see {@link FinBar#shortenBy|shortenBy}.
     * @see {@link FinBar#foreshortenBy|foreshortenBy}.
     * @param {string} whichEnd - a CSS style property name or an orientation hash name that translates to a CSS style property name.
     * @param {FinBar|null} otherFinBar - Other scrollbar to avoid by shortening this one; `null` removes the trailing space
     * @returns {FinBar} For chaining
     */
    shortenEndBy: function (whichEnd, otherFinBar) {
        if (!otherFinBar) {
            delete this._auxStyles;
        } else if (otherFinBar instanceof FinBar && otherFinBar.orientation !== this.orientation) {
            var otherStyle = window.getComputedStyle(otherFinBar.bar),
                ooh = orientationHashes[otherFinBar.orientation];
            this._auxStyles = {};
            this._auxStyles[whichEnd] = otherStyle[ooh.thickness];
        }
        return this; // for chaining
    },

    /**
     * @private
     * @summary Sets the proportional thumb size and hides thumb when 100%.
     * @desc The thumb size has an absolute minimum of 20 (pixels).
     * @memberOf FinBar.prototype
     */
    _setThumbSize: function () {
        var oh = this.oh,
            thumbComp = window.getComputedStyle(this.thumb),
            thumbMarginLeading = parseInt(thumbComp[oh.marginLeading]),
            thumbMarginTrailing = parseInt(thumbComp[oh.marginTrailing]),
            thumbMargins = thumbMarginLeading + thumbMarginTrailing,
            barSize = this.bar.getBoundingClientRect()[oh.size],
            thumbSize = Math.max(20, barSize * this.containerSize / this.contentSize);

        if (this.containerSize < this.contentSize) {
            this.bar.style.visibility = 'visible';
            this.thumb.style[oh.size] = thumbSize + 'px';
        } else {
            this.bar.style.visibility = 'hidden';
        }

        /**
         * @private
         * @name _thumbMax
         * @summary Maximum offset of thumb's leading edge.
         * @desc This is the pixel offset within the scrollbar of the thumb when it is at its maximum position at the extreme end of its range.
         *
         * This value takes into account the newly calculated size of the thumb element (including its margins) and the inner size of the scrollbar (the thumb's containing element, including _its_ margins).
         *
         * NOTE: Scrollbar padding is not taken into account and assumed to be 0 in the current implementation and is assumed to be `0`; use thumb margins in place of scrollbar padding.
         * @type {number}
         * @memberOf FinBar.prototype
         */
        this._thumbMax = barSize - thumbSize - thumbMargins;

        this._thumbMarginLeading = thumbMarginLeading; // used in mousedown
    },

    /**
     * @summary Remove the scrollbar.
     * @desc Unhooks all the event handlers and then removes the element from the DOM. Always call this method prior to disposing of the scrollbar object.
     * @memberOf FinBar.prototype
     */
    remove: function () {
        this._removeEvt('mousedown');
        this._removeEvt('mousemove');
        this._removeEvt('mouseup');

        (this.container || this.bar.parentElement)._removeEvt('wheel', this._bound.onwheel);

        this.bar.onclick =
            this.thumb.onclick =
                this.thumb.onmouseover =
                    this.thumb.transitionend =
                        this.thumb.onmouseout = null;

        this.bar.remove();
    },

    /**
     * @private
     * @function _addTestPanelItem
     * @summary Append a test panel element.
     * @desc If there is a test panel in the DOM (typically an `<ol>...</ol>` element) with class names of both `this.classPrefix` and `'test-panel'` (or, barring that, any element with class name `'test-panel'`), an `<li>...</li>` element will be created and appended to it. This new element will contain a span for each class name given.
     *
     * You should define a CSS selector `.listening` for these spans. This class will be added to the spans to alter their appearance when a listener is added with that class name (prefixed with 'on').
     *
     * (This is an internal function that is called once by the constructor on every instantiation.)
     * @returns {Element|undefined} The appended `<li>...</li>` element or `undefined` if there is no test panel.
     * @memberOf FinBar.prototype
     */
    _addTestPanelItem: function () {
        var testPanelItem,
            testPanelElement = document.querySelector('.' + this._classPrefix + '.test-panel') || document.querySelector('.test-panel');

        if (testPanelElement) {
            var testPanelItemPartNames = [ 'mousedown', 'mousemove', 'mouseup', 'index' ],
                item = document.createElement('li');

            testPanelItemPartNames.forEach(function (partName) {
                item.innerHTML += '<span class="' + partName + '">' + partName.replace('mouse', '') + '</span>';
            });

            testPanelElement.appendChild(item);

            testPanelItem = {};
            testPanelItemPartNames.forEach(function (partName) {
                testPanelItem[partName] = item.getElementsByClassName(partName)[0];
            });
        }

        return testPanelItem;
    },

    _addEvt: function (evtName) {
        var spy = this.testPanelItem && this.testPanelItem[evtName];
        if (spy) { spy.classList.add('listening'); }
        window.addEventListener(evtName, this._bound['on' + evtName]);
    },

    _removeEvt: function (evtName) {
        var spy = this.testPanelItem && this.testPanelItem[evtName];
        if (spy) { spy.classList.remove('listening'); }
        window.removeEventListener(evtName, this._bound['on' + evtName]);
    }
};

function extend(obj) {
    for (var i = 1; i < arguments.length; ++i) {
        var objn = arguments[i];
        if (objn) {
            for (var key in objn) {
                obj[key] = objn[key];
            }
        }
    }
    return obj;
}

function validRange(range) {
    var keys = Object.keys(range),
        valid =  keys.length === 2 &&
            typeof range.min === 'number' &&
            typeof range.max === 'number' &&
            range.min <= range.max;

    if (!valid) {
        error('Invalid .range object.');
    }
}

/**
 * @private
 * @name handlersToBeBound
 * @type {object}
 * @desc The functions defined in this object are all DOM event handlers that are bound by the FinBar constructor to each new instance. In other words, the `this` value of these handlers, once bound, refer to the FinBar object and not to the event emitter. "Do not consume raw."
 */
var handlersToBeBound = {
    shortStop: function (evt) {
        evt.stopPropagation();
    },

    onwheel: function (evt) {
        this.index += evt[this.deltaProp];
        evt.stopPropagation();
        evt.preventDefault();
    },

    onclick: function (evt) {
        var thumbBox = this.thumb.getBoundingClientRect(),
            goingUp = evt[this.oh.coordinate] < thumbBox[this.oh.leading];

        if (typeof this.paging === 'object') {
            this.index = this.paging[goingUp ? 'up' : 'down'](Math.round(this.index));
        } else {
            this.index += goingUp ? -this.increment : this.increment;
        }

        // make the thumb glow momentarily
        this.thumb.classList.add('hover');
        var self = this;
        this.thumb.addEventListener('transitionend', function waitForIt() {
            this.removeEventListener('transitionend', waitForIt);
            self._bound.onmouseup(evt);
        });

        evt.stopPropagation();
    },

    onmouseover: function () {
        this.thumb.classList.add('hover');
        this.thumb.onmouseout = this._bound.onmouseout;
        this._addEvt('mousedown');
    },

    onmouseout: function () {
        this._removeEvt('mousedown');
        this.thumb.onmouseover = this._bound.onmouseover;
        this.thumb.classList.remove('hover');
    },

    onmousedown: function (evt) {
        this._removeEvt('mousedown');
        this.thumb.onmouseover = this.thumb.onmouseout = null;

        var thumbBox = this.thumb.getBoundingClientRect();
        this.pinOffset = evt[this.oh.axis] - thumbBox[this.oh.leading] + this.bar.getBoundingClientRect()[this.oh.leading] + this._thumbMarginLeading;
        document.documentElement.style.cursor = 'default';

        this._addEvt('mousemove');
        this._addEvt('mouseup');

        evt.stopPropagation();
        evt.preventDefault();
    },

    onmousemove: function (evt) {
        var scaled = Math.min(this._thumbMax, Math.max(0, evt[this.oh.axis] - this.pinOffset));
        var idx = scaled / this._thumbMax * (this._max - this._min) + this._min;

        this._setScroll(idx, scaled);

        evt.stopPropagation();
        evt.preventDefault();
    },

    onmouseup: function (evt) {
        this._removeEvt('mousemove');
        this._removeEvt('mouseup');

        document.documentElement.style.cursor = 'auto';

        var thumbBox = this.thumb.getBoundingClientRect();
        if (
            thumbBox.left <= evt.clientX && evt.clientX <= thumbBox.right &&
            thumbBox.top <= evt.clientY && evt.clientY <= thumbBox.bottom
        ) {
            this._bound.onmouseover(evt);
        } else {
            this._bound.onmouseout(evt);
        }

        evt.stopPropagation();
        evt.preventDefault();
    }
};

var orientationHashes = {
    vertical: {
        coordinate:     'clientY',
        axis:           'pageY',
        size:           'height',
        outside:        'right',
        inside:         'left',
        leading:        'top',
        trailing:       'bottom',
        marginLeading:  'marginTop',
        marginTrailing: 'marginBottom',
        thickness:      'width',
        delta:          'deltaY'
    },
    horizontal: {
        coordinate:     'clientX',
        axis:           'pageX',
        size:           'width',
        outside:        'bottom',
        inside:         'top',
        leading:        'left',
        trailing:       'right',
        marginLeading:  'marginLeft',
        marginTrailing: 'marginRight',
        thickness:      'height',
        delta:          'deltaX'
    }
};

var axis = {
    top:    'vertical',
    bottom: 'vertical',
    height: 'vertical',
    left:   'horizontal',
    right:  'horizontal',
    width:  'horizontal'
};

var cssFinBars; // definition inserted by gulpfile between following comments
/* inject:css */
cssFinBars = 'div.finbar-horizontal,div.finbar-vertical{position:absolute;margin:3px}div.finbar-horizontal>.thumb,div.finbar-vertical>.thumb{position:absolute;background-color:#d3d3d3;-webkit-box-shadow:0 0 1px #000;-moz-box-shadow:0 0 1px #000;box-shadow:0 0 1px #000;border-radius:4px;margin:2px;opacity:.4;transition:opacity .5s}div.finbar-horizontal>.thumb.hover,div.finbar-vertical>.thumb.hover{opacity:1;transition:opacity .5s}div.finbar-vertical{top:0;bottom:0;right:0;width:11px}div.finbar-vertical>.thumb{top:0;right:0;width:7px}div.finbar-horizontal{left:0;right:0;bottom:0;height:11px}div.finbar-horizontal>.thumb{left:0;bottom:0;height:7px}';
/* endinject */

function error(msg) {
    throw 'finbars: ' + msg;
}

// Interface
module.exports = FinBar;

},{"css-injector":6}],20:[function(require,module,exports){
/* eslint-env browser */

'use strict';

var rectangular = require('rectangular');

var gestures = require('./js/polymergestures.dev.js');
var GraphicsContext = require('./js/GraphicsContext.js');

var RESIZE_POLLING_INTERVAL = 200,
    paintables = [],
    resizables = [],
    paintLoopRunning = true,
    resizeLoopRunning = true,
    charMap = makeCharMap();

function Canvas(div, component, options) {
    var self = this;

    this.div = div;
    this.component = component;

    options = options || {};
    this.doubleClickDelay = options.doubleClickDelay || 325;

    this.dragEndtime = Date.now();

    this.canvas = document.createElement('canvas');
    this.div.appendChild(this.canvas);

    this.canvas.style.outline = 'none';

    // this.focuser = document.createElement('button');
    // this.focuser.style.position = 'absolute';
    // this.focuser.style.top = '0px';
    // this.focuser.style.left = '0px';
    // this.focuser.style.zIndex = '-1';
    // this.focuser.style.outline = 'none';
    // this.div.appendChild(this.focuser);

    this.canvasCTX = this.canvas.getContext('2d');
    this.gc = new GraphicsContext(this.canvasCTX);

    this.buffer = document.createElement('canvas');
    this.bufferCTX = this.buffer.getContext('2d');
    this.bufferGC = new GraphicsContext(this.bufferCTX);

    this.mouseLocation = new rectangular.Point(-1, -1);
    this.dragstart = new rectangular.Point(-1, -1);
    //this.origin = new rectangular.Point(0, 0);
    this.bounds = new rectangular.Rectangle(0, 0, 0, 0);
    this.hasMouse = false;

    document.addEventListener('mousemove', function(e) {
        if (self.hasMouse || self.isDragging()) {
            self.finmousemove(e);
        }
    });
    document.addEventListener('mouseup', function(e) {
        self.finmouseup(e);
    });
    document.addEventListener('wheel', function(e) {
        self.finwheelmoved(e);
    });
    document.addEventListener('keydown', function(e) {
        self.finkeydown(e);
    });
    document.addEventListener('keyup', function(e) {
        self.finkeyup(e);
    });

    this.canvas.onmouseover = function() {
        self.hasMouse = true;
    };
    this.canvas.addEventListener('focus', function(e) {
        self.finfocusgained(e);
    });
    this.canvas.addEventListener('blur', function(e) {
        self.finfocuslost(e);
    });
    this.canvas.addEventListener('mousedown', function(e) {
        self.finmousedown(e);
    });
    this.canvas.addEventListener('mouseout', function(e) {
        self.hasMouse = false;
        self.finmouseout(e);
    });
    this.canvas.addEventListener('click', function(e) {
        self.finclick(e);
    });
    this.canvas.addEventListener('contextmenu', function(e) {
        self.fincontextmenu(e);
        e.preventDefault();
        return false;
    });

    gestures.addEventListener(this.canvas, 'tap', function(e) {
        self.fintap(e);
    });
    gestures.addEventListener(this.canvas, 'holdpulse', function(e) {
        self.finholdpulse(e);
    });
    gestures.addEventListener(this.canvas, 'flick', function(e) {
        self.finflick(e);
    });
    gestures.addEventListener(this.canvas, 'release', function(e) {
        self.finrelease(e);
    });
    gestures.addEventListener(this.canvas, 'trackstart', function(e) {
        self.fintrackstart(e);
    });
    gestures.addEventListener(this.canvas, 'track', function(e) {
        self.fintrack(e);
    });
    gestures.addEventListener(this.canvas, 'trackend', function(e) {
        self.fintrackend(e);
    });

    this.canvas.setAttribute('tabindex', 0);
    this.canvas.contentEditable = true;

    this.resize();

    this.beginResizing();
    this.beginPainting();
}

Canvas.prototype = {
    constructor: Canvas.prototype.constructor,
    div: null,
    component: null,
    gestures: gestures, // TODO: why do we need this? (was previously at bottom of file)
    canvas: null,
    canvasCTX: null,
    focuser: null,
    buffer: null,
    ctx: null,
    mouseLocation: null,
    holdPulseCount: -1,
    dragstart: null,
    origin: null,
    bounds: null,
    dirty: false,
    size: null,
    mousedown: false,
    dragging: false,
    repeatKeyCount: 0,
    repeatKey: null,
    repeatKeyStartTime: 0,
    currentKeys: [],
    hasMouse: false,
    lastDoubleClickTime: 0,
    dragEndTime: 0,
    lastRepaintTime: 0,

    addEventListener: function(name, callback) {
        this.canvas.addEventListener(name, callback);
    },

    stopPaintLoop: function() {
        paintLoopRunning = false;
    },

    restartPaintLoop: function() {
        if (paintLoopRunning) {
            return; // already running
        }
        paintLoopRunning = true;
        requestAnimationFrame(paintLoopFunction);
    },

    stopResizeLoop: function() {
        resizeLoopRunning = false;
    },

    restartResizeLoop: function() {
        if (resizeLoopRunning) {
            return; // already running
        }
        resizeLoopRunning = true;
        setInterval(resizablesLoopFunction, 200);
    },

    detached: function() {
        this.stopPainting();
        this.stopResizing();
    },

    useHiDPI: function() {
        return this.component.resolveProperty('useHiDPI');
    },

    useBitBlit: function() {
        return this.component.resolveProperty('useBitBlit');
    },

    getFPS: function() {
        var fps = this.component.resolveProperty('repaintIntervalRate');
        return fps ? parseInt(fps) : 0;
    },

    tickPaint: function(now) {
        var fps = this.getFPS();
        if (fps === 0) {
            return;
        }
        var interval = 1000 / fps;

        var elapsed = now - this.lastRepaintTime;
        if (elapsed > interval && this.dirty) {
            this.lastRepaintTime = now - (elapsed % interval);
            this.paintNow();
        }
    },

    beginPainting: function() {
        var self = this;
        this.dirty = true;
        this.tickPainter = function(now) {
            self.tickPaint(now);
        };
        paintables.push(this);
    },

    stopPainting: function() {
        paintables.splice(paintables.indexOf(this), 1);
    },

    beginResizing: function() {
        var self = this;
        this.tickResizer = function() {
            self.checksize();
        };
        resizables.push(this);
    },

    stopResizing: function() {
        resizables.splice(resizables.indexOf(this), 1);
    },

    start: function() {
        this.beginPainting();
        this.beginResizing();
    },

    stop: function() {
        this.stopPainting();
        this.stopResizing();
    },

    checksize: function() {
        //this is expensive lets do it at some modulo
        var sizeNow = this.div.getBoundingClientRect();
        if (sizeNow.width !== this.size.width || sizeNow.height !== this.size.height) {
            this.sizeChangedNotification();
        }
    },

    sizeChangedNotification: function() {
        this.resize();
    },

    resize: function() {
        var box = this.size = this.div.getBoundingClientRect();

        this.canvas.width = this.buffer.width = box.width;
        this.canvas.height = this.buffer.height = box.height;

        //fix ala sir spinka, see
        //http://www.html5rocks.com/en/tutorials/canvas/hidpi/
        //just add 'hdpi' as an attribute to the fin-canvas tag
        var ratio = 1;
        var useBitBlit = this.useBitBlit();
        var isHIDPI = window.devicePixelRatio && this.useHiDPI();
        if (isHIDPI) {
            var devicePixelRatio = window.devicePixelRatio || 1;
            var backingStoreRatio = this.canvasCTX.webkitBackingStorePixelRatio ||
                this.canvasCTX.mozBackingStorePixelRatio ||
                this.canvasCTX.msBackingStorePixelRatio ||
                this.canvasCTX.oBackingStorePixelRatio ||
                this.canvasCTX.backingStorePixelRatio || 1;

            ratio = devicePixelRatio / backingStoreRatio;
            //this.canvasCTX.scale(ratio, ratio);
        }
        var width = this.canvas.getAttribute('width');
        var height = this.canvas.getAttribute('height');
        this.canvas.width = this.buffer.width = width * ratio;
        this.canvas.height = this.buffer.height = height * ratio;

        this.canvas.style.width = this.buffer.style.width = width + 'px';
        this.canvas.style.height = this.buffer.style.height = height + 'px';

        this.bufferCTX.scale(ratio, ratio);
        if (isHIDPI && !useBitBlit) {
            this.canvasCTX.scale(ratio, ratio);
        }

        //this.origin = new rectangular.Point(Math.round(this.size.left), Math.round(this.size.top));
        this.bounds = new rectangular.Rectangle(0, 0, box.width, box.height);
        //setTimeout(function() {
        var comp = this.component;
        if (comp) {
            comp.setBounds(this.bounds);
        }
        this.resizeNotification();
        this.paintNow();
        //});
    },

    resizeNotification: function() {
        //to be overridden
    },

    getBounds: function() {
        return this.bounds;
    },

    paintNow: function() {
        var self = this;
        this.safePaintImmediately(function(gc) {
            gc.clearRect(0, 0, self.canvas.width, self.canvas.height);

            var comp = self.component;
            if (comp) {
                comp.paint(gc);
            }

            self.dirty = false;
        });
    },

    safePaintImmediately: function(paintFunction) {
        var useBitBlit = this.useBitBlit(),
            gc = useBitBlit ? this.bufferGC : this.gc;
        try {
            gc.save();
            paintFunction(gc);
        } catch (e) {
            console.error(e);
        } finally {
            gc.restore();
        }
        if (useBitBlit) {
            this.flushBuffer();
        }
    },

    flushBuffer: function() {
        if (this.buffer.width > 0 && this.buffer.height > 0) {
            this.canvasCTX.drawImage(this.buffer, 0, 0);
        }
    },

    dispatchNewEvent: function(event, name, detail) {
        detail = {
            detail: detail || {}
        };
        detail.detail.primitiveEvent = event;
        return this.canvas.dispatchEvent(new CustomEvent(name, detail));
    },

    dispatchNewMouseKeysEvent: function(event, name, detail) {
        detail = detail || {};
        detail.mouse = this.mouseLocation;
        detail.keys = this.currentKeys;
        return this.dispatchNewEvent(event, name, detail);
    },

    finmousemove: function(e) {
        if (!this.isDragging() && this.mousedown) {
            this.beDragging();
            this.dispatchNewMouseKeysEvent(e, 'fin-canvas-dragstart', {
                isRightClick: this.isRightClick(e)
            });
            this.dragstart = new rectangular.Point(this.mouseLocation.x, this.mouseLocation.y);
        }
        this.mouseLocation = this.getLocal(e);
        //console.log(this.mouseLocation);
        if (this.isDragging()) {
            this.dispatchNewMouseKeysEvent(e, 'fin-canvas-drag', {
                dragstart: this.dragstart,
                isRightClick: this.isRightClick(e)
            });
        }
        if (this.bounds.contains(this.mouseLocation)) {
            this.dispatchNewMouseKeysEvent(e, 'fin-canvas-mousemove');
        }
    },

    finmousedown: function(e) {
        this.mouseLocation = this.mouseDownLocation = this.getLocal(e);
        this.mousedown = true;

        this.dispatchNewMouseKeysEvent(e, 'fin-canvas-mousedown', {
            isRightClick: this.isRightClick(e)
        });
        this.takeFocus();
    },

    finmouseup: function(e) {
        if (this.isDragging()) {
            this.dispatchNewMouseKeysEvent(e, 'fin-canvas-dragend', {
                dragstart: this.dragstart,
                isRightClick: this.isRightClick(e)
            });
            this.beNotDragging();
            this.dragEndtime = Date.now();
        }
        this.mousedown = false;
        this.dispatchNewMouseKeysEvent(e, 'fin-canvas-mouseup', {
            isRightClick: this.isRightClick(e)
        });
        //this.mouseLocation = new rectangular.Point(-1, -1);
    },

    finmouseout: function(e) {
        if (!this.mousedown) {
            this.mouseLocation = new rectangular.Point(-1, -1);
        }
        this.dispatchNewMouseKeysEvent(e, 'fin-canvas-mouseout');
    },

    finwheelmoved: function(e) {
        if (this.isDragging() || !this.hasFocus()) {
            return;
        }
        e.preventDefault();
        this.dispatchNewMouseKeysEvent(e, 'fin-canvas-wheelmoved', {
            isRightClick: this.isRightClick(e)
        });
    },

    finclick: function(e) {
        if (this.doubleClickTimer && Date.now() - this.lastClickTime < this.doubleClickDelay) {
            //this is a double click...
            clearTimeout(this.doubleClickTimer); // prevent click event
            this.doubleClickTimer = undefined;
            this.findblclick(e);
        } else {
            this.lastClickTime = Date.now();

            this.doubleClickTimer = setTimeout(function() {
                this.doubleClickTimer = undefined;
                this.mouseLocation = this.getLocal(e);
                this.dispatchNewMouseKeysEvent(e, 'fin-canvas-click', {
                    isRightClick: this.isRightClick(e)
                });
            }.bind(this), this.doubleClickDelay);
        }
    },

    finrelease: function(e) {
        this.holdPulseCount = 0;
        this.mouseLocation = this.getLocal(e);
        this.dispatchNewMouseKeysEvent(e, 'fin-canvas-release');
    },

    finflick: function(e) {
        if (!this.hasFocus()) {
            return;
        }
        this.mouseLocation = this.getLocal(e);
        this.dispatchNewMouseKeysEvent(e, 'fin-canvas-flick', {
            isRightClick: this.isRightClick(e)
        });
    },

    fintrackstart: function(e) {
        if (!this.hasFocus()) {
            return;
        }
        this.mouseLocation = this.getLocal(e);
        this.dispatchNewMouseKeysEvent(e, 'fin-canvas-trackstart');
    },

    fintrack: function(e) {
        if (!this.hasFocus()) {
            return;
        }
        this.mouseLocation = this.getLocal(e);
        this.dispatchNewMouseKeysEvent(e, 'fin-canvas-track');
    },

    fintrackend: function(e) {
        this.mouseLocation = this.getLocal(e);
        this.dispatchNewMouseKeysEvent(e, 'fin-canvas-trackend');
    },

    finhold: function(e) {
        this.mouseLocation = this.getLocal(e);
        this.dispatchNewMouseKeysEvent(e, 'fin-canvas-hold', {
            isRightClick: this.isRightClick(e)
        });
    },

    finholdpulse: function(e) {
        this.mouseLocation = this.getLocal(e);
        this.dispatchNewMouseKeysEvent(e, 'fin-canvas-holdpulse', {
            count: this.holdPulseCount++
        });
    },

    fintap: function(e) {
        //this nonsense is to hold a tap if it's really a double click
        var self = this;
        var now = Date.now();
        var dif = now - this.lastDoubleClickTime;
        if (dif < 300) {
            return;
        }
        //dragend is also causing a tap
        //lets fix this here
        if (now - this.dragEndtime < 100) {
            return;
        }
        setTimeout(function() {
            self._fintap(e);
        }, 180);
    },

    _fintap: function(e) {
        //this nonsense is to hold a tap if it's really a double click
        var now = Date.now();
        var dif = now - this.lastDoubleClickTime;
        if (dif < 300) {
            return;
        }

        if (this.mouseDownLocation) { // maybe no mousedown on a phone?
            this.mouseLocation = this.mouseDownLocation; // mouse may have moved since mousedown
            this.mouseDownLocation = undefined; // consume it (maybe not needed; once a mousedown always a mousedown)
        }

        this.dispatchNewMouseKeysEvent(e, 'fin-canvas-tap', {
            isRightClick: this.isRightClick(e)
        });
    },

    findblclick: function(e) {
        this.mouseLocation = this.getLocal(e);
        this.lastDoubleClickTime = Date.now();
        this.dispatchNewMouseKeysEvent(e, 'fin-canvas-dblclick', {
            isRightClick: this.isRightClick(e)
        });
        //console.log('dblclick', this.currentKeys);
    },

    getCharMap: function() { //TODO: This is static. Make it a property of the constructor.
        return charMap;
    },

    finkeydown: function(e) {
        if (!this.hasFocus()) {
            return;
        }

        //e.preventDefault();
        var keyChar = e.shiftKey ? charMap[e.keyCode][1] : charMap[e.keyCode][0];
        if (e.repeat) {
            if (this.repeatKey === keyChar) {
                this.repeatKeyCount++;
            } else {
                this.repeatKey = keyChar;
                this.repeatKeyStartTime = Date.now();
            }
        } else {
            this.repeatKey = null;
            this.repeatKeyCount = 0;
            this.repeatKeyStartTime = 0;
        }
        if (this.currentKeys.indexOf(keyChar) === -1) {
            this.currentKeys.push(keyChar);
        }
        //console.log(keyChar, e.keyCode);
        this.dispatchNewEvent(e, 'fin-canvas-keydown', {
            alt: e.altKey,
            ctrl: e.ctrlKey,
            char: keyChar,
            code: e.charCode,
            key: e.keyCode,
            meta: e.metaKey,
            repeatCount: this.repeatKeyCount,
            repeatStartTime: this.repeatKeyStartTime,
            shift: e.shiftKey,
            identifier: e.keyIdentifier,
            currentKeys: this.currentKeys.slice(0)
        });
    },

    finkeyup: function(e) {
        var keyChar = e.shiftKey ? charMap[e.keyCode][1] : charMap[e.keyCode][0];
        this.currentKeys.splice(this.currentKeys.indexOf(keyChar), 1);
        if (!this.hasFocus()) {
            return;
        }
        this.repeatKeyCount = 0;
        this.repeatKey = null;
        this.repeatKeyStartTime = 0;
        this.dispatchNewEvent(e, 'fin-canvas-keyup', {
            alt: e.altKey,
            ctrl: e.ctrlKey,
            char: keyChar,
            code: e.charCode,
            key: e.keyCode,
            meta: e.metaKey,
            repeat: e.repeat,
            shift: e.shiftKey,
            identifier: e.keyIdentifier,
            currentKeys: this.currentKeys.slice(0)
        });
    },

    finfocusgained: function(e) {
        this.dispatchNewEvent(e, 'fin-canvas-focus-gained');
    },

    finfocuslost: function(e) {
        this.dispatchNewEvent(e, 'fin-canvas-focus-lost');
    },

    fincontextmenu: function(e) {
        if (e.ctrlKey && this.currentKeys.indexOf('CTRL') === -1) {
            this.currentKeys.push('CTRL');
        }
        if (this.doubleRightClickTimer && Date.now() - this.lastClickTime < this.doubleClickDelay) {
            //this is a double click...
            clearTimeout(this.doubleRightClickTimer); // prevent context menu event
            this.doubleRightClickTimer = undefined;
            this.findblclick(e);
        } else {
            this.lastClickTime = Date.now();

            this.doubleRightClickTimer = setTimeout(function() {
                this.doubleRightClickTimer = undefined;
                this.dispatchNewMouseKeysEvent(e, 'fin-canvas-context-menu', {
                    isRightClick: this.isRightClick(e)
                });
            }.bind(this), this.doubleClickDelay);
        }
    },

    repaint: function() {
        var fps = this.getFPS();
        this.dirty = true;
        if (!paintLoopRunning || fps === 0) {
            this.paintNow();
        }
    },

    getMouseLocation: function() {
        return this.mouseLocation;
    },

    getOrigin: function() {
        var rect = this.canvas.getBoundingClientRect();
        var p = new rectangular.Point(rect.left, rect.top);
        return p;
    },

    getLocal: function(e) {
        var rect = this.canvas.getBoundingClientRect();
        var p = new rectangular.Point(e.clientX - rect.left, e.clientY - rect.top);
        return p;
    },

    hasFocus: function() {
        return document.activeElement === this.canvas;
    },

    takeFocus: function() {
        var self = this;
        if (!this.hasFocus()) {
            setTimeout(function() {
                self.canvas.focus();
            }, 10);
        }
    },

    beDragging: function() {
        this.dragging = true;
        this.disableDocumentElementSelection();
    },

    beNotDragging: function() {
        this.dragging = false;
        this.enableDocumentElementSelection();
    },

    isDragging: function() {
        return this.dragging;
    },

    disableDocumentElementSelection: function() {
        var style = document.body.style;
        style.cssText = style.cssText + '-webkit-user-select: none';
    },

    enableDocumentElementSelection: function() {
        var style = document.body.style;
        style.cssText = style.cssText.replace('-webkit-user-select: none', '');
    },

    setFocusable: function(truthy) {
        this.focuser.style.display = truthy ? '' : 'none';
    },

    isRightClick: function(e) {
        var isRightMB;
        e = e || window.event;

        if ('which' in e) { // Gecko (Firefox), WebKit (Safari/Chrome) & Opera
            isRightMB = e.which === 3;
        } else if ('button' in e) { // IE, Opera
            isRightMB = e.button === 2;
        }
        return isRightMB;
    },

    dispatchEvent: function(e) {
        return this.canvas.dispatchEvent(e);
    }
};

function paintLoopFunction(now) {
    if (!paintLoopRunning) {
        return;
    }
    for (var i = 0; i < paintables.length; i++) {
        try {
            paintables[i].tickPainter(now);
        } catch (e) {
            console.error(e);
        }
    }
    requestAnimationFrame(paintLoopFunction);
}
requestAnimationFrame(paintLoopFunction);

function resizablesLoopFunction(now) {
    if (!resizeLoopRunning) {
        return;
    }
    for (var i = 0; i < resizables.length; i++) {
        try {
            resizables[i].tickResizer(now);
        } catch (e) {
            console.error(e);
        }
    }
}
setInterval(resizablesLoopFunction, RESIZE_POLLING_INTERVAL);

function makeCharMap() {
    var map = [];

    var empty = ['', ''];

    for (var i = 0; i < 256; i++) {
        map[i] = empty;
    }

    map[27] = ['ESC', 'ESCSHIFT'];
    map[192] = ['`', '~'];
    map[49] = ['1', '!'];
    map[50] = ['2', '@'];
    map[51] = ['3', '#'];
    map[52] = ['4', '$'];
    map[53] = ['5', '%'];
    map[54] = ['6', '^'];
    map[55] = ['7', '&'];
    map[56] = ['8', '*'];
    map[57] = ['9', '('];
    map[48] = ['0', ')'];
    map[189] = ['-', '_'];
    map[187] = ['=', '+'];
    map[8] = ['BACKSPACE', 'BACKSPACESHIFT'];
    map[46] = ['DELETE', 'DELETESHIFT'];
    map[9] = ['TAB', 'TABSHIFT'];
    map[81] = ['q', 'Q'];
    map[87] = ['w', 'W'];
    map[69] = ['e', 'E'];
    map[82] = ['r', 'R'];
    map[84] = ['t', 'T'];
    map[89] = ['y', 'Y'];
    map[85] = ['u', 'U'];
    map[73] = ['i', 'I'];
    map[79] = ['o', 'O'];
    map[80] = ['p', 'P'];
    map[219] = ['[', '{'];
    map[221] = [']', '}'];
    map[220] = ['\\', '|'];
    map[220] = ['CAPSLOCK', 'CAPSLOCKSHIFT'];
    map[65] = ['a', 'A'];
    map[83] = ['s', 'S'];
    map[68] = ['d', 'D'];
    map[70] = ['f', 'F'];
    map[71] = ['g', 'G'];
    map[72] = ['h', 'H'];
    map[74] = ['j', 'J'];
    map[75] = ['k', 'K'];
    map[76] = ['l', 'L'];
    map[186] = [';', ':'];
    map[222] = ['\'', '|'];
    map[13] = ['RETURN', 'RETURNSHIFT'];
    map[16] = ['SHIFT', 'SHIFT'];
    map[90] = ['z', 'Z'];
    map[88] = ['x', 'X'];
    map[67] = ['c', 'C'];
    map[86] = ['v', 'V'];
    map[66] = ['b', 'B'];
    map[78] = ['n', 'N'];
    map[77] = ['m', 'M'];
    map[188] = [',', '<'];
    map[190] = ['.', '>'];
    map[191] = ['/', '?'];
    map[16] = ['SHIFT', 'SHIFT'];
    map[17] = ['CTRL', 'CTRLSHIFT'];
    map[18] = ['ALT', 'ALTSHIFT'];
    map[91] = ['COMMANDLEFT', 'COMMANDLEFTSHIFT'];
    map[32] = ['SPACE', 'SPACESHIFT'];
    map[93] = ['COMMANDRIGHT', 'COMMANDRIGHTSHIFT'];
    map[18] = ['ALT', 'ALTSHIFT'];
    map[38] = ['UP', 'UPSHIFT'];
    map[37] = ['LEFT', 'LEFTSHIFT'];
    map[40] = ['DOWN', 'DOWNSHIFT'];
    map[39] = ['RIGHT', 'RIGHTSHIFT'];

    map[33] = ['PAGEUP', 'PAGEUPSHIFT'];
    map[34] = ['PAGEDOWN', 'PAGEDOWNSHIFT'];
    map[35] = ['PAGERIGHT', 'PAGERIGHTSHIFT']; // END
    map[36] = ['PAGELEFT', 'PAGELEFTSHIFT']; // HOME

    map[112] = ['F1', 'F1SHIFT'];
    map[113] = ['F2', 'F2SHIFT'];
    map[114] = ['F3', 'F3SHIFT'];
    map[115] = ['F4', 'F4SHIFT'];
    map[116] = ['F5', 'F5SHIFT'];
    map[117] = ['F6', 'F6SHIFT'];
    map[118] = ['F7', 'F7SHIFT'];
    map[119] = ['F8', 'F8SHIFT'];
    map[120] = ['F9', 'F9SHIFT'];
    map[121] = ['F10', 'F10SHIFT'];
    map[122] = ['F11', 'F1S1HIFT'];
    map[123] = ['F12', 'F121HIFT'];

    return map;
}

module.exports = Canvas;

},{"./js/GraphicsContext.js":21,"./js/polymergestures.dev.js":23,"rectangular":48}],21:[function(require,module,exports){
'use strict';

var consoleLogger = require('./gc-console-logger');

/**
 * @constructor
 * @param gc - The 2-D graphics context from your canvas
 * @param {boolean|apiLogger} [logger=true]
 * * `true` uses `gc-console-logger` function bound to 'gc.' as prefix
 * * string uses `gc-console-logger` function bound to string
 * * function used as is
 */
function GraphicsContext(gc, logger) {
    this.gc = gc;

    var self = this;
    var reWEBKIT = /^webkit/;

    switch (typeof logger) {

        case 'string':
            logger =  consoleLogger.bind(undefined, logger + '.');
            break;

        case 'boolean':
            if (logger === true) {
                logger = consoleLogger.bind(undefined, 'gc.');
            }
            break;

        case 'function':
            if (logger.length !== 3) {
                throw 'GraphicsContext: User-supplied API logger function does not accept three parameters.';
            }
            break;

        default:
            logger = false;
    }

    // Stub out all the prototype members of the canvas 2D graphics context:
    Object.keys(Object.getPrototypeOf(gc)).forEach(MakeStub);

    // Some older browsers (e.g., Chrome 40) did not have all members of canvas
    // 2D graphics context in the prototype so we make this additional call:
    Object.keys(gc).forEach(MakeStub);

    function MakeStub(key) {
        if (key in GraphicsContext.prototype || reWEBKIT.test(key)) {
            return;
        }
        if (typeof gc[key] === 'function') {
            self[key] = !logger ? gc[key].bind(gc) : function() {
                return logger(key, arguments, gc[key].apply(gc, arguments));
            };
        } else {
            Object.defineProperty(self, key, {
                get: function() {
                    var result = gc[key];
                    return logger ? logger(key, 'getter', result) : result;
                },
                set: function(value) {
                    gc[key] = logger ? logger(key, 'setter', value) : value;
                }
            });
        }
    }
}

module.exports = GraphicsContext;

},{"./gc-console-logger":22}],22:[function(require,module,exports){
'use strict';

var YIELDS = '\u27F9'; // LONG RIGHTWARDS DOUBLE ARROW

function consoleLogger(prefix, name, args, value) {
    var result = value;

    if (typeof value === 'string') {
        result = '"' + result + '"';
    }

    name = prefix + name;

    switch (args) {
        case 'getter':
            console.log(name, '=', result);
            break;

        case 'setter':
            console.log(name, YIELDS, result);
            break;

        default: // method call
            name += '(' + Array.prototype.slice.call(args).join(', ') + ')';
            if (result === undefined) {
                console.log(name);
            } else {
                console.log(name, YIELDS, result);
            }
    }

    return value;
}

module.exports = consoleLogger;

},{}],23:[function(require,module,exports){
/* eslint-disable */

/**
 * @license
 * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */
//module.exports = {};

(function(scope) {
    var hasFullPath = false;

    // test for full event path support
    var pathTest = document.createElement('meta');
    if (pathTest.createShadowRoot) {
        var sr = pathTest.createShadowRoot();
        var s = document.createElement('span');
        sr.appendChild(s);
        pathTest.addEventListener('testpath', function(ev) {
            if (ev.path) {
                // if the span is in the event path, then path[0] is the real source for all events
                hasFullPath = ev.path[0] === s;
            }
            ev.stopPropagation();
        });
        var ev = new CustomEvent('testpath', {
            bubbles: true
        });
        // must add node to DOM to trigger event listener
        document.head.appendChild(pathTest);
        s.dispatchEvent(ev);
        pathTest.parentNode.removeChild(pathTest);
        sr = s = null;
    }
    pathTest = null;

    var target = {
        shadow: function(inEl) {
            if (inEl) {
                return inEl.shadowRoot || inEl.webkitShadowRoot;
            }
        },
        canTarget: function(shadow) {
            return shadow && Boolean(shadow.elementFromPoint);
        },
        targetingShadow: function(inEl) {
            var s = this.shadow(inEl);
            if (this.canTarget(s)) {
                return s;
            }
        },
        olderShadow: function(shadow) {
            var os = shadow.olderShadowRoot;
            if (!os) {
                var se = shadow.querySelector('shadow');
                if (se) {
                    os = se.olderShadowRoot;
                }
            }
            return os;
        },
        allShadows: function(element) {
            var shadows = [],
                s = this.shadow(element);
            while (s) {
                shadows.push(s);
                s = this.olderShadow(s);
            }
            return shadows;
        },
        searchRoot: function(inRoot, x, y) {
            var t, st, sr, os;
            if (inRoot) {
                t = inRoot.elementFromPoint(x, y);
                if (t) {
                    // found element, check if it has a ShadowRoot
                    sr = this.targetingShadow(t);
                } else if (inRoot !== document) {
                    // check for sibling roots
                    sr = this.olderShadow(inRoot);
                }
                // search other roots, fall back to light dom element
                return this.searchRoot(sr, x, y) || t;
            }
        },
        owner: function(element) {
            if (!element) {
                return document;
            }
            var s = element;
            // walk up until you hit the shadow root or document
            while (s.parentNode) {
                s = s.parentNode;
            }
            // the owner element is expected to be a Document or ShadowRoot
            if (s.nodeType != Node.DOCUMENT_NODE && s.nodeType != Node.DOCUMENT_FRAGMENT_NODE) {
                s = document;
            }
            return s;
        },
        findTarget: function(inEvent) {
            if (hasFullPath && inEvent.path && inEvent.path.length) {
                return inEvent.path[0];
            }
            var x = inEvent.clientX,
                y = inEvent.clientY;
            // if the listener is in the shadow root, it is much faster to start there
            var s = this.owner(inEvent.target);
            // if x, y is not in this root, fall back to document search
            if (!s.elementFromPoint(x, y)) {
                s = document;
            }
            return this.searchRoot(s, x, y);
        },
        findTouchAction: function(inEvent) {
            var n;
            if (hasFullPath && inEvent.path && inEvent.path.length) {
                var path = inEvent.path;
                for (var i = 0; i < path.length; i++) {
                    n = path[i];
                    if (n.nodeType === Node.ELEMENT_NODE && n.hasAttribute('touch-action')) {
                        return n.getAttribute('touch-action');
                    }
                }
            } else {
                n = inEvent.target;
                while (n) {
                    if (n.nodeType === Node.ELEMENT_NODE && n.hasAttribute('touch-action')) {
                        return n.getAttribute('touch-action');
                    }
                    n = n.parentNode || n.host;
                }
            }
            // auto is default
            return "auto";
        },
        LCA: function(a, b) {
            if (a === b) {
                return a;
            }
            if (a && !b) {
                return a;
            }
            if (b && !a) {
                return b;
            }
            if (!b && !a) {
                return document;
            }
            // fast case, a is a direct descendant of b or vice versa
            if (a.contains && a.contains(b)) {
                return a;
            }
            if (b.contains && b.contains(a)) {
                return b;
            }
            var adepth = this.depth(a);
            var bdepth = this.depth(b);
            var d = adepth - bdepth;
            if (d >= 0) {
                a = this.walk(a, d);
            } else {
                b = this.walk(b, -d);
            }
            while (a && b && a !== b) {
                a = a.parentNode || a.host;
                b = b.parentNode || b.host;
            }
            return a;
        },
        walk: function(n, u) {
            for (var i = 0; n && (i < u); i++) {
                n = n.parentNode || n.host;
            }
            return n;
        },
        depth: function(n) {
            var d = 0;
            while (n) {
                d++;
                n = n.parentNode || n.host;
            }
            return d;
        },
        deepContains: function(a, b) {
            var common = this.LCA(a, b);
            // if a is the common ancestor, it must "deeply" contain b
            return common === a;
        },
        insideNode: function(node, x, y) {
            var rect = node.getBoundingClientRect();
            return (rect.left <= x) && (x <= rect.right) && (rect.top <= y) && (y <= rect.bottom);
        },
        path: function(event) {
            var p;
            if (hasFullPath && event.path && event.path.length) {
                p = event.path;
            } else {
                p = [];
                var n = this.findTarget(event);
                while (n) {
                    p.push(n);
                    n = n.parentNode || n.host;
                }
            }
            return p;
        }
    };
    scope.targetFinding = target;
    /**
     * Given an event, finds the "deepest" node that could have been the original target before ShadowDOM retargetting
     *
     * @param {Event} Event An event object with clientX and clientY properties
     * @return {Element} The probable event origninator
     */
    scope.findTarget = target.findTarget.bind(target);
    /**
     * Determines if the "container" node deeply contains the "containee" node, including situations where the "containee" is contained by one or more ShadowDOM
     * roots.
     *
     * @param {Node} container
     * @param {Node} containee
     * @return {Boolean}
     */
    scope.deepContains = target.deepContains.bind(target);

    /**
     * Determines if the x/y position is inside the given node.
     *
     * Example:
     *
     *     function upHandler(event) {
     *       var innode = PolymerGestures.insideNode(event.target, event.clientX, event.clientY);
     *       if (innode) {
     *         // wait for tap?
     *       } else {
     *         // tap will never happen
     *       }
     *     }
     *
     * @param {Node} node
     * @param {Number} x Screen X position
     * @param {Number} y screen Y position
     * @return {Boolean}
     */
    scope.insideNode = target.insideNode;

})(exports);

(function() {
    function shadowSelector(v) {
        return 'html /deep/ ' + selector(v);
    }

    function selector(v) {
        return '[touch-action="' + v + '"]';
    }

    function rule(v) {
        return '{ -ms-touch-action: ' + v + '; touch-action: ' + v + ';}';
    }
    var attrib2css = [
        'none',
        'auto',
        'pan-x',
        'pan-y', {
            rule: 'pan-x pan-y',
            selectors: [
                'pan-x pan-y',
                'pan-y pan-x'
            ]
        },
        'manipulation'
    ];
    var styles = '';
    // only install stylesheet if the browser has touch action support
    var hasTouchAction = typeof document.head.style.touchAction === 'string';
    // only add shadow selectors if shadowdom is supported
    var hasShadowRoot = !window.ShadowDOMPolyfill && document.head.createShadowRoot;

    if (hasTouchAction) {
        attrib2css.forEach(function(r) {
            if (String(r) === r) {
                styles += selector(r) + rule(r) + '\n';
                if (hasShadowRoot) {
                    styles += shadowSelector(r) + rule(r) + '\n';
                }
            } else {
                styles += r.selectors.map(selector) + rule(r.rule) + '\n';
                if (hasShadowRoot) {
                    styles += r.selectors.map(shadowSelector) + rule(r.rule) + '\n';
                }
            }
        });

        var el = document.createElement('style');
        el.textContent = styles;
        document.head.appendChild(el);
    }
})();

/**
 * This is the constructor for new PointerEvents.
 *
 * New Pointer Events must be given a type, and an optional dictionary of
 * initialization properties.
 *
 * Due to certain platform requirements, events returned from the constructor
 * identify as MouseEvents.
 *
 * @constructor
 * @param {String} inType The type of the event to create.
 * @param {Object} [inDict] An optional dictionary of initial event properties.
 * @return {Event} A new PointerEvent of type `inType` and initialized with properties from `inDict`.
 */
(function(scope) {

    var MOUSE_PROPS = [
        'bubbles',
        'cancelable',
        'view',
        'detail',
        'screenX',
        'screenY',
        'clientX',
        'clientY',
        'ctrlKey',
        'altKey',
        'shiftKey',
        'metaKey',
        'button',
        'relatedTarget',
        'pageX',
        'pageY'
    ];

    var MOUSE_DEFAULTS = [
        false,
        false,
        null,
        null,
        0,
        0,
        0,
        0,
        false,
        false,
        false,
        false,
        0,
        null,
        0,
        0
    ];

    var NOP_FACTORY = function() {
        return function() {};
    };

    var eventFactory = {
        // TODO(dfreedm): this is overridden by tap recognizer, needs review
        preventTap: NOP_FACTORY,
        makeBaseEvent: function(inType, inDict) {
            var e = document.createEvent('Event');
            e.initEvent(inType, inDict.bubbles || false, inDict.cancelable || false);
            e.preventTap = eventFactory.preventTap(e);
            return e;
        },
        makeGestureEvent: function(inType, inDict) {
            inDict = inDict || Object.create(null);

            var e = this.makeBaseEvent(inType, inDict);
            for (var i = 0, keys = Object.keys(inDict), k; i < keys.length; i++) {
                k = keys[i];
                if (k !== 'bubbles' && k !== 'cancelable') {
                    e[k] = inDict[k];
                }
            }
            return e;
        },
        makePointerEvent: function(inType, inDict) {
            inDict = inDict || Object.create(null);

            var e = this.makeBaseEvent(inType, inDict);
            // define inherited MouseEvent properties
            for (var i = 2, p; i < MOUSE_PROPS.length; i++) {
                p = MOUSE_PROPS[i];
                e[p] = inDict[p] || MOUSE_DEFAULTS[i];
            }
            e.buttons = inDict.buttons || 0;

            // Spec requires that pointers without pressure specified use 0.5 for down
            // state and 0 for up state.
            var pressure = 0;
            if (inDict.pressure) {
                pressure = inDict.pressure;
            } else {
                pressure = e.buttons ? 0.5 : 0;
            }

            // add x/y properties aliased to clientX/Y
            e.x = e.clientX;
            e.y = e.clientY;

            // define the properties of the PointerEvent interface
            e.pointerId = inDict.pointerId || 0;
            e.width = inDict.width || 0;
            e.height = inDict.height || 0;
            e.pressure = pressure;
            e.tiltX = inDict.tiltX || 0;
            e.tiltY = inDict.tiltY || 0;
            e.pointerType = inDict.pointerType || '';
            e.hwTimestamp = inDict.hwTimestamp || 0;
            e.isPrimary = inDict.isPrimary || false;
            e._source = inDict._source || '';
            return e;
        }
    };

    scope.eventFactory = eventFactory;
})(exports);

/**
 * This module implements an map of pointer states
 */
(function(scope) {
    var USE_MAP = window.Map && window.Map.prototype.forEach;
    var POINTERS_FN = function() {
        return this.size;
    };

    function PointerMap() {
        if (USE_MAP) {
            var m = new Map();
            m.pointers = POINTERS_FN;
            return m;
        } else {
            this.keys = [];
            this.values = [];
        }
    }

    PointerMap.prototype = {
        set: function(inId, inEvent) {
            var i = this.keys.indexOf(inId);
            if (i > -1) {
                this.values[i] = inEvent;
            } else {
                this.keys.push(inId);
                this.values.push(inEvent);
            }
        },
        has: function(inId) {
            return this.keys.indexOf(inId) > -1;
        },
        'delete': function(inId) {
            var i = this.keys.indexOf(inId);
            if (i > -1) {
                this.keys.splice(i, 1);
                this.values.splice(i, 1);
            }
        },
        get: function(inId) {
            var i = this.keys.indexOf(inId);
            return this.values[i];
        },
        clear: function() {
            this.keys.length = 0;
            this.values.length = 0;
        },
        // return value, key, map
        forEach: function(callback, thisArg) {
            this.values.forEach(function(v, i) {
                callback.call(thisArg, v, this.keys[i], this);
            }, this);
        },
        pointers: function() {
            return this.keys.length;
        }
    };

    scope.PointerMap = PointerMap;
})(exports);

(function(scope) {
    var CLONE_PROPS = [
        // MouseEvent
        'bubbles',
        'cancelable',
        'view',
        'detail',
        'screenX',
        'screenY',
        'clientX',
        'clientY',
        'ctrlKey',
        'altKey',
        'shiftKey',
        'metaKey',
        'button',
        'relatedTarget',
        // DOM Level 3
        'buttons',
        // PointerEvent
        'pointerId',
        'width',
        'height',
        'pressure',
        'tiltX',
        'tiltY',
        'pointerType',
        'hwTimestamp',
        'isPrimary',
        // event instance
        'type',
        'target',
        'currentTarget',
        'which',
        'pageX',
        'pageY',
        'timeStamp',
        // gesture addons
        'preventTap',
        'tapPrevented',
        '_source'
    ];

    var CLONE_DEFAULTS = [
        // MouseEvent
        false,
        false,
        null,
        null,
        0,
        0,
        0,
        0,
        false,
        false,
        false,
        false,
        0,
        null,
        // DOM Level 3
        0,
        // PointerEvent
        0,
        0,
        0,
        0,
        0,
        0,
        '',
        0,
        false,
        // event instance
        '',
        null,
        null,
        0,
        0,
        0,
        0,
        function() {},
        false
    ];

    var HAS_SVG_INSTANCE = (typeof SVGElementInstance !== 'undefined');

    var eventFactory = scope.eventFactory;

    // set of recognizers to run for the currently handled event
    var currentGestures;

    /**
     * This module is for normalizing events. Mouse and Touch events will be
     * collected here, and fire PointerEvents that have the same semantics, no
     * matter the source.
     * Events fired:
     *   - pointerdown: a pointing is added
     *   - pointerup: a pointer is removed
     *   - pointermove: a pointer is moved
     *   - pointerover: a pointer crosses into an element
     *   - pointerout: a pointer leaves an element
     *   - pointercancel: a pointer will no longer generate events
     */
    var dispatcher = {
        IS_IOS: false,
        pointermap: new scope.PointerMap(),
        requiredGestures: new scope.PointerMap(),
        eventMap: Object.create(null),
        // Scope objects for native events.
        // This exists for ease of testing.
        eventSources: Object.create(null),
        eventSourceList: [],
        gestures: [],
        // map gesture event -> {listeners: int, index: gestures[int]}
        dependencyMap: {
            // make sure down and up are in the map to trigger "register"
            down: {
                listeners: 0,
                index: -1
            },
            up: {
                listeners: 0,
                index: -1
            }
        },
        gestureQueue: [],
        /**
         * Add a new event source that will generate pointer events.
         *
         * `inSource` must contain an array of event names named `events`, and
         * functions with the names specified in the `events` array.
         * @param {string} name A name for the event source
         * @param {Object} source A new source of platform events.
         */
        registerSource: function(name, source) {
            var s = source;
            var newEvents = s.events;
            if (newEvents) {
                newEvents.forEach(function(e) {
                    if (s[e]) {
                        this.eventMap[e] = s[e].bind(s);
                    }
                }, this);
                this.eventSources[name] = s;
                this.eventSourceList.push(s);
            }
        },
        registerGesture: function(name, source) {
            var obj = Object.create(null);
            obj.listeners = 0;
            obj.index = this.gestures.length;
            for (var i = 0, g; i < source.exposes.length; i++) {
                g = source.exposes[i].toLowerCase();
                this.dependencyMap[g] = obj;
            }
            this.gestures.push(source);
        },
        register: function(element, initial) {
            var l = this.eventSourceList.length;
            for (var i = 0, es;
                (i < l) && (es = this.eventSourceList[i]); i++) {
                // call eventsource register
                es.register.call(es, element, initial);
            }
        },
        unregister: function(element) {
            var l = this.eventSourceList.length;
            for (var i = 0, es;
                (i < l) && (es = this.eventSourceList[i]); i++) {
                // call eventsource register
                es.unregister.call(es, element);
            }
        },
        // EVENTS
        down: function(inEvent) {
            this.requiredGestures.set(inEvent.pointerId, currentGestures);
            this.fireEvent('down', inEvent);
        },
        move: function(inEvent) {
            // pipe move events into gesture queue directly
            inEvent.type = 'move';
            this.fillGestureQueue(inEvent);
        },
        up: function(inEvent) {
            this.fireEvent('up', inEvent);
            this.requiredGestures.delete(inEvent.pointerId);
        },
        cancel: function(inEvent) {
            inEvent.tapPrevented = true;
            this.fireEvent('up', inEvent);
            this.requiredGestures.delete(inEvent.pointerId);
        },
        addGestureDependency: function(node, currentGestures) {
            var gesturesWanted = node._pgEvents;
            if (gesturesWanted && currentGestures) {
                var gk = Object.keys(gesturesWanted);
                for (var i = 0, r, ri, g; i < gk.length; i++) {
                    // gesture
                    g = gk[i];
                    if (gesturesWanted[g] > 0) {
                        // lookup gesture recognizer
                        r = this.dependencyMap[g];
                        // recognizer index
                        ri = r ? r.index : -1;
                        currentGestures[ri] = true;
                    }
                }
            }
        },
        // LISTENER LOGIC
        eventHandler: function(inEvent) {
            // This is used to prevent multiple dispatch of events from
            // platform events. This can happen when two elements in different scopes
            // are set up to create pointer events, which is relevant to Shadow DOM.

            var type = inEvent.type;

            // only generate the list of desired events on "down"
            if (type === 'touchstart' || type === 'mousedown' || type === 'pointerdown' || type === 'MSPointerDown') {
                if (!inEvent._handledByPG) {
                    currentGestures = {};
                }

                // in IOS mode, there is only a listener on the document, so this is not re-entrant
                if (this.IS_IOS) {
                    var ev = inEvent;
                    if (type === 'touchstart') {
                        var ct = inEvent.changedTouches[0];
                        // set up a fake event to give to the path builder
                        ev = {
                            target: inEvent.target,
                            clientX: ct.clientX,
                            clientY: ct.clientY,
                            path: inEvent.path
                        };
                    }
                    // use event path if available, otherwise build a path from target finding
                    var nodes = inEvent.path || scope.targetFinding.path(ev);
                    for (var i = 0, n; i < nodes.length; i++) {
                        n = nodes[i];
                        this.addGestureDependency(n, currentGestures);
                    }
                } else {
                    this.addGestureDependency(inEvent.currentTarget, currentGestures);
                }
            }

            if (inEvent._handledByPG) {
                return;
            }
            var fn = this.eventMap && this.eventMap[type];
            if (fn) {
                fn(inEvent);
            }
            inEvent._handledByPG = true;
        },
        // set up event listeners
        listen: function(target, events) {
            for (var i = 0, l = events.length, e;
                (i < l) && (e = events[i]); i++) {
                this.addEvent(target, e);
            }
        },
        // remove event listeners
        unlisten: function(target, events) {
            for (var i = 0, l = events.length, e;
                (i < l) && (e = events[i]); i++) {
                this.removeEvent(target, e);
            }
        },
        addEvent: function(target, eventName) {
            target.addEventListener(eventName, this.boundHandler);
        },
        removeEvent: function(target, eventName) {
            target.removeEventListener(eventName, this.boundHandler);
        },
        // EVENT CREATION AND TRACKING
        /**
         * Creates a new Event of type `inType`, based on the information in
         * `inEvent`.
         *
         * @param {string} inType A string representing the type of event to create
         * @param {Event} inEvent A platform event with a target
         * @return {Event} A PointerEvent of type `inType`
         */
        makeEvent: function(inType, inEvent) {
            var e = eventFactory.makePointerEvent(inType, inEvent);
            e.preventDefault = inEvent.preventDefault;
            e.tapPrevented = inEvent.tapPrevented;
            e._target = e._target || inEvent.target;
            return e;
        },
        // make and dispatch an event in one call
        fireEvent: function(inType, inEvent) {
            var e = this.makeEvent(inType, inEvent);
            return this.dispatchEvent(e);
        },
        /**
         * Returns a snapshot of inEvent, with writable properties.
         *
         * @param {Event} inEvent An event that contains properties to copy.
         * @return {Object} An object containing shallow copies of `inEvent`'s
         *    properties.
         */
        cloneEvent: function(inEvent) {
            var eventCopy = Object.create(null),
                p;
            for (var i = 0; i < CLONE_PROPS.length; i++) {
                p = CLONE_PROPS[i];
                eventCopy[p] = inEvent[p] || CLONE_DEFAULTS[i];
                // Work around SVGInstanceElement shadow tree
                // Return the <use> element that is represented by the instance for Safari, Chrome, IE.
                // This is the behavior implemented by Firefox.
                if (p === 'target' || p === 'relatedTarget') {
                    if (HAS_SVG_INSTANCE && eventCopy[p] instanceof SVGElementInstance) {
                        eventCopy[p] = eventCopy[p].correspondingUseElement;
                    }
                }
            }
            // keep the semantics of preventDefault
            eventCopy.preventDefault = function() {
                inEvent.preventDefault();
            };
            return eventCopy;
        },
        /**
         * Dispatches the event to its target.
         *
         * @param {Event} inEvent The event to be dispatched.
         * @return {Boolean} True if an event handler returns true, false otherwise.
         */
        dispatchEvent: function(inEvent) {
            var t = inEvent._target;
            if (t) {
                t.dispatchEvent(inEvent);
                // clone the event for the gesture system to process
                // clone after dispatch to pick up gesture prevention code
                var clone = this.cloneEvent(inEvent);
                clone.target = t;
                this.fillGestureQueue(clone);
            }
        },
        gestureTrigger: function() {
            // process the gesture queue
            for (var i = 0, e, rg; i < this.gestureQueue.length; i++) {
                e = this.gestureQueue[i];
                rg = e._requiredGestures;
                if (rg) {
                    for (var j = 0, g, fn; j < this.gestures.length; j++) {
                        // only run recognizer if an element in the source event's path is listening for those gestures
                        if (rg[j]) {
                            g = this.gestures[j];
                            fn = g[e.type];
                            if (fn) {
                                fn.call(g, e);
                            }
                        }
                    }
                }
            }
            this.gestureQueue.length = 0;
        },
        fillGestureQueue: function(ev) {
            // only trigger the gesture queue once
            if (!this.gestureQueue.length) {
                requestAnimationFrame(this.boundGestureTrigger);
            }
            ev._requiredGestures = this.requiredGestures.get(ev.pointerId);
            this.gestureQueue.push(ev);
        }
    };
    dispatcher.boundHandler = dispatcher.eventHandler.bind(dispatcher);
    dispatcher.boundGestureTrigger = dispatcher.gestureTrigger.bind(dispatcher);
    scope.dispatcher = dispatcher;

    /**
     * Listen for `gesture` on `node` with the `handler` function
     *
     * If `handler` is the first listener for `gesture`, the underlying gesture recognizer is then enabled.
     *
     * @param {Element} node
     * @param {string} gesture
     * @return Boolean `gesture` is a valid gesture
     */
    scope.activateGesture = function(node, gesture) {
        var g = gesture.toLowerCase();
        var dep = dispatcher.dependencyMap[g];
        if (dep) {
            var recognizer = dispatcher.gestures[dep.index];
            if (!node._pgListeners) {
                dispatcher.register(node);
                node._pgListeners = 0;
            }
            // TODO(dfreedm): re-evaluate bookkeeping to avoid using attributes
            if (recognizer) {
                var touchAction = recognizer.defaultActions && recognizer.defaultActions[g];
                var actionNode;
                switch (node.nodeType) {
                    case Node.ELEMENT_NODE:
                        actionNode = node;
                        break;
                    case Node.DOCUMENT_FRAGMENT_NODE:
                        actionNode = node.host;
                        break;
                    default:
                        actionNode = null;
                        break;
                }
                if (touchAction && actionNode && !actionNode.hasAttribute('touch-action')) {
                    actionNode.setAttribute('touch-action', touchAction);
                }
            }
            if (!node._pgEvents) {
                node._pgEvents = {};
            }
            node._pgEvents[g] = (node._pgEvents[g] || 0) + 1;
            node._pgListeners++;
        }
        return Boolean(dep);
    };

    /**
     *
     * Listen for `gesture` from `node` with `handler` function.
     *
     * @param {Element} node
     * @param {string} gesture
     * @param {Function} handler
     * @param {Boolean} capture
     */
    scope.addEventListener = function(node, gesture, handler, capture) {
        if (handler) {
            scope.activateGesture(node, gesture);
            node.addEventListener(gesture, handler, capture);
        }
    };

    /**
     * Tears down the gesture configuration for `node`
     *
     * If `handler` is the last listener for `gesture`, the underlying gesture recognizer is disabled.
     *
     * @param {Element} node
     * @param {string} gesture
     * @return Boolean `gesture` is a valid gesture
     */
    scope.deactivateGesture = function(node, gesture) {
        var g = gesture.toLowerCase();
        var dep = dispatcher.dependencyMap[g];
        if (dep) {
            if (node._pgListeners > 0) {
                node._pgListeners--;
            }
            if (node._pgListeners === 0) {
                dispatcher.unregister(node);
            }
            if (node._pgEvents) {
                if (node._pgEvents[g] > 0) {
                    node._pgEvents[g]--;
                } else {
                    node._pgEvents[g] = 0;
                }
            }
        }
        return Boolean(dep);
    };

    /**
     * Stop listening for `gesture` from `node` with `handler` function.
     *
     * @param {Element} node
     * @param {string} gesture
     * @param {Function} handler
     * @param {Boolean} capture
     */
    scope.removeEventListener = function(node, gesture, handler, capture) {
        if (handler) {
            scope.deactivateGesture(node, gesture);
            node.removeEventListener(gesture, handler, capture);
        }
    };
})(exports);

(function(scope) {
    var dispatcher = scope.dispatcher;
    var pointermap = dispatcher.pointermap;
    // radius around touchend that swallows mouse events
    var DEDUP_DIST = 25;

    var WHICH_TO_BUTTONS = [0, 1, 4, 2];

    var currentButtons = 0;

    var FIREFOX_LINUX = /Linux.*Firefox\//i;

    var HAS_BUTTONS = (function() {
        // firefox on linux returns spec-incorrect values for mouseup.buttons
        // https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent.buttons#See_also
        // https://codereview.chromium.org/727593003/#msg16
        if (FIREFOX_LINUX.test(navigator.userAgent)) {
            return false;
        }
        try {
            return new MouseEvent('test', {
                buttons: 1
            }).buttons === 1;
        } catch (e) {
            return false;
        }
    })();

    // handler block for native mouse events
    var mouseEvents = {
        POINTER_ID: 1,
        POINTER_TYPE: 'mouse',
        events: [
            'mousedown',
            'mousemove',
            'mouseup'
        ],
        exposes: [
            'down',
            'up',
            'move'
        ],
        register: function(target) {
            dispatcher.listen(target, this.events);
        },
        unregister: function(target) {
            if (target.nodeType === Node.DOCUMENT_NODE) {
                return;
            }
            dispatcher.unlisten(target, this.events);
        },
        lastTouches: [],
        // collide with the global mouse listener
        isEventSimulatedFromTouch: function(inEvent) {
            var lts = this.lastTouches;
            var x = inEvent.clientX,
                y = inEvent.clientY;
            for (var i = 0, l = lts.length, t; i < l && (t = lts[i]); i++) {
                // simulated mouse events will be swallowed near a primary touchend
                var dx = Math.abs(x - t.x),
                    dy = Math.abs(y - t.y);
                if (dx <= DEDUP_DIST && dy <= DEDUP_DIST) {
                    return true;
                }
            }
        },
        prepareEvent: function(inEvent) {
            var e = dispatcher.cloneEvent(inEvent);
            e.pointerId = this.POINTER_ID;
            e.isPrimary = true;
            e.pointerType = this.POINTER_TYPE;
            e._source = 'mouse';
            if (!HAS_BUTTONS) {
                var type = inEvent.type;
                var bit = WHICH_TO_BUTTONS[inEvent.which] || 0;
                if (type === 'mousedown') {
                    currentButtons |= bit;
                } else if (type === 'mouseup') {
                    currentButtons &= ~bit;
                }
                e.buttons = currentButtons;
            }
            return e;
        },
        mousedown: function(inEvent) {
            if (!this.isEventSimulatedFromTouch(inEvent)) {
                var p = pointermap.has(this.POINTER_ID);
                var e = this.prepareEvent(inEvent);
                e.target = scope.findTarget(inEvent);
                pointermap.set(this.POINTER_ID, e.target);
                dispatcher.down(e);
            }
        },
        mousemove: function(inEvent) {
            if (!this.isEventSimulatedFromTouch(inEvent)) {
                var target = pointermap.get(this.POINTER_ID);
                if (target) {
                    var e = this.prepareEvent(inEvent);
                    e.target = target;
                    // handle case where we missed a mouseup
                    if ((HAS_BUTTONS ? e.buttons : e.which) === 0) {
                        if (!HAS_BUTTONS) {
                            currentButtons = e.buttons = 0;
                        }
                        dispatcher.cancel(e);
                        this.cleanupMouse(e.buttons);
                    } else {
                        dispatcher.move(e);
                    }
                }
            }
        },
        mouseup: function(inEvent) {
            if (!this.isEventSimulatedFromTouch(inEvent)) {
                var e = this.prepareEvent(inEvent);
                e.relatedTarget = scope.findTarget(inEvent);
                e.target = pointermap.get(this.POINTER_ID);
                dispatcher.up(e);
                this.cleanupMouse(e.buttons);
            }
        },
        cleanupMouse: function(buttons) {
            if (buttons === 0) {
                pointermap.delete(this.POINTER_ID);
            }
        }
    };

    scope.mouseEvents = mouseEvents;
})(exports);

(function(scope) {
    var dispatcher = scope.dispatcher;
    var allShadows = scope.targetFinding.allShadows.bind(scope.targetFinding);
    var pointermap = dispatcher.pointermap;
    var touchMap = Array.prototype.map.call.bind(Array.prototype.map);
    // This should be long enough to ignore compat mouse events made by touch
    var DEDUP_TIMEOUT = 2500;
    var DEDUP_DIST = 25;
    var CLICK_COUNT_TIMEOUT = 200;
    var HYSTERESIS = 20;
    var ATTRIB = 'touch-action';
    // TODO(dfreedm): disable until http://crbug.com/399765 is resolved
    // var HAS_TOUCH_ACTION = ATTRIB in document.head.style;
    var HAS_TOUCH_ACTION = false;

    // handler block for native touch events
    var touchEvents = {
        IS_IOS: false,
        events: [
            'touchstart',
            'touchmove',
            'touchend',
            'touchcancel'
        ],
        exposes: [
            'down',
            'up',
            'move'
        ],
        register: function(target, initial) {
            if (this.IS_IOS ? initial : !initial) {
                dispatcher.listen(target, this.events);
            }
        },
        unregister: function(target) {
            if (!this.IS_IOS) {
                dispatcher.unlisten(target, this.events);
            }
        },
        scrollTypes: {
            EMITTER: 'none',
            XSCROLLER: 'pan-x',
            YSCROLLER: 'pan-y',
        },
        touchActionToScrollType: function(touchAction) {
            var t = touchAction;
            var st = this.scrollTypes;
            if (t === st.EMITTER) {
                return 'none';
            } else if (t === st.XSCROLLER) {
                return 'X';
            } else if (t === st.YSCROLLER) {
                return 'Y';
            } else {
                return 'XY';
            }
        },
        POINTER_TYPE: 'touch',
        firstTouch: null,
        isPrimaryTouch: function(inTouch) {
            return this.firstTouch === inTouch.identifier;
        },
        setPrimaryTouch: function(inTouch) {
            // set primary touch if there no pointers, or the only pointer is the mouse
            if (pointermap.pointers() === 0 || (pointermap.pointers() === 1 && pointermap.has(1))) {
                this.firstTouch = inTouch.identifier;
                this.firstXY = {
                    X: inTouch.clientX,
                    Y: inTouch.clientY
                };
                this.firstTarget = inTouch.target;
                this.scrolling = null;
                this.cancelResetClickCount();
            }
        },
        removePrimaryPointer: function(inPointer) {
            if (inPointer.isPrimary) {
                this.firstTouch = null;
                this.firstXY = null;
                this.resetClickCount();
            }
        },
        clickCount: 0,
        resetId: null,
        resetClickCount: function() {
            var fn = function() {
                this.clickCount = 0;
                this.resetId = null;
            }.bind(this);
            this.resetId = setTimeout(fn, CLICK_COUNT_TIMEOUT);
        },
        cancelResetClickCount: function() {
            if (this.resetId) {
                clearTimeout(this.resetId);
            }
        },
        typeToButtons: function(type) {
            var ret = 0;
            if (type === 'touchstart' || type === 'touchmove') {
                ret = 1;
            }
            return ret;
        },
        findTarget: function(touch, id) {
            if (this.currentTouchEvent.type === 'touchstart') {
                if (this.isPrimaryTouch(touch)) {
                    var fastPath = {
                        clientX: touch.clientX,
                        clientY: touch.clientY,
                        path: this.currentTouchEvent.path,
                        target: this.currentTouchEvent.target
                    };
                    return scope.findTarget(fastPath);
                } else {
                    return scope.findTarget(touch);
                }
            }
            // reuse target we found in touchstart
            return pointermap.get(id);
        },
        touchToPointer: function(inTouch) {
            var cte = this.currentTouchEvent;
            var e = dispatcher.cloneEvent(inTouch);
            // Spec specifies that pointerId 1 is reserved for Mouse.
            // Touch identifiers can start at 0.
            // Add 2 to the touch identifier for compatibility.
            var id = e.pointerId = inTouch.identifier + 2;
            e.target = this.findTarget(inTouch, id);
            e.bubbles = true;
            e.cancelable = true;
            e.detail = this.clickCount;
            e.buttons = this.typeToButtons(cte.type);
            e.width = inTouch.webkitRadiusX || inTouch.radiusX || 0;
            e.height = inTouch.webkitRadiusY || inTouch.radiusY || 0;
            e.pressure = inTouch.webkitForce || inTouch.force || 0.5;
            e.isPrimary = this.isPrimaryTouch(inTouch);
            e.pointerType = this.POINTER_TYPE;
            e._source = 'touch';
            // forward touch preventDefaults
            var self = this;
            e.preventDefault = function() {
                self.scrolling = false;
                self.firstXY = null;
                cte.preventDefault();
            };
            return e;
        },
        processTouches: function(inEvent, inFunction) {
            var tl = inEvent.changedTouches;
            this.currentTouchEvent = inEvent;
            for (var i = 0, t, p; i < tl.length; i++) {
                t = tl[i];
                p = this.touchToPointer(t);
                if (inEvent.type === 'touchstart') {
                    pointermap.set(p.pointerId, p.target);
                }
                if (pointermap.has(p.pointerId)) {
                    inFunction.call(this, p);
                }
                if (inEvent.type === 'touchend' || inEvent._cancel) {
                    this.cleanUpPointer(p);
                }
            }
        },
        // For single axis scrollers, determines whether the element should emit
        // pointer events or behave as a scroller
        shouldScroll: function(inEvent) {
            if (this.firstXY) {
                var ret;
                var touchAction = scope.targetFinding.findTouchAction(inEvent);
                var scrollAxis = this.touchActionToScrollType(touchAction);
                if (scrollAxis === 'none') {
                    // this element is a touch-action: none, should never scroll
                    ret = false;
                } else if (scrollAxis === 'XY') {
                    // this element should always scroll
                    ret = true;
                } else {
                    var t = inEvent.changedTouches[0];
                    // check the intended scroll axis, and other axis
                    var a = scrollAxis;
                    var oa = scrollAxis === 'Y' ? 'X' : 'Y';
                    var da = Math.abs(t['client' + a] - this.firstXY[a]);
                    var doa = Math.abs(t['client' + oa] - this.firstXY[oa]);
                    // if delta in the scroll axis > delta other axis, scroll instead of
                    // making events
                    ret = da >= doa;
                }
                return ret;
            }
        },
        findTouch: function(inTL, inId) {
            for (var i = 0, l = inTL.length, t; i < l && (t = inTL[i]); i++) {
                if (t.identifier === inId) {
                    return true;
                }
            }
        },
        // In some instances, a touchstart can happen without a touchend. This
        // leaves the pointermap in a broken state.
        // Therefore, on every touchstart, we remove the touches that did not fire a
        // touchend event.
        // To keep state globally consistent, we fire a
        // pointercancel for this "abandoned" touch
        vacuumTouches: function(inEvent) {
            var tl = inEvent.touches;
            // pointermap.pointers() should be < tl.length here, as the touchstart has not
            // been processed yet.
            if (pointermap.pointers() >= tl.length) {
                var d = [];
                pointermap.forEach(function(value, key) {
                    // Never remove pointerId == 1, which is mouse.
                    // Touch identifiers are 2 smaller than their pointerId, which is the
                    // index in pointermap.
                    if (key !== 1 && !this.findTouch(tl, key - 2)) {
                        var p = value;
                        d.push(p);
                    }
                }, this);
                d.forEach(function(p) {
                    this.cancel(p);
                    pointermap.delete(p.pointerId);
                }, this);
            }
        },
        touchstart: function(inEvent) {
            this.vacuumTouches(inEvent);
            this.setPrimaryTouch(inEvent.changedTouches[0]);
            this.dedupSynthMouse(inEvent);
            if (!this.scrolling) {
                this.clickCount++;
                this.processTouches(inEvent, this.down);
            }
        },
        down: function(inPointer) {
            dispatcher.down(inPointer);
        },
        touchmove: function(inEvent) {
            if (HAS_TOUCH_ACTION) {
                // touchevent.cancelable == false is sent when the page is scrolling under native Touch Action in Chrome 36
                // https://groups.google.com/a/chromium.org/d/msg/input-dev/wHnyukcYBcA/b9kmtwM1jJQJ
                if (inEvent.cancelable) {
                    this.processTouches(inEvent, this.move);
                }
            } else {
                if (!this.scrolling) {
                    if (this.scrolling === null && this.shouldScroll(inEvent)) {
                        this.scrolling = true;
                    } else {
                        this.scrolling = false;
                        inEvent.preventDefault();
                        this.processTouches(inEvent, this.move);
                    }
                } else if (this.firstXY) {
                    var t = inEvent.changedTouches[0];
                    var dx = t.clientX - this.firstXY.X;
                    var dy = t.clientY - this.firstXY.Y;
                    var dd = Math.sqrt(dx * dx + dy * dy);
                    if (dd >= HYSTERESIS) {
                        this.touchcancel(inEvent);
                        this.scrolling = true;
                        this.firstXY = null;
                    }
                }
            }
        },
        move: function(inPointer) {
            dispatcher.move(inPointer);
        },
        touchend: function(inEvent) {
            this.dedupSynthMouse(inEvent);
            this.processTouches(inEvent, this.up);
        },
        up: function(inPointer) {
            inPointer.relatedTarget = scope.findTarget(inPointer);
            dispatcher.up(inPointer);
        },
        cancel: function(inPointer) {
            dispatcher.cancel(inPointer);
        },
        touchcancel: function(inEvent) {
            inEvent._cancel = true;
            this.processTouches(inEvent, this.cancel);
        },
        cleanUpPointer: function(inPointer) {
            pointermap['delete'](inPointer.pointerId);
            this.removePrimaryPointer(inPointer);
        },
        // prevent synth mouse events from creating pointer events
        dedupSynthMouse: function(inEvent) {
            var lts = scope.mouseEvents.lastTouches;
            var t = inEvent.changedTouches[0];
            // only the primary finger will synth mouse events
            if (this.isPrimaryTouch(t)) {
                // remember x/y of last touch
                var lt = {
                    x: t.clientX,
                    y: t.clientY
                };
                lts.push(lt);
                var fn = (function(lts, lt) {
                    var i = lts.indexOf(lt);
                    if (i > -1) {
                        lts.splice(i, 1);
                    }
                }).bind(null, lts, lt);
                setTimeout(fn, DEDUP_TIMEOUT);
            }
        }
    };

    // prevent "ghost clicks" that come from elements that were removed in a touch handler
    var STOP_PROP_FN = Event.prototype.stopImmediatePropagation || Event.prototype.stopPropagation;
    document.addEventListener('click', function(ev) {
        var x = ev.clientX,
            y = ev.clientY;
        // check if a click is within DEDUP_DIST px radius of the touchstart
        var closeTo = function(touch) {
            var dx = Math.abs(x - touch.x),
                dy = Math.abs(y - touch.y);
            return (dx <= DEDUP_DIST && dy <= DEDUP_DIST);
        };
        // if click coordinates are close to touch coordinates, assume the click came from a touch
        var wasTouched = scope.mouseEvents.lastTouches.some(closeTo);
        // if the click came from touch, and the touchstart target is not in the path of the click event,
        // then the touchstart target was probably removed, and the click should be "busted"
        var path = scope.targetFinding.path(ev);
        if (wasTouched) {
            for (var i = 0; i < path.length; i++) {
                if (path[i] === touchEvents.firstTarget) {
                    return;
                }
            }
            ev.preventDefault();
            STOP_PROP_FN.call(ev);
        }
    }, true);

    scope.touchEvents = touchEvents;
})(exports);

(function(scope) {
    var dispatcher = scope.dispatcher;
    var pointermap = dispatcher.pointermap;
    var HAS_BITMAP_TYPE = window.MSPointerEvent && typeof window.MSPointerEvent.MSPOINTER_TYPE_MOUSE === 'number';
    var msEvents = {
        events: [
            'MSPointerDown',
            'MSPointerMove',
            'MSPointerUp',
            'MSPointerCancel',
        ],
        register: function(target) {
            dispatcher.listen(target, this.events);
        },
        unregister: function(target) {
            if (target.nodeType === Node.DOCUMENT_NODE) {
                return;
            }
            dispatcher.unlisten(target, this.events);
        },
        POINTER_TYPES: [
            '',
            'unavailable',
            'touch',
            'pen',
            'mouse'
        ],
        prepareEvent: function(inEvent) {
            var e = inEvent;
            e = dispatcher.cloneEvent(inEvent);
            if (HAS_BITMAP_TYPE) {
                e.pointerType = this.POINTER_TYPES[inEvent.pointerType];
            }
            e._source = 'ms';
            return e;
        },
        cleanup: function(id) {
            pointermap['delete'](id);
        },
        MSPointerDown: function(inEvent) {
            var e = this.prepareEvent(inEvent);
            e.target = scope.findTarget(inEvent);
            pointermap.set(inEvent.pointerId, e.target);
            dispatcher.down(e);
        },
        MSPointerMove: function(inEvent) {
            var target = pointermap.get(inEvent.pointerId);
            if (target) {
                var e = this.prepareEvent(inEvent);
                e.target = target;
                dispatcher.move(e);
            }
        },
        MSPointerUp: function(inEvent) {
            var e = this.prepareEvent(inEvent);
            e.relatedTarget = scope.findTarget(inEvent);
            e.target = pointermap.get(e.pointerId);
            dispatcher.up(e);
            this.cleanup(inEvent.pointerId);
        },
        MSPointerCancel: function(inEvent) {
            var e = this.prepareEvent(inEvent);
            e.relatedTarget = scope.findTarget(inEvent);
            e.target = pointermap.get(e.pointerId);
            dispatcher.cancel(e);
            this.cleanup(inEvent.pointerId);
        }
    };

    scope.msEvents = msEvents;
})(exports);

(function(scope) {
    var dispatcher = scope.dispatcher;
    var pointermap = dispatcher.pointermap;
    var pointerEvents = {
        events: [
            'pointerdown',
            'pointermove',
            'pointerup',
            'pointercancel'
        ],
        prepareEvent: function(inEvent) {
            var e = dispatcher.cloneEvent(inEvent);
            e._source = 'pointer';
            return e;
        },
        register: function(target) {
            dispatcher.listen(target, this.events);
        },
        unregister: function(target) {
            if (target.nodeType === Node.DOCUMENT_NODE) {
                return;
            }
            dispatcher.unlisten(target, this.events);
        },
        cleanup: function(id) {
            pointermap['delete'](id);
        },
        pointerdown: function(inEvent) {
            var e = this.prepareEvent(inEvent);
            e.target = scope.findTarget(inEvent);
            pointermap.set(e.pointerId, e.target);
            dispatcher.down(e);
        },
        pointermove: function(inEvent) {
            var target = pointermap.get(inEvent.pointerId);
            if (target) {
                var e = this.prepareEvent(inEvent);
                e.target = target;
                dispatcher.move(e);
            }
        },
        pointerup: function(inEvent) {
            var e = this.prepareEvent(inEvent);
            e.relatedTarget = scope.findTarget(inEvent);
            e.target = pointermap.get(e.pointerId);
            dispatcher.up(e);
            this.cleanup(inEvent.pointerId);
        },
        pointercancel: function(inEvent) {
            var e = this.prepareEvent(inEvent);
            e.relatedTarget = scope.findTarget(inEvent);
            e.target = pointermap.get(e.pointerId);
            dispatcher.cancel(e);
            this.cleanup(inEvent.pointerId);
        }
    };

    scope.pointerEvents = pointerEvents;
})(exports);

/**
 * This module contains the handlers for native platform events.
 * From here, the dispatcher is called to create unified pointer events.
 * Included are touch events (v1), mouse events, and MSPointerEvents.
 */
(function(scope) {

    var dispatcher = scope.dispatcher;
    var nav = window.navigator;

    if (window.PointerEvent) {
        dispatcher.registerSource('pointer', scope.pointerEvents);
    } else if (nav.msPointerEnabled) {
        dispatcher.registerSource('ms', scope.msEvents);
    } else {
        dispatcher.registerSource('mouse', scope.mouseEvents);
        if (window.ontouchstart !== undefined) {
            dispatcher.registerSource('touch', scope.touchEvents);
        }
    }

    // Work around iOS bugs https://bugs.webkit.org/show_bug.cgi?id=135628 and https://bugs.webkit.org/show_bug.cgi?id=136506
    var ua = navigator.userAgent;
    var IS_IOS = ua.match(/iPad|iPhone|iPod/) && 'ontouchstart' in window;

    dispatcher.IS_IOS = IS_IOS;
    scope.touchEvents.IS_IOS = IS_IOS;

    dispatcher.register(document, true);
})(exports);

/**
 * This event denotes the beginning of a series of tracking events.
 *
 * @module PointerGestures
 * @submodule Events
 * @class trackstart
 */
/**
 * Pixels moved in the x direction since trackstart.
 * @type Number
 * @property dx
 */
/**
 * Pixes moved in the y direction since trackstart.
 * @type Number
 * @property dy
 */
/**
 * Pixels moved in the x direction since the last track.
 * @type Number
 * @property ddx
 */
/**
 * Pixles moved in the y direction since the last track.
 * @type Number
 * @property ddy
 */
/**
 * The clientX position of the track gesture.
 * @type Number
 * @property clientX
 */
/**
 * The clientY position of the track gesture.
 * @type Number
 * @property clientY
 */
/**
 * The pageX position of the track gesture.
 * @type Number
 * @property pageX
 */
/**
 * The pageY position of the track gesture.
 * @type Number
 * @property pageY
 */
/**
 * The screenX position of the track gesture.
 * @type Number
 * @property screenX
 */
/**
 * The screenY position of the track gesture.
 * @type Number
 * @property screenY
 */
/**
 * The last x axis direction of the pointer.
 * @type Number
 * @property xDirection
 */
/**
 * The last y axis direction of the pointer.
 * @type Number
 * @property yDirection
 */
/**
 * A shared object between all tracking events.
 * @type Object
 * @property trackInfo
 */
/**
 * The element currently under the pointer.
 * @type Element
 * @property relatedTarget
 */
/**
 * The type of pointer that make the track gesture.
 * @type String
 * @property pointerType
 */
/**
 *
 * This event fires for all pointer movement being tracked.
 *
 * @class track
 * @extends trackstart
 */
/**
 * This event fires when the pointer is no longer being tracked.
 *
 * @class trackend
 * @extends trackstart
 */

(function(scope) {
    var dispatcher = scope.dispatcher;
    var eventFactory = scope.eventFactory;
    var pointermap = new scope.PointerMap();
    var track = {
        events: [
            'down',
            'move',
            'up',
        ],
        exposes: [
            'trackstart',
            'track',
            'trackx',
            'tracky',
            'trackend'
        ],
        defaultActions: {
            'track': 'none',
            'trackx': 'pan-y',
            'tracky': 'pan-x'
        },
        WIGGLE_THRESHOLD: 4,
        clampDir: function(inDelta) {
            return inDelta > 0 ? 1 : -1;
        },
        calcPositionDelta: function(inA, inB) {
            var x = 0,
                y = 0;
            if (inA && inB) {
                x = inB.pageX - inA.pageX;
                y = inB.pageY - inA.pageY;
            }
            return {
                x: x,
                y: y
            };
        },
        fireTrack: function(inType, inEvent, inTrackingData) {
            var t = inTrackingData;
            var d = this.calcPositionDelta(t.downEvent, inEvent);
            var dd = this.calcPositionDelta(t.lastMoveEvent, inEvent);
            if (dd.x) {
                t.xDirection = this.clampDir(dd.x);
            } else if (inType === 'trackx') {
                return;
            }
            if (dd.y) {
                t.yDirection = this.clampDir(dd.y);
            } else if (inType === 'tracky') {
                return;
            }
            var gestureProto = {
                bubbles: true,
                cancelable: true,
                trackInfo: t.trackInfo,
                relatedTarget: inEvent.relatedTarget,
                pointerType: inEvent.pointerType,
                pointerId: inEvent.pointerId,
                _source: 'track'
            };
            if (inType !== 'tracky') {
                gestureProto.x = inEvent.x;
                gestureProto.dx = d.x;
                gestureProto.ddx = dd.x;
                gestureProto.clientX = inEvent.clientX;
                gestureProto.pageX = inEvent.pageX;
                gestureProto.screenX = inEvent.screenX;
                gestureProto.xDirection = t.xDirection;
            }
            if (inType !== 'trackx') {
                gestureProto.dy = d.y;
                gestureProto.ddy = dd.y;
                gestureProto.y = inEvent.y;
                gestureProto.clientY = inEvent.clientY;
                gestureProto.pageY = inEvent.pageY;
                gestureProto.screenY = inEvent.screenY;
                gestureProto.yDirection = t.yDirection;
            }
            var e = eventFactory.makeGestureEvent(inType, gestureProto);
            t.downTarget.dispatchEvent(e);
        },
        down: function(inEvent) {
            if (inEvent.isPrimary && (inEvent.pointerType === 'mouse' ? inEvent.buttons === 1 : true)) {
                var p = {
                    downEvent: inEvent,
                    downTarget: inEvent.target,
                    trackInfo: {},
                    lastMoveEvent: null,
                    xDirection: 0,
                    yDirection: 0,
                    tracking: false
                };
                pointermap.set(inEvent.pointerId, p);
            }
        },
        move: function(inEvent) {
            var p = pointermap.get(inEvent.pointerId);
            if (p) {
                if (!p.tracking) {
                    var d = this.calcPositionDelta(p.downEvent, inEvent);
                    var move = d.x * d.x + d.y * d.y;
                    // start tracking only if finger moves more than WIGGLE_THRESHOLD
                    if (move > this.WIGGLE_THRESHOLD) {
                        p.tracking = true;
                        p.lastMoveEvent = p.downEvent;
                        this.fireTrack('trackstart', inEvent, p);
                    }
                }
                if (p.tracking) {
                    this.fireTrack('track', inEvent, p);
                    this.fireTrack('trackx', inEvent, p);
                    this.fireTrack('tracky', inEvent, p);
                }
                p.lastMoveEvent = inEvent;
            }
        },
        up: function(inEvent) {
            var p = pointermap.get(inEvent.pointerId);
            if (p) {
                if (p.tracking) {
                    this.fireTrack('trackend', inEvent, p);
                }
                pointermap.delete(inEvent.pointerId);
            }
        }
    };
    dispatcher.registerGesture('track', track);
})(exports);

/**
 * This event is fired when a pointer is held down for 200ms.
 *
 * @module PointerGestures
 * @submodule Events
 * @class hold
 */
/**
 * Type of pointer that made the holding event.
 * @type String
 * @property pointerType
 */
/**
 * Screen X axis position of the held pointer
 * @type Number
 * @property clientX
 */
/**
 * Screen Y axis position of the held pointer
 * @type Number
 * @property clientY
 */
/**
 * Type of pointer that made the holding event.
 * @type String
 * @property pointerType
 */
/**
 * This event is fired every 200ms while a pointer is held down.
 *
 * @class holdpulse
 * @extends hold
 */
/**
 * Milliseconds pointer has been held down.
 * @type Number
 * @property holdTime
 */
/**
 * This event is fired when a held pointer is released or moved.
 *
 * @class release
 */

(function(scope) {
    var dispatcher = scope.dispatcher;
    var eventFactory = scope.eventFactory;
    var hold = {
        // wait at least HOLD_DELAY ms between hold and pulse events
        HOLD_DELAY: 200,
        // pointer can move WIGGLE_THRESHOLD pixels before not counting as a hold
        WIGGLE_THRESHOLD: 16,
        events: [
            'down',
            'move',
            'up',
        ],
        exposes: [
            'hold',
            'holdpulse',
            'release'
        ],
        heldPointer: null,
        holdJob: null,
        pulse: function() {
            var hold = Date.now() - this.heldPointer.timeStamp;
            var type = this.held ? 'holdpulse' : 'hold';
            this.fireHold(type, hold);
            this.held = true;
        },
        cancel: function() {
            clearInterval(this.holdJob);
            if (this.held) {
                this.fireHold('release');
            }
            this.held = false;
            this.heldPointer = null;
            this.target = null;
            this.holdJob = null;
        },
        down: function(inEvent) {
            if (inEvent.isPrimary && !this.heldPointer) {
                this.heldPointer = inEvent;
                this.target = inEvent.target;
                this.holdJob = setInterval(this.pulse.bind(this), this.HOLD_DELAY);
            }
        },
        up: function(inEvent) {
            if (this.heldPointer && this.heldPointer.pointerId === inEvent.pointerId) {
                this.cancel();
            }
        },
        move: function(inEvent) {
            if (this.heldPointer && this.heldPointer.pointerId === inEvent.pointerId) {
                var x = inEvent.clientX - this.heldPointer.clientX;
                var y = inEvent.clientY - this.heldPointer.clientY;
                if ((x * x + y * y) > this.WIGGLE_THRESHOLD) {
                    this.cancel();
                }
            }
        },
        fireHold: function(inType, inHoldTime) {
            var p = {
                bubbles: true,
                cancelable: true,
                pointerType: this.heldPointer.pointerType,
                pointerId: this.heldPointer.pointerId,
                x: this.heldPointer.clientX,
                y: this.heldPointer.clientY,
                _source: 'hold'
            };
            if (inHoldTime) {
                p.holdTime = inHoldTime;
            }
            var e = eventFactory.makeGestureEvent(inType, p);
            this.target.dispatchEvent(e);
        }
    };
    dispatcher.registerGesture('hold', hold);
})(exports);

/**
 * This event is fired when a pointer quickly goes down and up, and is used to
 * denote activation.
 *
 * Any gesture event can prevent the tap event from being created by calling
 * `event.preventTap`.
 *
 * Any pointer event can prevent the tap by setting the `tapPrevented` property
 * on itself.
 *
 * @module PointerGestures
 * @submodule Events
 * @class tap
 */
/**
 * X axis position of the tap.
 * @property x
 * @type Number
 */
/**
 * Y axis position of the tap.
 * @property y
 * @type Number
 */
/**
 * Type of the pointer that made the tap.
 * @property pointerType
 * @type String
 */
(function(scope) {
    var dispatcher = scope.dispatcher;
    var eventFactory = scope.eventFactory;
    var pointermap = new scope.PointerMap();
    var tap = {
        events: [
            'down',
            'up'
        ],
        exposes: [
            'tap'
        ],
        down: function(inEvent) {
            if (inEvent.isPrimary && !inEvent.tapPrevented) {
                pointermap.set(inEvent.pointerId, {
                    target: inEvent.target,
                    buttons: inEvent.buttons,
                    x: inEvent.clientX,
                    y: inEvent.clientY
                });
            }
        },
        shouldTap: function(e, downState) {
            var tap = true;
            if (e.pointerType === 'mouse') {
                // only allow left click to tap for mouse
                tap = (e.buttons ^ 1) && (downState.buttons & 1);
            }
            return tap && !e.tapPrevented;
        },
        up: function(inEvent) {
            var start = pointermap.get(inEvent.pointerId);
            if (start && this.shouldTap(inEvent, start)) {
                // up.relatedTarget is target currently under finger
                var t = scope.targetFinding.LCA(start.target, inEvent.relatedTarget);
                if (t) {
                    var e = eventFactory.makeGestureEvent('tap', {
                        bubbles: true,
                        cancelable: true,
                        x: inEvent.clientX,
                        y: inEvent.clientY,
                        detail: inEvent.detail,
                        pointerType: inEvent.pointerType,
                        pointerId: inEvent.pointerId,
                        altKey: inEvent.altKey,
                        ctrlKey: inEvent.ctrlKey,
                        metaKey: inEvent.metaKey,
                        shiftKey: inEvent.shiftKey,
                        _source: 'tap'
                    });
                    t.dispatchEvent(e);
                }
            }
            pointermap.delete(inEvent.pointerId);
        }
    };
    // patch eventFactory to remove id from tap's pointermap for preventTap calls
    eventFactory.preventTap = function(e) {
        return function() {
            e.tapPrevented = true;
            pointermap.delete(e.pointerId);
        };
    };
    dispatcher.registerGesture('tap', tap);
})(exports);

/*
 * Basic strategy: find the farthest apart points, use as diameter of circle
 * react to size change and rotation of the chord
 */

/**
 * @module pointer-gestures
 * @submodule Events
 * @class pinch
 */
/**
 * Scale of the pinch zoom gesture
 * @property scale
 * @type Number
 */
/**
 * Center X position of pointers causing pinch
 * @property centerX
 * @type Number
 */
/**
 * Center Y position of pointers causing pinch
 * @property centerY
 * @type Number
 */

/**
 * @module pointer-gestures
 * @submodule Events
 * @class rotate
 */
/**
 * Angle (in degrees) of rotation. Measured from starting positions of pointers.
 * @property angle
 * @type Number
 */
/**
 * Center X position of pointers causing rotation
 * @property centerX
 * @type Number
 */
/**
 * Center Y position of pointers causing rotation
 * @property centerY
 * @type Number
 */
(function(scope) {
    var dispatcher = scope.dispatcher;
    var eventFactory = scope.eventFactory;
    var pointermap = new scope.PointerMap();
    var RAD_TO_DEG = 180 / Math.PI;
    var pinch = {
        events: [
            'down',
            'up',
            'move',
            'cancel'
        ],
        exposes: [
            'pinchstart',
            'pinch',
            'pinchend',
            'rotate'
        ],
        defaultActions: {
            'pinch': 'none',
            'rotate': 'none'
        },
        reference: {},
        down: function(inEvent) {
            pointermap.set(inEvent.pointerId, inEvent);
            if (pointermap.pointers() == 2) {
                var points = this.calcChord();
                var angle = this.calcAngle(points);
                this.reference = {
                    angle: angle,
                    diameter: points.diameter,
                    target: scope.targetFinding.LCA(points.a.target, points.b.target)
                };

                this.firePinch('pinchstart', points.diameter, points);
            }
        },
        up: function(inEvent) {
            var p = pointermap.get(inEvent.pointerId);
            var num = pointermap.pointers();
            if (p) {
                if (num === 2) {
                    // fire 'pinchend' before deleting pointer
                    var points = this.calcChord();
                    this.firePinch('pinchend', points.diameter, points);
                }
                pointermap.delete(inEvent.pointerId);
            }
        },
        move: function(inEvent) {
            if (pointermap.has(inEvent.pointerId)) {
                pointermap.set(inEvent.pointerId, inEvent);
                if (pointermap.pointers() > 1) {
                    this.calcPinchRotate();
                }
            }
        },
        cancel: function(inEvent) {
            this.up(inEvent);
        },
        firePinch: function(type, diameter, points) {
            var zoom = diameter / this.reference.diameter;
            var e = eventFactory.makeGestureEvent(type, {
                bubbles: true,
                cancelable: true,
                scale: zoom,
                centerX: points.center.x,
                centerY: points.center.y,
                _source: 'pinch'
            });
            this.reference.target.dispatchEvent(e);
        },
        fireRotate: function(angle, points) {
            var diff = Math.round((angle - this.reference.angle) % 360);
            var e = eventFactory.makeGestureEvent('rotate', {
                bubbles: true,
                cancelable: true,
                angle: diff,
                centerX: points.center.x,
                centerY: points.center.y,
                _source: 'pinch'
            });
            this.reference.target.dispatchEvent(e);
        },
        calcPinchRotate: function() {
            var points = this.calcChord();
            var diameter = points.diameter;
            var angle = this.calcAngle(points);
            if (diameter != this.reference.diameter) {
                this.firePinch('pinch', diameter, points);
            }
            if (angle != this.reference.angle) {
                this.fireRotate(angle, points);
            }
        },
        calcChord: function() {
            var pointers = [];
            pointermap.forEach(function(p) {
                pointers.push(p);
            });
            var dist = 0;
            // start with at least two pointers
            var points = {
                a: pointers[0],
                b: pointers[1]
            };
            var x, y, d;
            for (var i = 0; i < pointers.length; i++) {
                var a = pointers[i];
                for (var j = i + 1; j < pointers.length; j++) {
                    var b = pointers[j];
                    x = Math.abs(a.clientX - b.clientX);
                    y = Math.abs(a.clientY - b.clientY);
                    d = x + y;
                    if (d > dist) {
                        dist = d;
                        points = {
                            a: a,
                            b: b
                        };
                    }
                }
            }
            x = Math.abs(points.a.clientX + points.b.clientX) / 2;
            y = Math.abs(points.a.clientY + points.b.clientY) / 2;
            points.center = {
                x: x,
                y: y
            };
            points.diameter = dist;
            return points;
        },
        calcAngle: function(points) {
            var x = points.a.clientX - points.b.clientX;
            var y = points.a.clientY - points.b.clientY;
            return (360 + Math.atan2(y, x) * RAD_TO_DEG) % 360;
        }
    };
    dispatcher.registerGesture('pinch', pinch);
})(exports);
},{}],24:[function(require,module,exports){
'use strict';

module.exports = function(numRows) {

    var firstNames = ['Olivia', 'Sophia', 'Ava', 'Isabella', 'Boy', 'Liam', 'Noah', 'Ethan', 'Mason', 'Logan', 'Moe', 'Larry', 'Curly', 'Shemp', 'Groucho', 'Harpo', 'Chico', 'Zeppo', 'Stanley', 'Hardy'];
    var lastNames = ['Wirts', 'Oneil', 'Smith', 'Barbarosa', 'Soprano', 'Gotti', 'Columbo', 'Luciano', 'Doerre', 'DePena'];
    var months = ['01', '02', '03', '04', '05', '06', '07', '08', '09', '10', '11', '12'];
    var days = ['01', '02', '03', '04', '05', '06', '07', '08', '09', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '30'];
    var states = ['Alabama', 'Alaska', 'Arizona', 'Arkansas', 'California', 'Colorado', 'Connecticut', 'Delaware', 'Florida', 'Georgia', 'Hawaii', 'Idaho', 'Illinois', 'Indiana', 'Iowa', 'Kansas', 'Kentucky', 'Louisiana', 'Maine', 'Maryland', 'Massachusetts', 'Michigan', 'Minnesota', 'Mississippi', 'Missouri', 'Montana', 'Nebraska', 'Nevada', 'New Hampshire', 'New Jersey', 'New Mexico', 'New York', 'North Carolina', 'North Dakota', 'Ohio', 'Oklahoma', 'Oregon', 'Pennsylvania', 'Rhode Island', 'South Carolina', 'South Dakota', 'Tennessee', 'Texas', 'Utah', 'Vermont', 'Virginia', 'Washington', 'West Virginia', 'Wisconsin', 'Wyoming'];

    var randomFunc = Math.random;
    //var randomFunc = rnd;
    var randomPerson = function() {
        var firstName = Math.round((firstNames.length - 1) * randomFunc());
        var lastName = Math.round((lastNames.length - 1) * randomFunc());
        var pets = Math.round(10 * randomFunc());
        var birthyear = 1900 + Math.round(randomFunc() * 114);
        var birthmonth = Math.round(randomFunc() * 11);
        var birthday = Math.round(randomFunc() * 29);
        var birthstate = Math.round(randomFunc() * 49);
        var residencestate = Math.round(randomFunc() * 49);
        var travel = randomFunc() * 1000;
        var income = randomFunc() * 100000;
        var employed = Math.round(randomFunc());
        var person = {
            last_name: lastNames[lastName],
            //jshint ignore:line
            first_name: firstNames[firstName],
            //jshint ignore:line
            pets: pets,
            birthDate: birthyear + '-' + months[birthmonth] + '-' + days[birthday],
            birthState: states[birthstate],
            residenceState: states[residencestate],
            employed: employed === 1,
            income: income,
            travel: travel
        };
        return person;
    };

    var data = [];
    for (var i = 0; i < numRows; i++) {
        var person = randomPerson();
        person.order = i;
        data.push(person);
    }

    return data;

};
},{}],25:[function(require,module,exports){
'use strict';

module.exports = {
    JSDataSource: require('./js/DataSource'),
    DataSourceSorter: require('./js/DataSourceSorter'),
    DataSourceSorterComposite: require('./js/DataSourceSorterComposite'),
    DataSourceGlobalFilter: require('./js/DataSourceGlobalFilter'),
    DataSourceAggregator: require('./js/DataSourceAggregator'),
    DataSourceTreeview: require('./js/DataSourceTreeview'),
    DataNodeGroupSorter: require('./js/DataNodeGroupSorter'),
    util: {
        aggregations: require('./js/util/aggregations'),
        Mappy: require('./js/util/Mappy'),
        stableSort: require('./js/util/stableSort'),
        headerify: require('./js/util/headerify'),
        generateSampleData: require('./generateSampleData.js')
    }
};

},{"./generateSampleData.js":24,"./js/DataNodeGroupSorter":29,"./js/DataSource":32,"./js/DataSourceAggregator":33,"./js/DataSourceGlobalFilter":34,"./js/DataSourceSorter":36,"./js/DataSourceSorterComposite":37,"./js/DataSourceTreeview":38,"./js/util/Mappy":39,"./js/util/aggregations":40,"./js/util/headerify":41,"./js/util/stableSort":42}],26:[function(require,module,exports){
'use strict';

function Base() {}
Base.extend = require('extend-me');

Base.prototype.click = function() {
    if (this.dataSource) {
        return this.dataSource.click.apply(this.dataSource, arguments);
    }
};

Base.prototype.findRow = function() {
    if (this.dataSource) {
        return this.dataSource.findRow.apply(this.dataSource, arguments);
    }
};

Base.prototype.revealRow = function() {
    if (this.dataSource) {
        return this.dataSource.revealRow.apply(this.dataSource, arguments);
    }
};

Base.prototype.replaceIndent = '_';

Base.prototype.fixIndentForTableDisplay = function(string) {
    var count = string.search(/\S/);
    var end = string.substring(count);
    var result = Array(count + 1).join(this.replaceIndent) + end;
    return result;
};

Base.prototype.dump = function(max) {
    max = Math.min(this.getRowCount(), max || Math.max(100, this.getRowCount()));
    var data = [];
    var fields = this.getHeaders();
    var cCount = this.getColumnCount();
    var viewMakesSense = this.viewMakesSense;
    for (var r = 0; r < max; r++) {
        var row = {};
        for (var c = 0; c < cCount; c++) {
            var val = this.getValue(c, r);
            if (c === 0 && viewMakesSense) {
                val = this.fixIndentForTableDisplay(val);
            }
            row[fields[c]] = val;
        }
        data[r] = row;
    }
    console.table(data);
};

module.exports = Base;

},{"extend-me":7}],27:[function(require,module,exports){
'use strict';

var Base = require('./Base');

/**
 * See {@link DataBaseNode#initialize|initialize()} method for parameters.
 * @constructor
 */
var DataNodeBase = Base.extend('DataNodeBase', {

    isNullObject: false,

    INDENT: '   ', // 3 spaces

    /**
     * @memberOf DataNodeBase.prototype
     * @param {string} key
     */
    initialize: function(key) {
        /**
         * @memberOf DataNodeBase.prototype
         * @type {string}
         */

        this.label = key;

        /**
         * @memberOf DataNodeBase.prototype
         * @type {string[]}
         * @default false
         */
        this.data = ['']; // TODO: Why is this first element needed?

        /**
         * @memberOf DataNodeBase.prototype
         * @type {number[]}
         * @default ['']
         */
        this.index = []; // TODO: formerly rowIndex

        /**
         * @memberOf DataNodeBase.prototype
         * @type {boolean}
         * @default false
         */
        this.hasChildren = false; // TODO: Where/how is this used?

        /**
         * @memberOf DataNodeBase.prototype
         * @type {number}
         * @default 0
         */
        this.depth = 0;

        /**
         * @memberOf DataNodeBase.prototype
         * @type {number}
         * @default 1
         */
        this.height = 1;

        /**
         * @memberOf DataNodeBase.prototype
         * @type {boolean}
         * @default false
         */
        this.expanded = false;
    },

    /**
     * @memberOf DataNodeLeaf.prototype
     * @param x
     * @returns {*}
     */
    getValue: function(x) {
        return this.data[x];
    },

    /**
     * @memberOf DataNodeLeaf.prototype
     * @param depth
     */
    toArray: function(depth) {
        this.depth = depth;
        this.data[0] = this.computeDepthString();
    },

    /**
     * @memberOf DataNodeLeaf.prototype
     * @returns {string}
     */
    computeDepthString: function() {
        return Array(this.depth + 1).join(this.INDENT) + '  ' + this.label;
    },

    /**
     * @memberOf DataNodeLeaf.prototype
     * @returns {number}
     */
    computeHeight: function() {
        return 1;
    },

    /**
     * @memberOf DataNodeLeaf.prototype
     * @returns {Array}
     */
    getIndex: function() { // TODO: formerly getAllRowIndexes
        return this.index;
    },

    /**
     * @memberOf DataNodeLeaf.prototype
     * @param aggregator
     */
    computeAggregates: function(aggregator) {
        var index = this.getIndex();

        if (index.length) {
            var groupsOffset = Number(aggregator.hasGroups());

            // redimension the data
            var data = this.data;
            data.length = groupsOffset + aggregator.aggregates.length;

            var sorter = aggregator.sorterInstance;
            sorter.index = index;

            aggregator.aggregates.forEach(function(aggregate, i) {
                data[groupsOffset + i] = aggregate(sorter);
            });
        }
    },

    /**
     * @memberOf DataNodeLeaf.prototype
     * @param aggregator
     */
    buildView: function(aggregator) {
        aggregator.addView(this);
    },

    /**
     * @memberOf DataNodeLeaf.prototype
     */
    toggleExpansionState: function() { /* aggregator */
        //do nothing by default
    },

    sortGroups: function(groupSorter) {
    }
});

//DataNodeBase.prototype.applyAggregates = DataNodeBase.prototype.computeAggregates;

module.exports = DataNodeBase;

},{"./Base":26}],28:[function(require,module,exports){
'use strict';

var Map = require('./util/Mappy');
var DataNodeBase = require('./DataNodeBase');

var expandedMap = {
    true: '\u25bc', // BLACK DOWN-POINTING TRIANGLE aka ''
    false: '\u25b6' // BLACK RIGHT-POINTING TRIANGLE aka ''
};

/**
 * > See {@link DataNodeGroup#initialize|initialize()} method for constructor parameters.
 * @constructor
 * @extends DataNodeBase
 */
var DataNodeGroup = DataNodeBase.extend('DataNodeGroup', {

    extendable: true,

    /**
     * @memberOf DataNodeGroup.prototype
     * @param key
     */
    initialize: function(key) {
        this.children = new Map();
    },

    /**
     * @memberOf DataNodeGroup.prototype
     * @param depth
     */
    toArray: function(depth) {
        this.depth = depth;
        this.children = this.children.values;
        this.children.forEach(function(child) {
            child.toArray(depth + 1);
        });
        this.data[0] = this.computeDepthString();
    },

    /**
     * @memberOf DataNodeGroup.prototype
     * @returns {string}
     */
    computeDepthString: function() {
        var string = Array(this.depth + 1).join(this.INDENT) +
            expandedMap[this.expanded] + ' ' +
            this.label;
        return string;
    },

    /**
     * @memberOf DataNodeGroup.prototype
     * @returns {*}
     */
    getIndex: function() {
        if (this.index.length === 0) {
            this.index = this.computeIndex();
        }
        return this.index;
    },

    /**
     * @memberOf DataNodeGroup.prototype
     * @returns {Array}
     */
    computeIndex: function() { // TODO: formerly computeAllRowIndexes
        var result = [];
        result.append = append;
        this.children.forEach(function(child) {
            result.append(child.getIndex());
        });
        return result;
    },

    /**
     * @memberOf DataNodeGroup.prototype
     * @param aggregator
     * @param {boolean} [expand] - One of:
     * * `true` - Expand all rows that are currently collapsed.
     * * `false` - Collapse all rows that are currently expanded.
     * * `undefined` (or omitted) - Expand all currently collapsed rows; collapse all currently expanded rows.
     * @returns {boolean} If this call resulted in a state change.
     */
    toggleExpansionState: function(aggregator, expand) { /* aggregator */
        if (expand === undefined) {
            expand = !this.expanded;
        }
        var changed = this.expanded ^ expand;
        this.expanded = expand;
        this.data[0] = this.computeDepthString();
        if (this.expanded) {
            this.computeAggregates(aggregator);
        }
        return !!changed;
    },

    /**
     * @memberOf DataNodeGroup.prototype
     * @param aggregator
     */
    computeAggregates: function(aggregator) {
        DataNodeBase.prototype.computeAggregates.call(this, aggregator); // call base class's version
        if (this.expanded) {
            this.children.forEach(function(child) {
                child.computeAggregates(aggregator);
            });
        }
    },

    /**
     * @memberOf DataNodeGroup.prototype
     * @param aggregator
     */
    buildView: function(aggregator) {
        aggregator.view.push(this);
        if (this.expanded) {
            this.children.forEach(function(child) {
                child.buildView(aggregator);
            });
        }
    },

    /**
     * @memberOf DataNodeGroup.prototype
     * @returns {number}
     */
    computeHeight: function() {
        var height = 1;

        if (this.expanded) {
            this.children.forEach(function(child) {
                height = height + child.computeHeight();
            });
        }

        return (this.height = height);
    },

    sortWith: function(sorter) {
        if (this.expanded) {
            sorter.sortGroup(this);
            this.children.forEach(function(child) {
                child.sortWith(sorter);
            });
        }
    },
    clearGroupSorts: function() {
        if (this.originalOrder) {
            for (var i = 0; i < this.originalOrder.length; i++) {
                this.children[i] = this.originalOrder[i];
            }
        }
        this.children.forEach(function(child) {
            child.clearGroupSorts();
        });
    }

});

/**
 * @private
 * @summary Array mixin to append another array to end of `this` one.
 * @desc Appends in place, unlike `this.concat()` which creates a new array.
 * Uses less memory than concat, important when `appendix` is huge.
 * > CAUTION: Mutates `this` array!
 * @param {Array} appendix
 * @returns {Array} Reference to `this` (for convenience)
 */
function append(appendix) {
    this.splice.bind(this, this.length, 0).apply(this, appendix);
    return this;
}

module.exports = DataNodeGroup;

},{"./DataNodeBase":27,"./util/Mappy":39}],29:[function(require,module,exports){
'use strict';

var Base = require('./Base');
var stableSort = require('./util/stableSort').sort;

/**
 * @constructor
 * @extends DataSourceIndexed
 */
var DataNodeGroupSorter = Base.extend('DataNodeGroupSorter', {

    /**
     * @memberOf DataSourceSorterComposite.prototype
     */
    initialize: function(dataSource) {
        this.dataSource = dataSource;
        this.sorts = [];

    },

    /**
     * @memberOf DataSourceSorterComposite.prototype
     * @param {number} y
     * @returns {Object}
     */
    getRow: function(y) {
        return this.last.getRow(y);
    },

    /**
     * @memberOf DataSourceSorterComposite.prototype
     * @param columnIndex
     * @param direction
     */
    sortOn: function(columnIndex, direction) {
        this.sorts.push({ columnIndex: columnIndex, direction: direction });
    },

    setSorts: function(sorts) {
        this.sorts = sorts || [];
    },

    /**
     * @memberOf DataSourceSorterComposite.prototype
     */
    apply: function() {
        this.dataSource.sortGroups(this);
    },

    /**
     * @memberOf DataSourceSorterComposite.prototype
     */
    clearSorts: function() {
        this.sorts.length = 0;
        this.dataSource.buildView();
    },

    sortGroup: function(group) {
        if (!group.originalOrder) {
            group.originalOrder = group.children.slice(0);
        }
        var sorts = this.sorts;
        for (var i = sorts.length - 1; i >= 0; i--) {
            this.sortGroupOnEach(group, sorts[sorts.length - i - 1]);
        }
    },

    sortGroupOnEach: function(group, sortSpec) {
        // we actually sort the children here....
        var children = group.children.slice(0);
        var indexVector = [];

        for (var i = 0; i < children.length; i++) {
            indexVector[i] = i;
        }

        stableSort(indexVector, function(rowNumber) {
            var child = children[rowNumber];
            if (sortSpec.columnIndex === 0) {
                return child.label;
            }
            return child.data[sortSpec.columnIndex];
        }, sortSpec.direction);

        for (i = 0; i < children.length; i++) {
            group.children[i] = children[indexVector[i]];
        }
    }

});

DataNodeGroupSorter.prototype.applySorts = function() {
    (console.warn || console.log).call(console, 'applySorts deprecated; use apply');
    this.apply();
};

module.exports = DataNodeGroupSorter;

},{"./Base":26,"./util/stableSort":42}],30:[function(require,module,exports){
'use strict';

var DataNodeBase = require('./DataNodeBase');

/**
 * @constructor
 * @extends DataNodeBase
 */
var DataNodeLeaf = DataNodeBase.extend('DataNodeLeaf', {

    /**
     * @memberOf DataNodeLeaf.prototype
     * @param depth
     */
    toArray: function(depth) {
        this.depth = depth;
        this.data[0] = this.computeDepthString();
    },

    /**
     * @memberOf DataNodeLeaf.prototype
     * @returns {numer[]}
     */
    getIndex: function() {
        return this.index;
    },

    /**
     * @memberOf DataNodeLeaf.prototype
     * @param aggregator
     */
    buildView: function(aggregator) {
        aggregator.addView(this);
    },

    /**
     * @memberOf DataNodeLeaf.prototype
     * @returns {number}
     */
    computeHeight: function() {
        return 1;
    },

    sortWith: function(sorter) {
      // do nothing we have no children to sort
    },

    clearGroupSorts: function() {
      // do nothing we have no children to sort
    }

});

module.exports = DataNodeLeaf;

},{"./DataNodeBase":27}],31:[function(require,module,exports){
'use strict';

var DataNodeGroup = require('./DataNodeGroup');

/**
 * See {@link DataNodeGroup#initialize|initialize()} method for parameters.
 * @constructor
 * @extends DataNodeGroup
 */
var DataNodeTree = DataNodeGroup.extend('DataNodeTree', {

    /**
     * @memberOf DataNodeGroup.prototype
     * @param {string} key
     */
    initialize: function(key) {
        this.height = 0;
        this.expanded = true;
    },

    /**
     * @memberOf DataNodeGroup.prototype
     */
    toArray: function() {
        this.children = this.children.values;
        this.children.forEach(function(child) {
            child.toArray(0);
        });
    },

    /**
     * @memberOf DataNodeGroup.prototype
     * @param aggregator
     */
    buildView: function(aggregator) {
        this.children.forEach(function(child) {
            child.buildView(aggregator);
        });
    },

    /**
     * @memberOf DataNodeGroup.prototype
     * @returns {number}
     */
    computeHeight: function() {
        var height = 1;

        this.children.forEach(function(child) {
            height = height + child.computeHeight();
        });

        return (this.height = height);
    }

});

module.exports = DataNodeTree;

},{"./DataNodeGroup":28}],32:[function(require,module,exports){
'use strict';

var Base = require('./Base');
var headerify = require('./util/headerify');

/**
 * @constructor
 * @param {object[]} data
 * @param {string[]} fields
 */
var DataSource = Base.extend('DataSource', {
    initialize: function(data, fields) {
        /**
         * @type {string[]}
         */
        this.fields = fields || computeFieldNames(data[0]);

        /**
         * @type {object[]}
         */
        this.data = data;
    },

    isNullObject: false,

    getDataIndex: function(y) {
        return y;
    },

    /**
     * @memberOf DataSource.prototype
     * @param y
     * @returns {object[]}
     */
    getRow: function(y) {
        return this.data[y];
    },

    findRow: function(columnName, value) {
        var result;
        if (value != null) {
            result = this.data.find(function(row) { return row[columnName] === value; });
        }
        return result;
    },

    /**
     * @memberOf DataSource.prototype
     * @param x
     * @param y
     * @returns {*}
     */
    getValue: function(x, y) {
        var row = this.getRow(y);
        if (!row) {
            return null;
        }
        return row[this.fields[x]];
    },

    /**
     * @memberOf DataSource.prototype
     * @param {number} x
     * @param {number} y
     * @param value
     */
    setValue: function(x, y, value) {
        this.getRow(y)[this.fields[x]] = value;
    },

    /**
     * @memberOf DataSource.prototype
     * @returns {number}
     */
    getRowCount: function() {
        return this.data.length;
    },

    /**
     * @memberOf DataSource.prototype
     * @returns {number}
     */
    getColumnCount: function() {
        return this.getFields().length;
    },

    /**
     * @memberOf DataSource.prototype
     * @returns {number[]}
     */
    getFields: function() {
        return this.fields;
    },

    /**
     * @memberOf DataSource.prototype
     * @returns {string[]}
     */
    getHeaders: function() {
        return (
            this.headers = this.headers || this.getDefaultHeaders().map(function(each) {
                return headerify.transform(each);
            })
        );
    },

    /**
     * @memberOf DataSource.prototype
     * @returns {string[]}
     */
    getDefaultHeaders: function() {
        return this.getFields();
    },

    /**
     * @memberOf DataSource.prototype
     * @param {string[]} fields
     */
    setFields: function(fields) {
        this.fields = fields;
    },

    /**
     * @memberOf DataSource.prototype
     * @param {string[]} headers
     */
    setHeaders: function(headers) {
        if (!(headers instanceof Array)) {
            error('setHeaders', 'param #1 `headers` not array');
        }
        this.headers = headers;
    },

    /**
     * @memberOf DataSource.prototype
     */
    getGrandTotals: function() {
        //nothing here
    },

    /**
     * @memberOf DataSource.prototype
     * @param arrayOfUniformObjects
     */
    setData: function(arrayOfUniformObjects) {
        this.data = arrayOfUniformObjects;
    }
});

function error(methodName, message) {
    throw new Error('DataSource.' + methodName + ': ' + message);
}

/**
 * @private
 * @param {object} object
 * @returns {string[]}
 */
function computeFieldNames(object) {
    if (!object) {
        return [];
    }
    return Object.getOwnPropertyNames(object || []).filter(function(e) {
        return e.substr(0, 2) !== '__';
    });
}

module.exports = DataSource;

},{"./Base":26,"./util/headerify":41}],33:[function(require,module,exports){
'use strict';

var Base = require('./Base');
var DataSourceSorter = require('./DataSourceSorter');
var DataNodeTree = require('./DataNodeTree');
var DataNodeGroup = require('./DataNodeGroup');
var DataNodeLeaf = require('./DataNodeLeaf');
var headerify = require('./util/headerify');

/**
 * @constructor
 * @param {DataSource} dataSource
 */
var DataSourceAggregator = Base.extend('DataSourceAggregator', {
    initialize: function(dataSource) {

        /**
         * @memberOf DataSourceAggregator.prototype
         * @type {DataSource}
         */
        this.dataSource = dataSource;

        /**
         * @memberOf DataSourceAggregator.prototype
         * @type {DataNodeTree}
         */
        this.tree = new DataNodeTree('Totals');

        /**
         * @memberOf DataSourceAggregator.prototype
         * @type {number[]}
         * @default []
         */
        this.index = [];

        /**
         * @memberOf DataSourceAggregator.prototype
         * @type {Array}
         * @default []
         */
        this.aggregates = [];

        /**
         * @memberOf DataSourceAggregator.prototype
         * @type {Array}
         * @default []
         */
        this.groupBys = [];

        /**
         * @memberOf DataSourceAggregator.prototype
         * @type {Array}
         * @default []
         */
        this.view = [];

        /**
         * @memberOf DataSourceAggregator.prototype
         * @type {object}
         * @default {}
         */
        this.sorterInstance = {};

        /**
         * @memberOf DataSourceAggregator.prototype
         * @type {boolean}
         * @default true
         */
        this.presortGroups = true;

        /**
         * @memberOf DataSourceAggregator.prototype
         * @type {object}
         * @default {}
         */
        this.lastAggregate = {};

        this.setAggregates({});
    },

    isNullObject: false,

    /**
     * @memberOf DataSourceAggregator.prototype
     * @param aggregations
     */
    setAggregates: function(aggregations) {
        this.lastAggregate = aggregations;
        this.clearAggregations();

        for (var key in aggregations) {
            this.addAggregate(key, aggregations[key]);
        }

    },

    getFields: function() {
        if (!this.viewMakesSense()) {
            return this.dataSource.getFields();
        }
        var fields = this.getHeaders().map(function(e) {
            return e.toLowerCase().split(' ').join('_');
        });
        return fields;
    },

    getHeaders: function() {
        if (!this.viewMakesSense()) {
            return this.dataSource.getHeaders();
        }
        var headers = this.aggregates.map(function(e) {
            return e.header;
        });
        if (this.hasGroups()) {
            headers.unshift('Tree');
        }
        return headers;
    },
    /**
     * @memberOf DataSourceAggregator.prototype
     * @param label
     * @param func
     */
    addAggregate: function(label, func) {
        func.header = headerify.transform(label);
        this.aggregates.push(func);
    },

    /**
     * @memberOf DataSourceAggregator.prototype
     * @param columnIndexArray
     */
    setGroupBys: function(columnIndexArray) {
        var groupBys = this.groupBys;
        groupBys.length = 0;
        columnIndexArray.forEach(function(columnIndex) {
            groupBys.push(columnIndex);
        });
        this.setAggregates(this.lastAggregate);
    },

    /**
     * @memberOf DataSourceAggregator.prototype
     * @param index
     */
    addGroupBy: function(index) {
        this.groupBys.push(index);
    },

    /**
     * @memberOf DataSourceAggregator.prototype
     * @returns {boolean}
     */
    hasGroups: function() {
        return !!this.groupBys.length;
    },

    /**
     * @memberOf DataSourceAggregator.prototype
     * @returns {boolean}
     */
    hasAggregates: function() {
        return !!this.aggregates.length;
    },

    /**
     * @memberOf DataSourceAggregator.prototype
     */
    apply: function() {
        this.buildGroupTree();
    },

    /**
     * @memberOf DataSourceAggregator.prototype
     */
    clearGroups: function() {
        this.groupBys.length = 0;
    },

    /**
     * @memberOf DataSourceAggregator.prototype
     */
    clearAggregations: function() {
        this.aggregates.length = 0;
    },

    /**
     * @memberOf DataSourceAggregator.prototype
     */
    buildGroupTree: function() {
        var reversedGroupBys = this.groupBys.slice(0).reverse(),
            leafDepth = this.groupBys.length - 1,
            source = this.dataSource,
            rowCount = source.getRowCount(),
            tree = this.tree = new DataNodeTree('Totals');

        // first sort data
        if (this.presortGroups) {
            reversedGroupBys.forEach(function(groupBy) {
                source = new DataSourceSorter(source);
                source.sortOn(groupBy);
            });
        }

        for (var r = 0; r < rowCount; r++) {
            var path = tree;

            this.groupBys.forEach(function(g, c) { // eslint-disable-line no-loop-func
                var key = source.getValue(g, r),
                    factoryDataNode = (c === leafDepth) ? factoryDataNodeLeaf : factoryDataNodeGroup;
                path = path.children.getIfUndefined(key, factoryDataNode);
            });

            path.index.push(r);
        }

        this.sorterInstance = new DataSourceSorter(source);
        tree.toArray();
        tree.computeAggregates(this);
        this.buildView();
    },

    /**
     * @memberOf DataSourceAggregator.prototype
     * @param dataNode
     */
    addView: function(dataNode) {
        this.view.push(dataNode);
    },

    /**
     * @memberOf DataSourceAggregator.prototype
     */
    buildView: function() {
        this.view.length = 0;
        this.tree.computeHeight();
        this.tree.buildView(this);
    },

    /**
     * @memberOf DataSourceAggregator.prototype
     * @returns {*|boolean}
     */
    viewMakesSense: function() {
        return this.hasAggregates() && this.hasGroups();
    },

    getDataIndex: function(y) {
        return this.viewMakesSense() ? y : this.dataSource.getDataIndex(y);
    },

    /**
     * @memberOf DataSourceAggregator.prototype
     * @param x
     * @param y
     * @returns {*}
     */
    getValue: function(x, y) {
        if (!this.viewMakesSense()) {
            return this.dataSource.getValue(x, y);
        }
        var row = this.view[y];
        return row ? row.getValue(x) : null;
    },

    /**
     * @memberOf DataSourceAggregator.prototype
     * @param x
     * @param y
     * @param value
     * @returns {*}
     */
    setValue: function(x, y, value) {
        if (!this.viewMakesSense()) {
            return this.dataSource.setValue(x, y, value);
        }
    },

    /**
     * @memberOf DataSourceAggregator.prototype
     * @returns {*}
     */
    getColumnCount: function() {
        if (!this.viewMakesSense()) {
            return this.dataSource.getColumnCount();
        }
        return this.getHeaders().length;
    },

    /**
     * @memberOf DataSourceAggregator.prototype
     * @returns {*}
     */
    getRowCount: function() {
        if (!this.viewMakesSense()) {
            return this.dataSource.getRowCount();
        }
        return this.view.length; //header column
    },

    /**
     * @memberOf DataSourceAggregator.prototype
     * @param y
     * @param {boolean} [expand] - One of:
     * * `true` - Expand all rows that are currently collapsed.
     * * `false` - Collapse all rows that are currently expanded.
     * * `undefined` (or omitted) - Expand all currently collapsed rows; collapse all currently expanded rows.
     * @param {number} [depth=Infinity] - One of:
     * * number > 0 - Apply only if row depth is above the given depth.
     * * number <= 0 - Apply only if row depth is below the given depth.
     * @returns {undefined|boolean} One of:
     * * `undefined` - row was not expandable
     * * `true` - row was expandable _and_ state changed
     * * `false` - row was expandable _but_ state did _not_ change
     */
    click: function(y, expand, depth) {
        if (!this.viewMakesSense()) {
            return this.dataSource.click.apply(this.dataSource, arguments);
        }
        var group = this.view[y], expandable, changed;
        if (
            group && (
                depth === undefined ||
                depth > 0 && group.depth < depth ||
                depth <= 0 && group.depth >= -depth
            )
        ) {
            changed = group.toggleExpansionState(this, expand);
            if ((expandable = group.children)) {
                this.buildView();
            }
        }

        return expandable ? changed : undefined;
    },

    /**
     * @memberOf DataSourceAggregator.prototype
     * @param headers
     */
    setHeaders: function(headers) {
        this.dataSource.setHeaders(headers);
    },

    /**
     * @memberOf DataSourceAggregator.prototype
     * @param fields
     * @returns {*}
     */
    setFields: function(fields) {
        return this.dataSource.setFields(fields);
    },

    /**
     * @memberOf DataSourceAggregator.prototype
     * @returns {object[]}
     */
    getGrandTotals: function() {
        var view = this.tree;
        return [view.data];
    },

    /**
     * @memberOf DataSourceAggregator.prototype
     * @param y
     * @returns {*}
     */
    getRow: function(y) {
        if (!this.viewMakesSense()) {
            return this.dataSource.getRow(y);
        }

        var rollups = this.view[y];

        return rollups ? rollups : this.tree;
    },

    /**
     * @memberOf DataSourceAggregator.prototype
     * @param arrayOfUniformObjects
     */
    setData: function(arrayOfUniformObjects) {
        this.dataSource.setData(arrayOfUniformObjects);
        this.apply();
    },

    sortGroups: function(groupSorter) {
        this.tree.clearGroupSorts();
        this.tree.sortWith(groupSorter);
        this.buildView();
    }
});

function factoryDataNodeLeaf(key) {
    return new DataNodeLeaf(key);
}

function factoryDataNodeGroup(key) {
    return new DataNodeGroup(key);
}

module.exports = DataSourceAggregator;

},{"./Base":26,"./DataNodeGroup":28,"./DataNodeLeaf":30,"./DataNodeTree":31,"./DataSourceSorter":36,"./util/headerify":41}],34:[function(require,module,exports){
'use strict';

var DataSourceIndexed = require('./DataSourceIndexed');

/**
 * @typedef {function} filterFunction
 * @param cellValue
 * @param {object} rowObject - Reference to `this.dataSource.data[r]`.
 * @param {number} r - Row number (index within `this.dataSource.data`).
 */

/**
 * @constructor
 * @extends DataSourceIndexed
 */
var DataSourceGlobalFilter = DataSourceIndexed.extend('DataSourceGlobalFilter', {

    /**
     *
     * @memberOf DataSourceGlobalFilter.prototype
     * @param {object} [filter] - If undefined, deletes filter.
     */
    set: function(filter) {
        if (filter) {
            /**
             * @type {filterFunction}
             * @memberOf DataSourceGlobalFilter.prototype
             */
            this.filter = filter;
        } else {
            delete this.filter;
        }
    },

    get: function(filter) {
        return this.filter;
    },

    /**
     *
     * @memberOf DataSourceGlobalFilter.prototype
     */
    apply: function() {
        if (!this.filter) {
            this.clearIndex();
        } else {
            this.buildIndex(function applyFilter(r, rowObject) {
                return this.filter.test(rowObject);
            });
        }
    },

    /**
     *
     * @memberOf DataSourceGlobalFilter.prototype
     * @returns {number}
     */
    getRowCount: function() {
        return this.filter ? this.index.length : this.dataSource.getRowCount();
    }
});

module.exports = DataSourceGlobalFilter;

},{"./DataSourceIndexed":35}],35:[function(require,module,exports){
'use strict';

var Base = require('./Base');

/**
 * @constructor
 */
var DataSourceIndexed = Base.extend('DataSourceIndexed', {

    /**
     *
     */
    isNullObject: false,

    /**
     * @memberOf DataSourceIndexed.prototype
     * @param dataSource
     */
    initialize: function(dataSource) {
        this.dataSource = dataSource;
        this.index = [];
    },

    /**
     * @memberOf DataSourceIndexed.prototype
     * @param y
     * @returns {*}
     */
    transposeY: function(y) {
        return this.index.length ? this.index[y] : y;
    },

    getDataIndex: function(y) {
        return this.dataSource.getDataIndex(this.transposeY(y));
    },

    /**
     * @memberOf DataSourceIndexed.prototype
     * @param y
     * @returns {object}
     */
    getRow: function(y) {
        return this.dataSource.getRow(this.transposeY(y));
    },

    /**
     * @memberOf DataSourceIndexed.prototype
     * @param x
     * @param y
     * @returns {*|Mixed}
     */
    getValue: function(x, y) {
        return this.dataSource.getValue(x, this.transposeY(y));
    },

    /**
     * @memberOf DataSourceIndexed.prototype
     * @param {number} x
     * @param {number} y
     * @param {*} value
     */
    setValue: function(x, y, value) {
        this.dataSource.setValue(x, this.transposeY(y), value);
    },

    /**
     * @memberOf DataSourceIndexed.prototype
     * @returns {Number|*}
     */
    getRowCount: function() {
        return this.index.length || this.dataSource.getRowCount();
    },

    /**
     *
     * @returns {*}
     */
    getColumnCount: function() {
        return this.dataSource.getColumnCount();
    },

    /**
     * @memberOf DataSourceIndexed.prototype
     * @returns {*}
     */
    getFields: function() {
        return this.dataSource.getFields();
    },

    /**
     * @memberOf DataSourceIndexed.prototype
     * @param fields
     * @returns {*}
     */
    setFields: function(fields) {
        return this.dataSource.setFields(fields);
    },

    /**
     * @memberOf DataSourceIndexed.prototype
     * @param {string[]} headers
     * @returns {string[]}
     */
    setHeaders: function(headers) {
        return this.dataSource.setHeaders(headers);
    },

    /**
     *
     * @returns {string[]}
     */
    getHeaders: function() {
        return this.dataSource.getHeaders();
    },

    /**
     * @memberOf DataSourceIndexed.prototype
     * @returns {*}
     */
    getGrandTotals: function() {
        return this.dataSource.getGrandTotals();
    },

    /**
     * @memberOf DataSourceIndexed.prototype
     * @param {object[]} arrayOfUniformObjects
     * @returns {object[]}
     */
    setData: function(arrayOfUniformObjects) {
        return this.dataSource.setData(arrayOfUniformObjects);
    },

    /**
     * @memberOf DataSourceIndexed.prototype
     */
    clearIndex: function() {
        this.index.length = 0;
    },

    /**
     * @memberOf DataSourceIndexed.prototype
     * @param {filterPredicate} predicate
     * @returns {number[]}
     */
    buildIndex: function(predicate) {
        var rowCount = this.dataSource.getRowCount(),
            index = this.index;

        this.clearIndex();

        for (var r = 0; r < rowCount; r++) {
            if (!predicate || predicate.call(this, r, this.dataSource.getRow(r))) {
                index.push(r);
            }
        }

        return index;
    }
});

/** @typedef {function} filterPredicate
 * @summary Applies filter to given row.
 * @param {nubmer} r - Row index of row data within rows array `this.dataSource.data[]`.
 * @param {object} rowObject - Row data; element of `this.dataSource.data[]`.
 * @returns {boolean} Row qualifies (passes through filter).
 */

module.exports = DataSourceIndexed;

},{"./Base":26}],36:[function(require,module,exports){
'use strict';

var DataSourceIndexed = require('./DataSourceIndexed');
var stableSort = require('./util/stableSort');

/**
 * @constructor
 * @extends DataSourceIndexed
 */
var DataSourceSorter = DataSourceIndexed.extend('DataSourceSorter', {

    /**
     * @memberOf DataSourceSorter.prototype
     */
    initialize: function() {
        /**
         * @memberOf DataSourceSorter.prototype
         * @type {boolean}
         */
        this.descendingSort = false; // TODO: this does not seem to be in use
    },

    /**
     * @memberOf DataSourceSorter.prototype
     * @param {number} columnIndex
     * @param {number} [direction=1]
     */
    sortOn: function(columnIndex, direction) {
        var dataSource = this.dataSource,
            columnName = dataSource.getFields()[columnIndex];

        switch (direction) {
            case 0:
                this.clearIndex();
                break;

            case undefined:
            case 1:
            case -1:
                stableSort.sort(this.buildIndex(), getValue, direction);
                break;
        }

        function getValue(rowIdx) {
            return valOrFunc(dataSource.getRow(rowIdx), columnName);
        }
    }
});

/**
 * @private
 * @param {*|function} valOrFunc
 * @returns {*}
 */
function valOrFunc(dataRow, columnName) {
    var vf = dataRow[columnName];
    return (typeof vf)[0] === 'f' ? vf(dataRow, columnName) : vf;
}

module.exports = DataSourceSorter;

},{"./DataSourceIndexed":35,"./util/stableSort":42}],37:[function(require,module,exports){
'use strict';

var DataSourceIndexed = require('./DataSourceIndexed');
var DataSourceSorter = require('./DataSourceSorter');

/**
 * @constructor
 * @extends DataSourceIndexed
 */
var DataSourceSorterComposite = DataSourceIndexed.extend('DataSourceSorterComposite', {

    /**
     * @memberOf DataSourceSorterComposite.prototype
     */
    initialize: function() {
        /**
         * Caveats:
         *
         * 1. Columns should be uniquely represented (i.e., no repeats with same columnIndex)
         * 2. Columns should be added low- to high-order (i.e., most grouped columns come last)
         *
         * @type {number[]}
         * @memberOf DataSourceSorterComposite.prototype
         */
        this.sorts = [];

        /**
         * @type {DataSource}
         * @memberOf DataSourceSorterComposite.prototype
         */
        this.last = this.dataSource;
    },

    /**
     * @memberOf DataSourceSorterComposite.prototype
     * @param {number} y
     * @returns {Object}
     */
    getRow: function(y) {
        return this.last.getRow(y);
    },

    /**
     * @memberOf DataSourceSorterComposite.prototype
     * @param columnIndex
     * @param direction
     */
    sortOn: function(columnIndex, direction) {
        this.sorts.push({ columnIndex: columnIndex, direction: direction });
    },

    setSorts: function(sorts) {
        this.sorts = sorts || [];
    },

    /**
     * @memberOf DataSourceSorterComposite.prototype
     */
    apply: function() {
        var each = this.dataSource;

        this.sorts.forEach(function(sortSpec) {
            each = new DataSourceSorter(each);
            each.sortOn(sortSpec.columnIndex, sortSpec.direction);
        });

        this.last = each;
    },

    /**
     * @memberOf DataSourceSorterComposite.prototype
     */
    clearSorts: function() {
        this.sorts.length = 0;
        this.last = this.dataSource;
    },

    getDataIndex: function(y) {
        return this.last.getDataIndex(y);
    },

    /**
     * @memberOf DataSourceSorterComposite.prototype
     * @param {number} x
     * @param {number} y
     * @returns {*}
     */
    getValue: function(x, y) {
        return this.last.getValue(x, y);
    },

    /**
     * @memberOf DataSourceSorterComposite.prototype
     * @param {number} x
     * @param {number} y
     * @param {*} value
     */
    setValue: function(x, y, value) {
        this.last.setValue(x, y, value);
    }
});

DataSourceSorterComposite.prototype.applySorts = function() {
    (console.warn || console.log).call(console, 'applySorts deprecated; use apply');
    this.apply();
};

module.exports = DataSourceSorterComposite;

},{"./DataSourceIndexed":35,"./DataSourceSorter":36}],38:[function(require,module,exports){
'use strict';

var DataSourceIndexed = require('./DataSourceIndexed');

var expandedMap = {
    true: '\u25bc ', // BLACK DOWN-POINTING TRIANGLE aka ''
    false: '\u25b6 ', // BLACK RIGHT-POINTING TRIANGLE aka ''
    undefined: '  ' // for leaf rows
};


/**
 * @constructor
 * @extends DataSourceIndexed
 */
var DataSourceTreeview = DataSourceIndexed.extend('DataSourceTreeview', {

    /**
     * @summary Toggle the tree-view.
     * @desc Calculates or recalculates nesting depth of each row and marks it as expandable if it has children.
     *
     * If resetting previously set data, the state of expansion of all rows that still have children is retained.
     *
     * All three named columns must exist.
     *
     * @param {boolean|object} [options] - Turn tree-view **ON**. If falsy (or omitted), turn it **OFF**.
     * @param {string} [options.idColumnName='ID'] - Column name of the primary key column.
     * @param {string} [options.parentIdColumnName='parentID'] - Column name of the foreign key column for grouping.
     * @param {string} [options.treeColumnName='name'] - Column name of the drill-down column to decorate.
     * @returns {boolean} Joined state.
     * @memberOf DataSourceTreeview.prototype
     */
    setRelation: function(options) {
        var idColumnName, parentIdColumnName, treeColumnName, fields,
            rowCount, r, parentID, depth, leafRow, row, ID;

        this.joined = false;

        if (options) {
            fields = this.getFields();
            idColumnName = options.idColumnName || 'ID';
            parentIdColumnName = options.parentIdColumnName || 'parentID';
            treeColumnName = options.treeColumnName || 'name';

            if ( // all three columns must exist
                fields.indexOf(idColumnName) >= 0 &&
                fields.indexOf(parentIdColumnName) >= 0 &&
                fields.indexOf(treeColumnName) >= 0
            ) {
                this.idColumnName = idColumnName;
                this.idColumnIndex = fields.indexOf(idColumnName);

                this.parentIdColumnName = parentIdColumnName;
                this.parentIdColumnIndex = fields.indexOf(parentIdColumnName);

                this.treeColumnName = treeColumnName;
                this.treeColumnIndex = fields.indexOf(treeColumnName);

                this.joined = this.treeColumnIndex !== undefined;
            }
        }

        this.buildIndex(); // make all rows visible to getRow()

        if (this.joined) {
            // mutate data row with __DEPTH (all rows) and __EXPANDED (all "parent" rows)
            rowCount = this.getRowCount();
            r = rowCount;
            while (r--) {
                depth = 0;
                leafRow = this.getRow(r);
                row = leafRow;
                ID = row[idColumnName];

                while ((parentID = row[parentIdColumnName]) != undefined) { // eslint-disable-line eqeqeq
                    row = this.findRow(idColumnName, parentID);
                    ++depth;
                }

                leafRow.__DEPTH = depth;

                if (!this.findRow(parentIdColumnName, ID)) {
                    delete leafRow.__EXPANDED; // no longer expandable
                } else if (leafRow.__EXPANDED === undefined) { // retain previous setting for old rows
                    leafRow.__EXPANDED = false; // default for new row is unexpanded
                }
            }
        }

        return this.joined;
    },

    /**
     * @memberOf DataSourceTreeview.prototype
     */
    apply: function() {
        if (this.viewMakesSense()) {
            this.buildIndex(this.treeColumnIndex === undefined ? undefined : collapseRows);
        }
    },

    /**
     * @param x
     * @param y
     * @returns {*}
     * @memberOf DataSourceTreeview.prototype
     */
    getValue: function(x, y) {
        var value = DataSourceIndexed.prototype.getValue.call(this, x, y);

        if (this.viewMakesSense() && x === this.treeColumnIndex) {
            var row = this.getRow(y),
                prefix = Array(row.__DEPTH + 1).join('    ') + expandedMap[row.__EXPANDED];
            value = prefix + value;
        }

        return value;
    },

    viewMakesSense: function() {
        return this.joined;
    },

    /**
     * @desc Operates only on the following rows:
     * * Expandable rows - Rows with a drill-down control.
     * * Revealed rows - Rows not hidden inside of collapsed drill-downs.
     * @param y - Revealed row number. (This is not the row ID.)
     * @param {boolean} [expand] - One of:
     * * `true` - Expand all rows that are currently collapsed.
     * * `false` - Collapse all rows that are currently expanded.
     * * `undefined` (or omitted) - Expand all currently collapsed rows; collapse all currently expanded rows.
     * @param {number} [depth=Infinity] - One of:
     * * number > 0 - Apply only if row depth is above the given depth.
     * * number <= 0 - Apply only if row depth is below the given depth.
     * @returns {undefined|boolean} One of:
     * * `undefined` - Row was not expandable.
     * * `true` - Row had drill-down _and_ state changed.
     * * `false` - Row had drill-down _but_ state did _not_ change.
     * @memberOf DataSourceTreeview.prototype
     */
    click: function(y, expand, depth) {
        if (!this.viewMakesSense()) {
            return this.dataSource.click.apply(this.dataSource, arguments);
        }
        var changed, row = this.getRow(y);
        if (row && row.__EXPANDED !== undefined) {
            if (depth !== undefined && (
                depth > 0 && row.__DEPTH >= depth ||
                depth <= 0 && row.__DEPTH < -depth
            )) {
                changed = false;
            } else {
                if (expand === undefined) {
                    expand = !row.__EXPANDED;
                }
                changed = row.__EXPANDED && !expand || !row.__EXPANDED && expand;
                row.__EXPANDED = expand;
            }
        }
        return changed;
    },

    /**
     * @summary Expand nested drill-downs containing this row.
     * @param ID - The unique row ID.
     * @returns {boolean} If any rows expanded.
     */
    revealRow: function(ID) {
        if (!this.viewMakesSense()) {
            return this.dataSource.revealRow.apply(this.dataSource, arguments);
        }

        var row, parent, changed = false;
        while ((row = this.findRow(this.idColumnName, ID))) {
            if (parent && row.__EXPANDED === false) {
                row.__EXPANDED = changed = true;
            }
            parent = true;
            ID = row[this.parentIdColumnName];
        }
        return changed;
    }
});

function collapseRows(r, row) {
    var parentID;
    while ((parentID = row[this.parentIdColumnName]) != undefined) { // eslint-disable-line eqeqeq
        row = this.findRow(this.idColumnName, parentID);
        if (row.__EXPANDED === false) {
            return false;
        }
    }
    return true;
}

module.exports = DataSourceTreeview;

},{"./DataSourceIndexed":35}],39:[function(require,module,exports){
'use strict';

/**
 * @constructor
 */
function Mappy() {
    this.keys = [];
    this.data = {};
    this.values = [];
}

Mappy.prototype = {

    constructor: Mappy.prototype.constructor, // preserve constructor

    /**
     * @memberOf Mappy.prototype
     * @param key
     * @param value
     */
    set: function(key, value) {
        var hashCode = hash(key);
        if (!(hashCode in this.data)) {
            this.keys.push(key);
            this.values.push(value);
        }
        this.data[hashCode] = value;
    },

    /**
     * @memberOf Mappy.prototype
     * @param key
     * @returns {*}
     */
    get: function(key) {
        var hashCode = hash(key);
        return this.data[hashCode];
    },

    /**
     *
     * @memberOf Mappy.prototype
     * @param key
     * @param {function} ifUndefinedFunc - Value getter when value is otherwise undefined.
     * @returns {*}
     */
    getIfUndefined: function(key, ifUndefinedFunc) {
        var value = this.get(key);
        if (value === undefined) {
            value = ifUndefinedFunc(key);
            this.set(key, value);
        }
        return value;
    },

    size: function() {
        return this.keys.length;
    },

    /**
     * @memberOf Mappy.prototype
     */
    clear: function() {
        this.keys.length = 0;
        this.values.length = 0;
        this.data = {};
    },

    /**
     * @memberOf Mappy.prototype
     * @param key
     */
    delete: function(key) {
        var hashCode = hash(key);
        if (this.data[hashCode] !== undefined) {
            var index = betterIndexOf(this.keys, key);
            this.keys.splice(index, 1);
            this.values.splice(index, 1);
            delete this.data[hashCode];
        }
    },

    /**
     * @memberOf Mappy.prototype
     * @param {function} iteratee
     */
    forEach: function(iteratee) {
        if (typeof iteratee === 'function') {
            var keys = this.keys,
                self = this;
            keys.forEach(function(key) {
                var value = self.get(key);
                iteratee(value, key, self);
            });
        }
    },

    /**
     * @memberOf Mappy.prototype
     * @param {function} iteratee
     * @returns {Mappy}
     */
    map: function(iteratee) {
        var keys = this.keys,
            newMap = new Mappy(),
            self = this;

        if (!(typeof iteratee === 'function')) {
            iteratee = reflection;
        }

        keys.forEach(function(key) {
            var value = self.get(key),
                transformed = iteratee(value, key, self);
            newMap.set(key, transformed);
        });
        return newMap;
    },

    /**
     * @memberOf Mappy.prototype
     * @returns {Mappy}
     */
    copy: function() {
        var keys = this.keys,
            newMap = new Mappy(),
            self = this;
        keys.forEach(function(key) {
            var value = self.get(key);
            newMap.set(key, value);
        });
        return newMap;
    }

};

var OID_PREFIX = '.~.#%_'; //this should be something we never will see at the beginning of a string
var counter = 0;

function hash(key) {
    var typeOf = typeof key;

    switch (typeOf) {
        case 'number':
        case 'string':
        case 'boolean':
        case 'symbol':
            return OID_PREFIX + typeOf + '_' + key;

        case 'undefined':
            return 'UNDEFINED';

        case 'object':
            if (key === null) {
                return 'NULL';
            }
            // fall through when not null:
        case 'function':
            return (key.___finhash = key.___finhash || OID_PREFIX + counter++);
    }
}

// Object.is polyfill, courtesy of @WebReflection
var is = Object.is || function(a, b) {
    return a === b ? a !== 0 || 1 / a == 1 / b : a != a && b != b; // eslint-disable-line eqeqeq
};

function reflection(val) {
    return val;
}

// More reliable indexOf, courtesy of @WebReflection
function betterIndexOf(arr, value) {
    if (value != value || value === 0) { // eslint-disable-line eqeqeq
        var i = arr.length;
        while (i-- && !is(arr[i], value)) {
            // eslint-disable-line no-empty
        }
    } else {
        i = [].indexOf.call(arr, value);
    }
    return i;
}

module.exports = Mappy;

},{}],40:[function(require,module,exports){
'use strict';

/**
 * @module aggregations
 */

/**
 * @typedef {function} aggregationFunction
 * @summary A bound function.
 * @desc An aggregation function bound to the `columnIndex` value supplied to one of the above factory functions.
 * @param {object} group
 * @returns {*} Aggregated value.
 */

module.exports = {
    /**
     * @instance
     * @param {number} columnIndex
     * @returns {aggregationFunction} Bound function.
     */
    count: function(columnIndex) {
        return count;
    },

    /**
     * @instance
     * @param {number} columnIndex
     * @returns {aggregationFunction} Bound function.
     */
    sum: function(columnIndex) {
        return sum.bind(this, columnIndex);
    },

    /**
     * @instance
     * @param {number} columnIndex
     * @returns {aggregationFunction} Bound function.
     */
    min: function(columnIndex) {
        return minmax.bind(this, columnIndex, Math.min, Infinity);
    },

    /**
     * @instance
     * @param {number} columnIndex
     * @returns {aggregationFunction} Bound function.
     */
    max: function(columnIndex) {
        return minmax.bind(this, columnIndex, Math.max, -Infinity);
    },

    /**
     * @instance
     * @param {number} columnIndex
     * @returns {aggregationFunction} Bound function.
     */
    avg: function(columnIndex) {
        return avg.bind(this, columnIndex);
    },

    /**
     * @instance
     * @param {number} columnIndex
     * @returns {aggregationFunction} Bound function.
     */
    first: function(columnIndex) {
        return first.bind(this, columnIndex);
    },

    /**
     * @instance
     * @param {number} columnIndex
     * @returns {aggregationFunction} Bound function.
     */
    last: function(columnIndex) {
        return last.bind(this, columnIndex);
    },

    /**
     * @instance
     * @param {number} columnIndex
     * @returns {aggregationFunction} Bound function.
     */
    stddev: function(columnIndex) {
        return stddev.bind(this, columnIndex);
    }
};

function count(group) {
    return group.getRowCount();
}

function sum(columnIndex, group) {
    var r = group.getRowCount(),
        n = 0;

    while (r--) {
        n += group.getValue(columnIndex, r);
    }

    return n;
}

function minmax(columnIndex, method, n, group) {
    var r = group.getRowCount();

    while (r--) {
        n = method(n, group.getValue(columnIndex, r));
    }

    return n;
}

function avg(columnIndex, group) {
    return sum(columnIndex, group) / group.getRowCount();
}

function first(columnIndex, group) {
    return group.getValue(columnIndex, 0);
}

function last(columnIndex, group) {
    return group.getValue(columnIndex, group.getRowCount() - 1);
}

function stddev(columnIndex, group) {
    var rows = group.getRowCount(),
        mean = avg(columnIndex, group);

    for (var dev, r = rows, variance = 0; r--; variance += dev * dev) {
        dev = group.getValue(columnIndex, r) - mean;
    }

    return Math.sqrt(variance / rows);
}

},{}],41:[function(require,module,exports){
'use strict';

// NOTE: For backwards compatibility, `capitalize` is still a function, doubling now as the API.

function capitalize(string) {
    return (/[a-z]/.test(string) ? string : string.toLowerCase())
        .replace(/[\s\-_]*([^\s\-_])([^\s\-_]+)/g, replacer)
        .replace(/[A-Z]/g, ' $&')
        .trim();
}

function replacer(a, b, c) {
    return b.toUpperCase() + c;
}

function set(methodName) {
    capitalize.transform = capitalize[methodName];
}

function passthrough(string) {
    return string;
}

capitalize.transform = passthrough;
capitalize.set = set;
capitalize.passthrough = passthrough;
capitalize.capitalize = capitalize;

module.exports = capitalize;

},{}],42:[function(require,module,exports){
'use strict';

/**
 * Note that {@link module:stableSort#sort|sort()} is the only exposed method.
 * @module stableSort
 */

/**
 * @private
 * @instance
 * @param {function} comparator
 * @param {boolean} descending
 * @param {Array} arr1
 * @param {Array} arr2
 * @returns {function}
 */
function stabilize(comparator, descending, arr1, arr2) { // eslint-disable-line no-shadow
    var x = arr1[0];
    var y = arr2[0];

    if (x === y) {
        x = descending ? arr2[1] : arr1[1];
        y = descending ? arr1[1] : arr2[1];
    } else {
        if (y === null) {
            return -1;
        }
        if (x === null) {
            return 1;
        }
    }

    return comparator(x, y);
}

/**
 * @private
 * @instance
 * @param x
 * @param y
 * @returns {number}
 */
function ascendingNumbers(x, y) {
    return x - y;
}

/**
 * @private
 * @instance
 * @param x
 * @param y
 * @returns {number}
 */
function descendingNumbers(x, y) {
    return y - x;
}

/**
 * @private
 * @instance
 * @param x
 * @param y
 * @returns {number}
 */
function ascendingAllOthers(x, y) {
    return x < y ? -1 : 1;
}

/**
 * @private
 * @instance
 * @param x
 * @param y
 * @returns {number}
 */
function descendingAllOthers(x, y) {
    return y < x ? -1 : 1;
}

/**
 * @private
 * @instance
 * @param typeOfData
 * @returns {function(this:ascending)}
 */
function ascending(typeOfData) {
    return stabilize.bind(this, typeOfData === 'number' ? ascendingNumbers : ascendingAllOthers, false);
}

/**
 * @private
 * @instance
 * @param typeOfData
 * @returns {function(this:descending)}
 */
function descending(typeOfData) {
    return stabilize.bind(this, typeOfData === 'number' ? descendingNumbers : descendingAllOthers, true);
}

/**
 * @instance
 * @param {number} index
 * @param {function} getValue
 * @param {number} [direction=1]
 */
function sort(index, getValue, direction) {

    var compare, i;

    // apply defaults
    if (direction === undefined) {
        direction = 1;
    }

    if (index.length) { // something to do
        switch (direction) {
            case 0:
                return; // bail: nothing to sort

            case undefined: // eslint-disable-line no-fallthrough
                direction = 1;
            case 1:  // eslint-disable-line no-fallthrough
                compare = ascending(typeof getValue(0));
                break;

            case -1:
                compare = descending(typeof getValue(0));
                break;
        }

        // set up the sort.....
        var tmp = new Array(index.length);

        // add the index for "stability"
        for (i = 0; i < index.length; i++) {
            tmp[i] = [getValue(i), i];
        }

        // do the actual sort
        tmp.sort(compare);

        // copy the sorted values into our index vector
        for (i = 0; i < index.length; i++) {
            index[i] = tmp[i][1];
        }
    }

}

exports.sort = sort;

},{}],43:[function(require,module,exports){
// list-dragon node module
// https://github.com/joneit/list-dragon

/* eslint-env node, browser */

'use strict';

var cssInjector = require('css-injector');
var format = require('templex');

var REVERT_TO_STYLESHEET_VALUE = null;  // null removes the style

var transform, timer, scrollVelocity, cssListDragon;

/* inject:css */
cssListDragon = 'div.dragon-list{position:relative;background-color:#fff}div.dragon-list>div,div.dragon-list>ul{position:absolute;left:0;right:0}div.dragon-list>div{text-align:center;background-color:#00796b;color:#fff;box-shadow:0 3px 6px rgba(0,0,0,.16),0 3px 6px rgba(0,0,0,.23);overflow:hidden;white-space:nowrap}div.dragon-list>ul{overflow-y:auto;bottom:0;margin:0;padding:0;box-shadow:0 1px 3px rgba(0,0,0,.12),0 1px 2px rgba(0,0,0,.24)}div.dragon-list>ul>li,li.dragon-pop{white-space:nowrap;list-style-type:none;border:0 solid #f4f4f4;border-bottom:1px solid #e0e0e0;cursor:move;transition:border-top-width .2s}div.dragon-list>ul>li:last-child{height:0;border-bottom:none}li.dragon-pop{position:fixed;background-color:#fff;border:1px solid #e0e0e0;left:0;top:0;overflow-x:hidden;box-shadow:rgba(0,0,0,.188235) 0 10px 20px,rgba(0,0,0,.227451) 0 6px 6px}';
/* endinject */

/**
 * @constructor ListDragon
 *
 * @desc This object services a set of item lists that allow dragging and dropping items within and between lists in a set.
 *
 * Two strategies are supported:
 *
 * 1. Supply your own HTML markup and let the API build the item models for you.
 *    To use this strategy, script your HTML and provide one of these:
 *    * an array of all the list item (`<li>`) tags
 *    * a CSS selector that points to all the list item tags
 * 2. Supply your own item models and let the API build the HTML markup for you.
 *    To use this strategy, provide an array of model lists.
 *
 * The new ListDragon object's `modelLists` property references the array of model lists the API constructed for you in strategy #1 or the array of model lists you supplied for strategy #2.
 *
 * After the user performs a successful drag-and-drop operation, the position of the model references within the `modelLists` array is rearranged. (The models themselves are the original objects as supplied in the model lists; they are not rebuilt or altered in any way. Just the references to them are moved around.)
 *
 * @param {string|Element[]|modelListType[]} selectorOrModelLists - You must supply one of the items in **bold** below:
 *
 * 1. _For strategy #1 above (API creates models from supplied elements):_ All the list item (`<li>`) DOM elements of all the lists you want the new object to manage, as either:
 *    1. **A CSS selector;** _or_
 *    2. **An array of DOM elements**
 * 2. _For strategy #2 above (API creates elements from supplied models):_ **An array of model lists,** each of which is in one of the following forms:
 *    1. An array of item models (with various option properties hanging off of it); _and/or_
 *    2. A {@link modelListType} object with those same various option properties including the required `models` property containing that same array of item models.
 *
 * In either case (2.1 or 2.2), each element of such arrays of item models may take the form of:
 * * A string primitive; _or_
 * * A {@link itemModelType} object with a various option properties including the required `label` property containing a string primitive.
 *
 * Regarding these string primitives, each is either:
 * * A string to be displayed in the list item; _or_
 * * A format string with other property values merged in, the result of which is to be displayed in the list item.
 *
 * @param {object} [options={}] - You may supply "global" template variables here, representing the "outer scope," after first searching each model and then each model list.
 * @param {undefined|null|Element|string} [cssStylesheetReferenceElement] - Determines where to insert the stylesheet. (This is the only formal option.) Passed to css-injector, the overloads are (from css-injector docs):
 * * `undefined` type (or omitted): injects stylesheet at top of `<head>...</head>` element
 * * `null` value: injects stylesheet at bottom of `<head>...</head>` element
 * * `Element` type: injects stylesheet immediately before given element, wherever it is found.
 * * `string` type: injects stylesheet immediately before given first element found that matches the given css selector.
 */
function ListDragon(selectorOrModelLists, options) {

    if (!(this instanceof ListDragon)) {
        throw error('Not called with "new" keyword.');
    }

    var self = this, modelLists, items;

    options = options || {};

    if (typeof selectorOrModelLists === 'string') {
        items = toArray(document.querySelectorAll(selectorOrModelLists));
        modelLists = createModelListsFromListElements(items);
    } else if (selectorOrModelLists[0] instanceof Element) {
        items = toArray(selectorOrModelLists);
        modelLists = createModelListsFromListElements(items);
    } else {
        // param is array of model lists
        // build new <ul> element(s) for each list and put in `.modelLists`;
        // fill `.items` array with <li> elements from these new <ul> elements
        items = [];
        modelLists = createListElementsFromModelLists(selectorOrModelLists, options);
        modelLists.forEach(function (list) {
            items = items.concat(toArray(list.element.querySelectorAll('li')));
        });
    }

    // grab wheel events and don't let 'em bubble
    modelLists.forEach(function (modelList) {
        modelList.element.addEventListener('wheel', captureEvent);
    });

    items.forEach(function (itemElement, index) {
        var item = (itemElement !== itemElement.parentElement.lastElementChild)
            ? self.addEvt(itemElement, 'mousedown', itemElement, true)
            : { element: itemElement };

        /* `item.model` not currently needed so commented out here.
         * (Originally used for rebuilding modelLists for final
         * reporting, modelLists are now spliced on every successful
         * drag-and-drop operation so they're always up to date.)

         var origin = this.itemCoordinates(itemElement);
         item.model = this.modelLists[origin.list].models[origin.item];

         */

        items[index] = item;
    });

    transform = 'transform' in items[0].element.style
        ? 'transform' // Chrome 45 and Firefox 40
        : '-webkit-transform'; // Safari 8

    // set up the new object
    this.modelLists = modelLists;
    this.items = items;
    this.bindings = {};
    this.callback = {};

    cssInjector(cssListDragon, 'list-dragon-base', options.cssStylesheetReferenceElement);

}

ListDragon.prototype = {

    addEvt: function (target, type, listener, doNotBind) {
        var binding = {
            handler: handlers[type].bind(target, this),
            element: listener || window
        };

        if (!doNotBind) {
            this.bindings[type] = binding;
        }

        binding.element.addEventListener(type, binding.handler);

        return binding;
    },

    removeEvt: function (type) {
        var binding = this.bindings[type];
        delete this.bindings[type];
        binding.element.removeEventListener(type, binding.handler);
    },

    removeAllEventListeners: function () {
        // remove drag & drop events (mousemove, mouseup, and transitionend)
        for (var type in this.bindings) {
            var binding = this.bindings[type];
            binding.element.removeEventListener(type, binding.handler);
        }
        // remove the mousedown events from all list items
        this.items.forEach(function (item) {
            if (item.handler) {
                item.element.removeEventListener('mousedown', item.handler);
            }
        });
        // wheel events on the list elements
        this.modelLists.forEach(function (modelList) {
            modelList.element.removeEventListener('wheel', captureEvent);
        });
    },

    pointInListRects: function (point) {
        return this.modelLists.find(function (modelList) {
            var rect = modelList.element.getBoundingClientRect();

            rect = {
                left:   window.scrollX + rect.left,
                top:    window.scrollY + rect.top,
                right:  window.scrollX + rect.right,
                bottom: window.scrollY + rect.bottom,
                width:  rect.width,
                height: rect.height
            };

            modelList.rect = rect;

            if (pointInRect(point, rect)) {
                modelList.rect = rect;
                return true; // found
            } else {
                return false;
            }
        });
    },

    pointInItemRects: function (point, except1, except2) {
        return this.items.find(function (item) {
            var element = item.element;
            return (
                element !== except1 &&
                element !== except2 &&
                pointInRect(point, item.rect)
            );
        });
    },

    // get positions of all list items in page coords (normalized for window and list scrolling)
    getAllItemBoundingRects: function () {
        var modelLists = this.modelLists, height;
        this.items.forEach(function (item) {
            var itemElement = item.element,
                listElement = itemElement.parentElement,
                list = modelLists.find(function (list) { return list.element === listElement; });

            if (
                // omitted: default to true
                list.isDropTarget === undefined ||

                // function: use return value
                typeof list.isDropTarget === 'function' && list.isDropTarget() ||

                // otherwise: use truthiness of given value
                list.isDropTarget
            ) {
                var rect = itemElement.getBoundingClientRect(),
                    bottom = rect.bottom;

                if (itemElement === listElement.lastElementChild) {
                    bottom = listElement.getBoundingClientRect().bottom;
                    if (bottom < rect.top) {
                        bottom = rect.top + (height || 50);
                    }
                } else {
                    height = rect.height;
                }

                rect = {
                    left:   window.scrollX + rect.left,
                    right:  window.scrollX + rect.right,
                    top:    window.scrollY + rect.top    + listElement.scrollTop,
                    bottom: window.scrollY + bottom + listElement.scrollTop
                };

                item.rect = rect;
            }
        });
    },

    reinsert: function (target) {
        var style = target.style;
        style.width = style[transform] = style.transition = REVERT_TO_STYLESHEET_VALUE;

        target.classList.remove('dragon-pop');

        this.drop.style.transitionDuration = '0s';
        this.drop.style.borderTopWidth = REVERT_TO_STYLESHEET_VALUE;
        this.drop.parentElement.insertBefore(target, this.drop);

        delete this.drop;
    },

    // return an object { item: <item index within list>, list: <list index within list of lists> }
    itemCoordinates: function (item) {
        var listElement = item.parentElement,
            coords = { item: 0 };

        while ((item = item.previousElementSibling)) {
            ++coords.item;
        }

        this.modelLists.find(function (list, index) {
            coords.list = index;
            return list.element === listElement; // stop when we find the one we belong to
        });

        return coords;
    }

};

var handlers = {
    mousedown: function (dragon, evt) {

        evt.stopPropagation();
        evt.preventDefault();  //prevents user selection of rendered nodes during drag

        if (dragon.drop) {
            return;
        }

        var rect = this.getBoundingClientRect();

        dragon.rect = rect = {
            left:   Math.round(rect.left - 1),
            top:    Math.round(rect.top - 1),
            right:  Math.round(rect.right),
            bottom: Math.round(rect.bottom),
            width:  Math.round(rect.width),
            height: Math.round(rect.height)
        };

        dragon.pin = {
            x: window.scrollX + evt.clientX,
            y: window.scrollY + evt.clientY
        };

        dragon.origin = dragon.itemCoordinates(this);

        if (dragon.callback.grabbed) {
            dragon.callback.grabbed.call(this, dragon);
        }

        dragon.getAllItemBoundingRects();

        dragon.drop = this.nextElementSibling;
        dragon.drop.style.transitionDuration = '0s';
        dragon.drop.style.borderTopWidth = rect.height + 'px';

        this.style.width = rect.width + 'px';
        this.style.transitionDuration = '0s';
        this.style[transform] = translate(
            rect.left - window.scrollX,
            rect.top  - window.scrollY
        );
        this.classList.add('dragon-pop');
        this.style.zIndex = window.getComputedStyle(dragon.modelLists[0].container.parentElement).zIndex;

        if (!dragon.container) {
            // walk back to closest shadow root OR body tag OR root tag
            var container = this;
            while (container.parentNode) {
                container = container.parentNode;
                if (
                    typeof ShadowRoot !== 'undefined' && container instanceof ShadowRoot ||
                    container.tagName === 'BODY'
                ){
                    break;
                }
            }
            dragon.container = container;
        }

        dragon.container.appendChild(this);

        rect.left   += window.scrollX;
        rect.top    += window.scrollY;
        rect.right  += window.scrollX;
        rect.bottom += window.scrollY;

        dragon.addEvt(this, 'mousemove');
        dragon.addEvt(this, 'mouseup');
    },

    mousemove: function (dragon, evt) {
        dragon.drop.style.transition = REVERT_TO_STYLESHEET_VALUE;

        var hoverList = dragon.pointInListRects({ x: evt.clientX, y: evt.clientY }) || dragon.mostRecentHoverList;

        if (hoverList) {
            var dx = evt.clientX - dragon.pin.x,
                dy = evt.clientY - dragon.pin.y;

            dragon.mostRecentHoverList = hoverList;

            var maxScrollY = hoverList.element.scrollHeight - hoverList.rect.height,
                y = evt.clientY + window.scrollY,
                magnitude;

            if (maxScrollY > 0) {
                // list is scrollable (is taller than rect)
                if (hoverList.element.scrollTop > 0 && (magnitude = y - (hoverList.rect.top + 5)) < 0) {
                    // mouse near or above top and list is not scrolled to top yet
                    resetAutoScrollTimer(magnitude, 0, hoverList.element);
                } else if (hoverList.element.scrollTop < maxScrollY && (magnitude = y - (hoverList.rect.bottom - 1 - 5)) > 0) {
                    // mouse near or below bottom and list not scrolled to bottom yet
                    resetAutoScrollTimer(magnitude, maxScrollY, hoverList.element);
                } else {
                    // mouse inside
                    resetAutoScrollTimer();
                }
            }

            var other = dragon.pointInItemRects({
                x: evt.clientX,
                y: dragon.rect.bottom + window.scrollY + dy + hoverList.element.scrollTop
            }, this, dragon.drop);

            this.style[transform] = translate(
                dragon.rect.left - window.scrollX + dx,
                dragon.rect.top - window.scrollY + dy
            );

            if (other) {
                var element = other.element;
                element.style.transition = REVERT_TO_STYLESHEET_VALUE;
                element.style.borderTopWidth = dragon.drop.style.borderTopWidth;
                dragon.drop.style.borderTopWidth = null;
                dragon.drop = element;
            }
        }
    },

    mouseup: function (dragon, evt) {
        resetAutoScrollTimer();
        dragon.removeEvt('mousemove');
        dragon.removeEvt('mouseup');

        evt.stopPropagation();

        var newRect = this.getBoundingClientRect();

        if (
            window.scrollX + newRect.left === dragon.rect.left &&
            window.scrollY + newRect.top === dragon.rect.top
        ) {
            dragon.reinsert(this);
        } else {
            var dropRect = dragon.drop.getBoundingClientRect();

            dragon.addEvt(this, 'transitionend', this);
            this.style.transitionDuration = REVERT_TO_STYLESHEET_VALUE; //reverts to 200ms
            this.style.transitionProperty = transform;
            this.style[transform] = translate(
                dropRect.left - window.scrollX,
                dropRect.top - window.scrollY
            );
        }
    },

    transitionend: function (dragon, evt) {
        if (evt.propertyName === transform) {
            dragon.removeEvt('transitionend');
            dragon.reinsert(this);

            this.style.transitionProperty = REVERT_TO_STYLESHEET_VALUE; //reverts to border-top-width

            var originList = dragon.modelLists[dragon.origin.list];
            var model = originList.splice(dragon.origin.item, 1)[0];
            var destination = dragon.itemCoordinates(this);
            var destinationList = dragon.modelLists[destination.list];
            var interListDrop = originList !== destinationList;
            var listChanged = interListDrop || dragon.origin.item !== destination.item;
            destinationList.splice(destination.item, 0, model);

            if (listChanged) {
                originList.element.dispatchEvent(new CustomEvent('listchanged'));
                if (interListDrop) {
                    destinationList.element.dispatchEvent(new CustomEvent('listchanged'));
                }
            }

            if (dragon.callback.dropped) {
                dragon.callback.dropped.call(this, dragon);
            }
        }
    }
};

function resetAutoScrollTimer(magnitude, limit, element) {
    if (!magnitude) {
        clearInterval(timer);
        scrollVelocity = 0;
    } else {
        var changeDirection =
            scrollVelocity  <  0 && magnitude  >= 0 ||
            scrollVelocity === 0 && magnitude !== 0 ||
            scrollVelocity  >  0 && magnitude  <= 0;
        scrollVelocity = magnitude > 0 ? Math.min(50, magnitude) : Math.max(-50, magnitude);
        if (changeDirection) {
            clearInterval(timer);
            timer = setInterval(function (limit) {
                var scrollTop = element.scrollTop + scrollVelocity;
                if (scrollVelocity < 0 && scrollTop < limit || scrollVelocity > 0 && scrollTop > limit) {
                    element.scrollTop = limit;
                    clearInterval(timer);
                } else {
                    element.scrollTop = scrollTop;
                }
            }, 125);
        }
    }
}

function toArray(arrayLikeObject) {
    return Array.prototype.slice.call(arrayLikeObject);
}

function pointInRect(point, rect) {
    return rect.top <= point.y && point.y <= rect.bottom
        && rect.left <= point.x && point.x <= rect.right;
}

function translate(left, top) {
    return 'translate('
        + Math.floor(left + window.scrollX) + 'px,'
        + Math.floor(top + window.scrollY) + 'px)';
}

function htmlEncode(string) {
    var textNode = document.createTextNode(string);

    return document
        .createElement('a')
        .appendChild(textNode)
        .parentNode
        .innerHTML;
}

/**
 * Creates `<ul>...</ul>` elements and inserts them into an `element` property on each model.
 * @param {object} modelLists
 * @returns `modelLists`
 */
function createListElementsFromModelLists(modelLists, options) {
    var templateLabel = options.label || '{label}';

    modelLists.forEach(function (modelList, listIndex) {
        var listLabel = modelList.label || templateLabel,
            listHtmlEncode = modelList.htmlEncode !== undefined && modelList.htmlEncode || options.htmlEncode,
            container = document.createElement('div'),
            listElement = document.createElement('ul');

        if (modelList.models) {
            Object.keys(modelList).forEach(function (key) {
                if (key !== 'models') {
                    modelList.models[key] = modelList[key];
                }
            });
            modelLists[listIndex] = modelList = modelList.models;
        } else if (modelList instanceof Array) {
            modelList.models = modelList; // point to self
        } else {
            throw error('List [{1}] not an array of models (with or without additional properties) OR ' +
                'an object (with a `models` property containing an array of models).', listIndex);
        }

        modelList.forEach(function (model) {
            var modelLabel = model.label || listLabel,
                modelHtmlEncode = model.htmlEncode !== undefined && model.htmlEncode || listHtmlEncode,
                modelObject = typeof model === 'object' ? model : { label: model},
                label = format.call([modelObject, modelList, options], modelLabel),
                itemElement = document.createElement('li');

            itemElement.innerHTML = modelHtmlEncode ? htmlEncode(label) : label;

            listElement.appendChild(itemElement);
        });

        // append the final "fencepost" item -- drop target at bottom of list after all items
        var itemElement = document.createElement('li');
        itemElement.innerHTML = '&nbsp;';
        listElement.appendChild(itemElement);

        // append header to container
        if (modelList.title) {
            var header = document.createElement('div');
            header.innerHTML = listHtmlEncode ? htmlEncode(modelList.title) : modelList.title;
            container.appendChild(header);
        }

        container.appendChild(listElement);
        container.className = modelList.cssClassNames || options.cssClassNames || 'dragon-list';
        modelList.element = listElement;
        modelList.container = container;
    });

    return modelLists;
}

/**
 * Create a `.modelLists` array with these <li> elements' parent <ul> elements
 * @param {Element[]} listItemElements
 * @returns {Array}
 */
function createModelListsFromListElements(listItemElements) {
    var modelLists = [];

    listItemElements.forEach(function (itemElement) {
        var listElement = itemElement.parentElement,
            container = listElement.parentElement,
            models = [];
        if (!modelLists.find(function (list) { return list.element === listElement; })) {
            toArray(listElement.querySelectorAll('li')).forEach(function (itemElement) {
                if (itemElement !== listElement.lastElementChild) {
                    models.push(itemElement.innerHTML);
                }
            });
            models.element = listElement;
            models.container = container;
            modelLists.push(models);
        }
    });

    return modelLists;
}

function captureEvent(evt) {
    evt.stopPropagation();
}

function error() {
    return 'list-dragon: ' + format.apply(this, Array.prototype.slice.call(arguments));
}

// this interface consists solely of the prototypal object constructor
module.exports = ListDragon;

},{"css-injector":6,"templex":52}],44:[function(require,module,exports){
;(function () { // closure for web browsers

if (typeof module === 'object' && module.exports) {
  module.exports = LRUCache
} else {
  // just set the global for non-node platforms.
  this.LRUCache = LRUCache
}

function hOP (obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key)
}

function naiveLength () { return 1 }

function LRUCache (options) {
  if (!(this instanceof LRUCache))
    return new LRUCache(options)

  if (typeof options === 'number')
    options = { max: options }

  if (!options)
    options = {}

  this._max = options.max
  // Kind of weird to have a default max of Infinity, but oh well.
  if (!this._max || !(typeof this._max === "number") || this._max <= 0 )
    this._max = Infinity

  this._lengthCalculator = options.length || naiveLength
  if (typeof this._lengthCalculator !== "function")
    this._lengthCalculator = naiveLength

  this._allowStale = options.stale || false
  this._maxAge = options.maxAge || null
  this._dispose = options.dispose
  this.reset()
}

// resize the cache when the max changes.
Object.defineProperty(LRUCache.prototype, "max",
  { set : function (mL) {
      if (!mL || !(typeof mL === "number") || mL <= 0 ) mL = Infinity
      this._max = mL
      if (this._length > this._max) trim(this)
    }
  , get : function () { return this._max }
  , enumerable : true
  })

// resize the cache when the lengthCalculator changes.
Object.defineProperty(LRUCache.prototype, "lengthCalculator",
  { set : function (lC) {
      if (typeof lC !== "function") {
        this._lengthCalculator = naiveLength
        this._length = this._itemCount
        for (var key in this._cache) {
          this._cache[key].length = 1
        }
      } else {
        this._lengthCalculator = lC
        this._length = 0
        for (var key in this._cache) {
          this._cache[key].length = this._lengthCalculator(this._cache[key].value)
          this._length += this._cache[key].length
        }
      }

      if (this._length > this._max) trim(this)
    }
  , get : function () { return this._lengthCalculator }
  , enumerable : true
  })

Object.defineProperty(LRUCache.prototype, "length",
  { get : function () { return this._length }
  , enumerable : true
  })


Object.defineProperty(LRUCache.prototype, "itemCount",
  { get : function () { return this._itemCount }
  , enumerable : true
  })

LRUCache.prototype.forEach = function (fn, thisp) {
  thisp = thisp || this
  var i = 0
  var itemCount = this._itemCount

  for (var k = this._mru - 1; k >= 0 && i < itemCount; k--) if (this._lruList[k]) {
    i++
    var hit = this._lruList[k]
    if (isStale(this, hit)) {
      del(this, hit)
      if (!this._allowStale) hit = undefined
    }
    if (hit) {
      fn.call(thisp, hit.value, hit.key, this)
    }
  }
}

LRUCache.prototype.keys = function () {
  var keys = new Array(this._itemCount)
  var i = 0
  for (var k = this._mru - 1; k >= 0 && i < this._itemCount; k--) if (this._lruList[k]) {
    var hit = this._lruList[k]
    keys[i++] = hit.key
  }
  return keys
}

LRUCache.prototype.values = function () {
  var values = new Array(this._itemCount)
  var i = 0
  for (var k = this._mru - 1; k >= 0 && i < this._itemCount; k--) if (this._lruList[k]) {
    var hit = this._lruList[k]
    values[i++] = hit.value
  }
  return values
}

LRUCache.prototype.reset = function () {
  if (this._dispose && this._cache) {
    for (var k in this._cache) {
      this._dispose(k, this._cache[k].value)
    }
  }

  this._cache = Object.create(null) // hash of items by key
  this._lruList = Object.create(null) // list of items in order of use recency
  this._mru = 0 // most recently used
  this._lru = 0 // least recently used
  this._length = 0 // number of items in the list
  this._itemCount = 0
}

LRUCache.prototype.dump = function () {
  var arr = []
  var i = 0

  for (var k = this._mru - 1; k >= 0 && i < this._itemCount; k--) if (this._lruList[k]) {
    var hit = this._lruList[k]
    if (!isStale(this, hit)) {
      //Do not store staled hits
      ++i
      arr.push({
        k: hit.key,
        v: hit.value,
        e: hit.now + (hit.maxAge || 0)
      });
    }
  }
  //arr has the most read first
  return arr
}

LRUCache.prototype.dumpLru = function () {
  return this._lruList
}

LRUCache.prototype.set = function (key, value, maxAge) {
  maxAge = maxAge || this._maxAge
  var now = maxAge ? Date.now() : 0
  var len = this._lengthCalculator(value)

  if (hOP(this._cache, key)) {
    if (len > this._max) {
      del(this, this._cache[key])
      return false
    }
    // dispose of the old one before overwriting
    if (this._dispose)
      this._dispose(key, this._cache[key].value)

    this._cache[key].now = now
    this._cache[key].maxAge = maxAge
    this._cache[key].value = value
    this._length += (len - this._cache[key].length)
    this._cache[key].length = len
    this.get(key)

    if (this._length > this._max)
      trim(this)

    return true
  }

  var hit = new Entry(key, value, this._mru++, len, now, maxAge)

  // oversized objects fall out of cache automatically.
  if (hit.length > this._max) {
    if (this._dispose) this._dispose(key, value)
    return false
  }

  this._length += hit.length
  this._lruList[hit.lu] = this._cache[key] = hit
  this._itemCount ++

  if (this._length > this._max)
    trim(this)

  return true
}

LRUCache.prototype.has = function (key) {
  if (!hOP(this._cache, key)) return false
  var hit = this._cache[key]
  if (isStale(this, hit)) {
    return false
  }
  return true
}

LRUCache.prototype.get = function (key) {
  return get(this, key, true)
}

LRUCache.prototype.peek = function (key) {
  return get(this, key, false)
}

LRUCache.prototype.pop = function () {
  var hit = this._lruList[this._lru]
  del(this, hit)
  return hit || null
}

LRUCache.prototype.del = function (key) {
  del(this, this._cache[key])
}

LRUCache.prototype.load = function (arr) {
  //reset the cache
  this.reset();

  var now = Date.now()
  //A previous serialized cache has the most recent items first
  for (var l = arr.length - 1; l >= 0; l-- ) {
    var hit = arr[l]
    var expiresAt = hit.e || 0
    if (expiresAt === 0) {
      //the item was created without expiration in a non aged cache
      this.set(hit.k, hit.v)
    } else {
      var maxAge = expiresAt - now
      //dont add already expired items
      if (maxAge > 0) this.set(hit.k, hit.v, maxAge)
    }
  }
}

function get (self, key, doUse) {
  var hit = self._cache[key]
  if (hit) {
    if (isStale(self, hit)) {
      del(self, hit)
      if (!self._allowStale) hit = undefined
    } else {
      if (doUse) use(self, hit)
    }
    if (hit) hit = hit.value
  }
  return hit
}

function isStale(self, hit) {
  if (!hit || (!hit.maxAge && !self._maxAge)) return false
  var stale = false;
  var diff = Date.now() - hit.now
  if (hit.maxAge) {
    stale = diff > hit.maxAge
  } else {
    stale = self._maxAge && (diff > self._maxAge)
  }
  return stale;
}

function use (self, hit) {
  shiftLU(self, hit)
  hit.lu = self._mru ++
  self._lruList[hit.lu] = hit
}

function trim (self) {
  while (self._lru < self._mru && self._length > self._max)
    del(self, self._lruList[self._lru])
}

function shiftLU (self, hit) {
  delete self._lruList[ hit.lu ]
  while (self._lru < self._mru && !self._lruList[self._lru]) self._lru ++
}

function del (self, hit) {
  if (hit) {
    if (self._dispose) self._dispose(hit.key, hit.value)
    self._length -= hit.length
    self._itemCount --
    delete self._cache[ hit.key ]
    shiftLU(self, hit)
  }
}

// classy, since V8 prefers predictable objects.
function Entry (key, value, lu, length, now, maxAge) {
  this.key = key
  this.value = value
  this.lu = lu
  this.length = length
  this.now = now
  if (maxAge) this.maxAge = maxAge
}

})()

},{}],45:[function(require,module,exports){
/*!
 * mustache.js - Logic-less {{mustache}} templates with JavaScript
 * http://github.com/janl/mustache.js
 */

/*global define: false Mustache: true*/

(function defineMustache (global, factory) {
  if (typeof exports === 'object' && exports && typeof exports.nodeName !== 'string') {
    factory(exports); // CommonJS
  } else if (typeof define === 'function' && define.amd) {
    define(['exports'], factory); // AMD
  } else {
    global.Mustache = {};
    factory(Mustache); // script, wsh, asp
  }
}(this, function mustacheFactory (mustache) {

  var objectToString = Object.prototype.toString;
  var isArray = Array.isArray || function isArrayPolyfill (object) {
    return objectToString.call(object) === '[object Array]';
  };

  function isFunction (object) {
    return typeof object === 'function';
  }

  /**
   * More correct typeof string handling array
   * which normally returns typeof 'object'
   */
  function typeStr (obj) {
    return isArray(obj) ? 'array' : typeof obj;
  }

  function escapeRegExp (string) {
    return string.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, '\\$&');
  }

  /**
   * Null safe way of checking whether or not an object,
   * including its prototype, has a given property
   */
  function hasProperty (obj, propName) {
    return obj != null && typeof obj === 'object' && (propName in obj);
  }

  // Workaround for https://issues.apache.org/jira/browse/COUCHDB-577
  // See https://github.com/janl/mustache.js/issues/189
  var regExpTest = RegExp.prototype.test;
  function testRegExp (re, string) {
    return regExpTest.call(re, string);
  }

  var nonSpaceRe = /\S/;
  function isWhitespace (string) {
    return !testRegExp(nonSpaceRe, string);
  }

  var entityMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;',
    '/': '&#x2F;'
  };

  function escapeHtml (string) {
    return String(string).replace(/[&<>"'\/]/g, function fromEntityMap (s) {
      return entityMap[s];
    });
  }

  var whiteRe = /\s*/;
  var spaceRe = /\s+/;
  var equalsRe = /\s*=/;
  var curlyRe = /\s*\}/;
  var tagRe = /#|\^|\/|>|\{|&|=|!/;

  /**
   * Breaks up the given `template` string into a tree of tokens. If the `tags`
   * argument is given here it must be an array with two string values: the
   * opening and closing tags used in the template (e.g. [ "<%", "%>" ]). Of
   * course, the default is to use mustaches (i.e. mustache.tags).
   *
   * A token is an array with at least 4 elements. The first element is the
   * mustache symbol that was used inside the tag, e.g. "#" or "&". If the tag
   * did not contain a symbol (i.e. {{myValue}}) this element is "name". For
   * all text that appears outside a symbol this element is "text".
   *
   * The second element of a token is its "value". For mustache tags this is
   * whatever else was inside the tag besides the opening symbol. For text tokens
   * this is the text itself.
   *
   * The third and fourth elements of the token are the start and end indices,
   * respectively, of the token in the original template.
   *
   * Tokens that are the root node of a subtree contain two more elements: 1) an
   * array of tokens in the subtree and 2) the index in the original template at
   * which the closing tag for that section begins.
   */
  function parseTemplate (template, tags) {
    if (!template)
      return [];

    var sections = [];     // Stack to hold section tokens
    var tokens = [];       // Buffer to hold the tokens
    var spaces = [];       // Indices of whitespace tokens on the current line
    var hasTag = false;    // Is there a {{tag}} on the current line?
    var nonSpace = false;  // Is there a non-space char on the current line?

    // Strips all whitespace tokens array for the current line
    // if there was a {{#tag}} on it and otherwise only space.
    function stripSpace () {
      if (hasTag && !nonSpace) {
        while (spaces.length)
          delete tokens[spaces.pop()];
      } else {
        spaces = [];
      }

      hasTag = false;
      nonSpace = false;
    }

    var openingTagRe, closingTagRe, closingCurlyRe;
    function compileTags (tagsToCompile) {
      if (typeof tagsToCompile === 'string')
        tagsToCompile = tagsToCompile.split(spaceRe, 2);

      if (!isArray(tagsToCompile) || tagsToCompile.length !== 2)
        throw new Error('Invalid tags: ' + tagsToCompile);

      openingTagRe = new RegExp(escapeRegExp(tagsToCompile[0]) + '\\s*');
      closingTagRe = new RegExp('\\s*' + escapeRegExp(tagsToCompile[1]));
      closingCurlyRe = new RegExp('\\s*' + escapeRegExp('}' + tagsToCompile[1]));
    }

    compileTags(tags || mustache.tags);

    var scanner = new Scanner(template);

    var start, type, value, chr, token, openSection;
    while (!scanner.eos()) {
      start = scanner.pos;

      // Match any text between tags.
      value = scanner.scanUntil(openingTagRe);

      if (value) {
        for (var i = 0, valueLength = value.length; i < valueLength; ++i) {
          chr = value.charAt(i);

          if (isWhitespace(chr)) {
            spaces.push(tokens.length);
          } else {
            nonSpace = true;
          }

          tokens.push([ 'text', chr, start, start + 1 ]);
          start += 1;

          // Check for whitespace on the current line.
          if (chr === '\n')
            stripSpace();
        }
      }

      // Match the opening tag.
      if (!scanner.scan(openingTagRe))
        break;

      hasTag = true;

      // Get the tag type.
      type = scanner.scan(tagRe) || 'name';
      scanner.scan(whiteRe);

      // Get the tag value.
      if (type === '=') {
        value = scanner.scanUntil(equalsRe);
        scanner.scan(equalsRe);
        scanner.scanUntil(closingTagRe);
      } else if (type === '{') {
        value = scanner.scanUntil(closingCurlyRe);
        scanner.scan(curlyRe);
        scanner.scanUntil(closingTagRe);
        type = '&';
      } else {
        value = scanner.scanUntil(closingTagRe);
      }

      // Match the closing tag.
      if (!scanner.scan(closingTagRe))
        throw new Error('Unclosed tag at ' + scanner.pos);

      token = [ type, value, start, scanner.pos ];
      tokens.push(token);

      if (type === '#' || type === '^') {
        sections.push(token);
      } else if (type === '/') {
        // Check section nesting.
        openSection = sections.pop();

        if (!openSection)
          throw new Error('Unopened section "' + value + '" at ' + start);

        if (openSection[1] !== value)
          throw new Error('Unclosed section "' + openSection[1] + '" at ' + start);
      } else if (type === 'name' || type === '{' || type === '&') {
        nonSpace = true;
      } else if (type === '=') {
        // Set the tags for the next time around.
        compileTags(value);
      }
    }

    // Make sure there are no open sections when we're done.
    openSection = sections.pop();

    if (openSection)
      throw new Error('Unclosed section "' + openSection[1] + '" at ' + scanner.pos);

    return nestTokens(squashTokens(tokens));
  }

  /**
   * Combines the values of consecutive text tokens in the given `tokens` array
   * to a single token.
   */
  function squashTokens (tokens) {
    var squashedTokens = [];

    var token, lastToken;
    for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
      token = tokens[i];

      if (token) {
        if (token[0] === 'text' && lastToken && lastToken[0] === 'text') {
          lastToken[1] += token[1];
          lastToken[3] = token[3];
        } else {
          squashedTokens.push(token);
          lastToken = token;
        }
      }
    }

    return squashedTokens;
  }

  /**
   * Forms the given array of `tokens` into a nested tree structure where
   * tokens that represent a section have two additional items: 1) an array of
   * all tokens that appear in that section and 2) the index in the original
   * template that represents the end of that section.
   */
  function nestTokens (tokens) {
    var nestedTokens = [];
    var collector = nestedTokens;
    var sections = [];

    var token, section;
    for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
      token = tokens[i];

      switch (token[0]) {
      case '#':
      case '^':
        collector.push(token);
        sections.push(token);
        collector = token[4] = [];
        break;
      case '/':
        section = sections.pop();
        section[5] = token[2];
        collector = sections.length > 0 ? sections[sections.length - 1][4] : nestedTokens;
        break;
      default:
        collector.push(token);
      }
    }

    return nestedTokens;
  }

  /**
   * A simple string scanner that is used by the template parser to find
   * tokens in template strings.
   */
  function Scanner (string) {
    this.string = string;
    this.tail = string;
    this.pos = 0;
  }

  /**
   * Returns `true` if the tail is empty (end of string).
   */
  Scanner.prototype.eos = function eos () {
    return this.tail === '';
  };

  /**
   * Tries to match the given regular expression at the current position.
   * Returns the matched text if it can match, the empty string otherwise.
   */
  Scanner.prototype.scan = function scan (re) {
    var match = this.tail.match(re);

    if (!match || match.index !== 0)
      return '';

    var string = match[0];

    this.tail = this.tail.substring(string.length);
    this.pos += string.length;

    return string;
  };

  /**
   * Skips all text until the given regular expression can be matched. Returns
   * the skipped string, which is the entire tail if no match can be made.
   */
  Scanner.prototype.scanUntil = function scanUntil (re) {
    var index = this.tail.search(re), match;

    switch (index) {
    case -1:
      match = this.tail;
      this.tail = '';
      break;
    case 0:
      match = '';
      break;
    default:
      match = this.tail.substring(0, index);
      this.tail = this.tail.substring(index);
    }

    this.pos += match.length;

    return match;
  };

  /**
   * Represents a rendering context by wrapping a view object and
   * maintaining a reference to the parent context.
   */
  function Context (view, parentContext) {
    this.view = view;
    this.cache = { '.': this.view };
    this.parent = parentContext;
  }

  /**
   * Creates a new context using the given view with this context
   * as the parent.
   */
  Context.prototype.push = function push (view) {
    return new Context(view, this);
  };

  /**
   * Returns the value of the given name in this context, traversing
   * up the context hierarchy if the value is absent in this context's view.
   */
  Context.prototype.lookup = function lookup (name) {
    var cache = this.cache;

    var value;
    if (cache.hasOwnProperty(name)) {
      value = cache[name];
    } else {
      var context = this, names, index, lookupHit = false;

      while (context) {
        if (name.indexOf('.') > 0) {
          value = context.view;
          names = name.split('.');
          index = 0;

          /**
           * Using the dot notion path in `name`, we descend through the
           * nested objects.
           *
           * To be certain that the lookup has been successful, we have to
           * check if the last object in the path actually has the property
           * we are looking for. We store the result in `lookupHit`.
           *
           * This is specially necessary for when the value has been set to
           * `undefined` and we want to avoid looking up parent contexts.
           **/
          while (value != null && index < names.length) {
            if (index === names.length - 1)
              lookupHit = hasProperty(value, names[index]);

            value = value[names[index++]];
          }
        } else {
          value = context.view[name];
          lookupHit = hasProperty(context.view, name);
        }

        if (lookupHit)
          break;

        context = context.parent;
      }

      cache[name] = value;
    }

    if (isFunction(value))
      value = value.call(this.view);

    return value;
  };

  /**
   * A Writer knows how to take a stream of tokens and render them to a
   * string, given a context. It also maintains a cache of templates to
   * avoid the need to parse the same template twice.
   */
  function Writer () {
    this.cache = {};
  }

  /**
   * Clears all cached templates in this writer.
   */
  Writer.prototype.clearCache = function clearCache () {
    this.cache = {};
  };

  /**
   * Parses and caches the given `template` and returns the array of tokens
   * that is generated from the parse.
   */
  Writer.prototype.parse = function parse (template, tags) {
    var cache = this.cache;
    var tokens = cache[template];

    if (tokens == null)
      tokens = cache[template] = parseTemplate(template, tags);

    return tokens;
  };

  /**
   * High-level method that is used to render the given `template` with
   * the given `view`.
   *
   * The optional `partials` argument may be an object that contains the
   * names and templates of partials that are used in the template. It may
   * also be a function that is used to load partial templates on the fly
   * that takes a single argument: the name of the partial.
   */
  Writer.prototype.render = function render (template, view, partials) {
    var tokens = this.parse(template);
    var context = (view instanceof Context) ? view : new Context(view);
    return this.renderTokens(tokens, context, partials, template);
  };

  /**
   * Low-level method that renders the given array of `tokens` using
   * the given `context` and `partials`.
   *
   * Note: The `originalTemplate` is only ever used to extract the portion
   * of the original template that was contained in a higher-order section.
   * If the template doesn't use higher-order sections, this argument may
   * be omitted.
   */
  Writer.prototype.renderTokens = function renderTokens (tokens, context, partials, originalTemplate) {
    var buffer = '';

    var token, symbol, value;
    for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
      value = undefined;
      token = tokens[i];
      symbol = token[0];

      if (symbol === '#') value = this.renderSection(token, context, partials, originalTemplate);
      else if (symbol === '^') value = this.renderInverted(token, context, partials, originalTemplate);
      else if (symbol === '>') value = this.renderPartial(token, context, partials, originalTemplate);
      else if (symbol === '&') value = this.unescapedValue(token, context);
      else if (symbol === 'name') value = this.escapedValue(token, context);
      else if (symbol === 'text') value = this.rawValue(token);

      if (value !== undefined)
        buffer += value;
    }

    return buffer;
  };

  Writer.prototype.renderSection = function renderSection (token, context, partials, originalTemplate) {
    var self = this;
    var buffer = '';
    var value = context.lookup(token[1]);

    // This function is used to render an arbitrary template
    // in the current context by higher-order sections.
    function subRender (template) {
      return self.render(template, context, partials);
    }

    if (!value) return;

    if (isArray(value)) {
      for (var j = 0, valueLength = value.length; j < valueLength; ++j) {
        buffer += this.renderTokens(token[4], context.push(value[j]), partials, originalTemplate);
      }
    } else if (typeof value === 'object' || typeof value === 'string' || typeof value === 'number') {
      buffer += this.renderTokens(token[4], context.push(value), partials, originalTemplate);
    } else if (isFunction(value)) {
      if (typeof originalTemplate !== 'string')
        throw new Error('Cannot use higher-order sections without the original template');

      // Extract the portion of the original template that the section contains.
      value = value.call(context.view, originalTemplate.slice(token[3], token[5]), subRender);

      if (value != null)
        buffer += value;
    } else {
      buffer += this.renderTokens(token[4], context, partials, originalTemplate);
    }
    return buffer;
  };

  Writer.prototype.renderInverted = function renderInverted (token, context, partials, originalTemplate) {
    var value = context.lookup(token[1]);

    // Use JavaScript's definition of falsy. Include empty arrays.
    // See https://github.com/janl/mustache.js/issues/186
    if (!value || (isArray(value) && value.length === 0))
      return this.renderTokens(token[4], context, partials, originalTemplate);
  };

  Writer.prototype.renderPartial = function renderPartial (token, context, partials) {
    if (!partials) return;

    var value = isFunction(partials) ? partials(token[1]) : partials[token[1]];
    if (value != null)
      return this.renderTokens(this.parse(value), context, partials, value);
  };

  Writer.prototype.unescapedValue = function unescapedValue (token, context) {
    var value = context.lookup(token[1]);
    if (value != null)
      return value;
  };

  Writer.prototype.escapedValue = function escapedValue (token, context) {
    var value = context.lookup(token[1]);
    if (value != null)
      return mustache.escape(value);
  };

  Writer.prototype.rawValue = function rawValue (token) {
    return token[1];
  };

  mustache.name = 'mustache.js';
  mustache.version = '2.2.0';
  mustache.tags = [ '{{', '}}' ];

  // All high-level mustache.* functions use this writer.
  var defaultWriter = new Writer();

  /**
   * Clears all cached templates in the default writer.
   */
  mustache.clearCache = function clearCache () {
    return defaultWriter.clearCache();
  };

  /**
   * Parses and caches the given template in the default writer and returns the
   * array of tokens it contains. Doing this ahead of time avoids the need to
   * parse templates on the fly as they are rendered.
   */
  mustache.parse = function parse (template, tags) {
    return defaultWriter.parse(template, tags);
  };

  /**
   * Renders the `template` with the given `view` and `partials` using the
   * default writer.
   */
  mustache.render = function render (template, view, partials) {
    if (typeof template !== 'string') {
      throw new TypeError('Invalid template! Template should be a "string" ' +
                          'but "' + typeStr(template) + '" was given as the first ' +
                          'argument for mustache#render(template, view, partials)');
    }

    return defaultWriter.render(template, view, partials);
  };

  // This is here for backwards compatibility with 0.4.x.,
  /*eslint-disable */ // eslint wants camel cased function name
  mustache.to_html = function to_html (template, view, partials, send) {
    /*eslint-enable*/

    var result = mustache.render(template, view, partials);

    if (isFunction(send)) {
      send(result);
    } else {
      return result;
    }
  };

  // Export the escaping function so that the user may override it.
  // See https://github.com/janl/mustache.js/issues/244
  mustache.escape = escapeHtml;

  // Export these mainly for testing, but also for advanced usage.
  mustache.Scanner = Scanner;
  mustache.Context = Context;
  mustache.Writer = Writer;

}));

},{}],46:[function(require,module,exports){
/* object-iterators.js - Mini Underscore library
 * by Jonathan Eiten
 *
 * The methods below operate on objects (but not arrays) similarly
 * to Underscore (http://underscorejs.org/#collections).
 *
 * For more information:
 * https://github.com/joneit/object-iterators
 */

'use strict';

/**
 * @constructor
 * @summary Wrap an object for one method call.
 * @Desc Note that the `new` keyword is not necessary.
 * @param {object|null|undefined} object - `null` or `undefined` is treated as an empty plain object.
 * @return {Wrapper} The wrapped object.
 */
function Wrapper(object) {
    if (object instanceof Wrapper) {
        return object;
    }
    if (!(this instanceof Wrapper)) {
        return new Wrapper(object);
    }
    this.originalValue = object;
    this.o = object || {};
}

/**
 * @name Wrapper.chain
 * @summary Wrap an object for a chain of method calls.
 * @Desc Calls the constructor `Wrapper()` and modifies the wrapper for chaining.
 * @param {object} object
 * @return {Wrapper} The wrapped object.
 */
Wrapper.chain = function (object) {
    var wrapped = Wrapper(object); // eslint-disable-line new-cap
    wrapped.chaining = true;
    return wrapped;
};

Wrapper.prototype = {
    /**
     * Unwrap an object wrapped with {@link Wrapper.chain|Wrapper.chain()}.
     * @return {object|null|undefined} The value originally wrapped by the constructor.
     * @memberOf Wrapper.prototype
     */
    value: function () {
        return this.originalValue;
    },

    /**
     * @desc Mimics Underscore's [each](http://underscorejs.org/#each) method: Iterate over the members of the wrapped object, calling `iteratee()` with each.
     * @param {function} iteratee - For each member of the wrapped object, this function is called with three arguments: `(value, key, object)`. The return value of this function is undefined; an `.each` loop cannot be broken out of (use {@link Wrapper#find|.find} instead).
     * @param {object} [context] - If given, `iteratee` is bound to this object. In other words, this object becomes the `this` value in the calls to `iteratee`. (Otherwise, the `this` value will be the unwrapped object.)
     * @return {Wrapper} The wrapped object for chaining.
     * @memberOf Wrapper.prototype
     */
    each: function (iteratee, context) {
        var o = this.o;
        Object.keys(o).forEach(function (key) {
            iteratee.call(this, o[key], key, o);
        }, context || o);
        return this;
    },

    /**
     * @desc Mimics Underscore's [find](http://underscorejs.org/#find) method: Look through each member of the wrapped object, returning the first one that passes a truth test (`predicate`), or `undefined` if no value passes the test. The function returns the value of the first acceptable member, and doesn't necessarily traverse the entire object.
     * @param {function} predicate - For each member of the wrapped object, this function is called with three arguments: `(value, key, object)`. The return value of this function should be truthy if the member passes the test and falsy otherwise.
     * @param {object} [context] - If given, `predicate` is bound to this object. In other words, this object becomes the `this` value in the calls to `predicate`. (Otherwise, the `this` value will be the unwrapped object.)
     * @return {*} The found property's value, or undefined if not found.
     * @memberOf Wrapper.prototype
     */
    find: function (predicate, context) {
        var o = this.o;
        var result;
        if (o) {
            result = Object.keys(o).find(function (key) {
                return predicate.call(this, o[key], key, o);
            }, context || o);
            if (result !== undefined) {
                result = o[result];
            }
        }
        return result;
    },

    /**
     * @desc Mimics Underscore's [filter](http://underscorejs.org/#filter) method: Look through each member of the wrapped object, returning the values of all members that pass a truth test (`predicate`), or empty array if no value passes the test. The function always traverses the entire object.
     * @param {function} predicate - For each member of the wrapped object, this function is called with three arguments: `(value, key, object)`. The return value of this function should be truthy if the member passes the test and falsy otherwise.
     * @param {object} [context] - If given, `predicate` is bound to this object. In other words, this object becomes the `this` value in the calls to `predicate`. (Otherwise, the `this` value will be the unwrapped object.)
     * @return {*} An array containing the filtered values.
     * @memberOf Wrapper.prototype
     */
    filter: function (predicate, context) {
        var o = this.o;
        var result = [];
        if (o) {
            Object.keys(o).forEach(function (key) {
                if (predicate.call(this, o[key], key, o)) {
                    result.push(o[key]);
                }
            }, context || o);
        }
        return result;
    },

    /**
     * @desc Mimics Underscore's [map](http://underscorejs.org/#map) method: Produces a new array of values by mapping each value in list through a transformation function (`iteratee`). The function always traverses the entire object.
     * @param {function} iteratee - For each member of the wrapped object, this function is called with three arguments: `(value, key, object)`. The return value of this function is concatenated to the end of the new array.
     * @param {object} [context] - If given, `iteratee` is bound to this object. In other words, this object becomes the `this` value in the calls to `predicate`. (Otherwise, the `this` value will be the unwrapped object.)
     * @return {*} An array containing the filtered values.
     * @memberOf Wrapper.prototype
     */
    map: function (iteratee, context) {
        var o = this.o;
        var result = [];
        if (o) {
            Object.keys(o).forEach(function (key) {
                result.push(iteratee.call(this, o[key], key, o));
            }, context || o);
        }
        return result;
    },

    /**
     * @desc Mimics Underscore's [reduce](http://underscorejs.org/#reduce) method: Boil down the values of all the members of the wrapped object into a single value. `memo` is the initial state of the reduction, and each successive step of it should be returned by `iteratee()`.
     * @param {function} iteratee - For each member of the wrapped object, this function is called with four arguments: `(memo, value, key, object)`. The return value of this function becomes the new value of `memo` for the next iteration.
     * @param {*} [memo] - If no memo is passed to the initial invocation of reduce, the iteratee is not invoked on the first element of the list. The first element is instead passed as the memo in the invocation of the iteratee on the next element in the list.
     * @param {object} [context] - If given, `iteratee` is bound to this object. In other words, this object becomes the `this` value in the calls to `iteratee`. (Otherwise, the `this` value will be the unwrapped object.)
     * @return {*} The value of `memo` "reduced" as per `iteratee`.
     * @memberOf Wrapper.prototype
     */
    reduce: function (iteratee, memo, context) {
        var o = this.o;
        if (o) {
            Object.keys(o).forEach(function (key, idx) {
                memo = (!idx && memo === undefined) ? o[key] : iteratee(memo, o[key], key, o);
            }, context || o);
        }
        return memo;
    },

    /**
     * @desc Mimics Underscore's [extend](http://underscorejs.org/#extend) method: Copy all of the properties in each of the `source` object parameter(s) over to the (wrapped) destination object (thus mutating it). It's in-order, so the properties of the last `source` object will override properties with the same name in previous arguments or in the destination object.
     * > This method copies own members as well as members inherited from prototype chain.
     * @param {...object|null|undefined} source - Values of `null` or `undefined` are treated as empty plain objects.
     * @return {Wrapper|object} The wrapped destination object if chaining is in effect; otherwise the unwrapped destination object.
     * @memberOf Wrapper.prototype
     */
    extend: function (source) {
        var o = this.o;
        Array.prototype.slice.call(arguments).forEach(function (object) {
            if (object) {
                for (var key in object) {
                    o[key] = object[key];
                }
            }
        });
        return this.chaining ? this : o;
    },

    /**
     * @desc Mimics Underscore's [extendOwn](http://underscorejs.org/#extendOwn) method: Like {@link Wrapper#extend|extend}, but only copies its "own" properties over to the destination object.
     * @param {...object|null|undefined} source - Values of `null` or `undefined` are treated as empty plain objects.
     * @return {Wrapper|object} The wrapped destination object if chaining is in effect; otherwise the unwrapped destination object.
     * @memberOf Wrapper.prototype
     */
    extendOwn: function (source) {
        var o = this.o;
        Array.prototype.slice.call(arguments).forEach(function (object) {
            Wrapper(object).each(function (val, key) { // eslint-disable-line new-cap
                o[key] = val;
            });
        });
        return this.chaining ? this : o;
    }
};

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find
if (!Array.prototype.find) {
    Array.prototype.find = function (predicate) { // eslint-disable-line no-extend-native
        if (this === null) {
            throw new TypeError('Array.prototype.find called on null or undefined');
        }
        if (typeof predicate !== 'function') {
            throw new TypeError('predicate must be a function');
        }
        var list = Object(this);
        var length = list.length >>> 0;
        var thisArg = arguments[1];
        var value;

        for (var i = 0; i < length; i++) {
            value = list[i];
            if (predicate.call(thisArg, value, i, list)) {
                return value;
            }
        }
        return undefined;
    };
}

module.exports = Wrapper;

},{}],47:[function(require,module,exports){
/* eslint-env browser */

'use strict';

var REGEXP_INDIRECTION = /^(\w+)\((\w+)\)$/;  // finds complete pattern a(b) where both a and b are regex "words"

/** @typedef {object} valueItem
 * You should supply both `name` and `alias` but you could omit one or the other and whichever you provide will be used for both.
 * > If you only give the `name` property, you might as well just give a string for {@link menuItem} rather than this object.
 * @property {string} [name=alias] - Value of `value` attribute of `<option>...</option>` element.
 * @property {string} [alias=name] - Text of `<option>...</option>` element.
 * @property {string} [type] One of the keys of `this.converters`. If not one of these (including `undefined`), field values will be tested with a string comparison.
 * @property {boolean} [hidden=false]
 */

/** @typedef {object|menuItem[]} submenuItem
 * @summary Hierarchical array of select list items.
 * @desc Data structure representing the list of `<option>...</option>` and `<optgroup>...</optgroup>` elements that make up a `<select>...</select>` element.
 *
 * > Alternate form: Instead of an object with a `menu` property containing an array, may itself be that array. Both forms have the optional `label` property.
 * @property {string} [label] - Defaults to a generated string of the form "Group n[.m]..." where each decimal position represents a level of the optgroup hierarchy.
 * @property {menuItem[]} submenu
 */

/** @typedef {string|valueItem|submenuItem} menuItem
 * May be one of three possible types that specify either an `<option>....</option>` element or an `<optgroup>....</optgroup>` element as follows:
 * * If a `string`, specifies the text of an `<option>....</option>` element with no `value` attribute. (In the absence of a `value` attribute, the `value` property of the element defaults to the text.)
 * * If shaped like a {@link valueItem} object, specifies both the text and value of an `<option....</option>` element.
 * * If shaped like a {@link submenuItem} object (or its alternate array form), specifies an `<optgroup>....</optgroup>` element.
 */

/**
 * @summary Builds a new menu pre-populated with items and groups.
 * @desc This function creates a new pop-up menu (a.k.a. "drop-down"). This is a `<select>...</select>` element, pre-populated with items (`<option>...</option>` elements) and groups (`<optgroup>...</optgroup>` elements).
 * > Bonus: This function also builds `input type=text` elements.
 * > NOTE: This function generates OPTGROUP elements for subtrees. However, note that HTML5 specifies that OPTGROUP elemnents made not nest! This function generates the markup for them but they are not rendered by most browsers, or not completely. Therefore, for now, do not specify more than one level subtrees. Future versions of HTML may support it. I also plan to add here options to avoid OPTGROUPS entirely either by indenting option text, or by creating alternate DOM nodes using `<li>` instead of `<select>`, or both.
 * @memberOf popMenu
 *
 * @param {Element|string} el - Must be one of (case-sensitive):
 * * text box - an `HTMLInputElement` to use an existing element or `'INPUT'` to create a new one
 * * drop-down - an `HTMLSelectElement` to use an existing element or `'SELECT'` to create a new one
 * * submenu - an `HTMLOptGroupElement` to use an existing element or `'OPTGROUP'` to create a new one (meant for internal use only)
 *
 * @param {menuItem[]} [menu] - Hierarchical list of strings to add as `<option>...</option>` or `<optgroup>....</optgroup>` elements. Omitting creates a text box.
 *
 * @param {null|string} [options.prompt=''] - Adds an initial `<option>...</option>` element to the drop-down with this value in parentheses as its `text`; and empty string as its `value`. Default is empty string, which creates a blank prompt; `null` suppresses prompt altogether.
 *
 * @param {boolean} [options.sort] - Whether to alpha sort or not. If truthy, sorts each optgroup on its `label`; and each select option on its text (its `alias` if given; or its `name` if not).
 *
 * @param {string[]} [options.blacklist] - Optional list of menu item names to be ignored.
 *
 * @param {number[]} [options.breadcrumbs] - List of option group section numbers (root is section 0). (For internal use.)
 *
 * @param {boolean} [options.append=false] - When `el` is an existing `<select>` Element, giving truthy value adds the new children without first removing existing children.
 *
 * @returns {Element} Either a `<select>` or `<optgroup>` element.
 */
function build(el, menu, options) {
    options = options || {};

    var prompt = options.prompt,
        blacklist = options.blacklist,
        sort = options.sort,
        breadcrumbs = options.breadcrumbs || [],
        path = breadcrumbs.length ? breadcrumbs.join('.') + '.' : '',
        subtreeName = popMenu.subtree,
        groupIndex = 0,
        tagName;

    if (el instanceof Element) {
        tagName = el.tagName;
        if (!options.append) {
            el.innerHTML = ''; // remove all <option> and <optgroup> elements
        }
    } else {
        tagName = el;
        el = document.createElement(tagName);
    }

    if (menu) {
        var add, newOption;
        if (tagName === 'SELECT') {
            add = el.add;
            if (prompt) {
                newOption = new Option(prompt, '');
                newOption.innerHTML += '&hellip;';
                el.add(newOption);
            } else if (prompt !== null) {
                el.add(new Option());
            }
        } else {
            add = el.appendChild;
            el.label = prompt;
        }

        if (sort) {
            menu = menu.slice().sort(itemComparator); // sorted clone
        }

        menu.forEach(function(item) {
            // if item is of form a(b) and there is an function a in options, then item = options.a(b)
            if (options && typeof item === 'string') {
                var indirection = item.match(REGEXP_INDIRECTION);
                if (indirection) {
                    var a = indirection[1],
                        b = indirection[2],
                        f = options[a];
                    if (typeof f === 'function') {
                        item = f(b);
                    } else {
                        throw 'build: Expected options.' + a + ' to be a function.';
                    }
                }
            }

            var subtree = item[subtreeName] || item;
            if (subtree instanceof Array) {

                var groupOptions = {
                    breadcrumbs: breadcrumbs.concat(++groupIndex),
                    prompt: item.label || 'Group ' + path + groupIndex,
                    options: sort,
                    blacklist: blacklist
                };

                var optgroup = build('OPTGROUP', subtree, groupOptions);

                if (optgroup.childElementCount) {
                    el.appendChild(optgroup);
                }

            } else if (typeof item !== 'object') {

                if (!(blacklist && blacklist.indexOf(item) >= 0)) {
                    add.call(el, new Option(item));
                }

            } else if (!item.hidden) {

                var name = item.name || item.alias;
                if (!(blacklist && blacklist.indexOf(name) >= 0)) {
                    add.call(el, new Option(
                        item.alias || item.name,
                        name
                    ));
                }

            }
        });
    } else {
        el.type = 'text';
    }

    return el;
}

function itemComparator(a, b) {
    a = a.alias || a.name || a.label || a;
    b = b.alias || b.name || b.label || b;
    return a < b ? -1 : a > b ? 1 : 0;
}

/**
 * @summary Recursively searches the context array of `menuItem`s for a named `item`.
 * @memberOf popMenu
 * @this Array
 * @param {object} [options]
 * @param {string} [options.keys=[popMenu.defaultKey]] - Properties to search each menuItem when it is an object.
 * @param {boolean} [options.caseSensitive=false] - Ignore case while searching.
 * @param {string} value - Value to search for.
 * @returns {undefined|menuItem} The found item or `undefined` if not found.
 */
function lookup(options, value) {
    if (arguments.length === 1) {
        value = options;
        options = undefined;
    }

    var shallow, deep, item, prop,
        keys = options && options.keys || [popMenu.defaultKey],
        caseSensitive = options && options.caseSensitive;

    value = toString(value, caseSensitive);

    shallow = this.find(function(item) {
        var subtree = item[popMenu.subtree] || item;

        if (subtree instanceof Array) {
            return (deep = lookup.call(subtree, options, value));
        }

        if (typeof item !== 'object') {
            return toString(item, caseSensitive) === value;
        } else {
            for (var i = 0; i < keys.length; ++i) {
                prop = item[keys[i]];
                if (prop && toString(prop, caseSensitive) === value) {
                    return true;
                }
            }
        }
    });

    item = deep || shallow;

    return item && (item.name ? item : { name: item });
}

function toString(s, caseSensitive) {
    var result = '';
    if (s) {
        result += s; // convert s to string
        if (!caseSensitive) {
            result = result.toUpperCase();
        }
    }
    return result;
}

/**
 * @summary Recursively walks the context array of `menuItem`s and calls `iteratee` on each item therein.
 * @desc `iteratee` is called with each item (terminal node) in the menu tree and a flat 0-based index. Recurses on member with name of `popMenu.subtree`.
 *
 * The node will always be a {@link valueItem} object; when a `string`, it is boxed for you.
 *
 * @memberOf popMenu
 *
 * @this Array
 *
 * @param {function} iteratee - For each item in the menu, `iteratee` is called with:
 * * the `valueItem` (if the item is a primative string, it is wrapped up for you)
 * * a 0-based `ordinal`
 *
 * The `iteratee` return value can be used to replace the item, as follows:
 * * `undefined` - do nothing
 * * `null` - splice out the item; resulting empty submenus are also spliced out (see note)
 * * anything else - replace the item with this value; if value is a subtree (i.e., an array) `iteratee` will then be called to walk it as well (see note)
 *
 * > Note: Returning anything (other than `undefined`) from `iteratee` will (deeply) mutate the original `menu` so you may want to copy it first (deeply, including all levels of array nesting but not the terminal node objects).
 *
 * @returns {number} Number of items (terminal nodes) in the menu tree.
 */
function walk(iteratee) {
    var menu = this,
        ordinal = 0,
        subtreeName = popMenu.subtree,
        i, item, subtree, newVal;

    for (i = menu.length - 1; i >= 0; --i) {
        item = menu[i];
        subtree = item[subtreeName] || item;

        if (!(subtree instanceof Array)) {
            subtree = undefined;
        }

        if (!subtree) {
            newVal = iteratee(item.name ? item : { name: item }, ordinal);
            ordinal += 1;

            if (newVal !== undefined) {
                if (newVal === null) {
                    menu.splice(i, 1);
                    ordinal -= 1;
                } else {
                    menu[i] = item = newVal;
                    subtree = item[subtreeName] || item;
                    if (!(subtree instanceof Array)) {
                        subtree = undefined;
                    }
                }
            }
        }

        if (subtree) {
            ordinal += walk.call(subtree, iteratee);
            if (subtree.length === 0) {
                menu.splice(i, 1);
                ordinal -= 1;
            }
        }
    }

    return ordinal;
}

/**
 * @summary Format item name with it's alias when available.
 * @memberOf popMenu
 * @param {string|valueItem} item
 * @returns {string} The formatted name and alias.
 */
function formatItem(item) {
    var result = item.name || item;
    if (item.alias) {
        result = '"' + item.alias + '" (' + result + ')';
    }
    return result;
}


function isGroupProxy(s) {
    return REGEXP_INDIRECTION.test(s);
}

/**
 * @namespace
 */
var popMenu = {
    build: build,
    walk: walk,
    lookup: lookup,
    formatItem: formatItem,
    isGroupProxy: isGroupProxy,
    subtree: 'submenu',
    defaultKey: 'name'
};

module.exports = popMenu;

},{}],48:[function(require,module,exports){
'use strict';

/* eslint-env node, browser */

/**
 * Creates a new read-only property and attaches it to the provided context.
 * @private
 * @param {string} name - Name for new property.
 * @param {*} [value] - Value of new property.
 */
function addReadOnlyProperty(name, value) {
    Object.defineProperty(this, name, {
        value: value,
        writable: false,
        enumerable: true,
        configurable: false
    });
}

/**
 * @constructor Point
 *
 * @desc This object represents a single point in an abstract 2-dimensional matrix.
 *
 * The unit of measure is typically pixels.
 * (If used to model computer graphics, vertical coordinates are typically measured downwards
 * from the top of the window. This convention however is not inherent in this object.)
 *
 * Note: This object should be instantiated with the `new` keyword.
 *
 * @param {number} x - the new point's `x` property
 * @param {number} y - the new point's `y` property
 */
function Point(x, y) {

    /**
     * @name x
     * @type {number}
     * @summary This point's horizontal coordinate.
     * @desc Created upon instantiation by the {@link Point|constructor}.
     * @memberOf Point.prototype
     * @abstract
     */
    addReadOnlyProperty.call(this, 'x', Number(x) || 0);

    /**
     * @name y
     * @type {number}
     * @summary This point's vertical coordinate.
     * @desc Created upon instantiation by the {@link Point|constructor}.
     * @memberOf Point.prototype
     * @abstract
     */
    addReadOnlyProperty.call(this, 'y', Number(y) || 0);

}

Point.prototype = {

    /**
     * @returns {Point} A new point which is this point's position increased by coordinates of given `offset`.
     * @param {Point} offset - Horizontal and vertical values to add to this point's coordinates.
     * @memberOf Point.prototype
     */
    plus: function(offset) {
        return new Point(
            this.x + offset.x,
            this.y + offset.y
        );
    },

    /**
     * @returns {Point} A new point which is this point's position increased by given offsets.
     * @param {number} [offsetX=0] - Value to add to this point's horizontal coordinate.
     * @param {number} [offsetY=0] - Value to add to this point's horizontal coordinate.
     * @memberOf Point.prototype
     */
    plusXY: function(offsetX, offsetY) {
        return new Point(
            this.x + (offsetX || 0),
            this.y + (offsetY || 0)
        );
    },

    /**
     * @returns {Point} A new point which is this point's position decreased by coordinates of given `offset`.
     * @param {Point} offset - Horizontal and vertical values to subtract from this point's coordinates.
     * @memberOf Point.prototype
     */
    minus: function(offset) {
        return new Point(
            this.x - offset.x,
            this.y - offset.y
        );
    },

    /**
     * @returns {Point} A new `Point` positioned to least x and least y of this point and given `offset`.
     * @param {Point} point - A point to compare to this point.
     * @memberOf Point.prototype
     */
    min: function(point) {
        return new Point(
            Math.min(this.x, point.x),
            Math.min(this.y, point.y)
        );
    },

    /**
     * @returns {Point} A new `Point` positioned to greatest x and greatest y of this point and given `point`.
     * @param {Point} point - A point to compare to this point.
     * @memberOf Point.prototype
     */
    max: function(point) {
        return new Point(
            Math.max(this.x, point.x),
            Math.max(this.y, point.y)
        );
    },

    /**
     * @returns {number} Distance between given `point` and this point using Pythagorean Theorem formula.
     * @param {Point} point - A point from which to compute the distance to this point.
     * @memberOf Point.prototype
     */
    distance: function(point) {
        var deltaX = point.x - this.x,
            deltaY = point.y - this.y;

        return Math.sqrt(
            deltaX * deltaX +
            deltaY * deltaY
        );
    },

    /**
     * _(Formerly: `equal`.)_
     * @returns {boolean} `true` iff _both_ coordinates of this point are exactly equal to those of given `point`.
     * @param {Point} point - A point to compare to this point.
     * @memberOf Point.prototype
     */
    equals: function(point) {
        var result = false;

        if (point) {
            result =
                this.x === point.x &&
                this.y === point.y;
        }

        return result;
    },

    /**
     * @returns {boolean} `true` iff _both_ coordinates of this point are greater than those of given `point`.
     * @param {Point} point - A point to compare to this point
     * @memberOf Point.prototype
     */
    greaterThan: function(point) {
        return (
            this.x > point.x &&
            this.y > point.y
        );
    },

    /**
     * @returns {boolean} `true` iff _both_ coordinates of this point are less than those of given `point`.
     * @param {Point} point - A point to compare to this point
     * @memberOf Point.prototype
     */
    lessThan: function(point) {
        return (
            this.x < point.x &&
            this.y < point.y
        );
    },

    /**
     * _(Formerly `greaterThanEqualTo`.)_
     * @returns {boolean} `true` iff _both_ coordinates of this point are greater than or equal to those of given `point`.
     * @param {Point} point - A point to compare to this point
     * @memberOf Point.prototype
     */
    greaterThanOrEqualTo: function(point) {
        return (
            this.x >= point.x &&
            this.y >= point.y
        );
    },

    /**
     * _(Formerly `lessThanEqualTo`.)_
     * @returns {boolean} `true` iff _both_ coordinates of this point are less than or equal to those of given `point`.
     * @param {Point} point - A point to compare to this point.
     * @memberOf Point.prototype
     */
    lessThanOrEqualTo: function(point) {
        return (
            this.x <= point.x &&
            this.y <= point.y
        );
    },

    /**
     * _(Formerly `isContainedWithinRectangle`.)_
     * @param rect {Rectangle} - Rectangle to test this point against.
     * @returns {boolean} `true` iff this point is within given `rect`.
     * @memberOf Point.prototype
     */
    within: function(rect) {
        var minX = rect.origin.x,
            maxX = minX + rect.extent.x;
        var minY = rect.origin.y,
            maxY = minY + rect.extent.y;

        if (rect.extent.x < 0) {
            minX = maxX;
            maxX = rect.origin.x;
        }

        if (rect.extent.y < 0) {
            minY = maxY;
            maxY = rect.origin.y;
        }

        return (
            minX <= this.x && this.x < maxX &&
            minY <= this.y && this.y < maxY
        );
    }
};

Point.prototype.EQ = Point.prototype.equals;
Point.prototype.GT = Point.prototype.greaterThan;
Point.prototype.LT = Point.prototype.lessThan;
Point.prototype.GE = Point.prototype.greaterThanOrEqualTo;
Point.prototype.LE = Point.prototype.lessThanOrEqualTo;


/**
 * @constructor Rectangle
 *
 * @desc This object represents a rectangular area within an abstract 2-dimensional matrix.
 *
 * The unit of measure is typically pixels.
 * (If used to model computer graphics, vertical coordinates are typically measured downwards
 * from the top of the window. This convention however is not inherent in this object.)
 *
 * Normally, the `x` and `y` parameters to the constructor describe the upper left corner of the rect.
 * However, negative values of `width` and `height` will be added to the given `x` and `y`. That is,
 * a negative value of the `width` parameter will extend the rect to the left of the given `x` and
 * a negative value of the `height` parameter will extend the rect above the given `y`.
 * In any case, after instantiation the following are guaranteed to always be true:
 * * The `extent`, `width`, and `height` properties _always_ give positive values.
 * * The `origin`, `top`, and `left` properties _always_ reflect the upper left corner.
 * * The `corner`, `bottom`, and `right` properties _always_ reflect the lower right corner.
 *
 * Note: This object should be instantiated with the `new` keyword.
 *
 * @param {number} [x=0] - Horizontal coordinate of some corner of the rect.
 * @param {number} [y=0] - Vertical coordinate of some corner of the rect.
 * @param {number} [width=0] - Width of the new rect. May be negative (see above).
 * @param {number} [height=0] - Height of the new rect. May be negative (see above).
 */
function Rectangle(x, y, width, height) {

    x = Number(x) || 0;
    y = Number(y) || 0;
    width = Number(width) || 0;
    height = Number(height) || 0;

    if (width < 0) {
        x += width;
        width = -width;
    }

    if (height < 0) {
        y += height;
        height = -height;
    }

    /**
     * @name origin
     * @type {Point}
     * @summary Upper left corner of this rect.
     * @desc Created upon instantiation by the {@linkplain Rectangle|constructor}.
     * @memberOf Rectangle.prototype
     * @abstract
     */
    addReadOnlyProperty.call(this, 'origin', new Point(x, y));

    /**
     * @name extent
     * @type {Point}
     * @summary this rect's width and height.
     * @desc Unlike the other `Point` properties, `extent` is not a global coordinate pair; rather it consists of a _width_ (`x`, always positive) and a _height_ (`y`, always positive).
     *
     * This object might be more legitimately typed as something like `Area` with properties `width` and `height`; however we wanted it to be able to use it efficiently with a point's `plus` and `minus` methods (that is, without those methods having to check and branch on the type of its parameter).
     *
     * Created upon instantiation by the {@linkplain Rectangle|constructor}.
     * @see The {@link Rectangle#corner|corner} method.
     * @memberOf Rectangle.prototype
     * @abstract
     */
    addReadOnlyProperty.call(this, 'extent', new Point(width, height));

    /**
     * @name corner
     * @type {Point}
     * @summary Lower right corner of this rect.
     * @desc This is a calculated value created upon instantiation by the {@linkplain Rectangle|constructor}. It is `origin` offset by `extent`.
     *
     * **Note:** These coordinates actually point to the pixel one below and one to the right of the rect's actual lower right pixel.
     * @memberOf Rectangle.prototype
     * @abstract
     */
    addReadOnlyProperty.call(this, 'corner', new Point(x + width, y + height));

    /**
     * @name center
     * @type {Point}
     * @summary Center of this rect.
     * @desc Created upon instantiation by the {@linkplain Rectangle|constructor}.
     * @memberOf Rectangle.prototype
     * @abstract
     */
    addReadOnlyProperty.call(this, 'center', new Point(x + (width / 2), y + (height / 2)));

}

Rectangle.prototype = {

    /**
     * @type {number}
     * @desc _(Formerly a function; now a getter.)_
     * @summary Minimum vertical coordinate of this rect.
     * @memberOf Rectangle.prototype
     */
    get top() {
        return this.origin.y;
    },

    /**
     * @type {number}
     * @desc _(Formerly a function; now a getter.)_
     * @summary Minimum horizontal coordinate of this rect.
     * @memberOf Rectangle.prototype
     */
    get left() {
        return this.origin.x;
    },

    /**
     * @type {number}
     * @desc _(Formerly a function; now a getter.)_
     * @summary Maximum vertical coordinate of this rect + 1.
     * @memberOf Rectangle.prototype
     */
    get bottom() {
        return this.corner.y;
    },

    /**
     * @type {number}
     * @desc _(Formerly a function; now a getter.)_
     * @summary Maximum horizontal coordinate of this rect + 1.
     * @memberOf Rectangle.prototype
     */
    get right() {
        return this.corner.x;
    },

    /**
     * @type {number}
     * @desc _(Formerly a function; now a getter.)_
     * @summary Width of this rect (always positive).
     * @memberOf Rectangle.prototype
     */
    get width() {
        return this.extent.x;
    },

    /**
     * @type {number}
     * @desc _(Formerly a function; now a getter.)_
     * @summary Height of this rect (always positive).
     * @memberOf Rectangle.prototype
     */
    get height() {
        return this.extent.y;
    },

    /**
     * @type {number}
     * @desc _(Formerly a function; now a getter.)_
     * @summary Area of this rect.
     * @memberOf Rectangle.prototype
     */
    get area() {
        return this.width * this.height;
    },

    /**
     * @returns {Rectangle} A copy of this rect but with horizontal position reset to given `x` and no width.
     * @param {number} x - Horizontal coordinate of the new rect.
     * @memberOf Rectangle.prototype
     */
    flattenXAt: function(x) {
        return new Rectangle(x, this.origin.y, 0, this.extent.y);
    },

    /**
     * @returns {Rectangle} A copy of this rect but with vertical position reset to given `y` and no height.
     * @param {number} y - Vertical coordinate of the new rect.
     * @memberOf Rectangle.prototype
     */
    flattenYAt: function(y) {
        return new Rectangle(this.origin.x, y, this.extent.x, 0);
    },

    /**
     * @returns {boolean} `true` iff given `point` entirely contained within this rect.
     * @param {Point} pointOrRect - The point or rect to test for containment.
     * @memberOf Rectangle.prototype
     */
    contains: function(pointOrRect) {
        return pointOrRect.within(this);
    },

    /**
     * _(Formerly `isContainedWithinRectangle`.)_
     * @returns {boolean} `true` iff `this` rect is entirely contained within given `rect`.
     * @param {Rectangle} rect - Rectangle to test against this rect.
     * @memberOf Rectangle.prototype
     */
    within: function(rect) {
        return (
            rect.origin.lessThanOrEqualTo(this.origin) &&
            rect.corner.greaterThanOrEqualTo(this.corner)
        );
    },

    /**
     * _(Formerly: `insetBy`.)_
     * @returns {Rectangle} That is enlarged/shrunk by given `padding`.
     * @param {number} padding - Amount by which to increase (+) or decrease (-) this rect
     * @see The {@link Rectangle#shrinkBy|shrinkBy} method.
     * @memberOf Rectangle.prototype
     */
    growBy: function(padding) {
        return new Rectangle(
            this.origin.x + padding,
            this.origin.y + padding,
            this.extent.x - padding - padding,
            this.extent.y - padding - padding);
    },

    /**
     * @returns {Rectangle} That is enlarged/shrunk by given `padding`.
     * @param {number} padding - Amount by which to decrease (+) or increase (-) this rect.
     * @see The {@link Rectangle#growBy|growBy} method.
     * @memberOf Rectangle.prototype
     */
    shrinkBy: function(padding) {
        return this.growBy(-padding);
    },

    /**
     * @returns {Rectangle} Bounding rect that contains both this rect and the given `rect`.
     * @param {Rectangle} rect - The rectangle to union with this rect.
     * @memberOf Rectangle.prototype
     */
    union: function(rect) {
        var origin = this.origin.min(rect.origin),
            corner = this.corner.max(rect.corner),
            extent = corner.minus(origin);

        return new Rectangle(
            origin.x, origin.y,
            extent.x, extent.y
        );
    },

    /**
     * iterate over all points within this rect, invoking `iteratee` for each.
     * @param {function(number,number)} iteratee - Function to call for each point.
     * Bound to `context` when given; otherwise it is bound to this rect.
     * Each invocation of `iteratee` is called with two arguments:
     * the horizontal and vertical coordinates of the point.
     * @param {object} [context=this] - Context to bind to `iteratee` (when not `this`).
     * @memberOf Rectangle.prototype
     */
    forEach: function(iteratee, context) {
        context = context || this;
        for (var x = this.origin.x, x2 = this.corner.x; x < x2; x++) {
            for (var y = this.origin.y, y2 = this.corner.y; y < y2; y++) {
                iteratee.call(context, x, y);
            }
        }
    },

    /**
     * @returns {Rectangle} One of:
     * * _If this rect intersects with the given `rect`:_
     *      a new rect representing that intersection.
     * * _If it doesn't intersect and `ifNoneAction` defined:_
     *      result of calling `ifNoneAction`.
     * * _If it doesn't intersect and `ifNoneAction` undefined:_
     *      `null`.
     * @param {Rectangle} rect - The rectangle to intersect with this rect.
     * @param {function(Rectangle)} [ifNoneAction] - When no intersection, invoke and return result.
     * Bound to `context` when given; otherwise bound to this rect.
     * Invoked with `rect` as sole parameter.
     * @param {object} [context=this] - Context to bind to `ifNoneAction` (when not `this`).
     * @memberOf Rectangle.prototype
     */
    intersect: function(rect, ifNoneAction, context) {
        var result = null,
            origin = this.origin.max(rect.origin),
            corner = this.corner.min(rect.corner),
            extent = corner.minus(origin);

        if (extent.x > 0 && extent.y > 0) {
            result = new Rectangle(
                origin.x, origin.y,
                extent.x, extent.y
            );
        } else if (typeof ifNoneAction === 'function') {
            result = ifNoneAction.call(context || this, rect);
        }

        return result;
    },

    /**
     * @returns {boolean} `true` iff this rect overlaps with given `rect`.
     * @param {Rectangle} rect - The rectangle to intersect with this rect.
     * @memberOf Rectangle.prototype
     */
    intersects: function(rect) {
        return (
            rect.corner.x > this.origin.x &&
            rect.corner.y > this.origin.y &&
            rect.origin.x < this.corner.x &&
            rect.origin.y < this.corner.y
        );
    }
};

// Interface
exports.Point = Point;
exports.Rectangle = Rectangle;

},{}],49:[function(require,module,exports){
'use strict';

var // a regex search pattern that matches all the reserved chars of a regex search pattern
    reserved = /([\.\\\+\*\?\^\$\(\)\{\}\=\!\<\>\|\:\[\]])/g,

    // regex wildcard search patterns
    REGEXP_WILDCARD = '.*',
    REGEXP_WILDCHAR = '.',
    REGEXP_WILDCARD_MATCHER = '(' + REGEXP_WILDCARD + ')',

    // LIKE search patterns
    LIKE_WILDCHAR = '_',
    LIKE_WILDCARD = '%',

    // regex search patterns that match LIKE search patterns
    REGEXP_LIKE_PATTERN_MATCHER = new RegExp('(' + [
        LIKE_WILDCHAR,
        LIKE_WILDCARD,
        '\\[\\^?[^-\\]]+]', // matches a LIKE set (same syntax as a RegExp set)
        '\\[\\^?[^-\\]]\\-[^\\]]]' // matches a LIKE range (same syntax as a RegExp range)
    ].join('|') + ')', 'g');

function regExpLIKE(pattern, ignoreCase) {
    var i, parts;

    // Find all LIKE patterns
    parts = pattern.match(REGEXP_LIKE_PATTERN_MATCHER);

    if (parts) {
        // Translate found LIKE patterns to regex patterns, escaped intervening non-patterns, and interleave the two

        for (i = 0; i < parts.length; ++i) {
            // Escape left brackets (unpaired right brackets are OK)
            if (parts[i][0] === '[') {
                parts[i] = regExpLIKE.reserve(parts[i]);
            }

            // Make each found pattern matchable by enclosing in parentheses
            parts[i] = '(' + parts[i] + ')';
        }

        // Match these precise patterns again with their intervening non-patterns (i.e., text)
        parts = pattern.match(new RegExp(
            REGEXP_WILDCARD_MATCHER +
            parts.join(REGEXP_WILDCARD_MATCHER)  +
            REGEXP_WILDCARD_MATCHER
        ));

        // Discard first match of non-global search (which is the whole string)
        parts.shift();

        // For each re-found pattern part, translate % and _ to regex equivalent
        for (i = 1; i < parts.length; i += 2) {
            var part = parts[i];
            switch (part) {
                case LIKE_WILDCARD: part = REGEXP_WILDCARD; break;
                case LIKE_WILDCHAR: part = REGEXP_WILDCHAR; break;
                default:
                    var j = part[1] === '^' ? 2 : 1;
                    part = '[' + regExpLIKE.reserve(part.substr(j, part.length - (j + 1))) + ']';
            }
            parts[i] = part;
        }
    } else {
        parts = [pattern];
    }

    // For each surrounding text part, escape reserved regex chars
    for (i = 0; i < parts.length; i += 2) {
        parts[i] = regExpLIKE.reserve(parts[i]);
    }

    // Join all the interleaved parts
    parts = parts.join('');

    // Optimize or anchor the pattern at each end as needed
    if (parts.substr(0, 2) === REGEXP_WILDCARD) { parts = parts.substr(2); } else { parts = '^' + parts; }
    if (parts.substr(-2, 2) === REGEXP_WILDCARD) { parts = parts.substr(0, parts.length - 2); } else { parts += '$'; }

    // Return the new regex
    return new RegExp(parts, ignoreCase ? 'i' : undefined);
}

regExpLIKE.reserve = function (s) {
    return s.replace(reserved, '\\$1');
};

var cache, size;

/**
 * @summary Delete a pattern from the cache; or clear the whole cache.
 * @param {string} [pattern] - The LIKE pattern to remove from the cache. Fails silently if not found in the cache. If pattern omitted, clears whole cache.
 */
(regExpLIKE.clearCache = function (pattern) {
    if (!pattern) {
        cache = {};
        size = 0;
    } else if (cache[pattern]) {
        delete cache[pattern];
        size--;
    }
    return size;
})(); // init the cache

regExpLIKE.getCacheSize = function () { return size; };

/**
 * @summary Cached version of `regExpLIKE()`.
 * @desc Cached entries are subject to garbage collection if `keep` is `undefined` or `false` on insertion or `false` on most recent reference. Garbage collection will occur iff `regExpLIKE.cacheMax` is defined and it equals the number of cached patterns. The garbage collector sorts the patterns based on most recent reference; the oldest 10% of the entries are deleted. Alternatively, you can manage the cache yourself to a limited extent (see {@link regeExpLIKE.clearCache|clearCache}).
 * @param pattern - the LIKE pattern (to be) converted to a RegExp
 * @param [keep] - If given, changes the keep status for this pattern as follows:
 * * `true` permanently caches the pattern (not subject to garbage collection) until `false` is given on a subsequent call
 * * `false` allows garbage collection on the cached pattern
 * * `undefined` no change to keep status
 * @returns {RegExp}
 */
regExpLIKE.cached = function (keep, pattern, ignoreCase) {
    if (typeof keep === 'string') {
        ignoreCase = pattern;
        pattern = keep;
        keep = false;
    }
    var patternAndCase = pattern + (ignoreCase ? 'i' : 'c'),
        item = cache[patternAndCase];
    if (item) {
        item.when = new Date().getTime();
        if (keep !== undefined) {
            item.keep = keep;
        }
    } else {
        if (size === regExpLIKE.cacheMax) {
            var age = [], ages = 0, key, i;
            for (key in cache) {
                item = cache[key];
                if (!item.keep) {
                    for (i = 0; i < ages; ++i) {
                        if (item.when < age[i].item.when) {
                            break;
                        }
                    }
                    age.splice(i, 0, { key: key, item: item });
                    ages++;
                }
            }
            if (!age.length) {
                return regExpLIKE(pattern, ignoreCase); // cache is full!
            }
            i = Math.ceil(age.length / 10); // will always be at least 1
            size -= i;
            while (i--) {
                delete cache[age[i].key];
            }
        }
        item = cache[patternAndCase] = {
            regex: regExpLIKE(pattern, ignoreCase),
            keep: keep,
            when: new Date().getTime()
        };
        size++;
    }
    return item.regex;
};

module.exports = regExpLIKE;

},{}],50:[function(require,module,exports){
'use strict';

/* eslint-env node, browser */

(function (module) {  // eslint-disable-line no-unused-expressions

    // This closure supports NodeJS-less client side includes with <script> tags. See https://github.com/joneit/mnm.

    /**
     * @constructor RangeSelectionModel
     *
     * @desc This object models selection of "cells" within an abstract single-dimensional matrix.
     *
     * Disjoint selections can be built with calls to the following methods:
     * * {@link RangeSelectionModel#select|select(start, stop)} - Add a range to the matrix.
     * * {@link RangeSelectionModel#deselect|deselect(start, stop)} - Remove a range from the matrix.
     *
     * Two more methods are available:
     * * Test a cell to see if it {@link RangeSelectionModel#isSelected|isSelected(cell)}
     * * {@link RangeSelectionModel#clear|clear()} the matrix
     *
     * Internally, the selection is run-length-encoded. It is therefore a "sparse" matrix
     * with undefined bounds. A single data property called `selection` is an array that
     * contains all the "runs" (ranges) of selected cells albeit in no particular order.
     * This property should not normally need to be accessed directly.
     *
     * Note: This object should be instantiated with the `new` keyword.
     *
     * @returns {RangeSelectionModel} Self (i.e., `this` object).
     */
    function RangeSelectionModel() {
        /**
         * @name selection
         * @type {Array.Array.number}
         * @summary Unordered list of runs.
         * @desc A "run" is defined as an Array(2) where:
         * * element [0] is the beginning of the run
         * * element [1] is the end of the run (inclusive) and is always >= element [0]
         * The order of the runs within is undefined.
         * @memberOf RangeSelectionModel.prototype
         * @abstract
         */
        this.selection = [];

        //we need to be able to go back in time
        //the states field
        this.states = [];

        //clone and store my current state
        //so we can unwind changes if need be
        this.storeState = function () {
            var sels = this.selection;
            var state = [];
            var copy;
            for (var i = 0; i < sels.length; i++) {
                copy = [].concat(sels[i]);
                state.push(copy);
            }
            this.states.push(state);
        };
    }

    RangeSelectionModel.prototype = {

        /**
         * @summary Add a contiguous run of points to the selection.
         * @desc Insert a new run into `this.selection`.
         * The new run will be merged with overlapping and adjacent runs.
         *
         * The two parameters may be given in either order.
         * The start and stop elements in the resulting run will however always be ordered.
         * (However, note that the order of the runs within `this.selection` is itself always unordered.)
         *
         * Note that `this.selection` is updated in place, preserving validity of any external references.
         * @param {number} start - Start of run. May be greater than `stop`.
         * @param {number} [stop=stop] - End of run (inclusive). May be less than `start`.
         * @returns {RangeSelectionModel} Self (i.e., `this`), for chaining.
         * @memberOf RangeSelectionModel.prototype
         */
        select: function (start, stop) {
            this.storeState();
            var run = makeRun(start, stop);
            var splicer = [0, 1];
            this.selection.forEach(function (each) {
                if (overlaps(each, run) || abuts(each, run)) {
                    run = merge(each, run);
                } else {
                    splicer.push(each);
                }
            });
            splicer.push(run);
            splicer[1] = this.selection.length;
            this.selection.splice.apply(this.selection, splicer); // update in place to preserve external references
            return this;
        },

        /**
         * @summary Remove a contiguous run of points from the selection.
         * @desc Truncate and/or remove run(s) from `this.selection`.
         * Removing part of existing runs will (correctly) shorten them or break them into two fragments.
         *
         * The two parameters may be given in either order.
         *
         * Note that `this.selection` is updated in place, preserving validity of any external references.
         * @param {number} start - Start of run. May be greater than `stop`.
         * @param {number} [stop=stop] - End of run (inclusive). May be less than `start`.
         * @returns {RangeSelectionModel} Self (i.e., `this`), for chaining.
         * @memberOf RangeSelectionModel.prototype
         */
        deselect: function (start, stop) {
            var run = makeRun(start, stop);
            var splicer = [0, 0];
            this.selection.forEach(function (each) {
                if (overlaps(each, run)) {
                    var pieces = subtract(each, run);
                    splicer = splicer.concat(pieces);
                } else {
                    splicer.push(each);
                }
            });
            splicer[1] = this.selection.length;
            this.selection.splice.apply(this.selection, splicer); // update in place to preserve external references
            return this;
        },

        /**
         * @summary Empties `this.selection`, effectively removing all runs.
         * @returns {RangeSelectionModel} Self (i.e., `this`), for chaining.
         * @memberOf RangeSelectionModel.prototype
         */
        clear: function () {
            this.states.length = 0;
            this.selection.length = 0;
            return this;
        },

        clearMostRecentSelection: function () {
            if (this.states.length === 0) {
                return;
            }
            this.selection = this.states.pop();
        },

        /**
         * @summary Determines if the given `cell` is selected.
         * @returns {boolean} `true` iff given `cell` is within any of the runs in `this.selection`.
         * @param {number} cell - The cell to test for inclusion in the selection.
         * @memberOf RangeSelectionModel.prototype
         */
        isSelected: function (cell) {
            return this.selection.some(function (each) {
                return each[0] <= cell && cell <= each[1];
            });
        },

        isEmpty: function (){
            return this.selection.length === 0;
        },

        /**
         * @summary Return the indexes that are selected.
         * @desc Return the indexes that are selected.
         * @returns {Array.Array.number}
         * @memberOf RangeSelectionModel.prototype
         */
        getSelections: function (){
            var result = [];
            this.selection.forEach(function (each) {
                for (var i = each[0]; i <= each[1]; i++) {
                    result.push(i);
                }
            });
            result.sort(function (a, b){
                return a - b;
            });
            return result;
        }

    };

    /**
     * @private
     * @summary Preps `start` and `stop` params into order array
     * @function makeRun
     * @desc Utility function called by both `select()` and `deselect()`.
     * @param {number|number[]} start - Start of run. if array, `start` and `stop` are taken from first two elements.
     * @param {number} [stop=start] - End of run (inclusive).
     */
    function makeRun(start, stop) {
        return (
            start instanceof Array
                ? makeRun.apply(this, start) // extract params from given array
                : stop === undefined
                ? [ start, start ] // single param is a run that stops where it starts
                : start <= stop
                ? [ start, stop ]
                : [ stop, start ] // reverse descending params into ascending order
        );
    }

    /**
     * @private
     * @function overlaps
     * @returns {boolean} `true` iff `run1` overlaps `run2`
     * @summary Comparison operator that determines if given runs overlap with one another.
     * @desc Both parameters are assumed to be _ordered_ arrays.
     *
     * Overlap is defined to include the case where one run completely contains the other.
     *
     * Note: This operator is commutative.
     * @param {number[]} run1 - first run
     * @param {number[]} run2 - second run
     */
    function overlaps(run1, run2) {
        return (
            run1[0] <= run2[0] && run2[0] <= run1[1] || // run2's start is within run1 OR...
            run1[0] <= run2[1] && run2[1] <= run1[1] || // run2's stop is within run1 OR...
            run2[0] <  run1[0] && run1[1] <  run2[1]    // run2 completely contains run1
        );
    }

    /**
     * @private
     * @function abuts
     * @summary Comparison operator that determines if given runs are consecutive with one another.
     * @returns {boolean} `true` iff `run1` is consecutive with `run2`
     * @desc Both parameters are assumed to be _ordered_ arrays.
     *
     * Note: This operator is commutative.
     * @param {number[]} run1 - first run
     * @param {number[]} run2 - second run
     */
    function abuts(run1, run2) {
        return (
            run1[1] === run2[0] - 1 || // run1's top immediately precedes run2's start OR...
            run2[1] === run1[0] - 1    // run2's top immediately precedes run1's start
        );
    }

    /**
     * @private
     * @function subtract
     * @summary Operator that subtracts one run from another.
     * @returns {Array.Array.number} The remaining pieces of `minuend` after removing `subtrahend`.
     * @desc Both parameters are assumed to be _ordered_ arrays.
     *
     * This function _does not assumes_ that `overlap()` has already been called with the same runs and has returned `true`.
     *
     * Returned array contains 0, 1, or 2 runs which are the portion(s) of `minuend` that do _not_ include `subtrahend`.
     *
     * Caveat: This operator is *not* commutative.
     * @param {number[]} minuend - a run from which to "subtract" `subtrahend`
     * @param {number[]} subtrahend - a run to "subtracted" from `minuend`
     */
    function subtract(minuend, subtrahend) {
        var m0 = minuend[0];
        var m1 = minuend[1];
        var s0 = subtrahend[0];
        var s1 = subtrahend[1];
        var result = [];

        if (s0 <= m0 && s1 < m1) {
            //subtrahend extends before minuend: return remaining piece of `minuend`
            result.push([s1 + 1, m1]);
        } else if (s0 > m0 && s1 >= m1) {
            //subtrahend extends after minuend: return remaining piece of `minuend`
            result.push([m0, s0 - 1]);
        } else if (m0 < s0 && s1 < m1) {
            //completely inside: return 2 smaller pieces resulting from the hole
            result.push([m0, s0 - 1]);
            result.push([s1 + 1, m1]);
        } else if (s1 < m0 || s0 > m1) {
            // completely outside: return `minuend` untouched
            result.push(minuend);
        }

        //else subtrahend must completely overlap minuend so return no pieces

        return result;
    }


    // Local utility functions

    /**
     * @private
     * @function merge
     * @summary Operator that merges given runs.
     * @returns {number[]} A single merged run.
     * @desc Both parameters are assumed to be _ordered_ arrays.
     *
     * The runs are assumed to be overlapping or adjacent to one another.
     *
     * Note: This operator is commutative.
     * @param {number[]} run1 - a run to merge with `run2`
     * @param {number[]} run2 - a run to merge with `run1`
     */
    function merge(run1, run2) {
        var min = Math.min(Math.min.apply(Math, run1), Math.min.apply(Math, run2));
        var max = Math.max(Math.max.apply(Math, run1), Math.max.apply(Math, run2));
        return [min, max];
    }

    // Interface
    module.exports = RangeSelectionModel;
})(
    typeof module === 'object' && module || (window.RangeSelectionModel = {}),
    typeof module === 'object' && module.exports || (window.RangeSelectionModel.exports = {})
) || (
    typeof module === 'object' || (window.RangeSelectionModel = window.RangeSelectionModel.exports)
);

/* About the above IIFE:
 * This file is a "modified node module." It functions as usual in Node.js *and* is also usable directly in the browser.
 * 1. Node.js: The IIFE is superfluous but innocuous.
 * 2. In the browser: The IIFE closure serves to keep internal declarations private.
 * 2.a. In the browser as a global: The logic in the actual parameter expressions + the post-invocation expression
 * will put your API in `window.RangeSelectionModel`.
 * 2.b. In the browser as a module: If you predefine a `window.module` object, the results will be in `module.exports`.
 * The bower component `mnm` makes this easy and also provides a global `require()` function for referencing your module
 * from other closures. In either case, this works with both NodeJs-style export mechanisms -- a single API assignment,
 * `module.exports = yourAPI` *or* a series of individual property assignments, `module.exports.property = property`.
 *
 * Before the IIFE runs, the actual parameter expressions are executed:
 * 1. If `window` object undefined, we're in NodeJs so assume there is a `module` object with an `exports` property
 * 2. If `window` object defined, we're in browser
 * 2.a. If `module` object predefined, use it
 * 2.b. If `module` object undefined, create a `RangeSelectionModel` object
 *
 * After the IIFE returns:
 * Because it always returns undefined, the expression after the || will execute:
 * 1. If `window` object undefined, then we're in NodeJs so we're done
 * 2. If `window` object defined, then we're in browser
 * 2.a. If `module` object predefined, we're done; results are in `moudule.exports`
 * 2.b. If `module` object undefined, redefine`RangeSelectionModel` to be the `RangeSelectionModel.exports` object
 */

},{}],51:[function(require,module,exports){
// tabz node module
// https://github.com/joneit/tabz

/* eslint-env node, browser */

'use strict';

var cssInjector = require('css-injector');

/**
 * Register/deregister click handler on all tab collections.
 * @param {Element} [options.root=document] - Where to look for tab panels (`.tabz` elements) containing tabs and folders.
 * @param {boolean} [options.unhook=false] - Remove event listener from tab panels (`.tabz` elements).
 * @param {Element} [options.referenceElement] - Passed to cssInjector's insertBefore() call.
 * @param {string} [options.defaultTabSelector='.default-tab'] - .classname or #id of the tab to select by default
 * @param {object} [options.onEnable] - Handler implementation. See {@link Tabz#onEnable|onEnable}.
 * @param {object} [options.onDisable] - Handler implementation. See {@link Tabz#onDisable|onEnable}.
 * @param {object} [options.onEnabled] - Handler implementation. See {@link Tabz#onEnabled|onEnable}.
 * @param {object} [options.onDisabled] - Handler implementation. See {@link Tabz#onDisabled|onEnable}.
 * @constructor
 */
function Tabz(options) {
    var i, el;

    options = options || {};
    var root = options.root || document,
        unhook = options.unhook,
        referenceElement = options.referenceElement,
        defaultTabSelector = options.defaultTabSelector || '.default-tab';

    if (!unhook) {
        var css;
        /* inject:css */
        css = '.tabz{position:relative;visibility:hidden;height:100%}.tabz>header{position:relative;display:inline-block;background-color:#fff;margin-left:1em;padding:5px .6em;border:1px solid #666;border-bottom-color:transparent;border-radius:6px 6px 0 0;cursor:default;user-select:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none}.tabz>header+section{position:absolute;display:none;background-color:#fff;margin-top:-1px;padding:8px;border:1px solid #666;border-radius:6px;left:0;right:0;bottom:0;top:0;z-index:0}.tabz>header+section.tabz-enable{z-index:1}.tabz>header.tabz-enable{z-index:2}.tabz-bg0{background-color:#eee!important}.tabz-bg1{background-color:#eef!important}.tabz-bg2{background-color:#efe!important}.tabz-bg3{background-color:#eff!important}.tabz-bg4{background-color:#fee!important}.tabz-bg5{background-color:#fef!important}.tabz-bg6{background-color:#ffe!important}';
        /* endinject */

        if (!referenceElement) {
            // find first <link> or <style> in <head>
            var headStuff = document.querySelector('head').children;
            for (i = 0; !referenceElement && i < headStuff.length; ++i) {
                el = headStuff[i];
                if (el.tagName === 'STYLE' || el.tagName === 'LINK' && el.rel === 'stylesheet') {
                    referenceElement = el;
                }
            }
        }
        cssInjector(css, 'tabz-css-base', referenceElement);

        for (var key in options) {
            if (this[key] === noop) {
                this[key] = options[key];
            }
        }

        /**
         * @summary The context of this tab object.
         * @desc The context may encompass any number of tab panels (`.tabz` elements).
         * @type {HTMLDocumen|HTMLElement}
         */
        this.root = root;

        // enable first tab on each tab panel (`.tabz` element)
        forEachEl('.tabz>header:first-of-type,.tabz>section:first-of-type', function(el) {
            el.classList.add('tabz-enable');
        }, root);

        // enable default tab and all its parents (must be a tab)
        this.tabTo(root.querySelector('.tabz > header' + defaultTabSelector));

        setTimeout(function() {
            forEachEl('.tabz > section', function(el) {

                // Step 1: A bug in older versions of Chrome (like v40) that inserted a break at mark-up location of an absolute positioned block. The work-around is to hide those blocks until after first render; then show them. I don't know why this works but it does. Seems to be durable.
                el.style.display = 'block';

                // Step 2: Adjust absolute top of each rendered folder to the bottom of its tab
                el.style.top = el.previousElementSibling.getBoundingClientRect().bottom - el.parentElement.getBoundingClientRect().top + 'px';

            }, root);
        }, 0);
    }

    var method = unhook ? 'removeEventListener' : 'addEventListener';
    var boundClickHandler = onclick.bind(this);
    forEachEl('.tabz', function(tabBar) {
        tabBar.style.visibility = 'visible';
        tabBar[method]('click', boundClickHandler);
    }, root);
}

function onclick(evt) {
    click.call(this, evt.currentTarget, evt.target);
}

/**
 * @summary Selects the given tab.
 * @desc If it is a nested tab, also reveals all its ancestor tabs.
 * @param {string|HTMLElement} [el] - May be one of:
 * * `HTMLElement`
 *   * `<header>` - tab element
 *   * `<section>` - folder element
 * * `string` - CSS selector to one of the above
 * * falsy - fails silently
 * @memberOf Tabz.prototype
 */
Tabz.prototype.tabTo = function(el) {
    while ((el = this.tab(el))) {
        click.call(this, el.parentElement, el);
        el = el.parentElement.parentElement; // loop to click on each containing tab...
    }
};

/**
 * Current selected tab.
 * @param {HTMLElement|number} el - An element that is (or is within) the tab panel (`.tabz` element) to look in.
 * @returns {undefined|HTMLElement} Returns tab (`<header>`) element.  Returns `undefined` if `el` is neither of the above or an out of range index.
 */
Tabz.prototype.enabledTab = function(el) {
    el = this.panel(el);
    return el && el.querySelector(':scope>header.tabz-enable');
};

/**
 * @summary Get tab element.
 * @desc Get tab element if given tab or folder element; or an element within such; or find tab.
 * @param {string|Element} [el] - May be one of:
 * * a tab (a `<header>` element)
 * * a folder (a `<section>` element)
 * * an element within one of the above
 * * `string` - CSS selector to one of the above, searching within the root or document
 * @returns {null|Element} tab (`<header>...</header>`) element or `null` if not found
 * @memberOf Tabz.prototype
 */
Tabz.prototype.tab = function(el) {
    el = lookForEl.call(this, el);
    return !(el instanceof HTMLElement) ? null : el.tagName === 'HEADER' ? el : el.tagName === 'SECTION' ? el.previousElementSibling : null;
};

/**
 * @summary Get folder element.
 * @desc Get folder element if given tab or folder element; or an element within such; or find folder.
 * @param {string|Element} [el] - May be one of:
 * * a tab (a `<header>` element)
 * * a folder (a `<section>` element)
 * * an element within one of the above
 * * `string` - CSS selector to one of the above, searching within the root or document
 * @returns {null|Element} tab (`<header>...</header>`) element or `null` if not found
 * @memberOf Tabz.prototype
 */
Tabz.prototype.folder = function(el) {
    el = lookForEl.call(this, el);
    return !(el instanceof HTMLElement) ? null : el.tagName === 'SECTION' ? el : el.tagName === 'HEADER' ? el.nextElementSibling : null;
};

/**
 * @summary Get tab panel element.
 * @desc Get panel element if given tab panel element; or an element within a tab panel; or find tab panel.
 * @param {string|Element} [el] - May be one of:
 * * a tab panel (an `HTMLElement` with class `tabz`)
 * * an element within a tab panel
 * * `string` - CSS selector to one a tab panel, searching within the root or document
 * @returns {null|Element} tab panel element or `null` if not found
 * @memberOf Tabz.prototype
 */
Tabz.prototype.panel = function(el) {
    while (el && !el.classList.contains('tabz')) {
        el = el.parentElement;
    }
    return !(el instanceof HTMLElement) ? null : el.classList.contains('tabz') ? el : null;
};

function lookForEl(el) {
    if (el instanceof Element) {
        while (el && el.tagName !== 'HEADER' && el.tagName !== 'SECTION') {
            el = el.parentElement;
        }
    } else {
        el = this.root.querySelector(el);
    }
    return el;
}

/** Enables the tab/folder pair of the clicked tab.
 * Disables all the other pairs in this scope which will include the previously enabled pair.
 * @private
 * @this Tabz
 * @param {Element} div - The tab panel (`.tabz` element) that's handling the click event.
 * @param {Element} target - The element that received the click.
 * @returns {undefined|Element} The `<header>` element (tab) the was clicked; or `undefined` when click was not within a tab.
 */
function click(div, target) {
    var newTab, oldTab;

    forEachEl(':scope>header:not(.tabz-enable)', function(tab) { // todo: use a .find() polyfill here
        if (tab.contains(target)) {
            newTab = tab;
        }
    }, div);

    if (newTab) {
        oldTab = this.enabledTab(div);
        toggleTab.call(this, oldTab, false);
        toggleTab.call(this, newTab, true);
    }

    return newTab;
}

/**
 * @private
 * @this Tabz
 * @param {Element} tab - The `<header>` element of the tab to enable or disable.
 * @param {boolean} enable - Enable (vs. disable) the tab.
 */
function toggleTab(tab, enable) {
    if (tab) {
        var folder = this.folder(tab),
            method = enable ? 'onEnable' : 'onDisable';

        this[method].call(this, tab, folder);

        tab.classList.toggle('tabz-enable', enable);
        folder.classList.toggle('tabz-enable', enable);

        method += 'd';
        this[method].call(this, tab, folder);
    }
}

/**
 * @typedef tabEvent
 * @type {function}
 * @param {tabEventObject}
 */

/**
 * @typedef tabEventObject
 * @property {Tabz} tabz - The tab object issuing the callback.
 * @property {Element} target - The tab (`<header>` element).
 */

/**
 * Called before a previously disabled tab is enabled.
 * @type {tabEvent}
 * @abstract
 * @memberOf Tabz.prototype
 */
Tabz.prototype.onEnable = noop;

/**
 * Called before a previously enabled tab is disabled by another tab being enabled.
 * @type {tabEvent}
 * @abstract
 * @memberOf Tabz.prototype
 */
Tabz.prototype.onDisable = noop;

/**
 * Called after a previously disabled tab is enabled.
 * @type {tabEvent}
 * @abstract
 * @memberOf Tabz.prototype
 */
Tabz.prototype.onEnabled = noop;

/**
 * Called after a previously enabled tab is disabled by another tab being enabled.
 * @type {tabEvent}
 * @abstract
 * @memberOf Tabz.prototype
 */
Tabz.prototype.onDisabled = noop;

function noop() {} // null pattern

function forEachEl(selector, iteratee, context) {
    return Array.prototype.forEach.call((context || document).querySelectorAll(selector), iteratee);
}


module.exports = Tabz;

},{"css-injector":6}],52:[function(require,module,exports){
// templex node module
// https://github.com/joneit/templex

/* eslint-env node */

/**
 * Merges values of execution context properties named in template by {prop1},
 * {prop2}, etc., or any javascript expression incorporating such prop names.
 * The context always includes the global object. In addition you can specify a single
 * context or an array of contexts to search (in the order given) before finally
 * searching the global context.
 *
 * Merge expressions consisting of simple numeric terms, such as {0}, {1}, etc., deref
 * the first context given, which is assumed to be an array. As a convenience feature,
 * if additional args are given after `template`, `arguments` is unshifted onto the context
 * array, thus making first additional arg available as {1}, second as {2}, etc., as in
 * `templex('Hello, {1}!', 'World')`. ({0} is the template so consider this to be 1-based.)
 *
 * If you prefer something other than braces, redefine `templex.regexp`.
 *
 * See tests for examples.
 *
 * @param {string} template
 * @param {...string} [args]
 */
function templex(template) {
    var contexts = this instanceof Array ? this : [this];
    if (arguments.length > 1) { contexts.unshift(arguments); }
    return template.replace(templex.regexp, templex.merger.bind(contexts));
}

templex.regexp = /\{(.*?)\}/g;

templex.with = function (i, s) {
    return 'with(this[' + i + ']){' + s + '}';
};

templex.cache = [];

templex.deref = function (key) {
    if (!(this.length in templex.cache)) {
        var code = 'return eval(expr)';

        for (var i = 0; i < this.length; ++i) {
            code = templex.with(i, code);
        }

        templex.cache[this.length] = eval('(function(expr){' + code + '})'); // eslint-disable-line no-eval
    }
    return templex.cache[this.length].call(this, key);
};

templex.merger = function (match, key) {
    // Advanced features: Context can be a list of contexts which are searched in order.
    var replacement;

    try {
        replacement = isNaN(key) ? templex.deref.call(this, key) : this[0][key];
    } catch (e) {
        replacement = '{' + key + '}';
    }

    return replacement;
};

// this interface consists solely of the templex function (and it's properties)
module.exports = templex;

},{}],53:[function(require,module,exports){
// Created by Jonathan Eiten on 1/7/16.

'use strict';

/**
 * Very fast array test.
 * For cross-frame scripting; use `crossFramesIsArray` instead.
 * @param {*} arr - The object to test.
 * @returns {boolean}
 */
unstrungify.isArray = function(arr) { return arr.constructor === Array; };

/**
 * @summary Walk a hierarchical object as JSON.stringify does but without serializing.
 *
 * @desc Usage:
 * * var myDistilledObject = unstrungify.call(myObject);
 * * var myDistilledObject = myApi.getState(); // where myApi.prototype.getState = unstrungify
 *
 * Result equivalent to `JSON.parse(JSON.stringify(this))`.
 *
 * > Do not use this function to get a JSON string; use `JSON.stringify(this)` instead.
 *
 * @this {*|object|*[]} - Object to walk; typically an object or array.
 *
 * @param {boolean} [options.nullElements==false] - Preserve undefined array elements as `null`s.
 * Use this when precise index matters (not merely the order of the elements).
 *
 * @param {boolean} [options.nullProperties==false] - Preserve undefined object properties as `null`s.
 *
 * @returns {object} - Distilled object.
 */
function unstrungify(options) {
    var clone, preserve,
        object = (typeof this.toJSON === 'function') ? this.toJSON() : this;

    if (unstrungify.isArray(object)) {
        clone = [];
        preserve = options && options.nullElements;
        object.forEach(function(obj) {
            var value = unstrungify.call(obj);
            if (value !== undefined) {
                clone.push(value);
            } else if (preserve) {
                clone.push(null); // undefined not a valid JSON value
            }
        });
    } else  if (typeof object === 'object') {
        clone = {};
        preserve = options && options.nullProperties;
        Object.keys(object).forEach(function(key) {
            var value = object[key];
            if (value !== undefined) {
                value = unstrungify.call(object[key]);
            }
            if (value !== undefined) {
                clone[key] = value;
            } else if (preserve) {
                clone[key] = null; // undefined not a valid JSON value
            }
        });
    } else {
        clone = object;
    }

    return clone;
}

/**
 * Very slow array test. Suitable for cross-frame scripting.
 *
 * Suggestion: If you need this and have jQuery loaded, use `jQuery.isArray` instead which is reasonably fast.
 *
 * @param {*} arr - The object to test.
 * @returns {boolean}
 */
unstrungify.crossFramesIsArray = function(arr) { return toString.call(arr) === arrString; }; // eslint-disable-line no-unused-vars

var toString = Object.prototype.toString, arrString = '[object Array]';

module.exports = unstrungify;

},{}],54:[function(require,module,exports){
/* eslint-env browser */

'use strict';

require('./lib/polyfills'); // Installs misc. polyfills into global objects, as needed

var FinBar = require('finbars');
var Canvas = require('fincanvas');
var Point = require('rectangular').Point;
var Rectangle = require('rectangular').Rectangle;
var _ = require('object-iterators'); // fyi: installs the Array.prototype.find polyfill, as needed

var deprecated = require('./lib/deprecated');
var defaults = require('./defaults');
var Renderer = require('./lib/Renderer');
var SelectionModel = require('./lib/SelectionModel');
var stylesheet = require('./lib/stylesheet');
var Localization = require('./lib/Localization');
var behaviors = require('./behaviors');
var CellRenderers = require('./cellRenderers');
var CellEditors = require('./cellEditors');

var themeInitialized = false,
    polymerTheme = Object.create(defaults),
    globalProperties = Object.create(polymerTheme);

/**s
 * @constructor
 * @param {string|Element} div - CSS selector or Element
 * @param {object} [options]
 * @param {function} [options.Behavior=behaviors.JSON] - A behavior constructor.
 * @param {function|object[]} [options.data] - Passed to behavior constructor. May be:
 * * An array of congruent raw data objects
 * * A function returning same
 * @param {function|menuItem[]} [options.schema=derivedSchema] - Passed to behavior constructor. May be:
 * * A schema array
 * * A function returning a schema array. Called at filter reset time with behavior as context.
 * * Omit to generate a basic schema from `this.behavior.columns`.
 * @param {Behavior} [options.Behavior=JSON] - A grid behavior (descendant of Behavior "class"). Will be used if `getBehavior` omitted, in which case `options.data` (which has no default) *must* also be provided.
 * @param {string} [options.localization=Hypergrid.localization]
 * @param {string|string[]} [options.localization.locale=Hypergrid.localization.locale] - The default locale to use when an explicit `locale` is omitted from localizer constructor calls. Passed to Intl.NumberFomrat` and `Intl.DateFomrat`. See {@ https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl#Locale_identification_and_negotiation|Locale identification and negotiation} for more information.
 * @param {string} [options.localization.numberOptions=Hypergrid.localization.numberOptions] - Options passed to `Intl.NumberFomrat` for creating the basic "number" localizer.
 * @param {string} [options.localization.dateOptions=Hypergrid.localization.dateOptions] - Options passed to `Intl.DateFomrat` for creating the basic "date" localizer.
 * @param {object} [options.margin] - optional canvas margins
 * @param {string} [options.margin.top=0]
 * @param {string} [options.margin.right='-200px']
 * @param {string} [options.margin.bottom=0]
 * @param {string} [options.margin.left=0]
 */
function Hypergrid(div, options) {
    var self = this;

    this.div = (typeof div === 'string') ? document.querySelector(div) : div;

    stylesheet.inject('grid');

    this.lastEdgeSelection = [0, 0];

    this.lnfProperties = Object.create(globalProperties);

    this.isWebkit = navigator.userAgent.toLowerCase().indexOf('webkit') > -1;
    this.selectionModel = new SelectionModel(this);
    this.renderOverridesCache = {};

    options = options || {};
    var data = typeof options.data === 'function' ? options.data() : options.data;
    var Behavior = options.Behavior || behaviors.JSON;
    this.behavior = new Behavior(this, options.schema, data);

    var loc = options.localization || {};
    this.localization = new Localization(
        loc.locale || Hypergrid.localization.locale,
        loc.numberOptions || Hypergrid.localization.numberOptions,
        loc.dateOptions || Hypergrid.localization.dateOptions
    );

    //prevent the default context menu for appearing
    this.div.oncontextmenu = function(event) {
        event.preventDefault();
        return false;
    };

    this.clearMouseDown();
    this.dragExtent = new Point(0, 0);
    this.numRows = 0;
    this.numColumns = 0;

    //install any plugins
    this.pluginsDo(function(each) {
        if (each.installOn) {
            each.installOn(self);
        }
    });

    var margin = options.margin || {};
    margin.top = margin.top || 0;
    margin.right = margin.right || '-200px';
    margin.bottom = margin.bottom || 0;
    margin.left = margin.left || 0;

    /**
     * @type {CellRenderers}
     * @memberOf Hypergrid.prototype
     */
    this.cellRenderers = new CellRenderers();

    /**
     * @type {CellEditors}
     * @memberOf Hypergrid.prototype
     */
    this.cellEditors = new CellEditors(this);

    this.allowEventHandlers = true;

    //initialize our various pieces
    if (!themeInitialized) {
        themeInitialized = true;
        buildPolymerTheme();
    }
    this.initRenderer();
    this.initCanvas(margin);
    this.initScrollbars();

    //Register a listener for the copy event so we can copy our selected region to the pastebuffer if conditions are right.
    document.body.addEventListener('copy', function(evt) {
        self.checkClipboardCopy(evt);
    });
    this.getCanvas().resize();
}

Hypergrid.prototype = {
    constructor: Hypergrid.prototype.constructor,

    deprecated: deprecated,
    registerCellEditor: function(Constructor, name) {
        return this.deprecated('registerCellEditor(Constructor, name)', 'cellEditors.add(name, Constructor)', '1.0.6', arguments);
    },
    createCellEditor: function(name) {
        return this.deprecated('createCellEditor(name)', 'cellEditors.create(name)', '1.0.6', arguments);
    },
    getCellProvider: function(name) {
        return this.deprecated('getCellProvider()', 'cellRenderers', '1.0.6', arguments);
    },
    registerLocalizer: function(name, localizer, baseClassName, newClassName) {
        return this.deprecated('registerLocalizer(name, localizer, baseClassName, newClassName)', 'localization.add(name, localizer)', '1.0.6', arguments,
            'STRUCTURAL CHANGE: No longer supports deriving and registering a new cell editor class. Use .cellEditors.get(baseClassName).extend(newClassName || name, {...}) for that.');
    },

    /**
     *
     * A null object behavior serves as a place holder.
     * @type {object}
     * @memberOf Hypergrid.prototype
     */
    behavior: null,

    /**
     * Cached resulan}
     * @memberOf Hypergrid.prototype
     */
    isWebkit: true,

    /**
     * The pixel location of an initial mousedown click, either for editing a cell or for dragging a selection.
     * @type {Point}
     * @memberOf Hypergrid.prototype
     */
    mouseDown: [],

    /**
     * The extent from the mousedown point during a drag operation.
     * @type {Point}
     * @memberOf Hypergrid.prototype
     */

    dragExtent: null,

    /**
     * A float value between 0.0 - 1.0 of the vertical scroll position.
     * @type {number}
     * @memberOf Hypergrid.prototype
     */
    vScrollValue: 0,

    /**
     * A float value between 0.0 - 1.0 of the horizontal scroll position.
     * @type {number}
     * @memberOf Hypergrid.prototype
     */
    hScrollValue: 0,

    /**
     * @property {fin-hypergrid-selection-model} selectionModel - A [fin-hypergrid-selection-model](module-._selection-model.html) instance.
     * @memberOf Hypergrid.prototype
     */
    selectionModel: null,

    /**
     * @property {fin-hypergrid-cell-editor} cellEditor - The current instance of [fin-hypergrid-cell-editor](module-cell-editors_base.html).
     * @memberOf Hypergrid.prototype
     */
    cellEditor: null,

    /**
     * @property {fin-vampire-bar} sbHScroller - An instance of {@link https://github.com/openfin/finbars|FinBar}.
     * @memberOf Hypergrid.prototype
     */
    sbHScroller: null,

    /**
     * @property {fin-vampire-bar} sbVScroller - An instance of {@link https://github.com/openfin/finbars|FinBar}.
     * @memberOf Hypergrid.prototype
     */
    sbVScroller: null,

    /**
     * The previous value of sbVScrollVal.
     * @type {number}
     * @memberOf Hypergrid.prototype
     */
    sbPrevVScrollValue: null,

    /**
     * The previous value of sbHScrollValue.
     * @type {number}
     * @memberOf Hypergrid.prototype
     */
    sbPrevHScrollValue: null,

    /**
     * is the short term memory of what column I might be dragging around
     * @type {object}
     * @memberOf Hypergrid.prototype
     */

    renderOverridesCache: {},

    /**
     * The pixel location of the current hovered cell.
     * @type {Point}
     * @memberOf Hypergrid.prototype
     */
    hoverCell: null,

    scrollingNow: false,

    lastEdgeSelection: null,

    /**
     * @memberOf Hypergrid.prototype
    clear out the LRU cache of text widths
     */
    setAttribute: function(attribute, value) {
        this.div.setAttribute(attribute, value);
    },

    /**
     * @memberOf Hypergrid.prototype
    clear out all state and data of the grid
     */
    reset: function() {
        this.lastEdgeSelection = [0, 0];
        this.lnfProperties = Object.create(globalProperties);
        this.selectionModel = new SelectionModel(this);
        this.renderOverridesCache = {};
        this.clearMouseDown();
        this.dragExtent = new Point(0, 0);

        this.numRows = 0;
        this.numColumns = 0;

        this.vScrollValue = 0;
        this.hScrollValue = 0;

        this.cellEditor = null;

        this.sbPrevVScrollValue = null;
        this.sbPrevHScrollValue = null;

        this.hoverCell = null;
        this.scrollingNow = false;
        this.lastEdgeSelection = [0, 0];

        this.behavior.reset();
        this.getRenderer().reset();
        this.getCanvas().resize();
        this.behaviorChanged();
    },

    //resetTextWidthCache: function() {
    //    textWidthCache = new LRUCache(2000);
    //},

    getProperties: function() {
        return this.getPrivateState();
    },

    _getProperties: function() {
        return this.lnfProperties;
    },

    computeCellsBounds: function() {
        var renderer = this.getRenderer();
        if (renderer) {
            renderer.computeCellsBounds();
        }
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {boolean} The pointer is over the given cell.
     * @param {number} x - The x cell coordinate.
     * @param {number} y - The y cell coordinate.
     */
    isHovered: function(x, y) {
        var p = this.getHoverCell();
        return p && p.x === x && p.y === y;
    },

    getFormatter: function(localizerName) {
        return this.localization.get(localizerName).format;
    },

    formatValue: function(localizerName, value) {
        var formatter = this.getFormatter(localizerName);
        return formatter(value);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns boolean} The pointer is hovering over the given column.
     * @param {number} x - The horizontal cell coordinate.
     */
    isColumnHovered: function(x) {
        var p = this.getHoverCell();
        return p && p.x === x;
    },

    isRowResizeable: function() {
        return this.resolveProperty('rowResize');
    },

    isCheckboxOnlyRowSelections: function() {
        return this.resolveProperty('checkboxOnlyRowSelections');
    },

    /**
     *
     * @memberOf Hypergrid.prototype
     * @returns {boolean} The pointer is hovering over the row `y`.
     * @param {number} y - The vertical cell coordinate.
     */
    isRowHovered: function(y) {
        var p = this.getHoverCell();
        return p && p.y === y;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {Point} The cell over which the cursor is hovering.
     */
    getHoverCell: function() {
        return this.hoverCell;
    },


    /**
     * @memberOf Hypergrid.prototype
     * @desc Set the cell under the cursor.
     * @param {Point} point
     */
    setHoverCell: function(point) {
        var me = this.hoverCell;
        var newPoint = new Point(point.x, point.y);
        if (me && me.equals(newPoint)) {
            return;
        }
        this.hoverCell = newPoint;
        this.fireSyntheticOnCellEnterEvent(newPoint);
        this.repaint();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Ammend properties for all hypergrids in this process.
     * @param {object} properties - A simple properties hash.
     */
    addGlobalProperties: function(properties) {
        //we check for existence to avoid race condition in initialization
        if (!globalProperties) {
            var self = this;
            setTimeout(function() {
                self.addGlobalProperties(properties);
            }, 10);
        } else {
            this._addGlobalProperties(properties);
        }

    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Ammend properties for all hypergrids in this process.
     * @param {object} properties - A simple properties hash.
     * @private
     */
    _addGlobalProperties: function(properties) {
        _(properties).each(function(property, key) {
            globalProperties[key] = property;
        });
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Utility function to push out properties if we change them.
     * @param {object} properties - An object of various key value pairs.
     */

    refreshProperties: function() {
        // this.canvas = this.shadowRoot.querySelector('fin-canvas');
        //this.canvas = new Canvas(this.divCanvas, this.renderer); //TODO: Do we really need to be recreating it here?
        this.renderer.computeCellsBounds();
        this.checkScrollbarVisibility();
        this.behavior.defaultRowHeight = null;
        if (this.isColumnAutosizing()) {
            this.behavior.autosizeAllColumns();
        }
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Ammend properties for this hypergrid only.
     * @param {object} moreProperties - A simple properties hash.
     */
    addProperties: function(moreProperties) {
        var properties = this.getProperties();
        addDeepProperties(properties, moreProperties);
        this.refreshProperties();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {object} The state object for remembering our state.
     * @see [Memento pattern](http://en.wikipedia.org/wiki/Memento_pattern)
     */
    getPrivateState: function() {
        return this.behavior.getPrivateState();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Set the state object to return to the given user configuration.
     * @param {object} state - A memento object.
     * @see [Memento pattern](http://en.wikipedia.org/wiki/Memento_pattern)
     */
    setState: function(state) {
        var self = this;
        this.behavior.setState(state);
        setTimeout(function() {
            self.behaviorChanged();
            self.synchronizeScrollingBoundries();
        }, 100);
    },

    getState: function() {
        return this.behavior.getState();
    },
    /**
     * @memberOf Hypergrid.prototype
     * @returns {object} The initial mouse position on a mouse down event for cell editing or a drag operation.
     * @memberOf Hypergrid.prototype
     */
    getMouseDown: function() {
        var last = this.mouseDown.length - 1;
        if (last < 0) {
            return null;
        }
        return this.mouseDown[last];
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Remove the last item from the mouse down stack.
     */
    popMouseDown: function() {
        if (this.mouseDown.length !== 0) {
            this.mouseDown.length = this.mouseDown.length - 1;
        }
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Empty out the mouse down stack.
     */
    clearMouseDown: function() {
        this.mouseDown = [new Point(-1, -1)];
        this.dragExtent = null;
    },

    /**
     * Set the mouse point that initiated a cell edit or drag operation.
     * @param {Point} point
     * @memberOf Hypergrid.prototype
     */
    setMouseDown: function(point) {
        this.mouseDown.push(point);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {Point} The extent point of the current drag selection rectangle.
     */
    getDragExtent: function() {
        return this.dragExtent;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Set the extent point of the current drag selection operation.
     * @param {Point} point
     */
    setDragExtent: function(point) {
        this.dragExtent = point;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Iterate over the plugins invoking the given function with each.
     * @todo We need a new plugin mechanism!
     * @param {function} func - The function to invoke on all the plugins.
     */
    pluginsDo: function(func) {
        //TODO: We need a new plugin mechanism!
        //var userPlugins = this.children.array();
        //var pluginsTag = this.shadowRoot.querySelector('fin-plugins');
        //
        //var plugins = userPlugins;
        //if (pluginsTag) {
        //    var systemPlugins = pluginsTag.children.array();
        //    plugins = systemPlugins.concat(plugins);
        //}
        //
        //plugins.forEach(function(plugin) {
        //    func(plugin);
        //});
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc This function is a callback from the HypergridRenderer sub-component. It is called after each paint of the canvas.
     */
    gridRenderedNotification: function() {
        this.updateRenderedSizes();
        if (this.cellEditor) {
            this.cellEditor.gridRenderedNotification();
        }
        this.checkColumnAutosizing();
        this.fireSyntheticGridRenderedEvent();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc The grid has just been rendered, make sure the column widths are optimal.
     */
    checkColumnAutosizing: function() {
        var behavior = this.behavior;
        behavior.autoSizeRowNumberColumn();
        if (this.isColumnAutosizing()) {
            behavior.checkColumnAutosizing(false);
        }
    },
    /**
     * @memberOf Hypergrid.prototype
     * @desc Notify the GridBehavior how many rows and columns we just rendered.
     */
    updateRenderedSizes: function() {
        //add one to each of these values as we want also to include
        //the columns and rows that are partially visible
        this.behavior.setRenderedColumnCount(this.getVisibleColumns() + 1);
        this.behavior.setRenderedRowCount(this.getVisibleRows() + 1);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Conditionally copy to clipboard.
     * @desc If we have focus, copy our current selection data to the system clipboard.
     * @param {event} event - The copy system event.
     */
    checkClipboardCopy: function(event) {
        if (this.hasFocus()) {
            event.preventDefault();
            var csvData = this.getSelectionAsTSV();
            event.clipboardData.setData('text/plain', csvData);
        }
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {boolean} We have any selections.
     */
    hasSelections: function() {
        if (!this.getSelectionModel) {
            return; // were not fully initialized yet
        }
        return this.selectionModel.hasSelections();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {string} Tab separated value string from the selection and our data.
     */
    getSelectionAsTSV: function() {
        var sm = this.selectionModel;
        if (sm.hasSelections()) {
            var selections = this.getSelectionMatrix();
            selections = selections[selections.length - 1];
            return this.getMatrixSelectionAsTSV(selections);
        } else if (sm.hasRowSelections()) {
            return this.getMatrixSelectionAsTSV(this.getRowSelectionMatrix());
        } else if (sm.hasColumnSelections()) {
            return this.getMatrixSelectionAsTSV(this.getColumnSelectionMatrix());
        }
    },

    getMatrixSelectionAsTSV: function(selections) {
        var result = '';

        //only use the data from the last selection
        if (selections.length) {
            var width = selections.length,
                height = selections[0].length,
                area = width * height,
                lastCol = width - 1,
                //Whitespace will only be added on non-singular rows, selections
                whiteSpaceDelimiterForRow = (height > 1 ? '\n' : '');

            //disallow if selection is too big
            if (area > 20000) {
                alert('selection size is too big to copy to the paste buffer'); // eslint-disable-line no-alert
                return '';
            }

            for (var h = 0; h < height; h++) {
                for (var w = 0; w < width; w++) {
                    result += selections[w][h] + (w < lastCol ? '\t' : whiteSpaceDelimiterForRow);
                }
            }
        }

        return result;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {boolean} We have focus.
     */
    hasFocus: function() {
        return this.getCanvas().hasFocus();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Clear all the selections.
     */
    clearSelections: function() {
        var dontClearRows = this.isCheckboxOnlyRowSelections();
        this.selectionModel.clear(dontClearRows);
        this.clearMouseDown();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Clear the most recent selection.
     */
    clearMostRecentSelection: function() {
        var dontClearRows = this.isCheckboxOnlyRowSelections();
        this.selectionModel.clearMostRecentSelection(dontClearRows);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Clear the most recent column selection.
     */
    clearMostRecentColumnSelection: function() {
        this.selectionModel.clearMostRecentColumnSelection();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Clear the most recent row selection.
     */
    clearMostRecentRowSelection: function() {
        //this.selectionModel.clearMostRecentRowSelection(); // commented off as per GRID-112
    },

    clearRowSelection: function() {
        this.selectionModel.clearRowSelection();
        this.behavior.dataModel.clearSelectedData();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Select given region.
     * @param {number} ox - origin x
     * @param {number} oy - origin y
     * @param {number} ex - extent x
     * @param {number} ex - extent y
     */
    select: function(ox, oy, ex, ey) {
        if (ox < 0 || oy < 0) {
            //we don't select negative area
            //also this means there is no origin mouse down for a selection rect
            return;
        }
        this.selectionModel.select(ox, oy, ex, ey);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {boolean} Given point is selected.
     * @param {number} x - The horizontal coordinate.
     * @param {number} y - The vertical coordinate.
     */
    isSelected: function(x, y) {
        return this.selectionModel.isSelected(x, y);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {boolean} The given column is selected anywhere in the entire table.
     * @param {number} col - The column index.
     */
    isCellSelectedInRow: function(col) {
        var selectionModel = this.selectionModel;
        var isSelected = selectionModel.isCellSelectedInRow(col);
        return isSelected;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {boolean} The given row is selected anywhere in the entire table.
     * @param {number} row - The row index.
     */
    isCellSelectedInColumn: function(row) {
        var selectionModel = this.selectionModel;
        var isSelected = selectionModel.isCellSelectedInColumn(row);
        return isSelected;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Set the Behavior (model) object for this grid control.
     * @desc This can be done dynamically.
     * @param {Behavior} behavior - The behavior (model).
     */
    setBehavior: function(behavior) {
        behavior.changed = this.behaviorChanged.bind(this);
        behavior.shapeChanged = this.behaviorShapeChanged.bind(this);
        behavior.stateChanged = this.behaviorStateChanged.bind(this);
        this.behavior = behavior;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc I've been notified that the behavior has changed.
     */
    behaviorChanged: function() {
        if (this.numColumns !== this.getColumnCount() || this.numRows !== this.getRowCount()) {
            this.numColumns = this.getColumnCount();
            this.numRows = this.getRowCount();
            this.behaviorShapeChanged();
        }
        this.computeCellsBounds();
        this.repaint();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {Rectangle} My bounds.
     */
    getBounds: function() {
        var renderer = this.getRenderer();
        return renderer && renderer.getBounds();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {string} The value of a lnf property.
     * @param {string} key - A look-and-feel key.
     */
    resolveProperty: function(key) {
        var keys = key.split('.');
        var prop = this.getProperties();
        while (keys.length) { prop = prop[keys.shift()]; }
        return prop;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc The dimensions of the grid data have changed. You've been notified.
     */
    behaviorShapeChanged: function() {
        this.synchronizeScrollingBoundries();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc The dimensions of the grid data have changed. You've been notified.
     */
    behaviorStateChanged: function() {
        this.getRenderer().computeCellsBounds();
        this.repaint();
    },

    repaint: function() {
        var now = this.resolveProperty('repaintImmediately');
        var canvas = this.getCanvas();
        if (canvas) {
            if (now === true) {
                canvas.paintNow();
            } else {
                canvas.repaint();
            }
        }
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Paint immediately in this microtask.
     */
    paintNow: function() {
        var canvas = this.getCanvas();
        canvas.paintNow();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {boolean} In HiDPI mode (has an attribute as such).
     */
    useHiDPI: function() {
        return this.resolveProperty('useHiDPI') !== false;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Initialize drawing surface.
     * @private
     */
    initCanvas: function(margin) {

        var self = this;

        var divCanvas = this.divCanvas = document.createElement('div');
        this.div.appendChild(divCanvas);
        this.canvas = new Canvas(divCanvas, this.renderer);
        this.canvas.canvas.classList.add('hypergrid');

        var style = divCanvas.style;
        style.position = 'absolute';
        style.top = margin.top;
        style.right = margin.right;
        style.bottom = margin.bottom;
        style.left = margin.left;

        this.canvas.resizeNotification = function() {
            self.resized();
        };

        this.addEventListener('fin-canvas-mousemove', function(e) {
            if (self.resolveProperty('readOnly')) {
                return;
            }
            var mouse = e.detail.mouse;
            var mouseEvent = self.getGridCellFromMousePoint(mouse);
            mouseEvent.primitiveEvent = e;
            self.delegateMouseMove(mouseEvent);
        });

        this.addEventListener('fin-canvas-mousedown', function(e) {
            if (self.resolveProperty('readOnly')) {
                return;
            }
            //self.stopEditing();
            var mouse = e.detail.mouse;
            var mouseEvent = self.getGridCellFromMousePoint(mouse);
            mouseEvent.keys = e.detail.keys;
            mouseEvent.primitiveEvent = e;
            self.mouseDownState = mouseEvent;
            self.delegateMouseDown(mouseEvent);
            self.fireSyntheticMouseDownEvent(mouseEvent);
            self.repaint();
        });

        this.addEventListener('fin-canvas-click', function(e) {
            if (self.resolveProperty('readOnly')) {
                return;
            }
            //self.stopEditing();
            var mouse = e.detail.mouse;
            var mouseEvent = self.getGridCellFromMousePoint(mouse);
            mouseEvent.primitiveEvent = e;
            mouseEvent.keys = e.detail.keys; // todo: this was in fin-tap but wasn't here
            self.fireSyntheticClickEvent(mouseEvent);
            self.delegateClick(mouseEvent);
        });

        this.addEventListener('fin-canvas-mouseup', function(e) {
            if (self.resolveProperty('readOnly')) {
                return;
            }
            self.dragging = false;
            if (self.isScrollingNow()) {
                self.setScrollingNow(false);
            }
            if (self.columnDragAutoScrolling) {
                self.columnDragAutoScrolling = false;
            }
            //self.stopEditing();
            var mouse = e.detail.mouse;
            var mouseEvent = self.getGridCellFromMousePoint(mouse);
            mouseEvent.primitiveEvent = e;
            self.delegateMouseUp(mouseEvent);
            if (self.mouseDownState) {
                self.fireSyntheticButtonPressedEvent(self.mouseDownState);
            }
            self.mouseDownState = null;
            self.fireSyntheticMouseUpEvent(mouseEvent);
        });

        this.addEventListener('fin-canvas-dblclick', function(e) {
            if (self.resolveProperty('readOnly')) {
                return;
            }
            var mouse = e.detail.mouse;
            var mouseEvent = self.getGridCellFromMousePoint(mouse);
            mouseEvent.primitiveEvent = e;
            self.fireSyntheticDoubleClickEvent(mouseEvent, e);
            self.delegateDoubleClick(mouseEvent);
        });

        this.addEventListener('fin-canvas-drag', function(e) {
            if (self.resolveProperty('readOnly')) {
                return;
            }
            self.dragging = true;
            var mouse = e.detail.mouse;
            var mouseEvent = self.getGridCellFromMousePoint(mouse);
            mouseEvent.primitiveEvent = e;
            self.delegateMouseDrag(mouseEvent);
        });

        this.addEventListener('fin-canvas-keydown', function(e) {
            if (self.resolveProperty('readOnly')) {
                return;
            }
            self.fireSyntheticKeydownEvent(e);
            self.delegateKeyDown(e);
        });

        this.addEventListener('fin-canvas-keyup', function(e) {
            if (self.resolveProperty('readOnly')) {
                return;
            }
            self.fireSyntheticKeyupEvent(e);
            self.delegateKeyUp(e);
        });

        this.addEventListener('fin-canvas-wheelmoved', function(e) {
            var mouse = e.detail.mouse;
            var mouseEvent = self.getGridCellFromMousePoint(mouse);
            mouseEvent.primitiveEvent = e.detail.primitiveEvent;
            self.delegateWheelMoved(mouseEvent);
        });

        this.addEventListener('fin-canvas-mouseout', function(e) {
            if (self.resolveProperty('readOnly')) {
                return;
            }
            var mouse = e.detail.mouse;
            var mouseEvent = self.getGridCellFromMousePoint(mouse);
            mouseEvent.primitiveEvent = e.detail.primitiveEvent;
            self.delegateMouseExit(mouseEvent);
        });

        this.addEventListener('fin-canvas-context-menu', function(e) {
            var mouse = e.detail.mouse;
            var mouseEvent = self.getGridCellFromMousePoint(mouse);
            mouseEvent.primitiveEvent = e.detail.primitiveEvent;
            self.delegateContextMenu(mouseEvent);
        });

        this.div.removeAttribute('tabindex');

    },

    convertViewPointToDataPoint: function(viewPoint) {
        return this.behavior.convertViewPointToDataPoint(viewPoint);
    },

    convertDataPointToViewPoint: function(dataPoint) {
        return this.behavior.convertDataPointToViewPoint(dataPoint);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Add an event listener to me.
     * @param {string} eventName - The type of event we are interested in.
     * @param {function} callback - The event handler.
     */
    addEventListener: function(eventName, callback) {
        var self = this;
        var decorator = function(e) {
            if (self.allowEventHandlers){
                callback(e);
            }
        };
        this.canvas.addEventListener(eventName, decorator);
    },

    allowEvents: function(allow){
        if ((this.allowEventHandlers = !!allow)){
            this.behavior.featureChain.attachChain();
        } else {
            this.behavior.featureChain.detachChain();
        }

        this.behavior.changed();
    },

    addFinEventListener: function(eventName, callback) {
        console.warn('.addFinEventListener() method is deprecated as of v0.2. Use .addEventListener() instead. (Will be removed in a future release.)');
        this.addEventListener(eventName, callback);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Set for `scrollingNow` field.
     * @param {boolean} isItNow - The type of event we are interested in.
     */
    setScrollingNow: function(isItNow) {
        this.scrollingNow = isItNow;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {boolean} The `scrollingNow` field.
     */
    isScrollingNow: function() {
        return this.scrollingNow;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {number} The index of the column divider under the mouse coordinates.
     * @param {MouseEvent} mouseEvent - The event to interogate.
     */
    overColumnDivider: function(mouseEvent) {
        var x = mouseEvent.primitiveEvent.detail.mouse.x;
        var whichCol = this.getRenderer().overColumnDivider(x);
        return whichCol;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {number} The index of the row divider under the mouse coordinates.
     * @param {MouseEvent} mouseEvent - The event to interogate.
     */
    overRowDivider: function(mouseEvent) {
        var y = mouseEvent.primitiveEvent.detail.mouse.y;
        var which = this.getRenderer().overRowDivider(y);
        return which;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Switch the cursor for the grid.
     * @param {string} cursorName - A well know cursor name.
     * @see [cursor names](http://www.javascripter.net/faq/stylesc.htm)
     */
    beCursor: function(cursorName) {
        if (!cursorName) {
            cursorName = 'default';
        }
        this.div.style.cursor = cursorName;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Delegate the wheel moved event to the behavior.
     * @param {Event} event - The pertinent event.
     */
    delegateWheelMoved: function(event) {
        this.behavior.onWheelMoved(this, event);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Delegate MouseExit to the behavior (model).
     * @param {Event} event - The pertinent event.
     */
    delegateMouseExit: function(event) {
        this.behavior.handleMouseExit(this, event);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Delegate MouseExit to the behavior (model).
     * @param {Event} event - The pertinent event.
     */
    delegateContextMenu: function(event) {
       this. behavior.onContextMenu(this, event);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Delegate MouseMove to the behavior (model).
     * @param {mouseDetails} mouseDetails - An enriched mouse event from fin-canvas.
     */
    delegateMouseMove: function(mouseDetails) {
        this.behavior.onMouseMove(this, mouseDetails);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Delegate mousedown to the behavior (model).
     * @param {mouseDetails} mouseDetails - An enriched mouse event from fin-canvas.
     */
    delegateMouseDown: function(mouseDetails) {
        this.behavior.handleMouseDown(this, mouseDetails);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Delegate mouseup to the behavior (model).
     * @param {mouseDetails} mouseDetails - An enriched mouse event from fin-canvas.
     */
    delegateMouseUp: function(mouseDetails) {
        this.behavior.onMouseUp(this, mouseDetails);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Delegate click to the behavior (model).
     * @param {mouseDetails} mouseDetails - An enriched mouse event from fin-canvas.
     */
    delegateClick: function(mouseDetails) {
        this.behavior.onClick(this, mouseDetails);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Delegate mouseDrag to the behavior (model).
     * @param {mouseDetails} mouseDetails - An enriched mouse event from fin-canvas.
     */
    delegateMouseDrag: function(mouseDetails) {
        this.behavior.onMouseDrag(this, mouseDetails);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc We've been doubleclicked on. Delegate through the behavior (model).
     * @param {mouseDetails} mouseDetails - An enriched mouse event from fin-canvas.
     */
    delegateDoubleClick: function(mouseDetails) {
        this.behavior.onDoubleClick(this, mouseDetails);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Generate a function name and call it on self.
     * @desc This should also be delegated through Behavior keeping the default implementation here though.
     * @param {event} event - The pertinent event.
     */
    delegateKeyDown: function(event) {
        this.behavior.onKeyDown(this, event);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Generate a function name and call it on self.
     * @desc This should also be delegated through Behavior keeping the default implementation here though.
     * @param {event} event - The pertinent event.
     */
    delegateKeyUp: function(event) {
        this.behavior.onKeyUp(this, event);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Shut down the current cell editor and save the edited value.
     * @returns {boolean} `true` if we were editing; `false` if we were not.
     */
    stopEditing: function() {
        var wasEditing = !!this.cellEditor;
        if (wasEditing) {
            this.cellEditor.stopEditing();
        }
        return wasEditing;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Shut down the current cell editor without saving the edited value.
     * @returns {boolean} `true` if we were editing; `false` if we were not.
     */
    cancelEditing: function() {
        var wasEditing = !!this.cellEditor;
        if (wasEditing) {
            this.cellEditor.cancelEditing();
        }
        return wasEditing;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {Rectangle} The pixel coordinates of just the center 'main" data area.
     */
    getDataBounds: function() {
        var colDNDHackWidth = 200; //this was a hack to help with column dnd, need to factor this into a shared variable
        var b = this.canvas.bounds;

        //var x = this.getRowNumbersWidth();
        // var y = behavior.getFixedRowsHeight() + 2;

        var result = new Rectangle(0, 0, b.origin.x + b.extent.x - colDNDHackWidth, b.origin.y + b.extent.y);
        return result;
    },

    getRowNumbersWidth: function() {
        if (this.isShowRowNumbers()) {
            return this.getRenderer().getRowNumbersWidth();
        } else {
            return 0;
        }
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {Canvas} Our fin-canvas instance.
     */
    getCanvas: function() {
        return this.canvas;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Open the cell-editor at the provided model coordinates.
     * @param {Point} editPoint - The model coordinates of the cell to edit. This is the grid coordinates regardless of scroll position.
     * @return {undefined|CellEditor} The cellEditor determined from the cell's render properties, which may be modified by logic added by overriding {@link DataModel#getCellEditorAt|getCellEditorAt}.
     */
    editAt: function(editPoint) {
        var cellEditor;

        if (arguments.length === 2) {
            return this.deprecated('editAt(cellEditor, editPoint)', 'editAt(editPoint)', '1.0.6', arguments);
        }

        this.stopEditing(); //other editor is open, close it first

        if (editPoint.x >= 0 && editPoint.y >= 0) {
            var editable = this.behavior.getActiveColumn(editPoint.x).getProperties().editable;
            if (editable || this.isFilterRow(editPoint.y)) {
                this.setMouseDown(editPoint);
                this.setDragExtent(new Point(0, 0));
                cellEditor = this.getCellEditorAt(editPoint);
                if (cellEditor) {
                    cellEditor.beginEditing();
                }
            }
        }

        return cellEditor;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {boolean} The given column is fully visible.
     * @param {number} columnIndex - The column index in question.
     * @return {boolan} Visible.
     */
    isColumnVisible: function(columnIndex) {
        return this.getRenderer().isColumnVisible(columnIndex);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {boolean} The given row is fully visible.
     * @param {number} rowIndex - The row index in question.
     * @return {boolan} Visible.
     */
    isDataRowVisible: function(rowIndex) {
        return this.getRenderer().isRowVisible(rowIndex);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {boolean} The given cell is fully is visible.
     * @param {number} columnIndex - The column index in question.
     * @param {number} rowIndex - The row index in question.
     * @return {boolean} Data is visible.
     */
    isDataVisible: function(columnIndex, rowIndex) {
        return this.isDataRowVisible(rowIndex) && this.isColumnVisible(columnIndex);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Scroll in the `offsetX` direction if column index `colIndex` is not visible.
     * @param {number} colIndex - The column index in question.
     * @param {number} offsetX - The direction and magnitude to scroll if we need to.
     * @return {boolean} Column is visible.
     */
    insureModelColIsVisible: function(colIndex, offsetX) {
        var maxCols = this.getColumnCount() - 1, // -1 excludes partially visible columns
            indexToCheck = colIndex + (offsetX > 0),
            visible = !this.isColumnVisible(indexToCheck) || colIndex === maxCols;

        if (visible) {
            //the scroll position is the leftmost column
            this.scrollBy(offsetX, 0);
        }

        return visible;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Scroll in the `offsetY` direction if column index c is not visible.
     * @param {number} rowIndex - The column index in question.
     * @param {number} offsetX - The direction and magnitude to scroll if we need to.
     * @return {boolean} Row is visible.
     */
    insureModelRowIsVisible: function(rowIndex, offsetY) {
        var maxRows = this.getRowCount() - 1, // -1 excludes partially visible rows
            indexToCheck = rowIndex + (offsetY > 0),
            visible = !this.isDataRowVisible(indexToCheck) || rowIndex === maxRows;

        if (visible) {
            //the scroll position is the topmost row
            this.scrollBy(0, offsetY);
        }

        return visible;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Scroll horizontal and vertically by the provided offsets.
     * @param {number} offsetX - Scroll in the x direction this much.
     * @param {number} offsetY - Scroll in the y direction this much.
     */
    scrollBy: function(offsetX, offsetY) {
        this.scrollHBy(offsetX);
        this.scrollVBy(offsetY);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Scroll vertically by the provided offset.
     * @param {number} offsetY - Scroll in the y direction this much.
     */
    scrollVBy: function(offsetY) {
        var max = this.sbVScroller.range.max;
        var oldValue = this.getVScrollValue();
        var newValue = Math.min(max, Math.max(0, oldValue + offsetY));
        if (newValue !== oldValue) {
            this.setVScrollValue(newValue);
        }
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Scroll horizontally by the provided offset.
     * @param {number} offsetX - Scroll in the x direction this much.
     */
    scrollHBy: function(offsetX) {
        var max = this.sbHScroller.range.max;
        var oldValue = this.getHScrollValue();
        var newValue = Math.min(max, Math.max(0, oldValue + offsetX));
        if (newValue !== oldValue) {
            this.setHScrollValue(newValue);
        }
    },

    scrollToMakeVisible: function(c, r) {
        var leftColumn = this.renderer.getScrollLeft(),
            topRow = this.renderer.getScrollTop(),
            delta,
            numOfGridCtrlCols = 2, //TODO: Get rid of ALL magic and hardcoded numbers.
            numofGridCtrlRows = 3,
            adjustmentForPartiallyVisCols = -1;

        if (
            // target is off to left; negative delta scrolls left
            (delta = c - (leftColumn + this.renderer.getFixedColumnCount())) < 0 ||

            // target is off to right; positive delta scrolls right
            (delta = c - (leftColumn + this.getVisibleColumnsCount() - numOfGridCtrlCols + adjustmentForPartiallyVisCols)) > 0
        ) {
            this.sbHScroller.index += delta;
        }

        if (
            // target is above top; negative delta scrolls up
            (delta = r - (topRow + this.renderer.getFixedRowCount())) < 0 ||

            // target is below bottom; positive delta scrolls down
            (delta = r - (topRow + this.renderer.rowEdges.length - numofGridCtrlRows)) > 0
        ) {
            this.sbVScroller.index += delta;
        }
    },

    selectCellAndScrollToMakeVisible: function(c, r) {
        this.selectCell(c, r, true);
        this.scrollToMakeVisible(c, r);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Answer which data cell is under a pixel value mouse point.
     * @param {mousePoint} mouse - The mouse point to interrogate.
     */

    getGridCellFromMousePoint: function(mouse) {
        var cell = this.getRenderer().getGridCellFromMousePoint(mouse);
        return cell;
    },

    /**
     * @returns {Rectangle} The pixel based bounds rectangle given a data cell point.
     * @param {Point} cell - The pixel location of the mouse.
     * @memberOf Hypergrid.prototype
     */
    getBoundsOfCell: function(cell) {
        var b = this.getRenderer().getBoundsOfCell(cell);

        //we need to convert this to a proper rectangle
        var newBounds = new Rectangle(b.x, b.y, b.width, b.height);
        return newBounds;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc This is called by the fin-canvas when a resize occurs.
     */
    resized: function() {
        this.synchronizeScrollingBoundries();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary A click event occurred.
     * @desc Determine the cell and delegate to the behavior (model).
     * @param {MouseEvent} event - The mouse event to interrogate.
     */
    cellClicked: function(event) {
        var cell = event.gridCell;

        //click occurred in background area
        if (
            cell.x <= this.getColumnCount() &&
            cell.y <= this.getRowCount()
        ) {
            var hovered = this.getHoverCell(),
                x = hovered.x,
                y = hovered.y;

            // if (x >= 0) {
            //     x = behavior.translateColumnIndex(x + this.getHScrollValue());
            // }

            if (y >= 0) {
                y += this.getVScrollValue();
            }

            this.behavior.cellClicked(new Point(x, y), event);
        }
    },

    /**
     * @memberOf Hypergrid.prototype
     * @param {number} x - column index
     * @param {number} y - totals row index local to the totals area
     * @param value
     * @param {string[]} [areas=['top', 'bottom']] - may include `'top'` and/or `'bottom'`
     */
    setTotalsValueNotification: function(x, y, value, areas) {
        this.fireSyntheticSetTotalsValue(x, y, value, areas);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @param {number} x - column index
     * @param {number} y - totals row index local to the totals area
     * @param value
     * @param {string[]} [areas=['top', 'bottom']] - may include `'top'` and/or `'bottom'`
     */
    fireSyntheticSetTotalsValue: function(x, y, value, areas) {
        var clickEvent = new CustomEvent('fin-set-totals-value', {
            detail: {
                x: x,
                y: y,
                value: value,
                areas: areas
            }
        });
        this.canvas.dispatchEvent(clickEvent);
    },

    fireSyntheticEditorKeyUpEvent: function(inputControl, keyEvent) {
        var clickEvent = new CustomEvent('fin-editor-keyup', {
            detail: {
                input: inputControl,
                keyEvent: keyEvent,
                char: this.canvas.getCharMap()[keyEvent.keyCode][keyEvent.shiftKey ? 1 : 0]
            }
        });
        this.canvas.dispatchEvent(clickEvent);
    },

    fireSyntheticEditorKeyDownEvent: function(inputControl, keyEvent) {
        var clickEvent = new CustomEvent('fin-editor-keydown', {
            detail: {
                input: inputControl,
                keyEvent: keyEvent,
                char: this.canvas.getCharMap()[keyEvent.keyCode][keyEvent.shiftKey ? 1 : 0]
            }
        });
        this.canvas.dispatchEvent(clickEvent);
    },

    fireSyntheticEditorKeyPressEvent: function(inputControl, keyEvent) {
        var clickEvent = new CustomEvent('fin-editor-keypress', {
            detail: {
                input: inputControl,
                keyEvent: keyEvent,
                char: this.canvas.getCharMap()[keyEvent.keyCode][keyEvent.shiftKey ? 1 : 0]
            }
        });
        this.canvas.dispatchEvent(clickEvent);
    },

    fireSyntheticEditorDataChangeEvent: function(inputControl, oldValue, newValue) {
        var clickEvent = new CustomEvent('fin-editor-data-change', {
            detail: {
                input: inputControl,
                oldValue: oldValue,
                newValue: newValue
            },
            cancelable: true
        });
        return this.canvas.dispatchEvent(clickEvent);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Synthesize and fire a `fin-row-selection-changed` event.
     */
    fireSyntheticRowSelectionChangedEvent: function() {
        var selectionEvent = new CustomEvent('fin-row-selection-changed', {
            detail: {
                rows: this.getSelectedRows(),
                columns: this.getSelectedColumns(),
                selections: this.selectionModel.getSelections(),
            }
        });
        this.canvas.dispatchEvent(selectionEvent);
    },

    fireSyntheticColumnSelectionChangedEvent: function() {
        var selectionEvent = new CustomEvent('fin-column-selection-changed', {
            detail: {
                rows: this.getSelectedRows(),
                columns: this.getSelectedColumns(),
                selections: this.selectionModel.getSelections()
            }
        });
        this.canvas.dispatchEvent(selectionEvent);
    },
    /**
     * @memberOf Hypergrid.prototype
     * @desc Synthesize and dispatch a `fin-selection-changed` event.
     */
    selectionChanged: function() {
        var selectedRows = this.getSelectedRows();
        var selectionEvent = new CustomEvent('fin-selection-changed', {
            detail: {
                rows: selectedRows,
                columns: this.getSelectedColumns(),
                selections: this.selectionModel.getSelections(),
            }
        });
        this.canvas.dispatchEvent(selectionEvent);
    },

    getRowSelection: function(includeHiddenColumns) {
        var column, rows, getColumn,
            self = this,
            selectedRowIndexes = this.selectionModel.getSelectedRows(),
            numColumns = this.getColumnCount(),
            result = {};

        if (includeHiddenColumns) {
            numColumns += this.getHiddenColumns().length;
            getColumn = this.behavior.getColumn;
        } else {
            getColumn = this.behavior.getActiveColumn;
        }
        getColumn = getColumn.bind(this.behavior);

        for (var c = 0; c < numColumns; c++) {
            column = getColumn(c);
            rows = result[column.name] = new Array(selectedRowIndexes.length);
            selectedRowIndexes.forEach(getValue);
        }

        function getValue(selectedRowIndex, j) {
            var dataRow = self.getRow(selectedRowIndex);
            rows[j] = valOrFunc(dataRow, column.name);
        }

        return result;
    },

    getHiddenColumns: function(){
        //A non in-memory behavior will be more troublesome
      return this.behavior.getHiddenColumns();
    },

    getRowSelectionMatrix: function() {
        var self = this,
            selectedRowIndexes = this.selectionModel.getSelectedRows(),
            numCols = this.getColumnCount(),
            result = new Array(numCols);

        for (var c = 0; c < numCols; c++) {
            var column = this.behavior.getActiveColumn(c);
            result[c] = new Array(selectedRowIndexes.length);
            selectedRowIndexes.forEach(getValue);
        }

        function getValue(selectedRowIndex, r) {
            var dataRow = self.getRow(selectedRowIndex);
            result[c][r] = valOrFunc(dataRow, column.name);
        }

        return result;
    },

    getColumnSelectionMatrix: function() {
        var dataRow,
            self = this,
            headerRowCount = this.getHeaderRowCount(),
            selectedColumnIndexes = this.getSelectedColumns(),
            numRows = this.getRowCount(),
            result = new Array(selectedColumnIndexes.length);

        selectedColumnIndexes.forEach(function(selectedColumnIndex, c) {
            var column = self.behavior.getActiveColumn(selectedColumnIndex),
                values = result[c] = new Array(numRows);

            for (var r = headerRowCount; r < numRows; r++) {
                dataRow = self.getRow(r);
                values[r] = valOrFunc(dataRow, column.name);
            }
        });

        return result;
    },

    getColumnSelection: function() {
        var dataRow,
            self = this,
            headerRowCount = this.getHeaderRowCount(),
            selectedColumnIndexes = this.getSelectedColumns(),
            result = {},
            rowCount = this.getRowCount();

        selectedColumnIndexes.forEach(function(selectedColumnIndex) {
            var column = self.behavior.getActiveColumn(selectedColumnIndex),
                values = result[column.name] = new Array(rowCount);

            for (var r = headerRowCount; r < rowCount; r++) {
                dataRow = self.getRow(r);
                values[r] = valOrFunc(dataRow, column.name);
            }
        });

        return result;
    },

    getSelection: function() {
        var dataRow,
            self = this,
            selections = this.getSelections(),
            rects = new Array(selections.length);

        selections.forEach(getRect);

        function getRect(selectionRect, i) {
            var rect = normalizeRect(selectionRect),
                colCount = rect.extent.x + 1,
                rowCount = rect.extent.y + 1,
                columns = {};

            for (var c = 0, x = rect.origin.x; c < colCount; c++, x++) {
                var column = self.behavior.getActiveColumn(x),
                    values = columns[column.name] = new Array(rowCount);

                for (var r = 0, y = rect.origin.y; r < rowCount; r++, y++) {
                    dataRow = self.getRow(y);
                    values[r] = valOrFunc(dataRow, column.name);
                }
            }

            rects[i] = columns;
        }

        return rects;
    },

    getSelectionMatrix: function() {
        var dataRow,
            self = this,
            selections = this.getSelections(),
            rects = new Array(selections.length);

        selections.forEach(getRect);

        function getRect(selectionRect, i) {
            var rect = normalizeRect(selectionRect),
                colCount = rect.extent.x + 1,
                rowCount = rect.extent.y + 1,
                rows = [];

            for (var c = 0, x = rect.origin.x; c < colCount; c++, x++) {
                var values = rows[c] = new Array(rowCount),
                    column = self.behavior.getActiveColumn(x);

                for (var r = 0, y = rect.origin.y; r < rowCount; r++, y++) {
                    dataRow = self.getRow(y);
                    values[r] = valOrFunc(dataRow, column.name);
                }
            }

            rects[i] = rows;
        }

        return rects;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Synthesize and fire a `fin-context-menu` event
     * @param {keyEvent} event - The canvas event.
     */
    fireSyntheticContextMenuEvent: function(e) {
        e.gridCell = this.convertViewPointToDataPoint(e.gridCell);
        var event = new CustomEvent('fin-context-menu', {
            detail: {
                gridCell: e.gridCell,
                mousePoint: e.mousePoint,
                viewPoint: e.viewPoint,
                primitiveEvent: e.primitiveEvent,
                rows: this.getSelectedRows(),
                columns: this.getSelectedColumns(),
                selections: this.selectionModel.getSelections()
            }
        });
        this.canvas.dispatchEvent(event);
    },

    fireSyntheticMouseUpEvent: function(e) {
        var event = new CustomEvent('fin-mouseup', {
            detail: {
                gridCell: e.gridCell,
                mousePoint: e.mousePoint,
                viewPoint: e.viewPoint,
                primitiveEvent: e.primitiveEvent,
                rows: this.getSelectedRows(),
                columns: this.getSelectedColumns(),
                selections: this.selectionModel.getSelections()
            }
        });
        this.canvas.dispatchEvent(event);
    },

    fireSyntheticMouseDownEvent: function(e) {
        this.stopEditing();
        var event = new CustomEvent('fin-mousedown', {
            detail: {
                gridCell: e.gridCell,
                mousePoint: e.mousePoint,
                viewPoint: e.viewPoint,
                primitiveEvent: e.primitiveEvent,
                rows: this.getSelectedRows(),
                columns: this.getSelectedColumns(),
                selections: this.selectionModel.getSelections()
            }
        });
        this.canvas.dispatchEvent(event);
    },

    isViewableButton: function(c, r) {
        return this.getRenderer().isViewableButton(c, r);
    },

    fireSyntheticButtonPressedEvent: function(evt) {
        var dataCell = evt.dataCell;
        var gridCell = evt.gridCell;
        if (this.isViewableButton(dataCell.x, dataCell.y)) {
            var event = new CustomEvent('fin-button-pressed', {
                detail: {
                    gridCell: gridCell
                }
            });
            this.canvas.dispatchEvent(event);
        }
    },
    /**
     * @memberOf Hypergrid.prototype
     * @desc Synthesize and fire a `fin-column-drag-start` event.
     */
    fireSyntheticOnColumnsChangedEvent: function() {
        var detail = {
            time: Date.now(),
            grid: this
        };
        var cEvent = new CustomEvent('fin-column-changed-event', {
            detail: detail
        });
        console.log('column changed');
        this.canvas.dispatchEvent(cEvent);
    },
    /**
     * @memberOf Hypergrid.prototype
     * @desc Synthesize and fire a `fin-keydown` event.
     * @param {keyEvent} event - The canvas event.
     */
    fireSyntheticKeydownEvent: function(keyEvent) {
        var clickEvent = new CustomEvent('fin-keydown', {
            detail: keyEvent.detail
        });
        this.canvas.dispatchEvent(clickEvent);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Synthesize and fire a `fin-keyup` event.
     * @param {keyEvent} event - The canvas event.
     */
    fireSyntheticKeyupEvent: function(keyEvent) {
        var clickEvent = new CustomEvent('fin-keyup', {
            detail: keyEvent.detail
        });
        this.canvas.dispatchEvent(clickEvent);
    },

    fireSyntheticFilterAppliedEvent: function() {
        var filterEvent = new CustomEvent('fin-filter-applied');
        this.canvas.dispatchEvent(filterEvent);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Synthesize and fire a `fin-cell-enter` event
     * @param {Point} cell - The pixel location of the cell in which the click event occurred.
     * @param {MouseEvent} event - The system mouse event.
     */
    fireSyntheticOnCellEnterEvent: function(cell) {
        var detail = {
            gridCell: cell,
            time: Date.now(),
            grid: this
        };
        var clickEvent = new CustomEvent('fin-cell-enter', {
            detail: detail
        });
        this.canvas.dispatchEvent(clickEvent);
    },

    fireSyntheticGroupsChangedEvent: function(groups) {
        var detail = {
            groups: groups,
            time: Date.now(),
            grid: this
        };
        var clickEvent = new CustomEvent('fin-groups-changed', {
            detail: detail
        });
        this.canvas.dispatchEvent(clickEvent);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Synthesize and fire a `fin-cell-exit` event.
     * @param {Point} cell - The pixel location of the cell in which the click event occured.
     * @param {MouseEvent} event - The system mouse event.
     */
    fireSyntheticOnCellExitEvent: function(cell) {
        var detail = {
            gridCell: cell,
            time: Date.now(),
            grid: this
        };
        var clickEvent = new CustomEvent('fin-cell-exit', {
            detail: detail
        });
        this.canvas.dispatchEvent(clickEvent);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Synthesize and fire a `fin-cell-click` event.
     * @param {Point} cell - The pixel location of the cell in which the click event occured.
     * @param {MouseEvent} event - The system mouse event.
     */
    fireSyntheticClickEvent: function(mouseEvent) {
        var cell = mouseEvent.gridCell;
        var detail = {
            gridCell: cell,
            mousePoint: mouseEvent.mousePoint,
            keys: mouseEvent.keys,
            primitiveEvent: mouseEvent,
            time: Date.now(),
            grid: this
        };
        this.behavior.enhanceDoubleClickEvent(detail);
        var clickEvent = new CustomEvent('fin-click', {
            detail: detail
        });
        this.canvas.dispatchEvent(clickEvent);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Synthesize and fire a `fin-double-click` event.
     * @param {MouseEvent} event - The system mouse event.
     */
    fireSyntheticDoubleClickEvent: function(mouseEvent) {
        this.stopEditing();
        var cell = mouseEvent.gridCell;
        var detail = {
            gridCell: cell,
            mousePoint: mouseEvent.mousePoint,
            time: Date.now(),
            grid: this
        };
        this.behavior.enhanceDoubleClickEvent(mouseEvent);
        var clickEvent = new CustomEvent('fin-double-click', {
            detail: detail
        });
        this.behavior.cellDoubleClicked(cell, mouseEvent);
        this.canvas.dispatchEvent(clickEvent);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Synthesize and fire a rendered event.
     */
    fireSyntheticGridRenderedEvent: function() {
        var event = new CustomEvent('fin-grid-rendered', {
            detail: {
                source: this,
                time: Date.now()
            }
        });
        if (this.canvas) {
            this.canvas.dispatchEvent(event);
        }
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Synthesize and fire a scroll event.
     * @param {string} type - Should be either `fin-scroll-x` or `fin-scroll-y`.
     * @param {number} oldValue - The old scroll value.
     * @param {number} newValue - The new scroll value.
     */
    fireScrollEvent: function(type, oldValue, newValue) {
        var event = new CustomEvent(type, {
            detail: {
                oldValue: oldValue,
                value: newValue,
                time: Date.now()
            }
        });
        this.canvas.dispatchEvent(event);

    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Set the vertical scroll value.
     * @param {number} newValue - The new scroll value.
     */
    setVScrollValue: function(y) {
        var self = this;
        y = Math.min(this.sbVScroller.range.max, Math.max(0, Math.round(y)));
        if (y !== this.vScrollValue) {
            this.behavior._setScrollPositionY(y);
            var oldY = this.vScrollValue;
            this.vScrollValue = y;
            this.scrollValueChangedNotification();
            setTimeout(function() {
                // self.sbVRangeAdapter.subjectChanged();
                self.fireScrollEvent('fin-scroll-y', oldY, y);
            });
        }
    },

    /**
     * @memberOf Hypergrid.prototype
     * @return {number} The vertical scroll value.
     */
    getVScrollValue: function() {
        return this.vScrollValue;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Set the horizontal scroll value.
     * @param {number} newValue - The new scroll value.
     */
    setHScrollValue: function(x) {
        var self = this;
        x = Math.min(this.sbHScroller.range.max, Math.max(0, Math.round(x)));
        if (x !== this.hScrollValue) {
            this.behavior._setScrollPositionX(x);
            var oldX = this.hScrollValue;
            this.hScrollValue = x;
            this.scrollValueChangedNotification();
            setTimeout(function() {
                //self.sbHRangeAdapter.subjectChanged();
                self.fireScrollEvent('fin-scroll-x', oldX, x);
                //self.synchronizeScrollingBoundries(); // todo: Commented off to prevent the grid from bouncing back, but there may be repurcussions...
            });
        }
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns The vertical scroll value.
     */
    getHScrollValue: function() {
        return this.hScrollValue;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Request input focus.
     */
    takeFocus: function() {
        if (!this.stopEditing()) {
            this.getCanvas().takeFocus();
        }
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Request focus for our cell editor.
     */
    editorTakeFocus: function() {
        if (this.cellEditor) {
            return this.cellEditor.takeFocus();
        }
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Initialize the scroll bars.
     */
    initScrollbars: function() {

        var self = this;

        var horzBar = new FinBar({
            orientation: 'horizontal',
            onchange: self.setHScrollValue.bind(self),
            cssStylesheetReferenceElement: this.div
        });

        var vertBar = new FinBar({
            orientation: 'vertical',
            onchange: self.setVScrollValue.bind(self),
            paging: {
                up: self.pageUp.bind(self),
                down: self.pageDown.bind(self)
            }
        });

        this.sbHScroller = horzBar;
        this.sbVScroller = vertBar;

        var hPrefix = this.resolveProperty('hScrollbarClassPrefix');
        var vPrefix = this.resolveProperty('vScrollbarClassPrefix');

        if (hPrefix && hPrefix !== '') {
            this.sbHScroller.classPrefix = hPrefix;
        }

        if (vPrefix && vPrefix !== '') {
            this.sbVScroller.classPrefix = vPrefix;
        }

        this.div.appendChild(horzBar.bar);
        this.div.appendChild(vertBar.bar);

        this.resizeScrollbars();

    },

    resizeScrollbars: function() {
        this.sbHScroller.shortenBy(this.sbVScroller).resize();
        //this.sbVScroller.shortenBy(this.sbHScroller);
        this.sbVScroller.resize();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Scroll values have changed, we've been notified.
     */
    setVScrollbarValues: function(max) {
        this.sbVScroller.range = {
            min: 0,
            max: max
        };
    },

    setHScrollbarValues: function(max) {
        this.sbHScroller.range = {
            min: 0,
            max: max
        };
    },

    scrollValueChangedNotification: function() {

        if (this.hScrollValue === this.sbPrevHScrollValue && this.vScrollValue === this.sbPrevVScrollValue) {
            return;
        }

        this.sbPrevHScrollValue = this.hScrollValue;
        this.sbPrevVScrollValue = this.vScrollValue;

        if (this.cellEditor) {
            this.cellEditor.scrollValueChangedNotification();
        }

        this.computeCellsBounds();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Get data value at given cell.
     * @desc Delegates to the behavior.
     * @param {number} x - The horizontal coordinate.
     * @param {number} y - The vertical coordinate.
     * @param {*} value
     */
    getValue: function(x, y) {
        return this.behavior.getValue(x, y);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Set a data value into the behavior (model) at the given point
     * @param {number} x - The horizontal coordinate.
     * @param {number} y - The vertical coordinate.
     */
    setValue: function(x, y, value) {
        this.behavior.setValue(x, y, value);
    },

    getColumnAlignment: function(c) {
        return this.behavior.getColumnAlignment(c);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc The data dimensions have changed, or our pixel boundries have changed.
     * Adjust the scrollbar properties as necessary.
     */
    synchronizeScrollingBoundries: function() {
        var numFixedColumns = this.getFixedColumnCount();
        var numFixedRows = this.getFixedRowCount();

        var numColumns = this.getColumnCount();
        var numRows = this.getRowCount();

        var bounds = this.getBounds();
        if (!bounds) {
            return;
        }
        var scrollableHeight = bounds.height - this.behavior.getFixedRowsMaxHeight() - 15; //5px padding at bottom and right side
        var scrollableWidth = (bounds.width - 200) - this.behavior.getFixedColumnsMaxWidth() - 15;

        var lastPageColumnCount = 0;
        var columnsWidth = 0;
        for (; lastPageColumnCount < numColumns; lastPageColumnCount++) {
            var eachWidth = this.getColumnWidth(numColumns - lastPageColumnCount - 1);
            columnsWidth += eachWidth;
            if (columnsWidth > scrollableWidth) {
                break;
            }
        }

        var lastPageRowCount = 0;
        var rowsHeight = 0;
        for (; lastPageRowCount < numRows; lastPageRowCount++) {
            var eachHeight = this.getRowHeight(numRows - lastPageRowCount - 1);
            rowsHeight += eachHeight;
            if (rowsHeight > scrollableHeight) {
                break;
            }
        }

        var hMax = Math.max(0, numColumns - numFixedColumns - lastPageColumnCount);
        this.setHScrollbarValues(hMax);

        var vMax = 1 + Math.max(0, numRows - numFixedRows - lastPageRowCount);
        this.setVScrollbarValues(vMax);

        this.setHScrollValue(Math.min(this.getHScrollValue(), hMax));
        this.setVScrollValue(Math.min(this.getVScrollValue(), vMax));

        //this.getCanvas().resize();
        this.computeCellsBounds();
        this.repaint();

        this.resizeScrollbars();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Note that "viewable rows" includes any partially viewable rows.
     * @returns {number} The number of viewable rows.
     */
    getVisibleRows: function() {
        return this.getRenderer().getVisibleRows();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Note that "viewable columns" includes any partially viewable columns.
     * @returns {number} The number of viewable columns.
     */
    getVisibleColumns: function() {
        return this.getRenderer().getVisibleColumns();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Initialize the renderer sub-component.
     */
    initRenderer: function() {
        this.renderer = new Renderer(this);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {Renderer} sub-component
     */
    getRenderer: function() {
        return this.renderer;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {number} The width of the given column.
     * @param {number} columnIndex - The untranslated column index.
     */
    getColumnWidth: function(columnIndex) {
        return this.behavior.getColumnWidth(columnIndex);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Set the width of the given column.
     * @param {number} columnIndex - The untranslated column index.
     * @param {number} columnWidth - The width in pixels.
     */
    setColumnWidth: function(columnIndex, columnWidth) {
        this.stopEditing();
        this.behavior.setColumnWidth(columnIndex, columnWidth);
    },

    getColumnEdge: function(c) {
        return this.behavior.getColumnEdge(c, this.getRenderer());
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {number} The total width of all the fixed columns.
     */
    getFixedColumnsWidth: function() {
        return this.behavior.getFixedColumnsWidth();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {number} The height of the given row
     * @param {number} rowIndex - The untranslated fixed column index.
     */
    getRowHeight: function(rowIndex) {
        return this.behavior.getRowHeight(rowIndex);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Set the height of the given row.
     * @param {number} rowIndex - The row index.
     * @param {number} rowHeight - The width in pixels.
     */
    setRowHeight: function(rowIndex, rowHeight) {
        this.stopEditing();
        this.behavior.setRowHeight(rowIndex, rowHeight);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {number} The total fixed rows height
     */
    getFixedRowsHeight: function() {
        return this.behavior.getFixedRowsHeight();
    },

    /**
     * Number of _visible_ columns.
     * @memberOf Hypergrid.prototype
     * @returns {number} The number of columns.
     */
    getColumnCount: function() {
        return this.behavior.getActiveColumnCount();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {number} The number of fixed rows.
     */
    getRowCount: function() {
        return this.behavior.getRowCount();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {number} The number of unfiltered rows.
     */
    getUnfilteredRowCount: function() {
        return this.behavior.getUnfilteredRowCount();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {number} The number of fixed columns.
     */
    getFixedColumnCount: function() {
        return this.behavior.getFixedColumnCount();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns The number of fixed rows.
     */
    getFixedRowCount: function() {
        return this.behavior.getFixedRowCount();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary The top left area has been clicked on
     * @desc Delegates to the behavior.
     * @param {event} event - The event details.
     */
    topLeftClicked: function(mouse) {
        this.behavior.topLeftClicked(this, mouse);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary A fixed row has been clicked.
     * @desc Delegates to the behavior.
     * @param {event} event - The event details.
     */
    rowHeaderClicked: function(mouse) {
        this.behavior.rowHeaderClicked(this, mouse);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary A fixed column has been clicked.
     * @desc Delegates to the behavior.
     * @param {event} event - The event details.
     */
    columnHeaderClicked: function(mouse) {
        this.behavior.columnHeaderClicked(this, mouse);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc An edit event has occurred. Activate the editor at the given coordinates.
     * @param {number} event.gridCell.x - The horizontal coordinate.
     * @param {number} event.gridCell.y - The vertical coordinate.
     * @param {boolean} [event.primitiveEvent.type]
     * @returns {undefined|CellEditor} The editor object or `undefined` if no editor or editor already open.
     */
    onEditorActivate: function(event) {
        var point = event.gridCell;
        return this.editAt(point);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Get the cell editor.
     * @desc Delegates to the behavior.
     * @returns The cell editor at the given coordinates.
     * @param {Point} editPoint - The grid cell coordinates.
     */
    getCellEditorAt: function(editPoint) {
        return this.behavior.getCellEditorAt(editPoint);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Toggle HiDPI support.
     * @desc HiDPI support is now *on* by default.
     * > There used to be a bug in Chrome that caused severe slow down on bit blit of large images, so this HiDPI needed to be optional.
     */
    toggleHiDPI: function() {
        if (this.useHiDPI()) {
            this.removeAttribute('hidpi');
        } else {
            this.setAttribute('hidpi', null);
        }
        this.canvas.resize();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {number} Te HiDPI ratio.
     */
    getHiDPI: function(ctx) {
        if (window.devicePixelRatio && this.useHiDPI()) {
            var devicePixelRatio = window.devicePixelRatio || 1;
            var backingStoreRatio = ctx.webkitBackingStorePixelRatio ||
                ctx.mozBackingStorePixelRatio ||
                ctx.msBackingStorePixelRatio ||
                ctx.oBackingStorePixelRatio ||
                ctx.backingStorePixelRatio || 1;

            var ratio = devicePixelRatio / backingStoreRatio;
            return ratio;
        } else {
            return 1;
        }
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {number} The width of the given (recently rendered) column.
     * @param {number} colIndex - The column index.
     */
    getRenderedWidth: function(colIndex) {
        return this.renderer.getRenderedWidth(colIndex);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {number} The height of the given (recently rendered) row.
     * @param {number} rowIndex - Tthe row index.
     */
    getRenderedHeight: function(rowIndex) {
        return this.renderer.getRenderedHeight(rowIndex);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Update the cursor under the hover cell.
     */
    updateCursor: function() {
        var cursor = this.behavior.getCursorAt(-1, -1);
        var hoverCell = this.getHoverCell();
        if (
            hoverCell &&
            hoverCell.x > -1 &&
            hoverCell.y > -1
        ) {
            var x = hoverCell.x + this.getHScrollValue();
            cursor = this.behavior.getCursorAt(x, hoverCell.y + this.getVScrollValue());
        }
        this.beCursor(cursor);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Repaint the given cell.
     * @param {x} x - The horizontal coordinate.
     * @param {y} y - The vertical coordinate.
     */
    repaintCell: function(x, y) {
        this.getRenderer().repaintCell(x, y);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {boolean} The user is currently dragging a column to reorder it.
     */
    isDraggingColumn: function() {
        return !!this.renderOverridesCache.dragger;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Scroll up one full page.
     * @returns {number}
     */
    pageUp: function() {
        var rowNum = this.getRenderer().getPageUpRow();
        this.setVScrollValue(rowNum);
        return rowNum;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Scroll down one full page.
     * @returns {number}
     */
    pageDown: function() {
        var rowNum = this.getRenderer().getPageDownRow();
        this.setVScrollValue(rowNum);
        return rowNum;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Not yet implemented.
     */
    pageLeft: function() {
        console.log('page left');
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Not yet implemented.
     */
    pageRight: function() {
        console.log('page right');
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {object[]} Objects with the values that were just rendered.
     */
    getRenderedData: function() {
        // assumes one row of headers
        var behavior = this.behavior,
            renderer = this.getRenderer(),
            colCount = this.getColumnCount(),
            rowCount = renderer.getVisibleRows(),
            headers = new Array(colCount),
            results = new Array(rowCount),
            row;

        headers.forEach(function(header, c) {
            headers[c] = behavior.getActiveColumn(c).header;
        });

        results.forEach(function(result, r) {
            row = results[r] = {
                hierarchy: behavior.getFixedColumnValue(0, r)
            };
            headers.forEach(function(field, c) {
                row[field] = behavior.getValue(c, r);
            });
        });

        return results;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {object} An object that represents the currently selection row.
     */
    getSelectedRow: function() {
        var sels = this.selectionModel.getSelections();
        if (sels.length) {
            var behavior = this.behavior,
                colCount = this.getColumnCount(),
                topRow = sels[0].origin.y,
                row = {
                    //hierarchy: behavior.getFixedColumnValue(0, topRow)
                };

            for (var c = 0; c < colCount; c++) {
                row[behavior.getActiveColumn(c).header] = behavior.getValue(c, topRow);
            }

            return row;
        }
    },

    fireRequestCellEdit: function(cell, value) {
        var clickEvent = new CustomEvent('fin-request-cell-edit', {
            cancelable: true,
            detail: {
                value: value,
                gridCell: cell,
                time: Date.now()
            }
        });
        return this.canvas.dispatchEvent(clickEvent); //I wasn't cancelled
    },
    /**
     * @memberOf Hypergrid.prototype
     * @desc Synthesize and fire a fin-before-cell-edit event.
     * @param {Point} cell - The x,y coordinates.
     * @param {Object} value - The current value.
     */
    fireBeforeCellEdit: function(cell, oldValue, newValue, control) {
        var clickEvent = new CustomEvent('fin-before-cell-edit', {
            cancelable: true,
            detail: {
                oldValue: oldValue,
                newValue: newValue,
                gridCell: cell,
                time: Date.now(),
                input: control,
                row: this.getRow(cell.y)
            }
        });
        var proceed = this.canvas.dispatchEvent(clickEvent);
        return proceed; //I wasn't cancelled
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {Renderer} sub-component
     * @param {Point} cell - The x,y coordinates.
     * @param {Object} oldValue - The old value.
     * @param {Object} newValue - The new value.
     */
    fireAfterCellEdit: function(cell, oldValue, newValue, control) {
        var clickEvent = new CustomEvent('fin-after-cell-edit', {
            detail: {
                newValue: newValue,
                oldValue: oldValue,
                gridCell: cell,
                time: Date.now(),
                input: control,
                row: this.getRow(cell.y)
            }
        });
        this.canvas.dispatchEvent(clickEvent);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Autosize the column at colIndex for best fit.
     * @param {number} colIndex - The column index to modify at
     */
    autosizeColumn: function(activeColumnIndex) {
        var column = this.behavior.getActiveColumn(activeColumnIndex);
        column.checkColumnAutosizing(true);
        this.computeCellsBounds();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Enable/disable if this component can receive the focus.
     * @param {boolean} - canReceiveFocus
     */
    setFocusable: function(canReceiveFocus) {
        this.getCanvas().setFocusable(canReceiveFocus);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {number} The number of columns that were just rendered
     */
    getVisibleColumnsCount: function() {
        return this.getRenderer().getVisibleColumnsCount();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {number} The number of rows that were just rendered
     */
    getVisibleRowsCount: function() {
        return this.getRenderer().getVisibleRowsCount();
    },

    /**
     * @memberOf Hypergrid.prototype
    update the size of the grid
     *
     * #### returns: integer
     */
    updateSize: function() {
        this.canvas.checksize();
    },


    /**
     * @memberOf Hypergrid.prototype
     * @desc Stop the global repainting flag thread.
     */
    stopPaintThread: function() {
        this.canvas.stopPaintThread();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Stop the global resize check flag thread.
     */
    stopResizeThread: function() {
        this.canvas.stopResizeThread();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Restart the global resize check flag thread.
     */
    restartResizeThread: function() {
        this.canvas.restartResizeThread();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Restart the global repainting check flag thread.
     */
    restartPaintThread: function() {
        this.canvas.restartPaintThread();
    },

    swapColumns: function(source, target) {
        //Turns out this is called during dragged 'i.e' when the floater column is reshuffled
        //by the currently dragged column. The column positions are constantly reshuffled
        this.behavior.swapColumns(source, target);
    },

    endDragColumnNotification: function() {
        this.behavior.endDragColumnNotification();
    },

    getFixedColumnsMaxWidth: function() {
        return this.behavior.getFixedColumnsMaxWidth();
    },

    isMouseDownInHeaderArea: function() {
        var headerColumnCount = this.getHeaderColumnCount();
        var headerRowCount = this.getHeaderRowCount();
        var mouseDown = this.getMouseDown();
        return mouseDown.x < headerColumnCount || mouseDown.y < headerRowCount;
    },

    isHeaderWrapping: function() {
        return this.resolveProperty('headerTextWrapping');
    },

    _getBoundsOfCell: function(x, y) {
        return this.getRenderer()._getBoundsOfCell(x, y);
    },

    getColumnProperties: function(columnIndex) {
        return this.behavior.getColumnProperties(columnIndex);
    },

    setColumnProperties: function(columnIndex, properties) {
        this.behavior.setColumnProperties(columnIndex, properties);
    },

    moveSingleSelect: function(x, y) {
        this.behavior.moveSingleSelect(this, x, y);
    },

    selectCell: function(x, y, silent) {
        var dontClearRows = this.isCheckboxOnlyRowSelections();
        this.selectionModel.clear(dontClearRows);
        this.selectionModel.select(x, y, 0, 0, silent);
    },

    getHeaderColumnCount: function() {
        return this.behavior.getHeaderColumnCount();
    },

    toggleSort: function(x, keys) {
        this.stopEditing();
        var behavior = this.behavior;
        var self = this;
        behavior.toggleSort(x, keys);

        setTimeout(function() {
            self.synchronizeScrollingBoundries();
            //self.behaviorChanged();
            if (self.isColumnAutosizing()) {
                behavior.autosizeAllColumns();
            }
            self.repaint();
        }, 10);
    },

    toggleSelectColumn: function(x, keys) {
        keys = keys || [];
        var model = this.selectionModel;
        var alreadySelected = model.isColumnSelected(x);
        var hasCTRL = keys.indexOf('CTRL') > -1;
        var hasSHIFT = keys.indexOf('SHIFT') > -1;
        if (!hasCTRL && !hasSHIFT) {
            model.clear();
            if (!alreadySelected) {
                model.selectColumn(x);
            }
        } else {
            if (hasCTRL) {
                if (alreadySelected) {
                    model.deselectColumn(x);
                } else {
                    model.selectColumn(x);
                }
            }
            if (hasSHIFT) {
                model.clear();
                model.selectColumn(this.lastEdgeSelection[0], x);
            }
        }
        if (!alreadySelected && !hasSHIFT) {
            this.lastEdgeSelection[0] = x;
        }
        this.repaint();
        this.fireSyntheticColumnSelectionChangedEvent();
    },

    toggleSelectRow: function(y, keys) {
        //we can select the totals rows if they exist, but not rows above that
        if (y > this.getFilterRowIndex()) {
            keys = keys || [];

            var sm = this.selectionModel;
            var alreadySelected = sm.isRowSelected(y);
            var hasSHIFT = keys.indexOf('SHIFT') >= 0;

            if (alreadySelected) {
                sm.deselectRow(y);
            } else {
                this.singleSelect();
                sm.selectRow(y);
            }

            if (hasSHIFT) {
                sm.clear();
                sm.selectRow(this.lastEdgeSelection[1], y);
            }

            if (!alreadySelected && !hasSHIFT) {
                this.lastEdgeSelection[1] = y;
            }
            this.repaint();
        }
    },

    singleSelect: function() {
        var isCheckboxOnlyRowSelections = this.isCheckboxOnlyRowSelections(),
            isSingleRowSelectionMode = this.isSingleRowSelectionMode(),
            hasCTRL = false,
            result;

        if (this.mouseDownState){
            //triggered programmatically
            hasCTRL = this.mouseDownState.primitiveEvent.detail.primitiveEvent.ctrlKey;
        }

        result = (
            isCheckboxOnlyRowSelections && isSingleRowSelectionMode ||
            !isCheckboxOnlyRowSelections && (!hasCTRL || isSingleRowSelectionMode)
        );

        if (result) {
            this.selectionModel.clearRowSelection();
        }

        return result;
    },

    selectViewportCell: function(x, y) {
        var headerRowCount = this.getHeaderRowCount();
        var renderer = this.getRenderer();
        var realX = renderer.getVisibleColumns()[x];
        var realY = renderer.getVisibleRows()[y];
        this.clearSelections();
        this.select(realX, realY + headerRowCount, 0, 0);
        this.setMouseDown(this.newPoint(realX, realY + headerRowCount));
        this.setDragExtent(this.newPoint(0, 0));
        this.repaint();
    },

    selectToViewportCell: function(x, y) {
        var selections = this.getSelections();
        if (selections && selections.length) {
            var headerRowCount = this.getHeaderRowCount();
            var renderer = this.getRenderer();
            var realX = renderer.getVisibleColumns()[x];
            var realY = renderer.getVisibleRows()[y] + headerRowCount;
            var selection = selections[0];
            var origin = selection.origin;
            this.setDragExtent(this.newPoint(realX - origin.x, realY - origin.y));
            this.select(origin.x, origin.y, realX - origin.x, realY - origin.y);
            this.repaint();
        }
    },

    selectFinalCellOfCurrentRow: function() {
        var x = this.getColumnCount() - 1;
        var y = this.getSelectedRows()[0];
        var headerRowCount = this.getHeaderRowCount();
        this.clearSelections();
        this.scrollBy(this.getColumnCount(), 0);
        this.select(x, y + headerRowCount, 0, 0);
        this.setMouseDown(this.newPoint(x, y + headerRowCount));
        this.setDragExtent(this.newPoint(0, 0));
        this.repaint();
    },

    selectToFinalCellOfCurrentRow: function() {
        var selections = this.getSelections();
        if (selections && selections.length) {
            var selection = selections[0];
            var origin = selection.origin;
            var extent = selection.extent;
            var columnCount = this.getColumnCount();
            this.scrollBy(columnCount, 0);

            this.clearSelections();
            this.select(origin.x, origin.y, columnCount - origin.x - 1, extent.y);

            this.repaint();
        }
    },

    selectFirstCellOfCurrentRow: function() {
        var x = 0;
        var y = this.getSelectedRows()[0];
        var headerRowCount = this.getHeaderRowCount();
        this.clearSelections();
        this.setHScrollValue(0);
        this.select(x, y + headerRowCount, 0, 0);
        this.setMouseDown(this.newPoint(x, y + headerRowCount));
        this.setDragExtent(this.newPoint(0, 0));
        this.repaint();
    },

    selectToFirstCellOfCurrentRow: function() {
        var selections = this.getSelections();
        if (selections && selections.length) {
            var selection = selections[0];
            var origin = selection.origin;
            var extent = selection.extent;
            this.clearSelections();
            this.select(origin.x, origin.y, -origin.x, extent.y);
            this.setHScrollValue(0);
            this.repaint();
        }
    },

    selectFinalCell: function() {
        this.selectCell(this.getColumnCount() - 1, this.getRowCount() - 1);
        this.scrollBy(this.getColumnCount(), this.getRowCount());
        this.repaint();
    },

    selectToFinalCell: function() {
        var selections = this.getSelections();
        if (selections && selections.length) {
            var selection = selections[0];
            var origin = selection.origin;
            var columnCount = this.getColumnCount();
            var rowCount = this.getRowCount();

            this.clearSelections();
            this.select(origin.x, origin.y, columnCount - origin.x - 1, rowCount - origin.y - 1);
            this.scrollBy(columnCount, rowCount);
            this.repaint();
        }
    },

    isShowRowNumbers: function() {
        return this.resolveProperty('showRowNumbers');
    },
    isEditable: function() {
        return this.resolveProperty('editable') === true;
    },
    isShowFilterRow: function() {
        return this.resolveProperty('showFilterRow');
    },
    isShowHeaderRow: function() {
        return this.resolveProperty('showHeaderRow');
    },
    getHeaderRowCount: function() {
        return this.behavior.getHeaderRowCount();
    },
    isFilterRow: function(y) {
        return y === this.getFilterRowIndex();
    },
    getFilterRowIndex: function() {
        return !this.isShowFilterRow() ? -1 : this.isShowHeaderRow() ? 1 : 0;
    },
    setGroups: function(arrayOfColumnIndexes) {
        this.behavior.setGroups(arrayOfColumnIndexes);
    },
    hasHierarchyColumn: function() {
        return this.behavior.hasHierarchyColumn();
    },
    isHierarchyColumn: function(x) {
        return this.hasHierarchyColumn() && x === 0;
    },
    checkScrollbarVisibility: function() {
        // var hoverClassOver = this.resolveProperty('scrollbarHoverOver');
        // var hoverClassOff = this.resolveProperty('scrollbarHoverOff');

        // if (hoverClassOff === 'visible') {
        //     this.sbHScroller.classList.remove(hoverClassOver);
        //     this.sbVScroller.classList.remove(hoverClassOff);
        //     this.sbHScroller.classList.add('visible');
        //     this.sbVScroller.classList.add('visible');
        // }
    },
    isColumnOrRowSelected: function() {
        return this.selectionModel.isColumnOrRowSelected();
    },
    selectColumn: function(x1, x2) {
        this.selectionModel.selectColumn(x1, x2);
    },
    selectRow: function(y1, y2) {
        var sm = this.selectionModel;
        var selectionEdge = this.getFilterRowIndex() + 1;

        if (this.singleSelect()) {
            y1 = y2;
        } else {
            // multiple row selection
            y2 = y2 || y1;
        }
        var min = Math.min(y1, y2);
        if (min >= selectionEdge) {
            var max = Math.max(y1, y2);
            sm.selectRow(min, max);
        }
    },
    isRowNumberAutosizing: function() {
        return this.resolveProperty('rowNumberAutosizing');
    },
    isRowSelected: function(r) {
        return this.selectionModel.isRowSelected(r);
    },
    isColumnSelected: function(c) {
        return this.selectionModel.isColumnSelected(c);
    },
    lookupFeature: function(key) {
        return this.behavior.lookupFeature(key);
    },
    getRow: function(y) {
        return this.behavior.getRow(y);
    },
    isCellSelection: function() {
        return this.resolveProperty('cellSelection') === true;
    },
    isRowSelection: function() {
        return this.resolveProperty('rowSelection') === true;
    },
    isColumnSelection: function() {
        return this.resolveProperty('columnSelection') === true;
    },
    getComputedRow: function(y) {
        return this.behavior.getComputedRow(y);
    },
    isColumnAutosizing: function() {
        return this.resolveProperty('columnAutosizing') === true;
    },

    /**
     * @summary Get a reference to the filter attached to the Hypergrid.
     * @returns {FilterTree}
     * @memberOf Hypergrid.prototype
     */
    getGlobalFilter: function() {
        return this.behavior.getGlobalFilter();
    },

    /**
     * @summary Attach/detach a filter to a Hypergrid.
     * @param {FilterTree} [filter] - The filter object. If undefined, any attached filter is removed.
     * @memberOf Hypergrid.prototype
     */
    setGlobalFilter: function(filter) {
        this.behavior.setGlobalFilter(filter);
        this.behaviorChanged();
    },

    /**
     * @summary Set the case sensitivity of filter tests against data.
     * @desc Case sensitivity pertains to string compares only. This includes untyped columns, columns typed as strings, typed columns containing data that cannot be coerced to type or when the filter expression operand cannot be coerced.
     *
     * NOTE: This is a shared property and affects all grid managed by this instance of the app.
     * @param {boolean} isSensitive
     * @memberOf Hypergrid.prototype
     */
    setGlobalFilterCaseSensitivity: function(isSensitive) {
        // this setting affects all grids
        this.behavior.setGlobalFilterCaseSensitivity(isSensitive);
        this.computeCellsBounds();
        this.behaviorChanged();
    },

    /**
     * @param {number|string} columnIndexOrName - The _column filter_ to set.
     * @param {FilterTreeGetStateOptionsObject} [options] - Passed to the filter's {@link DefaultFilter#getState|getState} method.
     * @param {boolean} [options.syntax='CQL'] - The syntax to use to describe the filter state. Note that `getFilter`'s default syntax, `'CQL'`, differs from the other get state methods.
     * @returns {FilterTreeStateObject}
     * @memberOf Hypergrid.prototype
     */
    getFilter: function(columnIndexOrName, options) {
        return this.behavior.getFilter(columnIndexOrName, options);
    },

    /**
     * @summary Set a particular column filter's state.
     * @desc After setting the new filter state:
     * * Reapplies the filter to the data source.
     * * Calls `behaviorChanged()` to update the grid canvas.
     * @param {number|string} columnIndexOrName - The _column filter_ to set.
     * @param {string|object} [state] - A filter tree object or a JSON, SQL, or CQL subexpression string that describes the a new state for the named column filter. The existing column filter subexpression is replaced with a new node based on this state. If it does not exist, the new subexpression is added to the column filters subtree (`filter.columnFilters`).
     *
     * If undefined, removes the entire column filter subexpression from the column filters subtree.
     * @param {FilterTreeSetStateOptionsObject} [options] - Passed to the filter's [setState]{@link http://joneit.github.io/filter-tree/FilterTree.html#setState} method. You may mix in members of the {@link http://joneit.github.io/filter-tree/global.html#FilterTreeValidationOptionsObject|FilterTreeValidationOptionsObject}
     * @param {string} [options.syntax='CQL'] - The syntax to use to describe the filter state. Note that `setFilter`'s default syntax, `'CQL'`, differs from the other get state methods.
     * @returns {undefined|Error|string} `undefined` indicates success.
     * @memberOf Hypergrid.prototype
     */
    setFilter: function(columnIndexOrName, state, options) {
        if (this.cellEditor) {
            this.cellEditor.hideEditor();
        }
        this.behavior.setFilter(columnIndexOrName, state, options);
        this.behaviorChanged();
    },

    /**
     * @param {FilterTreeGetStateOptionsObject} [options] - Passed to the filter's {@link DefaultFilter#getState|getState} method.
     * @returns {FilterTreeStateObject}
     * @memberOf Hypergrid.prototype
     */
    getFilters: function(options) {
        return this.behavior.getFilters(options);
    },

    /**
     * @param {FilterTreeStateObject} state
     * @param {FilterTreeSetStateOptionsObject} [options] - Passed to the filter's [setState]{@link http://joneit.github.io/filter-tree/FilterTree.html#setState} method. You may mix in members of the {@link http://joneit.github.io/filter-tree/global.html#FilterTreeValidationOptionsObject|FilterTreeValidationOptionsObject}
     * @returns {undefined|Error|string} `undefined` indicates success.
     * @memberOf Hypergrid.prototype
     */
    setFilters: function(state, options) {
        if (this.cellEditor) {
            this.cellEditor.hideEditor();
        }
        this.behavior.setFilters(state, options);
        this.behaviorChanged();
    },

    /**
     * @param {FilterTreeGetStateOptionsObject} [options] - Passed to the filter's {@link DefaultFilter#getState|getState} method.
     * @returns {FilterTreeStateObject}
     * @memberOf Hypergrid.prototype
     */
    getTableFilter: function(options) {
        return this.behavior.getTableFilter(options);
    },

    /**
     * @param {FilterTreeStateObject} state
     * @param {FilterTreeSetStateOptionsObject} [options] - Passed to the filter's [setState]{@link http://joneit.github.io/filter-tree/FilterTree.html#setState} method. You may mix in members of the {@link http://joneit.github.io/filter-tree/global.html#FilterTreeValidationOptionsObject|FilterTreeValidationOptionsObject}
     * @returns {undefined|Error|string} `undefined` indicates success.
     * @memberOf Hypergrid.prototype
     */
    setTableFilter: function(state, options) {
        this.behavior.setTableFilter(state, options);
        this.behaviorChanged();
    },

    selectRowsFromCells: function() {
        if (!this.isCheckboxOnlyRowSelections()) {
            var last,
                hasCTRL = this.mouseDownState.primitiveEvent.detail.primitiveEvent.ctrlKey;

            if (hasCTRL && !this.isSingleRowSelectionMode()) {
                this.selectionModel.selectRowsFromCells(0, hasCTRL);
            } else if ((last = this.selectionModel.getLastSelection())) {
                this.selectRow(null, last.corner.y);
            } else {
                this.clearRowSelection();
            }
        }
    },
    selectColumnsFromCells: function() {
        this.selectionModel.selectColumnsFromCells();
    },
    getSelectedRows: function() {
        return this.behavior.getSelectedRows();
    },
    getSelectedColumns: function() {
        return this.behavior.getSelectedColumns();
    },
    getSelections: function() {
        return this.behavior.getSelections();
    },
    getLastSelectionType: function() {
        return this.selectionModel.getLastSelectionType();
    },
    isCellSelected: function(x, y) {
        return this.selectionModel.isCellSelected(x, y);
    },
    isInCurrentSelectionRectangle: function(x, y) {
        return this.selectionModel.isInCurrentSelectionRectangle(x, y);
    },
    selectAllRows: function() {
        this.selectionModel.selectAllRows();
    },
    areAllRowsSelected: function() {
        return this.selectionModel.areAllRowsSelected();
    },
    toggleSelectAllRows: function() {
        if (this.areAllRowsSelected()) {
            this.selectionModel.clear();
        } else {
            this.selectAllRows();
        }
        this.repaint();
    },
    isSingleRowSelectionMode: function() {
        return this.resolveProperty('singleRowSelectionMode');
    },
    newPoint: function(x, y) {
        return new Point(x, y);
    },
    newRectangle: function(x, y, width, height) {
        return new Rectangle(x, y, width, height);
    },
    getFormattedValue: function(x, y) {
        return this.formatValue(
            this.getColumnProperties(x).format,
            this.getValue(x, y + this.getHeaderRowCount())
        );
    },

    /**
     * @summary Sticky hash of dialog options objects.
     * @desc Each key is a dialog name; the value is the options object for that dialog.
     * The default dialog options object has the key `'undefined'`, which is undefined by default; it is set by calling `setDialogOptions` with no `dialogName` parameter.
     * @private
     */
    dialogOptions: {},

    /**
     * @summary Set and/or return a specific dialog options object *or* a default dialog options object.
     *
     * @desc If `options` defined:
     * * If `dialogName` defined: Save the specific dialog's options object.
     * * If `dialogName` undefined: Save the default dialog options object.
     *
     * If `options` is _not_ defined, no new dialog options object will be saved; but a previously saved preset will be returned (after mixing in the default preset if there is one).
     *
     * The default dialog options object is used in two ways:
     * * when a dialog has no options object
     * * as a mix-in base when a dialog does have an options object
     *
     * @param {string} [dialogName] If undefined, `options` defines the default dialog options object.
     *
     * @param {object} [options] If defined, preset the named dialog options object or the default dialog options object if name is undefined.
     *
     * @returns {object} One of:
     * * When `options` undefined, first of:
     *   * previous preset
     *   * default preset
     *   * empty object
     * * When `options` defined, first of:
     *   * mix-in: default preset members + `options` members
     *   * `options` verbatim when default preset undefined
     */
    setDialogOptions: function(dialogName, options) {
        if (typeof dialogName === 'object') {
            options = dialogName;
            dialogName = undefined;
        }
        var defaultOptions = this.dialogOptions.undefined;
        options = options || dialogName && this.dialogOptions[dialogName];
        if (options) {
            this.dialogOptions[dialogName] = options;
            if (defaultOptions) {
                options = _({}).extend(defaultOptions, options); // make a mix-in
            }
        } else {
            options = defaultOptions || {};
        }
        return options;
    },

    /**
     * Options objects are remembered for subsequent use. Alternatively, they can be preset by calling {@link Hypergrid#setDialogOptions|setDialogOptions}.
     * @param {string} dialogName
     * @param {object} [options] - If omitted, use the options object previously given here (or to {@link Hypergrid#setDialogOptions|setDialogOptions}), if any. In any case, the resultant options object, if any, is mixed into the default options object, if there is one.
     */
    openDialog: function(dialogName, options) {
        this.stopEditing();
        options = this.setDialogOptions(dialogName, options);
        options.terminate = function() { // when about-to-be-opened dialog is eventually closed
            delete this.dialog;
        }.bind(this);
        this.dialog = this.behavior.openDialog(dialogName, options);
    },

    // although you can have multiple dialogs open at the same time, the following enforces one at a time (for now)
    toggleDialog: function(newDialogName, options) {
        var dialog = this.dialog,
            oldDialogName = dialog && dialog.$$CLASS_NAME;
        if (!dialog || !this.dialog.close() && oldDialogName !== newDialogName) {
            if (!dialog) {
                // open new dialog now
                this.openDialog(newDialogName, options);
            } else {
                // open new dialog when already-opened dialog finishes closing due to .closeDialog() above
                dialog.terminate = this.openDialog.bind(this, newDialogName, options);
            }
        }
    },

    /**
     * @returns {string} One of:
     * * `'active'` - There is at least one defined filter (leaf node) in the filter tree.
     * * `'inactive'` - There are no defined filters (no leaf nodes) in the filter tree.
     * * `'error'` - There is at least one partially defined filter.
     */
    getFilterStatus: function() {
        var filter = this.getGlobalFilter(),
            result;

        if (filter.invalid()) {
            result = 'error';
        } else if (filter.filterCount()) {
            result = 'active';
        } else {
            result = 'inactive';
        }

        return result;
    },
};

/**
 * @summary Update deep properties with new values.
 * @desc This function is a recursive property setter which updates a deep property in a destination object with the value of a congruent property in a source object.
 *
 * > Terminology: A deep property is a "terminal node" (primitive value) nested at some depth (i.e., depth > 1) inside a complex object (an object containing nested objects). A congruent property is a property in another object with the same name and at the same level of nesting.
 *
 * This function is simple and elegant. I recommend you study the code, which nonetheless implies all of the following:
 *
 * * If the deep property is _not_ found in `destination`, it will be created.
 * * If the deep property is found in `destination` _and_ is a primitive type, it will be modified (overwritten with the value from `source`).
 * * If the deep property is found in `destination` _but_ is not a primitive type (i.e., is a nested object), it will _also_ be overwritten with the (primitive) value from `source`.
 * * If the nested object the deep property inhabits in `source` is not found in `destination`, it will be created.
 * * If the nested object the deep property inhabits in `source` is found in `destination` but is not in fact an object (i.e., it is a primitive value), it will be overwritten with a reference to that object.
 * * If the primitive value is `undefined`, the destination property is deleted.
 * * `source` may contain multiple properties to update.
 *
 * That one rule is simply this: If both the source _and_ the destination properties are objects, then recurse; else overwrite the destination property with the source property.
 *
 * > Caveat: This is _not_ equivalent to a deep extend function. While both a deep extend and this function will recurse over a complex object, they are fundamentally different: A deep extend clones the nested objects as it finds them; this function merely updates them (or creates them where they don't exist).
 *
 * @param {object} destination - An object to update with new or modified property values
 * @param {object} source - A congruent object continaly (only) the new or modified property values.
 * @returns {object} Always returns `destination`.
 */
function addDeepProperties(destination, source) {
    _(source).each(function(property, key) {
        if (typeof destination[key] === 'object' && typeof property === 'object') {
            addDeepProperties(destination[key], property);
        } else if (property === undefined) {
            delete destination[key];
        } else {
            destination[key] = property;
        }
    });
    return destination;
}

function normalizeRect(rect) {
    var o = rect.origin;
    var c = rect.corner;

    var ox = Math.min(o.x, c.x);
    var oy = Math.min(o.y, c.y);

    var cx = Math.max(o.x, c.x);
    var cy = Math.max(o.y, c.y);

    var result = new Rectangle(ox, oy, cx - ox, cy - oy);

    return result;
}

function buildPolymerTheme() {
    clearObjectProperties(polymerTheme);
    var pb = document.createElement('paper-button');

    pb.style.display = 'none';
    pb.setAttribute('disabled', true);
    document.body.appendChild(pb);
    var p = window.getComputedStyle(pb);

    var section = document.createElement('section');
    section.style.display = 'none';
    section.setAttribute('hero', true);
    document.body.appendChild(section);

    var h = window.getComputedStyle(document.querySelector('html'));
    var hb = window.getComputedStyle(document.querySelector('html, body'));
    var s = window.getComputedStyle(section);

    polymerTheme.columnHeaderBackgroundColor = p.color;
    polymerTheme.rowHeaderBackgroundColor = p.color;
    polymerTheme.topLeftBackgroundColor = p.color;
    polymerTheme.lineColor = p.backgroundColor;

    polymerTheme.backgroundColor2 = hb.backgroundColor;

    polymerTheme.color = h.color;
    polymerTheme.fontFamily = h.fontFamily;
    polymerTheme.backgroundColor = s.backgroundColor;

    pb.setAttribute('disabled', false);
    pb.setAttribute('secondary', true);
    pb.setAttribute('raised', true);
    p = window.getComputedStyle(pb);

    polymerTheme.columnHeaderColor = p.color;
    polymerTheme.rowHeaderColor = p.color;
    polymerTheme.topLeftColor = p.color;


    polymerTheme.backgroundSelectionColor = p.backgroundColor;
    polymerTheme.foregroundSelectionColor = p.color;

    pb.setAttribute('secondary', false);
    pb.setAttribute('warning', true);

    polymerTheme.columnHeaderForegroundSelectionColor = p.color;
    polymerTheme.columnHeaderBackgroundSelectionColor = p.backgroundColor;
    polymerTheme.rowHeaderForegroundSelectionColor = p.color;
    polymerTheme.fixedColumnBackgroundSelectionColor = p.backgroundColor;

    //check if there is actually a theme loaded if not, clear out all bogus values
    //from my cache
    if (polymerTheme.columnHeaderBackgroundSelectionColor === 'rgba(0, 0, 0, 0)' ||
        polymerTheme.lineColor === 'transparent') {
        clearObjectProperties(polymerTheme);
    }

    document.body.removeChild(pb);
    document.body.removeChild(section);
}

function clearObjectProperties(obj) {
    for (var prop in obj) {
        if (obj.hasOwnProperty(prop)) {
            delete obj[prop];
        }
    }
}

function valOrFunc(dataRow, columnName) {
    var vf = dataRow[columnName],
        result = (typeof vf)[0] === 'f' ? vf(dataRow, columnName) : vf;
    return result || result === 0 || result === false ? result : '';
}

/**
 * @summary Shared localization defaults for all grid instances.
 * @desc These property values are overridden by those supplied in the `Hypergrid` constructor's `options.localization`.
 * @property {string|string[]} [options.localization.defaultLocale] - The default locale to use when an explicit `locale` is omitted from localizer constructor calls. Passed to Intl.NumberFormat` and `Intl.DateFormat`. See {@ https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl#Locale_identification_and_negotiation|Locale identification and negotiation} for more information. Omitting will use the runtime's local language and region.
 * @property {object} [options.localization.numberOptions] - Options passed to `Intl.NumberFormat` for creating the basic "number" localizer.
 * @property {object} [options.localization.dateOptions] - Options passed to `Intl.DateFormat` for creating the basic "date" localizer.
 */

Hypergrid.localization = {
    locale: 'en-US',
    numberOptions: { maximumFractionDigits: 0 }
};

module.exports = Hypergrid;

},{"./behaviors":61,"./cellEditors":71,"./cellRenderers":81,"./defaults":87,"./lib/Localization":114,"./lib/Renderer":115,"./lib/SelectionModel":116,"./lib/deprecated":118,"./lib/polyfills":122,"./lib/stylesheet":124,"finbars":19,"fincanvas":20,"object-iterators":46,"rectangular":48}],55:[function(require,module,exports){
/* eslint-env browser */

'use strict';

// Only 1 choice from each block below should be exposed (uncommented):

module.exports = {

	analytics: require('hyper-analytics'), // npm
    //analytics: require('../../hyper-analytics/src'), // developers

    FilterTree: require('filter-tree'), // npm
    //FilterTree: require('../../filter-tree'), // developers

};

},{"filter-tree":9,"hyper-analytics":25}],56:[function(require,module,exports){
/* eslint-env browser */
'use strict';

var _ = require('object-iterators');
var Base = require('../lib/Base');

var Column = require('./Column');
var dialogs = require('../dialogs');
var DefaultFilter = require('../filter/DefaultFilter');

var noExportProperties = [
    'columnHeader',
    'columnHeaderColumnSelection',
    'filterProperties',
    'rowHeader',
    'rowHeaderRowSelection',
    'rowNumbersProperties',
    'treeColumnProperties',
    'treeColumnPropertiesColumnSelection',
];

var isNull = {
    isNull: true
};

/**
 * @constructor
 * @abstract
 * @desc A sort of "model++." It contains all code/data that's necessary for easily implementing a virtual data source and its manipulation/analytics.
 *
 */
var Behavior = Base.extend('Behavior', {

    /**
     * @desc this is the callback for the plugin pattern of nested tags
     * @param {Hypergrid} grid
     * @param {function|menuItem[]} [schema=derivedSchema] - Passed to behavior constructor. May be:
     * * A schema array
     * * A function returning a schema array. Called at filter reset time with behavior as context.
     * * Omit to generate a basic schema from `this.columns`.
     * @memberOf Behavior.prototype
     */
    initialize: function(grid, schema, dataRows) {
        /**
         * @type {Hypergrid}
         * @memberOf Behavior.prototype
         */
        this.grid = grid;

        /**
         * @type {DataModel}
         * @memberOf Behavior.prototype
         */
        this.dataModel = this.getNewDataModel();

        grid.setBehavior(this);

        this.reset();

        this.initializeFeatureChain(grid);
    },

    /**
     * @desc create the feature chain - this is the [chain of responsibility](http://c2.com/cgi/wiki?ChainOfResponsibilityPattern) pattern.
     * @param {Hypergrid} grid
     * @memberOf Behavior.prototype
     */
    initializeFeatureChain: function(grid) {
        var self = this;

        /**
         * @summary Hash of feature class names.
         * @desc Built here but otherwise not in use.
         * @type {object}
         * @memberOf Behavior.prototype
         */
        this.featureMap = {};

        this.features.forEach(function(FeatureConstructor) {
            var newFeature = new FeatureConstructor;
            self.featureMap[newFeature.$$CLASS_NAME] = newFeature;
            if (self.featureChain) {
                self.featureChain.setNext(newFeature);
            } else {
                /**
                 * @summary Controller chain of command.
                 * @desc Each feature is linked to the next feature.
                 * @type {Feature}
                 * @memberOf Behavior.prototype
                 */
                self.featureChain = newFeature;
            }
        });
        if (this.featureChain) {
            this.featureChain.initializeOn(grid);
        }
    },

    features: [], // override in implementing class unless no features

    reset: function() {
        this.renderedColumnCount = 30;
        this.renderedRowCount = 60;
        this.dataUpdates = {}; //for overriding with edit values;
        this.scrollPositionX = this.scrollPositionY = 0;
        this.clearColumns();
        this.clearState();
        this.dataModel.reset();
        this.createColumns();
    },

    clearColumns: function() {
        /**
         * @type {Column[]}
         * @memberOf Behavior.prototype
         */
        this.columns = [];

        /**
         * @type {Column[]}
         * @memberOf Behavior.prototype
         */
        this.allColumns = [];

        this.allColumns[-1] = this.columns[-1] = this.newColumn(-1);
        this.allColumns[-2] = this.columns[-2] = this.newColumn(-2);

        this.columnEnum = {};
    },

    getActiveColumn: function(x) {
        return this.columns[x];
    },
    getVisibleColumn: function() {
        return this.deprecated('getVisibleColumn(x)', 'getActiveColumn(x)', '1.0.6', arguments);
    },
    getVisibleColumnName: function() {
        return this.deprecated('getVisibleColumnName(x)', 'getActiveColumn(x).name', '1.0.6', arguments);
    },
    getColumnId: function() {
        return this.deprecated('getColumnId(x)', 'getActiveColumn(x).header', '1.0.6', arguments);
    },
    getHeader: function() {
        return this.deprecated('getHeader(x)', 'getActiveColumn(x).header', '1.0.6', arguments);
    },

    getColumn: function(x) {
        return this.allColumns[x];
    },

    newColumn: function(options) {
        var column = new Column(this, options);
        this.getPrivateState().columnProperties[column.index] = this.createColumnProperties();
        return column;
    },

    addColumn: function(options) {
        var column = this.newColumn(options);
        this.columns.push(column);
        this.allColumns.push(column);
        return column;
    },

    createColumns: function() {
        //concrete implementation here
    },

    createColumnProperties: function() {
        var tableState = this.getPrivateState();
        var properties = Object.create(tableState);

        properties.rowNumbersProperties = Object.create(properties, {
            foregroundSelectionColor: {
                configurable: true,
                get: function() {
                    return this.columnHeaderForegroundSelectionColor;
                },
                set: function(value) {
                    this.columnHeaderForegroundSelectionColor = value;
                }
            },
            backgroundSelectionColor: {
                configurable: true,
                get: function() {
                    return this.columnHeaderBackgroundSelectionColor;
                },
                set: function(value) {
                    this.columnHeaderBackgroundSelectionColor = value;
                }
            }
        });

        properties.rowHeader = Object.create(properties, {
            font: {
                configurable: true,
                get: function() {
                    return this.rowHeaderFont;
                },
                set: function(value) {
                    this.rowHeaderFont = value;
                }
            },
            color: {
                configurable: true,
                get: function() {
                    return this.rowHeaderColor;
                },
                set: function(value) {
                    this.rowHeaderColor = value;
                }
            },
            backgroundColor: {
                configurable: true,
                get: function() {
                    return this.rowHeaderBackgroundColor;
                },
                set: function(value) {
                    this.rowHeaderBackgroundColor = value;
                }
            },
            foregroundSelectionFont: {
                configurable: true,
                get: function() {
                    return this.rowHeaderForegroundSelectionFont;
                },
                set: function(value) {
                    this.rowHeaderForegroundSelectionFont = value;
                }
            },
            foregroundSelectionColor: {
                configurable: true,
                get: function() {
                    return this.rowHeaderForegroundSelectionColor;
                },
                set: function(value) {
                    this.rowHeaderForegroundSelectionColor = value;
                }
            },
            backgroundSelectionColor: {
                configurable: true,
                get: function() {
                    return this.rowHeaderBackgroundSelectionColor;
                },
                set: function(value) {
                    this.rowHeaderBackgroundSelectionColor = value;
                }
            }
        });

        properties.columnHeader = Object.create(properties, {
            font: {
                configurable: true,
                get: function() {
                    return this.columnHeaderFont;
                },
                set: function(value) {
                    this.columnHeaderFont = value;
                }
            },
            color: {
                configurable: true,
                get: function() {
                    return this.columnHeaderColor;
                },
                set: function(value) {
                    this.columnHeaderColor = value;
                }
            },
            backgroundColor: {
                configurable: true,
                get: function() {
                    return this.columnHeaderBackgroundColor;
                },
                set: function(value) {
                    this.columnHeaderBackgroundColor = value;
                }
            },
            foregroundSelectionFont: {
                configurable: true,
                get: function() {
                    return this.columnHeaderForegroundSelectionFont;
                },
                set: function(value) {
                    this.columnHeaderForegroundSelectionFont = value;
                }
            },
            foregroundSelectionColor: {
                configurable: true,
                get: function() {
                    return this.columnHeaderForegroundSelectionColor;
                },
                set: function(value) {
                    this.columnHeaderForegroundSelectionColor = value;
                }
            },
            backgroundSelectionColor: {
                configurable: true,
                get: function() {
                    return this.columnHeaderBackgroundSelectionColor;
                },
                set: function(value) {
                    this.columnHeaderBackgroundSelectionColor = value;
                }
            }
        });

        properties.columnHeaderColumnSelection = Object.create(properties.columnHeader, {
            foregroundSelectionColor: {
                configurable: true,
                get: function() {
                    return this.columnHeaderForegroundColumnSelectionColor;
                },
                set: function(value) {
                    this.columnHeaderForegroundColumnSelectionColor = value;
                }
            },
            backgroundSelectionColor: {
                configurable: true,
                get: function() {
                    return this.columnHeaderBackgroundColumnSelectionColor;
                },
                set: function(value) {
                    this.columnHeaderBackgroundColumnSelectionColor = value;
                }
            }
        });

        properties.rowHeaderRowSelection = Object.create(properties.rowHeader, {
            foregroundSelectionColor: {
                configurable: true,
                get: function() {
                    return this.rowHeaderForegroundRowSelectionColor;
                },
                set: function(value) {
                    this.rowHeaderForegroundRowSelectionColor = value;
                }
            },
            backgroundSelectionColor: {
                configurable: true,
                get: function() {
                    return this.rowHeaderBackgroundRowSelectionColor;
                },
                set: function(value) {
                    this.rowHeaderBackgroundRowSelectionColor = value;
                }
            }
        });

        properties.filterProperties = Object.create(properties, {
            font: {
                configurable: true,
                get: function() {
                    return this.filterFont;
                },
                set: function(value) {
                    this.filterFont = value;
                }
            },
            color: {
                configurable: true,
                get: function() {
                    return this.filterColor;
                },
                set: function(value) {
                    this.filterColor = value;
                }
            },
            backgroundColor: {
                configurable: true,
                get: function() {
                    return this.filterBackgroundColor;
                },
                set: function(value) {
                    this.filterBackgroundColor = value;
                }
            },
            foregroundSelectionColor: {
                configurable: true,
                get: function() {
                    return this.filterForegroundSelectionColor;
                },
                set: function(value) {
                    this.filterForegroundSelectionColor = value;
                }
            },
            backgroundSelectionColor: {
                configurable: true,
                get: function() {
                    return this.filterBackgroundSelectionColor;
                },
                set: function(value) {
                    this.filterBackgroundSelectionColor = value;
                }
            },
            cellBorderStyle: {
                configurable: true,
                get: function() {
                    return this.filterCellBorderStyle;
                },
                set: function(value) {
                    this.filterCellBorderStyle = value;
                }
            },
            cellBorderThickness: {
                configurable: true,
                get: function() {
                    return this.filterCellBorderThickness;
                },
                set: function(value) {
                    this.filterCellBorderThickness = value;
                }
            }
        });

        properties.treeColumnProperties = Object.create(properties, {
            font: {
                configurable: true,
                get: function() {
                    return this.treeColumnFont;
                },
                set: function(value) {
                    this.treeColumnFont = value;
                }
            },
            color: {
                configurable: true,
                get: function() {
                    return this.treeColumnColor;
                },
                set: function(value) {
                    this.treeColumnColor = value;
                }
            },
            backgroundColor: {
                configurable: true,
                get: function() {
                    return this.treeColumnBackgroundColor;
                },
                set: function(value) {
                    this.treeColumnBackgroundColor = value;
                }
            },
            foregroundSelectionColor: {
                configurable: true,
                get: function() {
                    return this.treeColumnForegroundSelectionColor;
                },
                set: function(value) {
                    this.treeColumnForegroundSelectionColor = value;
                }
            },
            backgroundSelectionColor: {
                configurable: true,
                get: function() {
                    return this.treeColumnBackgroundSelectionColor;
                },
                set: function(value) {
                    this.treeColumnBackgroundSelectionColor = value;
                }
            }
        });

        properties.treeColumnPropertiesColumnSelection = Object.create(properties.treeColumnProperties, {
            foregroundSelectionColor: {
                configurable: true,
                get: function() {
                    return this.treeColumnForegroundColumnSelectionColor;
                },
                set: function(value) {
                    this.treeColumnForegroundColumnSelectionColor = value;
                }
            },
            backgroundSelectionColor: {
                configurable: true,
                get: function() {
                    return this.treeColumnBackgroundColumnSelectionColor;
                },
                set: function(value) {
                    this.treeColumnBackgroundColumnSelectionColor = value;
                }
            }
        });

        return properties;
    },

    getColumnWidth: function(x) {
        var column = this.getActiveColumn(x);
        if (!column) {
            return this.resolveProperty('defaultColumnWidth');
        }
        var width = column.getWidth();
        return width;
    },

    setColumnWidth: function(x, width) {
        this.getActiveColumn(x).setWidth(width);
        this.stateChanged();
    },

    getCellRenderer: function(config, x, y) {
        return this.getActiveColumn(x).getCellRenderer(config, x, y);
    },
    getCellProvider: function(name) {
        return this.deprecated('getCellProvider()', 'grid.cellRenderers', '1.0.6', arguments);
    },
    createCellProvider: function(name) {
        console.error('getCellProvider() is deprecated as of v1.0.6. No replacement; do not call. Previously called by `Behavior` constructor; `new CellRenderers()` is now called by `Hypergrid` constructor instead.', arguments);
    },

    applyAnalytics: function() {
        this.dataModel.applyAnalytics();
    },

    /**
     * @memberOf Behavior.prototype
     * @desc utility function to empty an object of its members
     * @param {object} obj - the object to empty
     * @param {boolean} [exportProps]
     * * `undefined` (omitted) - delete *all* properties
     * * **falsy** - delete *only* the export properties
     * * **truthy** - delete all properties *except* the export properties
     */
    clearObjectProperties: function(obj, exportProps) {
        for (var key in obj) {
            if (
                obj.hasOwnProperty(key) && (
                    exportProps === undefined ||
                    !exportProps && noExportProperties.indexOf(key) >= 0 ||
                    exportProps && noExportProperties.indexOf(key) < 0
                )
            ) {
                delete obj[key];
            }
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @desc getter for a [Memento](http://c2.com/cgi/wiki?MementoPattern) Object
     * @returns {object}
     */
    getPrivateState: function() {
        if (!this.tableState) {
            this.tableState = this.getDefaultState();
        }
        return this.tableState;
    },

    //this is effectively a clone, with certain things removed....
    getState: function() {
        var copy = JSON.parse(JSON.stringify(this.getPrivateState()));
        this.clearObjectProperties(copy.columnProperties, false);
        return copy;
    },
    /**
     * @memberOf Behavior.prototype
     * @desc clear all table state
     */
    clearState: function() {
        /**
         * memento for the user configured visual properties of the table
         * @type {object}
         * @memberOf Behavior.prototype
         */
        this.tableState = null;
    },

    /**
     * @memberOf Behavior.prototype
     * @return {object} Newly created default empty tablestate.
     */
    getDefaultState: function() {
        var tableProperties = this.grid._getProperties();
        var state = Object.create(tableProperties);

        _(state).extendOwn({
            rowHeights: {},
            columnProperties: []
        });

        return state;
    },

    /**
     * @memberOf Behavior.prototype
     * @desc Restore this table to a previous state.
     * See the [memento pattern](http://c2.com/cgi/wiki?MementoPattern).
     * @param {Object} memento - an encapsulated representation of table state
     */
    setState: function(memento) {

        //we don't want to clobber the column properties completely
        if (!memento.columnIndexes) {
            var fields = this.dataModel.getFields();
            memento.columnIndexes = [];
            for (var i = 0; i < fields.length; i++) {
                memento.columnIndexes[i] = i;
            }
        }
        var colProperties = memento.columnProperties;
        delete memento.columnProperties;
        this.tableState = null;
        var state = this.getPrivateState();
        this.createColumns();
        this._setColumnOrder(memento.columnIndexes);
        _(state).extendOwn(memento);
        this.setAllColumnProperties(colProperties);
        memento.columnProperties = colProperties;

        //just to be close/ it's easier on the eyes
        this.setColumnWidth(-1, 24.193359375);
        this.dataModel.applyState();
    },

    setAllColumnProperties: function(properties) {
        properties = properties || [];
        for (var i = 0; i < properties.length; i++) {
            var current = this.getPrivateState().columnProperties[i];
            this.clearObjectProperties(current, false);
            _(current).extendOwn(properties[i]);
        }
    },

    _setColumnOrder: function(indexes) {
        if (!Array.isArray(indexes)){
            return;
        }
        if (!indexes) {
            this.columns.length = 0;
            return;
        }
        this.columns.length = indexes.length;
        for (var i = 0; i < indexes.length; i++) {
            this.columns[i] = this.allColumns[indexes[i]];
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @desc fetch the value for a property key
     * @returns {*} The value of the given property.
     * @param {string} key - a property name
     */
    resolveProperty: function(key) {
        return this.grid.resolveProperty(key);
    },

    /**
     * @memberOf Behavior.prototype
     * @desc A specific cell was clicked; you've been notified.
     * @param {Point} cell - point of cell coordinates
     * @param {Object} event - all event information
     */
    cellClicked: function(cell, event) {
        this.dataModel.cellClicked(cell, event);
    },

    /**
     * @memberOf Behavior.prototype
     * @desc A specific cell was le double-clicked; you've been notified.
     * @param {Point} cell - point of cell coordinates
     * @param {Object} event - all event information
     */
    cellDoubleClicked: function(cell, event) {

    },

    lookupFeature: function(key) {
        return this.featureMap[key];
    },

    /**
     * @memberOf Behavior.prototype
     * @desc setter for the hypergrid
     * @param {Hypergrid} grid
     */
    setGrid: function(grid) {
    },

    /**
     * @memberOf Behavior.prototype
     * @desc First check to see if something was overridden.
     * @return {*} The value at `x,y` for the top left section of the hypergrid.
     * @param {number} x - x coordinate
     * @param {number} y - y coordinate
     */
    getValue: function(x, y) {
        var column = this.getActiveColumn(x);
        return column && column.getValue(y);
    },

    getUnfilteredValue: function(x, y) {
        var column = this.getActiveColumn(x);
        return column && column.getUnfilteredValue(y);
    },

    /**
     * @memberOf Behavior.prototype
     * @desc update the data at point x, y with value
     * @return The data.
     * @param {number} x - x coordinate
     * @param {number} y - y coordinate
     * @param {Object} value - the value to use
     */
    setValue: function(x, y, value) {
        var column = this.getActiveColumn(x);
        return column && column.setValue(y, value);
    },

    getDataValue: function(x, y) {
        return this.dataModel.getValue(x, y);
    },

    setDataValue: function(x, y, value) {
        this.dataModel.setValue(x, y, value);
    },
    /**
     * @memberOf Behavior.prototype
     * @desc First checks to see if something was overridden.
     * @return {*} The value at x,y for the top left section of the hypergrid.
     * @param {number} x - x coordinate
     * @param {number} y - y coordinate
     */
    getCellProperties: function(x, y) {
        var column = this.allColumns[x];
        return column && column.getCellProperties(y);
    },

    /**
     * @memberOf Behavior.prototype
     * @desc update the data at point x, y with value
     * @param {number} x - x coordinate
     * @param {number} y - y coordinate
     * @param {Object} value - the value to use
     */
    setCellProperties: function(x, y, value) {
        var column = this.allColumns[x];
        if (column) {
            column.setCellProperties(y, value);
        }
    },
    /**
     * @memberOf Behavior.prototype
     * @return {number} The number of rows in the hypergrid.
     */
    getRowCount: function() {
        return this.dataModel.getRowCount();
    },

    getUnfilteredRowCount: function() {
        return this.dataModel.getUnfilteredRowCount();
    },
    /**
     * @memberOf Behavior.prototype
     * @return {number} The height in pixels of the fixed rows area  of the hypergrid.
     */
    getFixedRowsHeight: function() {
        var count = this.getFixedRowCount();
        var total = 0;
        for (var i = 0; i < count; i++) {
            total = total + this.getRowHeight(i);
        }
        //var footerHeight = this.getDefaultRowHeight();
        //total = total + (footerHeight * this.getFooterRowCount());
        return total;
    },

    /**
     * @memberOf Behavior.prototype
     * @return {number} The height in pixels of a specific row in the hypergrid.
     * @param {number} rowNum - row index of interest
     */
    getRowHeight: function(rowNum) {
        var rowHeights = this.getPrivateState().rowHeights;
        return rowHeights && rowHeights[rowNum] || this.getDefaultRowHeight();
    },

    /**
     * @memberOf Behavior.prototype
     * @desc The value is lazily initialized and comes from the properties mechanism for '`defaultRowHeight`', which should be ~20px.
     * @returns {number} The row height in pixels.
     */
    getDefaultRowHeight: function() {
        if (!this.defaultRowHeight) {
            this.defaultRowHeight = this.resolveProperty('defaultRowHeight');
        }
        return this.defaultRowHeight;
    },

    /**
     * @memberOf Behavior.prototype
     * @desc set the pixel height of a specific row
     * @param {number} rowNum - the row index of interest
     * @param {number} height - pixel height
     */
    setRowHeight: function(rowNum, height) {
        var tableState = this.getPrivateState();
        tableState.rowHeights[rowNum] = Math.max(5, height);
        this.stateChanged();
    },

    /**
     * @memberOf Behavior.prototype
     * @desc This will allow 'floating' fixed rows.
     * @return {number} The maximum height of the fixed rows area in the hypergrid.
     */
    getFixedRowsMaxHeight: function() {
        return this.getFixedRowsHeight();
    },

    /**
     * @memberOf Behavior.prototype
     * @return {number} The width of the fixed column area in the hypergrid.
     */
    getFixedColumnsWidth: function() {
        var count = this.getFixedColumnCount();
        var total = 0;
        if (this.grid.isShowRowNumbers()) {
            total = this.getColumnWidth(-1);
        }
        for (var i = 0; i < count; i++) {
            total = total + this.getColumnWidth(i);
        }
        return total;
    },

    /**
     * @memberOf Behavior.prototype
     * @desc This exists to support "floating" columns.
     * @return {number} The total width of the fixed columns area.
     */
    getFixedColumnsMaxWidth: function() {
        return this.getFixedColumnsWidth();
    },

    /**
     * @memberOf Behavior.prototype
     * @desc Set the scroll position in vertical dimension and notify listeners.
     * @param {number} y - the new y value
     */
    _setScrollPositionY: function(y) {
        this.setScrollPositionY(y);
        this.changed();
    },

    /**
     * @memberOf Behavior.prototype
     * @desc Set the scroll position in horizontal dimension and notify listeners.
     * @param {number} x - the new x value
     */
    _setScrollPositionX: function(x) {
        this.setScrollPositionX(x);
        this.changed();
    },

    /**
     * @memberOf Behavior.prototype
     * @desc Set the number of columns just rendered, including partially rendered columns.
     * @param {number} count - how many columns were just rendered
     */
    setRenderedColumnCount: function(count) {
        this.renderedColumnCount = count;
    },

    /**
     * @memberOf Behavior.prototype
     * @desc Set the number of rows just rendered, including partially rendered rows.
     * @param {number} count - how many rows were just rendered
     */
    setRenderedRowCount: function(count) {
        this.renderedRowCount = count;
    },


    /**
     * @memberOf Behavior.prototype
     * @desc The fixed row area has been clicked, massage the details and call the real function.
     * @param {Hypergrid} grid
     * @param {Object} mouse - event details
     */
    _fixedRowClicked: function(grid, mouse) {
        var x = this.translateColumnIndex(this.getScrollPositionX() + mouse.gridCell.x - this.getFixedColumnCount());
        var translatedPoint = this.grid.newPoint(x, mouse.gridCell.y);
        mouse.gridCell = translatedPoint;
        this.fixedRowClicked(grid, mouse);
    },

    /**
     * @memberOf Behavior.prototype
     * @desc The fixed column area has been clicked, massage the details and call the real function.
     * @param {Hypergrid} grid
     * @param {Object} mouse - event details
     */
    _fixedColumnClicked: function(grid, mouse) {
        var translatedPoint = this.grid.newPoint(mouse.gridCell.x, this.getScrollPositionY() + mouse.gridCell.y - this.getFixedRowCount());
        mouse.gridCell = translatedPoint;
        this.fixedColumnClicked(grid, mouse);
    },

    moveSingleSelect: function(grid, x, y) {
        if (this.featureChain) {
            this.featureChain.moveSingleSelect(grid, x, y);
            this.setCursor(grid);
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @desc delegate setting the cursor up the feature chain of responsibility
     * @param {Hypergrid} grid
     */
    setCursor: function(grid) {
        grid.updateCursor();
        this.featureChain.setCursor(grid);
    },

    /**
     * @memberOf Behavior.prototype
     * @desc delegate handling mouse move to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    onMouseMove: function(grid, event) {
        if (this.featureChain) {
            this.featureChain.handleMouseMove(grid, event);
            this.setCursor(grid);
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @desc delegate handling tap to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    onClick: function(grid, event) {
        if (this.featureChain) {
            this.featureChain.handleClick(grid, event);
            this.setCursor(grid);
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @desc delegate handling tap to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    onContextMenu: function(grid, event) {
        var proceed = grid.fireSyntheticContextMenuEvent(event);
        if (proceed && this.featureChain) {
            this.featureChain.handleContextMenu(grid, event);
            this.setCursor(grid);
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @desc delegate handling wheel moved to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    onWheelMoved: function(grid, event) {
        if (this.featureChain) {
            this.featureChain.handleWheelMoved(grid, event);
            this.setCursor(grid);
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @desc delegate handling mouse up to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    onMouseUp: function(grid, event) {
        if (this.featureChain) {
            this.featureChain.handleMouseUp(grid, event);
            this.setCursor(grid);
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @desc delegate handling mouse drag to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    onMouseDrag: function(grid, event) {
        if (this.featureChain) {
            this.featureChain.handleMouseDrag(grid, event);
            this.setCursor(grid);
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @desc delegate handling key down to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    onKeyDown: function(grid, event) {
        if (this.featureChain) {
            this.featureChain.handleKeyDown(grid, event);
            this.setCursor(grid);
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @desc delegate handling key up to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    onKeyUp: function(grid, event) {
        if (this.featureChain) {
            this.featureChain.handleKeyUp(grid, event);
            this.setCursor(grid);
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @desc delegate handling double click to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    onDoubleClick: function(grid, event) {
        if (this.featureChain) {
            this.featureChain.handleDoubleClick(grid, event);
            this.setCursor(grid);
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @desc delegate handling double click to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {string[]} [options] - Forwarded to dialog constructor.
     */
    openDialog: function(dialogName, options) {
        return new dialogs[dialogName](this.grid, options);
    },

    /**
     * @memberOf Behavior.prototype
     * @desc delegate handling mouse down to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDown: function(grid, event) {
        if (this.featureChain) {
            this.featureChain.handleMouseDown(grid, event);
            this.setCursor(grid);
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @desc delegate handling mouse exit to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseExit: function(grid, event) {
        if (this.featureChain) {
            this.featureChain.handleMouseExit(grid, event);
            this.setCursor(grid);
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @desc this function is replaced by the grid on initialization and serves as the callback
     */
    changed: function() {},

    /**
     * @memberOf Behavior.prototype
     * @desc this function is replaced by the grid on initialization and serves as the callback
     */
    shapeChanged: function() {},

    /**
     * @memberOf Behavior.prototype
     * @return {boolean} Can re-order columns.
     */
    isColumnReorderable: function() {
        return true;
    },

    /**
     * @memberOf Behavior.prototype
     * @return {Object} The properties for a specific column. These are used if no cell properties are specified.
     * @param {index} columnIndex - the column index of interest
     */
    getColumnProperties: function(columnIndex) {
        var column = this.columns[columnIndex];
        if (!column) {
            return isNull;
        }
        var properties = column.getProperties(); //TODO: returns `null` on Hypergrid.prototype.reset();
        if (!properties) {
            return isNull;
        }
        return properties;
    },

    setColumnProperties: function(columnIndex, properties) {
        var column = this.allColumns[columnIndex];
        var columnProperties = column.getProperties();
        _(columnProperties).extendOwn(properties);
        this.changed();
    },

    /**
     * Clears all cell properties of given column or of all columns.
     * @param {number} [columnIndex] - Omit for all columns.
     */
    clearAllCellProperties: function(columnIndex) {
        if (columnIndex === undefined) {
            for (var i = this.allColumns.length - 1; i >= 0; --i) {
                this.allColumns[i].clearAllCellProperties();
            }
        } else {
            var column = this.allColumns[i];
            if (column) {
                column.clearAllCellProperties();
            }
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @desc Rebuild the column order indexes
     * @param {Array} columnIndexes - list of column indexes
     * @param {Boolean} [silent=false] - whether to trigger column changed event
     */
    setColumnIndexes: function(columnIndexes, silent) {
        var tableState = this.getPrivateState();
        this._setColumnOrder(columnIndexes);
        tableState.columnIndexes = columnIndexes;
        this.changed();
        if (!silent) {
            this.grid.fireSyntheticOnColumnsChangedEvent();
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @return {string[]} All the currently hidden column header labels.
     */
    getHiddenColumnDescriptors: function() {
        var tableState = this.getPrivateState();
        var indexes = tableState.columnIndexes;
        var labels = [];
        var columnCount = this.getActiveColumnCount();
        for (var i = 0; i < columnCount; i++) {
            if (indexes.indexOf(i) === -1) {
                var column = this.getActiveColumn(i);
                labels.push({
                    id: i,
                    header: column.header,
                    field: column.name
                });
            }
        }
        return labels;
    },

    /**
     * @memberOf Behavior.prototype
     * @desc hide columns that are specified by their indexes
     * @param {Array} arrayOfIndexes - an array of column indexes to hide
     */
    hideColumns: function(arrayOfIndexes) {
        var tableState = this.getPrivateState();
        var order = tableState.columnIndexes;
        for (var i = 0; i < arrayOfIndexes.length; i++) {
            var each = arrayOfIndexes[i];
            if (order.indexOf(each) !== -1) {
                order.splice(order.indexOf(each), 1);
            }
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @return {integer} The number of fixed columns.
     */
    getFixedColumnCount: function() {
        return this.getPrivateState().fixedColumnCount || 0;
    },

    /**
     * @memberOf Behavior.prototype
     * @desc set the number of fixed columns
     * @param {number} n - the integer count of how many columns to be fixed
     */
    setFixedColumnCount: function(n) {
        this.getPrivateState().fixedColumnCount = n;
    },

    /**
     * @memberOf Behavior.prototype
     * @return {integer} The number of fixed rows.
     */
    getFixedRowCount: function() {
        if (!this.tableState) {
            return 0;
        }
        var headers = this.grid.getHeaderRowCount();
        var usersSize = this.tableState.fixedRowCount || 0;
        return headers + usersSize;
    },

    /**
     * @memberOf Behavior.prototype
     * @desc Set the number of fixed rows, which includes (top to bottom order):
     * 1. The header rows
     *    1. The header labels row (optional)
     *    2. The filter row (optional)
     *    3. The top total rows (0 or more)
     * 2. The non-scrolling rows (externally called "the fixed rows")
     *
     * @returns {number} Sum of the above or 0 if none of the above are in use.
     *
     * @param {number} n - The number of rows.
     */
    setFixedRowCount: function(n) {
        this.tableState.fixedRowCount = n;
    },

    /**
     * @memberOf Behavior.prototype
     * @return {number} The number of header rows.
     * A portion of the number returned by {@link Behavior#getFixedRowCount()|getFixedRowCount()}.
     * (The remaining _fixed rows_ are the _top totals_ rows.)
     */
    getHeaderRowCount: function() {
        var header = this.grid.isShowHeaderRow() ? 1 : 0;
        var filter = this.grid.isShowFilterRow() ? 1 : 0;
        var totals = this.getTopTotals().length;
        return header + filter + totals;
    },

    /**
     * @memberOf Behavior.prototype
     * @return {number} The number of footer rows, consisting entirely of 0 or more _bottom totals_ rows.
     */
    getFooterRowCount: function() {
        return this.getBottomTotals().length;
    },

    getTopTotals: function() {
        return this.dataModel.getTopTotals();
    },
    /**
     * @memberOf Behavior.prototype
     * @summary Set the number of header rows.
     * @param {number} n - The number of _fixed rows_ to reserve as header rows.
     * (The remaining _fixed rows_ are the _top totals_ rows.)
     */
    setHeaderRowCount: function(n) {
        this.tableState.headerRowCount = n;
    },

    /**
     * @memberOf Behavior.prototype
     * @return {number} The number of fixed rows.
     */
    getHeaderColumnCount: function() {
        return this.grid.resolveProperty('headerColumnCount');
    },

    /**
     * @memberOf Behavior.prototype
     * @param {number} The number of fixed rows.
     */
    setHeaderColumnCount: function(numberOfHeaderColumns) {
        this.tableState.headerColumnCount = numberOfHeaderColumns;
    },

    /**
     * @memberOf Behavior.prototype
     * @desc a dnd column has just been dropped, we've been notified
     */
    endDragColumnNotification: function() {},

    /**
     * @memberOf Behavior.prototype
     * @return {null} the cursor at a specific x,y coordinate
     * @param {number} x - the x coordinate
     * @param {number} y - the y coordinate
     */
    getCursorAt: function(x, y) {
        return null;
    },

    /**
     * Number of _visible_ columns.
     * @memberOf Behavior.prototype
     * @return {number} The total number of columns.
     */
    getActiveColumnCount: function() {
        return this.columns.length;
    },
    getColumnCount: function() {
        return this.deprecated('getColumnCount()', 'getActiveColumnCount()', '1.0.6', arguments);
    },

    /**
     * @memberOf Behavior.prototype
     * @return {string} The column alignment at column `x`: `'left'`, `'center'` , or `'right'`
     * @param {number} x - The column index of interest.
     */
    getColumnAlignment: function(x) {
        return 'center';
    },

    /**
     * @memberOf Behavior.prototype
     * @desc Quietly set the horizontal scroll position.
     * @param {number} x - The new position in pixels.
     */
    setScrollPositionX: function(x) {
        /**
         * @memberOf Behavior.prototype
         * @type {number}
         */
        this.scrollPositionX = x;
    },

    getScrollPositionX: function() {
        return this.scrollPositionX;
    },

    /**
     * @memberOf Behavior.prototype
     * @desc Quietly set the vertical scroll position.
     * @param {number} y - The new position in pixels.
     */
    setScrollPositionY: function(y) {
        /**
         * @memberOf Behavior.prototype
         * @type {number}
         */
        this.scrollPositionY = y;
    },

    getScrollPositionY: function() {
        return this.scrollPositionY;
    },

    /**
     * @memberOf Behavior.prototype
     * @return {cellEditor} The cell editor for the cell at the given coordinates.
     * @param {Point} editPoint - The grid cell coordinates.
     */
    getCellEditorAt: function(editPoint) {
        var cellEditor, options,
            column = this.getActiveColumn(editPoint.x);

        if (column) {
            options = {
                column: column,
                editPoint: editPoint
            };

            cellEditor = this.grid.isFilterRow(editPoint.y)
                ? this.grid.cellEditors.create('filterbox', options)
                : column.getCellEditorAt(editPoint.y, options);
        }

        return cellEditor;
    },

    /**
     * @memberOf Behavior.prototype
     * @param {number} x - The column index.
     * @param {string[]} keys
     */
    toggleSort: function(x, keys) {
        this.getActiveColumn(x).toggleSort(keys);
    },

    /**
     * @memberOf Behavior.prototype
     * @return {boolean} `true` if we should highlight on hover
     * @param {boolean} isColumnHovered - the column is hovered or not
     * @param {boolean} isRowHovered - the row is hovered or not
     */
    highlightCellOnHover: function(isColumnHovered, isRowHovered) {
        return isColumnHovered && isRowHovered;
    },

    /**
     * @memberOf Behavior.prototype
     * @desc this function is a hook and is called just before the painting of a cell occurs
     * @param {window.fin.rectangular.Point} cell
     */
    cellPropertiesPrePaintNotification: function(cell) {

    },

    /**
     * @memberOf Behavior.prototype
     * @desc this function is a hook and is called just before the painting of a fixed row cell occurs
     * @param {window.fin.rectangular.Point} cell
     */
    cellFixedRowPrePaintNotification: function(cell) {

    },

    /**
     * @memberOf Behavior.prototype
     * @desc this function is a hook and is called just before the painting of a fixed column cell occurs
     * @param {window.fin.rectangular.Point} cell
     */
    cellFixedColumnPrePaintNotification: function(cell) {

    },

    /**
     * @memberOf Behavior.prototype
     * @desc this function is a hook and is called just before the painting of a top left cell occurs
     * @param {window.fin.rectangular.Point} cell
     */
    cellTopLeftPrePaintNotification: function(cell) {

    },

    /**
     * @memberOf Behavior.prototype
     * @desc this function enhance the double click event just before it's broadcast to listeners
     * @param {Object} event - event to enhance
     */
    enhanceDoubleClickEvent: function(event) {},

    /**
     * @memberOf Behavior.prototype
     * @desc swap src and tar columns
     * @param {number} src - column index
     * @param {number} tar - column index
     */
    swapColumns: function(source, target) {
        var columns = this.columns;
        var tmp = columns[source];
        columns[source] = columns[target];
        columns[target] = tmp;
        this.changed();
    },

    getColumnEdge: function(c, renderer) {
        return this.dataModel.getColumnEdge(c, renderer);
    },

    /**
     * @memberOf Behavior.prototype
     * @param {number} x - column index
     * @param {number} y - totals row index local to the totals area
     * @param value
     * @param {string[]} [areas=['top', 'bottom']] - may include `'top'` and/or `'bottom'`
     */
    setTotalsValue: function(x, y, value, areas) {
        this.grid.setTotalsValueNotification(x, y, value, areas);
    },

    /**
     * @memberOf Behavior.prototype
     * @return {object} The object at y index.
     * @param {number} y - the row index of interest
     */
    getRow: function(y) {
        return this.dataModel.getRow(y);
    },

    convertViewPointToDataPoint: function(viewPoint) {
        var newX = this.getActiveColumn(viewPoint.x).index;
        var newPoint = this.grid.newPoint(newX, viewPoint.y);
        return newPoint;
    },

    setGroups: function(arrayOfColumnIndexes) {
        this.dataModel.setGroups(arrayOfColumnIndexes);
        this.createColumns();
        this.changed();
    },

    setAggregates: function(mapOfKeysToFunctions) {
        var self = this;
        this.dataModel.setAggregates(mapOfKeysToFunctions);
        this.createColumns();
        setTimeout(function() {
            self.changed();
        }, 100);
    },

    hasHierarchyColumn: function() {
        return false;
    },

    getRowContextFunction: function(selectedRows) {
        return function() {
            return null;
        };
    },

    getSelectionMatrixFunction: function(selectedRows) {
        return function() {
            return null;
        };
    },

    getComputedRow: function(y) {
        return this.dataModel.getComputedRow(y);
    },

    autosizeAllColumns: function() {
        this.checkColumnAutosizing(true);
        this.changed();
    },

    checkColumnAutosizing: function(force) {
        force = force === true;
        this.autoSizeRowNumberColumn();
        this.allColumns[-2].checkColumnAutosizing(force);
        this.allColumns.forEach(function(column) {
            column.checkColumnAutosizing(force);
        });
    },

    autoSizeRowNumberColumn: function() {
        if (this.grid.isRowNumberAutosizing()) {
            this.allColumns[-1].checkColumnAutosizing(true);
        }
    },

    getNewFilter: function() {
        var newFilter = new DefaultFilter({
            schema: typeof this.schema === 'function' ? this.schema(this.columns) : this.schema,
            caseSensitiveColumnNames: this.grid.resolveProperty('filterCaseSensitiveColumnNames'),
            resolveAliases: this.grid.resolveProperty('filterResolveAliases'),
            defaultColumnFilterOperator: this.grid.resolveProperty('filterDefaultColumnFilterOperator')
        });
        newFilter.loadColumnPropertiesFromSchema(this.columns);
        return newFilter;
    },

    /**
     * @summary Get a reference to the filter attached to the Hypergrid.
     * @returns {FilterTree}
     * @memberOf Behavior.prototype
     */
    getGlobalFilter: function() {
        return this.dataModel.getGlobalFilter();
    },

    /**
     * @summary Attach/detach a filter to a Hypergrid.
     * @param {FilterTree} [filter] - The filter object. If undefined, any attached filter is removed, turning filtering OFF.
     * @memberOf Behavior.prototype
     */
    setGlobalFilter: function(filter) {
        this.dataModel.setGlobalFilter(filter);
    },

    /**
     * @summary Set the case sensitivity of filter tests against data.
     * @desc Case sensitivity pertains to string compares only. This includes untyped columns, columns typed as strings, typed columns containing data that cannot be coerced to type or when the filter expression operand cannot be coerced.
     *
     * NOTE: This is a shared property and affects all grid managed by this instance of the app.
     * @param {boolean} isSensitive
     * @memberOf Behavior.prototype
     */
    setGlobalFilterCaseSensitivity: function(isSensitive) {
        this.dataModel.setGlobalFilterCaseSensitivity(isSensitive);
    },

    /**
     * @param {number|string} columnIndexOrName - The _column filter_ to set.
     * @param {FilterTreeGetStateOptionsObject} [options] - Passed to the filter's {@link DefaultFilter#getState|getState} method.
     * @param {boolean} [options.syntax='CQL'] - The syntax to use to describe the filter state. Note that `getFilter`'s default syntax, `'CQL'`, differs from the other get state methods.
     * @returns {FilterTreeStateObject}
     * @memberOf Behavior.prototype
     */
    getFilter: function(columnIndexOrName, options) {
        return this.dataModel.getFilter(columnIndexOrName, options);
    },

    /**
     * @summary Set a particular column filter's state.
     * @desc After setting the new filter state, reapplies the filter to the data source.
     * @param {number|string} columnIndexOrName - The _column filter_ to set.
     * @param {string|object} [state] - A filter tree object or a JSON, SQL, or CQL subexpression string that describes the a new state for the named column filter. The existing column filter subexpression is replaced with a new node based on this state. If it does not exist, the new subexpression is added to the column filters subtree (`filter.columnFilters`).
     *
     * If undefined, removes the entire column filter subexpression from the column filters subtree.
     * @param {FilterTreeSetStateOptionsObject} [options] - Passed to the filter's [setState]{@link http://joneit.github.io/filter-tree/FilterTree.html#setState} method. You may mix in members of the {@link http://joneit.github.io/filter-tree/global.html#FilterTreeValidationOptionsObject|FilterTreeValidationOptionsObject}
     * @param {string} [options.syntax='CQL'] - The syntax to use to describe the filter state. Note that `setFilter`'s default syntax, `'CQL'`, differs from the other get state methods.
     * @returns {undefined|Error|string} `undefined` indicates success.
     * @memberOf Behavior.prototype
     */
    setFilter: function(columnIndexOrName, state, options) {
        this.dataModel.setFilter(columnIndexOrName, state, options);
    },

    /**
     * @param {FilterTreeGetStateOptionsObject} [options] - Passed to the filter's {@link DefaultFilter#getState|getState} method.
     * @returns {FilterTreeStateObject}
     * @memberOf Behavior.prototype
     */
    getFilters: function(options) {
        return this.dataModel.getFilters(options);
    },

    /**
     * @param {FilterTreeStateObject} state
     * @param {FilterTreeSetStateOptionsObject} [options] - Passed to the filter's [setState]{@link http://joneit.github.io/filter-tree/FilterTree.html#setState} method. You may mix in members of the {@link http://joneit.github.io/filter-tree/global.html#FilterTreeValidationOptionsObject|FilterTreeValidationOptionsObject}
     * @returns {undefined|Error|string} `undefined` indicates success.
     * @memberOf Behavior.prototype
     */
    setFilters: function(state, options) {
        this.dataModel.setFilters(state, options);
    },

    /**
     * @param {FilterTreeGetStateOptionsObject} [options] - Passed to the filter's {@link DefaultFilter#getState|getState} method.
     * @returns {FilterTreeStateObject}
     * @memberOf Behavior.prototype
     */
    getTableFilter: function(options) {
        return this.dataModel.getTableFilter(options);
    },

    /**
     * @param {FilterTreeStateObject} state
     * @param {FilterTreeSetStateOptionsObject} [options] - Passed to the filter's [setState]{@link http://joneit.github.io/filter-tree/FilterTree.html#setState} method. You may mix in members of the {@link http://joneit.github.io/filter-tree/global.html#FilterTreeValidationOptionsObject|FilterTreeValidationOptionsObject}
     * @returns {undefined|Error|string} `undefined` indicates success.
     * @memberOf Behavior.prototype
     */
    setTableFilter: function(state, options) {
        this.dataModel.setTableFilter(state, options);
    },

    getSelectedRows: function() {
        return this.grid.selectionModel.getSelectedRows();
    },

    getSelectedColumns: function() {
        return this.grid.selectionModel.getSelectedColumns();
    },

    getSelections: function() {
        return this.grid.selectionModel.getSelections();
    },

    getData: function() {
        return this.dataModel.getData();
    },

    getFilteredData: function() {
        return this.dataModel.getFilteredData();
    },
});

module.exports = Behavior;

},{"../dialogs":91,"../filter/DefaultFilter":111,"../lib/Base":113,"./Column":57,"object-iterators":46}],57:[function(require,module,exports){
/* eslint-env browser */

'use strict';

var _ = require('object-iterators');

var propertyNames = [
    'index',
    'name',
    'header',
    'type'
];

/** @summary Create a new `Column` object.
 * @constructor
 * @param behavior
 * @param {number|object} indexOrOptions - If a number, shorthand for `options.index`.
 *
 * For positive values of `options.index`, see {@link Column#initialize|initialize}. Note that for new columns, you must supply either `index` or `name`. If you supply both, they must match the definitiion in data model's `fields` list.
 *
 * Negative values are special cases:
 * `index` | Meaning
 * :-----: | --------
 *    -1   | Row header column
 *    -2   | Tree (drill-down) column
 *
 *
 */
function Column(behavior, indexOrOptions) {
    this.behavior = behavior;
    this.dataModel = behavior.dataModel;
    this.cellProperties = [];

    var options = typeof indexOrOptions === 'object' ? indexOrOptions : { index: indexOrOptions },
        index = options.index;

    switch (index) {

        case -1:
            this.index = index;
            this.name = '';
            this.header = '';
            break;

        case -2:
            this.index = index;
            this.name = 'tree';
            this.header = 'Tree';
            break;

        default:
            if (index < 0) {
                throw '`index` out of range';
            } else {
                this.set(options);
            }

    }
}

Column.prototype = {
    constructor: Column.prototype.constructor,

    /** @summary Set or reset the properties of a column object.
     * @desc When (re)setting a column object, the object must end up with fully defined `index` and `name` properties. If one is missing it will be derived from the data model's `fields` list.
     * Note: These properties of the column object should not be confused with the members of the columnProperties object which supports grid render and is something else entirely.
     * @param {object} options - Required because you must supply at least `index` or `name`.
     * @param {object} [options.index]
     * @param {object} [options.name]
     * @param {object} [options.header]
     * @param {object} [options.type]
     */
    set: function(options) {
        var fields = this.dataModel.getFields();
        var column = this;
        propertyNames.forEach(function(option) {
            if (option in options) {
                column[option] = options[option];
            }

            if (option === 'name') {
                if (column.name === undefined) {
                    column.name = fields[column.index];
                } else if (column.index === undefined) {
                    column.index = fields.indexOf(column.name);
                }

                if (column.index === undefined || column.name === undefined) {
                    throw 'Expected column name or index.';
                } else if (fields[column.index] !== column.name) {
                    throw 'Expected to find `column.name` in position `column.index` in data model\'s fields list.';
                }
            }
        });
    },

    /**
     * @summary Get or set the text of the column's header.
     * @desc The _header_ is the label at the top of the column.
     *
     * Setting the value here updates the header in both this column object as well as the `fields` (aka, header) array in the underlying data source.
     *
     * The new text will appear on the next repaint.
     * @type {string}
     */
    set header(headerText) {
        this.dataModel.getHeaders()[this.index] = this._header = headerText;
    },
    get header() {
        return this._header;
    },

    getUnfilteredValue: function(y) {
        return this.dataModel.getUnfilteredValue(this.index, y);
    },

    getValue: function(y) {
        return this.dataModel.getValue(this.index, y);
    },

    setValue: function(y, value) {
        return this.dataModel.setValue(this.index, y, value);
    },

    getWidth: function() {
        var properties = this.getProperties();
        return properties && properties.width || this.behavior.resolveProperty('defaultColumnWidth');
    },

    setWidth: function(width) {
        this.getProperties().width = Math.max(5, width);
    },

    getCellRenderer: function(config, x, y) {
        config.untranslatedX = x;
        config.y = y;

        config.x = this.index;
        config.normalizedY = y - this.behavior.getHeaderRowCount();

        // Legacy config.x and config.y were confusing because the x was translated while the y was not.
        // These have been deprecated and are currently implemented as getters with deprecation warnings.
        // Rather than defining these getters here on every cell render, they are defined once in Behavior.prototype.getDefaultState.
        //config.x = this.index;
        //config.y = y;

        var declaredRendererName =
            this.getCellProperties(y).renderer ||
            this.getProperties().renderer;

        var renderer = this.dataModel.getCell(config, declaredRendererName);
        renderer.config = config;
        return renderer;
    },

    getCellProperties: function(y) {
        y = this.dataModel.getDataIndex(y);
        return this.cellProperties[y] || {};
    },

    setCellProperties: function(y, value) {
        this.cellProperties[y] = value;
    },

    clearAllCellProperties: function() {
        this.cellProperties.length = 0;
    },

    checkColumnAutosizing: function(force) {
        var properties = this.getProperties();
        var a, b, d;
        if (properties) {
            a = properties.width;
            b = properties.preferredWidth || a;
            d = properties.columnAutosized && !force;
            if (a !== b || !d) {
                properties.width = !d ? b : Math.max(a, b);
                properties.columnAutosized = !isNaN(properties.width);
            }
        }
    },

    getCellType: function(y) {
        var value = this.getValue(y);
        var type = this.typeOf(value);
        return type;
    },

    getType: function() {
        var props = this.getProperties();
        var type = props.type;
        if (!type) {
            type = this.computeColumnType();
            if (type !== 'unknown') {
                props.type = type;
            }
        }
        return type;
    },

    computeColumnType: function() {
        var headerRowCount = this.behavior.getHeaderRowCount();
        var height = this.behavior.getRowCount();
        var value = this.getValue(headerRowCount);
        var eachType = this.typeOf(value);
        if (!eachType) {
            return 'unknown';
        }
        var type = this.typeOf(value);
        var isNumber = ((typeof value) === 'number');
        for (var y = headerRowCount; y < height; y++) {
            value = this.getValue(y);
            eachType = this.typeOf(value);
            if (type !== eachType) {
                if (isNumber && (typeof value === 'number')) {
                    type = 'float';
                } else {
                    return 'mixed';
                }
            }
        }
        return type;
    },

    typeOf: function(something) {
        if (something == null) {
            return null;
        }
        var typeOf = typeof something;
        switch (typeOf) {
            case 'object':
                return something.constructor.name.toLowerCase();
            case 'number':
                return parseInt(something) === something ? 'int' : 'float';
            default:
                return typeOf;
        }
    },

    getProperties: function() {
        return this.behavior.getPrivateState().columnProperties[this.index];
    },

    setProperties: function(properties) {
        var current = this.getProperties();
        this.clearObjectProperties(current, false);
        _(current).extendOwn(properties);
    },

    toggleSort: function(keys) {
        this.dataModel.toggleSort(this.index, keys);
    },

    unSort: function(deferred) {
        this.dataModel.unSortColumn(this.index, deferred);
    },

    /**
     * This method determines the proposed cell editor name from the render properties. The algorithm is:
     * 1. `editor` render property (cell editor name)
     * 2. `format` render property (localizer name)
     * 3. `type` column property (type name)
     *
     * Note that "render property" means in each case the first defined property found on the cell, column, or grid.
     *
     * @param {number} y - The original untranslated row index.
     * @param {object} options - Will be decorated with `format` and `column`.
     * @param {Point} options.editPoint
     * @returns {undefined|CellEditor} Falsy value means either no declared cell editor _or_ instantiation aborted by falsy return return from fireRequestCellEdit.
     */
    getCellEditorAt: function(y, options) {
        var cellEditor,
            cellProps = this.getCellProperties(y),
            columnProps = this.getProperties(),
            editorName = cellProps.editor || columnProps.editor;

        options.format = cellProps.format || columnProps.format;

        cellEditor = this.dataModel.getCellEditorAt(this.index, y, editorName, options);

        if (cellEditor && !cellEditor.grid) {
            // cell editor returned but not fully instantiated (aborted by falsy return from fireRequestCellEdit)
            cellEditor = undefined;
        }

        return cellEditor;
    },

    getFormatter: function() {
        var localizerName = this.getProperties().format;
        return this.behavior.grid.localization.get(localizerName).format;
    }
};

module.exports = Column;

},{"object-iterators":46}],58:[function(require,module,exports){
'use strict';

var Local = require('./Local');
var DataModelJSON = require('../dataModels/JSON');
var ColumnSchemaFactory = require('../filter/ColumnSchemaFactory');
var features = require('../features');
var aggregations = require('../Shared.js').analytics.util.aggregations;

/**
 * @name behaviors.JSON
 * @desc > Same parameters as {@link behaviors.Behavior#initialize|initialize}, which is called by this constructor.
 * @constructor
 * @extends Behavior
 */
var JSON = Local.extend('behaviors.JSON', {

    /**
     * @summary Constructor logic, called _after_{@link Behavior#initialize|Behavior.initialize()}.
     * @desc This method will be called upon instantiation of this class or of any class that extends from this class.
     * > All `initialize()` methods in the inheritance chain are called, in turn, each with the same parameters that were passed to the constructor, beginning with that of the most "senior" class through that of the class of the new instance.
     *
     * @param grid - the hypergrid
     * @param {undefined|function|menuItem[]} schema - Already consumed by Behavior's {@link Behavior#initialize|initialize}.
     * @param {object[]} dataRows - May be:
     * * An array of congruent raw data objects
     * * A function returning same
     * @memberOf behaviors.JSON.prototype
     */
    initialize: function(grid, schema, dataRows) {
        this.setData(dataRows, schema);
    },

    features: [
        features.CellSelection,
        features.KeyPaging,
        features.ColumnPicker,
        features.ColumnResizing,
        features.RowResizing,
        features.Filters,
        features.RowSelection,
        features.ColumnSelection,
        features.ColumnMoving,
        features.ColumnSorting,
        features.CellEditing,
        features.CellClick,
        features.OnHover
    ],

    aggregations: aggregations,

    createColumns: function() {
        var dataModel = this.dataModel;
        var columnCount = dataModel.getColumnCount();
        var headers = dataModel.getHeaders();
        var fields = dataModel.getFields();
        var REGEX_CAMEL_CASE = /([^_A-Z])([A-Z]+)/g;
        this.clearColumns();
        for (var index = 0; index < columnCount; index++) {
            var header = headers[index];
            var column = this.addColumn({ index: index, header: header });
            this.columnEnum[column.name.replace(REGEX_CAMEL_CASE, '$1_$2').toUpperCase()] = index;
            var properties = column.getProperties();
            properties.field = fields[index];
            properties.header = header;
            properties.complexFilter = null;
        }
    },

    getNewDataModel: function() {
        return new DataModelJSON(this.grid);
    },

    applyAnalytics: function() {
        this.dataModel.applyAnalytics();
    },

    /**
     * @memberOf behaviors.JSON.prototype
     * @description Set the header labels.
     * @param {string[]} headerLabels - The header labels.
     */
    setHeaders: function(headerLabels) {
        this.dataModel.setHeaders(headerLabels);
    },

    /**
     * @memberOf behaviors.JSON.prototype
     * @description Set the fields array.
     * @param {string[]} fieldNames - The field names.
     */
    setFields: function(fieldNames) {
        //were defining the columns based on field names....
        //we must rebuild the column definitions
        this.dataModel.setFields(fieldNames);
        this.createColumns();
    },

    /**
     * @memberOf behaviors.JSON.prototype
     * @description Set the data field.
     * @param {object[]} dataRows - An array of uniform objects backing the rows in the grid.
     */
    setData: function(dataRows, options) {
        var self = this,
            grid = this.grid;

        this.dataModel.setData(dataRows, options);
        this.createColumns();

        this.schema = options && options.schema || deriveSchema;
        this.setGlobalFilter(this.getNewFilter());

        if (grid.cellEditor) {
            grid.cellEditor.cancelEditing();
        }

        if (grid.isColumnAutosizing()) {
            setTimeout(function() {
                self.autosizeAllColumns();
            }, 100);
            grid.allowEvents(dataRows.length);
        } else {
            setTimeout(function() {
                self.getColumn(-1).checkColumnAutosizing(true);
                grid.allowEvents(dataRows.length);
            });
        }
    },

    /**
     * @summary Set the top totals.
     * @memberOf behaviors.JSON.p rototype
     * @param {Array<Array>} totalRows - array of rows (arrays) of totals
     */
    setTopTotals: function(totalRows) {
        this.dataModel.setTopTotals(totalRows);
    },

    /**
     * @summary Get the top totals.
     * @memberOf behaviors.JSON.prototype
     * @returns {Array<Array>}
     */
    getTopTotals: function() {
        return this.dataModel.getTopTotals();
    },

    /**
     * @summary Set the bottom totals.
     * @memberOf behaviors.JSON.prototype
     * @param {Array<Array>} totalRows - array of rows (arrays) of totals
     */
    setBottomTotals: function(totalRows) {
        this.dataModel.setBottomTotals(totalRows);
    },

    /**
     * @summary Get the bottom totals.
     * @memberOf behaviors.JSON.prototype
     * @returns {Array<Array>}
     */
    getBottomTotals: function() {
        return this.dataModel.getBottomTotals();
    },

    /**
     * @memberOf behaviors.JSON.prototype
     * @description Build the fields and headers from the supplied column definitions.
     * ```javascript
     * myJsonBehavior.setColumns([
     *     { header: 'Stock Name', name: 'short_description' },
     *     { header: 'Status', name: 'trading_phase' },
     *     { header: 'Reference Price', name: 'reference_price' }
     * ]);
     * ```
     * @param {Array} columnDefinitions - an array of objects with fields 'title', and 'field'
     */
    setColumns: function(columnDefinitions) {
        this.dataModel.setColumns(columnDefinitions); // TODO: this method is missing
    },

    /**
     * @memberOf behaviors.JSON.prototype
     * @description Enhance the double-click event just before it's broadcast to listeners.
     * @param {Point} event
     */
    enhanceDoubleClickEvent: function(event) {
        event.row = this.getRow(event.gridCell.y);
    },

    setDataProvider: function(dataProvider) {
        this.dataModel.setDataProvider(dataProvider);
    },

    hasHierarchyColumn: function() {
        return this.dataModel.hasHierarchyColumn();
    },

    getColumnAlignment: function(x) {
        if (x === 0 && this.hasHierarchyColumn()) {
            return 'left';
        } else {
            return 'center';
        }
    },

    getGroups: function() {
        return this.dataModel.getGroups();
    },
    getAvailableGroups: function() {
        return this.dataModel.getAvailableGroups();
    },
    getHiddenColumns: function() {
        return this.dataModel.getHiddenColumns();
    },

    getActiveColumns: function() {
        return this.dataModel.getActiveColumns();
    },
    getVisibleColumns: function() {
        return this.deprecated('getVisibleColumns()', 'getActiveColumns()', '1.0.6', arguments);
    },

    getSelectedRows: function() {
        var offset = -this.grid.getHeaderRowCount();
        var selections = this.grid.selectionModel.getSelectedRows();
        var result = selections.map(function(each) {
            return each + offset;
        });
        return result;
    },

    getSelectedColumns: function() {
        return this.grid.selectionModel.getSelectedColumns();
    },

    getSelections: function() {
        return this.grid.selectionModel.getSelections();
    },

    getSortedColumnIndexes: function(){
      return this.dataModel.getSortedColumnIndexes();
    },

    sortChanged: function(hiddenColumns){
        var dirty = removeHiddenColumns(
            this.getSortedColumnIndexes(),
            (hiddenColumns || this.getHiddenColumns())
        );
        if (dirty){
            this.applyAnalytics();
        }
    }

});


function deriveSchema() {
    return new ColumnSchemaFactory(this.columns).schema;
}


//Logic to moved to adapter layer outside of Hypergrid Core
function removeHiddenColumns(oldSorted, hiddenColumns){
    var dirty = false;
    oldSorted.forEach(function(i) {
        var j = 0,
            colIndex;
        while (j < hiddenColumns.length) {
            colIndex = hiddenColumns[j].index + 1; //hack to get around 0 index
            if (colIndex === i) {
                hiddenColumns[j].unSort();
                dirty = true;
                break;
            }
            j++;
        }
    });
    return dirty;
}

module.exports = JSON;

},{"../Shared.js":55,"../dataModels/JSON":85,"../features":109,"../filter/ColumnSchemaFactory":110,"./Local":59}],59:[function(require,module,exports){
'use strict';

//var ListDragon = require('list-dragon');

var Behavior = require('./Behavior');
//var DataModelJSON = require('../dataModels/JSON');
//var features = require('../features');
//var aggregations = require('../local_node_modules/finanalytics').aggregations;

/**
 * @name behaviors.Local
 * @desc > Same parameters as {@link behaviors.Behavior#initialize|initialize}, which is called by this constructor.
 * @constructor
 * @extends Behavior
 */
var Local = Behavior.extend('Local', {

});

module.exports = Local;

},{"./Behavior":56}],60:[function(require,module,exports){
'use strict';

var Behavior = require('./Behavior');

var noop = function() {},
    n00p = function() { return 0; };

/**
 * @constructor
 * @extends Behavior
 */
var Null = Behavior.extend('Null', {

    //initalize: function(grid, component) {},

    setScrollPositionY: noop,
    setScrollPositionX: noop,
    getActiveColumnCount: n00p,
    getFixedColumnCount: n00p,
    getFixedColumnsWidth: n00p,
    getFixedColumnsMaxWidth: n00p,
    setRenderedWidth: n00p,
    getRowCount: n00p,
    getFixedRowCount: n00p,
    getFixedRowsHeight: n00p,
    getFixedRowsMaxHeight: n00p,
    setRenderedHeight: n00p,
    getCellProvider: noop,
    click: noop,
    doubleClick: noop
});

module.exports = Null;

},{"./Behavior":56}],61:[function(require,module,exports){
'use strict';

module.exports = {
    Behavior: require('./Behavior'), // abstract base class
    JSON: require('./JSON'),
    Null: require('./Null')
};
},{"./Behavior":56,"./JSON":58,"./Null":60}],62:[function(require,module,exports){
/* eslint-env browser */

'use strict';

var mustache = require('mustache');
var _ = require('object-iterators');

var Base = require('../lib/Base');
var effects = require('../lib/effects');
var Localization = require('../lib/Localization');

/**
 * @constructor
 */
var CellEditor = Base.extend('CellEditor', {

    /**
     * @param grid
     * @param {string} options - Properties listed below + arbitrary mustache "variables" for merging into template.
     * @param {Point} options.editPoint
     * @param {string} [options.format] - Name of a localizer with which to override prototype's `localizer` property.
     */
    initialize: function(grid, options) {

        // Establish `this.editPoint` and possibly `this.format`; plus other arbitrary properties for mustache use.
        for (var key in options) {
            if (options.hasOwnProperty(key) && this[key] !== null) {
                this[key] = options[key];
            }
        }

        var value = grid.behavior.getValue(this.editPoint.x, this.editPoint.y);
        if (value instanceof Array) {
            value = value[1]; //it's a nested object
        }

        /**
         * my instance of hypergrid
         * @type {Hypergrid}
         * @memberOf CellEditor.prototype
         */
        this.grid = grid;

        this.grid.cellEditor = this;

        this.locale = grid.localization.locale; // for template's `lang` attribute

        // override native localizer with localizer named in format if defined (from instantiation options)
        if (this.format) {
            this.localizer = this.grid.localization.get(this.format);
        }

        this.initialValue = value;

        var container = document.createElement('DIV');
        container.innerHTML = mustache.render(this.template, this);

        /**
         * This object's input control, one of:
         * * *input element* - an `HTMLElement` that has a `value` attribute, such as `HTMLInputElement`, `HTMLButtonElement`, etc.
         * * *container element* - an `HTMLElement` containing one or more input elements, only one of which contains the editor value.
         *
         * For access to the input control itself (which may or may not be the same as `this.el`), see `this.input`.
         *
         * @type {HTMLElement}
         * @default null
         * @memberOf CellEditor.prototype
         */
        this.el = container.firstChild;

        this.input = this.el;

        this.errors = 0;

        var self = this;
        this.el.addEventListener('keyup', this.keyup.bind(this));
        this.el.addEventListener('keydown', function(e) {
            grid.fireSyntheticEditorKeyDownEvent(self, e);
        });
        this.el.addEventListener('keypress', function(e) {
            grid.fireSyntheticEditorKeyPressEvent(self, e);
        });
        this.el.onblur = function(e) {
            self.cancelEditing();
        };
    },

    localizer: Localization.prototype.null,

    specialKeyups: {
        //0x08: 'clearStopEditing', // backspace
        0x09: 'stopEditing', // tab
        0x0d: 'stopEditing', // return/enter
        0x1b: 'cancelEditing' // escape
    },

    keyup: function(e) {
        if (e) {
            var specialKeyup = this.specialKeyups[e.keyCode];

            if (specialKeyup) {
                e.preventDefault();
                if (this[specialKeyup](3)) {
                    this.grid.repaint();
                    this.grid.takeFocus();
                }
            }

            this.grid.fireSyntheticEditorKeyUpEvent(this, e);
        }
    },

    /**
     * if true, check that the editor is in the right location
     * @type {boolean}
     * @default false
     * @memberOf CellEditor.prototype
     */
    checkEditorPositionFlag: false,

    /**
     * @memberOf CellEditor.prototype
     * @desc This function is a callback from the fin-hypergrid.   It is called after each paint of the canvas.
     */
    gridRenderedNotification: function() {
        this.checkEditor();
    },

    /**
     * @memberOf CellEditor.prototype
     * @desc scroll values have changed, we've been notified
     */
    scrollValueChangedNotification: function() {
        this.checkEditorPositionFlag = true;
    },

    /**
     * @memberOf CellEditor.prototype
     * @desc move the editor to the current editor point
     */
    moveEditor: function() {
        var cellBounds = this.grid._getBoundsOfCell(this.editPoint.x, this.editPoint.y);

        //hack to accommodate bootstrap margin issues...
        var xOffset =
            this.grid.div.getBoundingClientRect().left -
            this.grid.divCanvas.getBoundingClientRect().left;

        cellBounds.x -= xOffset;

        this.setBounds(cellBounds);
    },

    beginEditing: function() {
        if (this.grid.fireRequestCellEdit(this.editPoint, this.initialValue)) {
            this.checkEditorPositionFlag = true;
            this.checkEditor();
        }
    },
    beginEditAt: function(Constructor, name) {
        return this.deprecated('beginEditAt(point)', 'beginEditing()', '1.0.6');
    },

    /**
     * @summary Put the value into our editor.
     * @desc Formats the value and displays it.
     * The localizer's {@link localizerInterface#format|format} method will be called.
     *
     * Override this method if your editor has additional or alternative GUI elements.
     *
     * @param {object} value - The raw unformatted value from the data source that we want to edit.
     * @memberOf CellEditor.prototype
     */
    setEditorValue: function(value) {
        this.input.value = this.localizer.format(value);
    },

    /**
     * @memberOf CellEditor.prototype
     * @desc display the editor
     */
    showEditor: function() {
        this.el.style.display = 'inline';
    },

    /**
     * @memberOf CellEditor.prototype
     * @desc hide the editor
     */
    hideEditor: function() {
        this.el.style.display = 'none';
    },

    /** @summary Stops editing.
     * @desc Before saving, validates the edited value in two phases as follows:
     * 1. Call `validateEditorValue`. (Calls the localizer's `invalid()` function, if available.)
     * 2. Catch any errors thrown by the {@link CellEditor#getEditorValue|getEditorValue} method.
     *
     * **If the edited value passes both phases of the validation:**
     * Saves the edited value by calling the {@link CellEditor#saveEditorValue|saveEditorValue} method.
     *
     * **On validation failure:**
     * 1. If `feedback` was omitted, cancels editing, discarding the edited value.
     * 2. If `feedback` was provided, gives the user some feedback (see `feedback`, below).
     *
     * @param {number} [feedback] What to do on validation failure:
     * * If omitted, simply cancels editing without saving edited value.
     * * If 0, shows the error feedback effect (see the {@link CellEditor#errorEffect|errorEffect} property).
     * * If > 0, shows the error feedback effect _and_ calls the {@link CellEditor#errorEffectEnd|errorEffectEnd} method) every `feedback` call(s) to `stopEditing`.
     * @returns {boolean} Truthy means successful stop. Falsy means syntax error prevented stop. Note that editing is canceled when no feedback requested and successful stop includes (successful) cancel.
     * @memberOf CellEditor.prototype
     */
    stopEditing: function(feedback) {
        /**
         * @type {boolean|string|Error}
         */
        var error = this.validateEditorValue();

        if (!error) {
            try {
                var value = this.getEditorValue();
            } catch (err) {
                error = err;
            }
        }

        if (!error && this.grid.fireSyntheticEditorDataChangeEvent(this, this.initialValue, value)) {
            try {
                this.saveEditorValue(value);
            } catch (err) {
                error = err;
            }
        }

        if (!error) {
            this.hideEditor();
            this.grid.cellEditor = null;
            this.el.remove();
        } else if (feedback >= 0) { // never true when `feedback` undefined
            var point = this.editPoint;
            this.grid.selectViewportCell(point.x, point.y - this.grid.getHeaderRowCount());
            this.errorEffectBegin(++this.errors % feedback === 0 && error);
        } else { // invalid but no feedback
            return this.cancelEditing();
        }

        return !error;
    },

    /** @summary Cancels editing.
     * @returns {boolean} Successful. (Cancel is always successful.)
     */
    cancelEditing: function() {
        if (this.grid.cellEditor) { // because stopEditing's .remove triggers blur which comes here
            this.setEditorValue(this.initialValue);
            this.hideEditor();
            this.grid.cellEditor = null;
            this.el.remove();
        }
        return true;
    },

    /**
     * Calls the effect function indicated in the {@link CellEditor#errorEffect|errorEffect} property which triggers a series of CSS transitions.
     * @param {boolean|string|Error} [error] - If defined, call the {@link CellEditor#errorEffectEnd|errorEffectEnd} method at the end of the last effect transition with this error.
     * @memberOf CellEditor.prototype
     */
    errorEffectBegin: function(error) {
        var options = { callback: error && this.errorEffectEnd.bind(this, error) },
            effect = this.errorEffect;

        if (typeof effect === 'string') {
            effect = this.errorEffects[effect];
        }

        if (typeof effect === 'object') {
            _(options).extendOwn(effect.options);
            effect = effect.effector;
        }

        if (typeof effect === 'function') {
            effect.call(this, options);
        } else {
            throw 'Expected `this.errorEffect` to resolve to an error effect function.';
        }
    },

    /**
     * This function expects to be passed an error. There is no point in calling this function if there is no error. Nevertheless, if called with a falsy `error`, returns without doing anything.
     * @this {CellEditor}
     * @param {boolean|string|Error} [error]
     */
    errorEffectEnd: function(error) {
        if (error) {
            var msg =
                'Invalid value. To resolve, do one of the following:\n\n' +
                '   * Correct the error and try again.\n' +
                '         - or -\n' +
                '   * Cancel editing by pressing the "esc" (escape) key.';

            error = error.message || error;

            if (typeof error !== 'string') {
                error = '';
            }

            if (this.localizer.expectation) {
                error = error ? error + '\n' + this.localizer.expectation : this.localizer.expectation;
            }

            if (error) {
                error = '\n' + error;
                error = error.replace(/[\n\r]+/g, '\n\n   * ');
                msg += '\n\nAdditional information about this error:' + error;
            }

            alert(msg); // eslint-disable-line no-alert
        }
    },

    /** @typedef effectObject
     * @property {effectFunction} effector
     * @property {object} [options] - An options object with which to call the function.
     */
    /**
     * May be one of:
     * * **string** - Name of registered error effect.
     * * **effectFunction** - Reference to an effect function.
     * * **effectObject** - Reference to an effectObject containing an {@link effectFunction} and an `options` object with which to call the function.
     * @type {string|effectFunction|effectObject}
     * @memberOf CellEditor.prototype
     */
    errorEffect: 'shaker',

    /**
     * Hash of registered {@link effectFunction}s or {@link effectObject}s.
     * @memberOf CellEditor.prototype
     */
    errorEffects: {
        shaker: effects.shaker,
        glower: effects.glower
    },

    /**
     * @desc save the new value into the behavior (model)
     * @memberOf CellEditor.prototype
     */
    saveEditorValue: function(value) {
        var point = this.editPoint;

        if (
            !(value && value === this.initialValue) && // data changed
            this.grid.fireBeforeCellEdit(point, this.initialValue, value, this) // not aborting
        ) {
            this.grid.behavior.setValue(point.x, point.y, value);
            this.grid.fireAfterCellEdit(point, this.initialValue, value, this);
        }
    },

    /**
     * @summary Extract the edited value from the editor.
     * @desc De-format the edited string back into a primitive value.
     *
     * The localizer's {@link localizerInterface#parse|parse} method will be called on the text box contents.
     *
     * Override this method if your editor has additional or alternative GUI elements. The GUI elements will influence the primitive value, either by altering the edited string before it is parsed, or by transforming the parsed value before returning it.
     * @returns {object} the current editor's value
     * @memberOf CellEditor.prototype
     */
    getEditorValue: function() {
        return this.localizer.parse(this.input.value);
    },

    /**
     * If there is no validator on the localizer, returns falsy (not invalid; possibly valid).
     * @returns {boolean|string} Truthy value means invalid. If a string, this will be an error message. If not a string, it merely indicates a generic invalid result.
     */
    validateEditorValue: function() {
        return this.localizer.invalid && this.localizer.invalid(this.input.value);
    },

    /**
     * @summary Request focus for my input control.
     * @desc See GRID-95 "Scrollbar moves inward" for issue and work-around explanation.
     * @memberOf CellEditor.prototype
     */
    takeFocus: function() {
        var el = this.el,
            leftWas = el.style.left,
            topWas = el.style.top;

        el.style.left = el.style.top = 0; // work-around: move to upper left

        this.input.focus();
        this.selectAll();

        el.style.left = leftWas;
        el.style.top = topWas;
    },

    /**
     * @memberOf CellEditor.prototype
     * @desc select everything
     */
    selectAll: nullPattern,

    /**
     * @memberOf CellEditor.prototype
     * @desc set the bounds of my input control
     * @param {rectangle} rectangle - the bounds to move to
     */
    setBounds: function(cellBounds) {
        var input = this.el;

        input.style.position = 'absolute';
        input.style.left = px(cellBounds.x - 1);
        input.style.top = px(cellBounds.y - 1);
        input.style.width = px(cellBounds.width + 2);
        input.style.height = px(cellBounds.height + 2);
    },

    /**
     * @desc check that the editor is in the correct location, and is showing/hidden appropriately
     * @memberOf CellEditor.prototype
     */
    checkEditor: function() {
        if (this.checkEditorPositionFlag) {
            this.checkEditorPositionFlag = false;
            if (this.grid.isDataVisible(this.editPoint.x, this.editPoint.y)) {
                this.setEditorValue(this.initialValue);
                this.attachEditor();
                this.moveEditor();
                this.showEditor();
                this.takeFocus();
            } else {
                this.hideEditor();
            }
        }
    },

    attachEditor: function() {
        var input = this.el,
            div = this.grid.div,
            referenceNode = div.querySelectorAll('.finbar-horizontal, .finbar-vertical');

        div.insertBefore(input, referenceNode.length ? referenceNode[0] : null);
    },

    template: ''

});

function nullPattern() {}
function px(n) { return n + 'px'; }


CellEditor.abstract = true; // don't instantiate directly


module.exports = CellEditor;

},{"../lib/Base":113,"../lib/Localization":114,"../lib/effects":119,"mustache":45,"object-iterators":46}],63:[function(require,module,exports){
'use strict';

var CellEditor = require('./CellEditor');

/**
 * As of spring 2016:
 * Functions well in Chrome and Firefox; unimplemented in Safari.
 * @constructor
 * @extends CellEditor
 */
var Color = CellEditor.extend('Color', {

    template: '<input type="color" lang="{{locale}}" style="{{style}}">'

});

module.exports = Color;

},{"./CellEditor":62}],64:[function(require,module,exports){
// ComboBox.js - A combo-box is a combination of a text-box and a drop-down.
// User may type into it and/or select an item from the drop-down (by clicking on the triangle at the right).
// The drop-down has sections which are toggled from a control area between the text-box and the drop-down.

/* eslint-env browser */

'use strict';

var Textfield = require('./Textfield');
var prototype = require('./CellEditor').prototype;
var Queueless = require('../lib/queueless');
var elfor = require('../lib/elfor');

/*********************************/
/* eslint-disable no-unused-vars */
/*********************************/

var TOGGLE_MODE_PREFIX = 'toggle-mode-';

var stateToActionMap = {
    hidden: slideDown,
    visible: slideUp
};

/**
 * A combo box is a text box that also has a drop-down containing options. The drop-down consists of an actual drop-down list (a `<select>` list) plus a _control area_ above it containing toggles. The toggles control the visibility of the various "mode lists."
 *
 * Functions well in Chrome, Safari, Firefox, and Internet Explorer.
 * @constructor
 * @extends Textfield
 */
var ComboBox = Textfield.extend('ComboBox', {

    initialize: function() {
        var el = this.el;

        this.input = el.querySelector('input');
        this.dropper = el.querySelector('span');
        this.options = el.querySelector('div');
        this.controls = this.options.querySelector('div');
        this.dropdown = this.options.querySelector('select');

        this.controllable = this.modes.length > 1;

        // set up a transition end controller
        this.optionsTransition = new Queueless(this.options, this);

        this.menuModesSource = this.column.menuModes || { distinctValues: true };

        // wire-ups
        this.dropper.addEventListener('mousedown', this.toggleDropDown.bind(this));
        this.dropdown.addEventListener('mousewheel', function(e) { e.stopPropagation(); });
        this.dropdown.addEventListener('change', this.insertText.bind(this));
        el.onblur = null; // void this one, set by super's initialize
    },

    template: [
'<div class="hypergrid-input" title="">',
'    <input type="text" lang="{{locale}}" style="{{style}}">',
'    <span title="Click for options"></span>',
'    <div>',
'        <div></div>',
'        <select size="12" lang="{{locale}}"></select>',
'    </div>',
'</div>'
    ].join('\n'),

    modes: [
        {
            name: 'distinctValues',
            appendOptions: function(optgroup) {
                // get the distinct column values and sort them
                var distinct = {},
                    d = [],
                    columnName = this.column.name,
                    formatter = this.column.getFormatter();

                this.grid.behavior.getData().forEach(function(dataRow) {
                    var val = formatter(dataRow[columnName]);
                    distinct[val] = (distinct[val] || 0) + 1;
                });

                for (var key in distinct) {
                    d.push(key);
                }

                while (optgroup.firstElementChild) {
                    optgroup.firstElementChild.remove();
                }

                d.sort().forEach(function(val) {
                    var option = new Option(val + ' (' + distinct[val] + ')', val);
                    optgroup.appendChild(option);
                });

                return d.length;
            }
        }
    ],

    showEditor: function() {
        var menuModesSource = this.menuModesSource,
            menuModes = this.menuModes = {};

        // build the proxy
        this.modes.forEach(function(mode) {
            var modeName = mode.name;
            if (modeName in menuModesSource) {
                menuModes[modeName] = menuModesSource[modeName];
            }
        });

        // wire-ups
        if (this.controllable) {
            this.controls.addEventListener('click', onModeIconClick.bind(this));
        }

        // set the initial state of the mode toggles
        this.modes.forEach(function(mode) {
            // create a toggle
            var toggle = document.createElement('span');
            if (this.controllable) {
                toggle.className = TOGGLE_MODE_PREFIX + mode.name;
                toggle.title = 'Toggle ' + (mode.label || mode.name).toLowerCase();
                toggle.textContent = mode.symbol;
            }
            this.controls.appendChild(toggle);

            // create and label a new optgroup
            if (mode.selector) {
                var optgroup = document.createElement('optgroup');
                optgroup.label = mode.label;
                optgroup.className = 'submenu-' + mode.name;
                optgroup.style.backgroundColor = mode.backgroundColor;
                this.dropdown.add(optgroup);
            }

            setModeIconAndOptgroup.call(this, toggle, mode.name, menuModes[mode.name]);
        }.bind(this));

        prototype.showEditor.call(this);
    },

    hideEditor: function() {
        // this is where you would persist this.menuModes
        prototype.hideEditor.call(this);
    },

    toggleDropDown: function() {
        if (!this.optionsTransition.transitioning) {
            var state = window.getComputedStyle(this.dropdown).visibility;
            stateToActionMap[state].call(this);
        }
    },

    insertText: function(e) {
        // replace the input text with the drop-down text
        this.input.focus();
        this.input.value = this.dropdown.value;
        this.input.setSelectionRange(0, this.input.value.length);

        // close the drop-down
        this.toggleDropDown();
    }
});

function onModeIconClick(e) {
    var ctrl = e.target;

    if (ctrl.tagName === 'SPAN') {
        // extra ct the mode name from the toggle control's class name
        var modeClassName = Array.prototype.find.call(ctrl.classList, function(className) {
                return className.indexOf(TOGGLE_MODE_PREFIX) === 0;
            }),
            modeName = modeClassName.substr(TOGGLE_MODE_PREFIX.length);

        // toggle mode in the filter
        var modeState = this.menuModes[modeName] ^= 1;

        setModeIconAndOptgroup.call(this, ctrl, modeName, modeState);
    }
}

function setModeIconAndOptgroup(ctrl, name, state) {
    var style, optgroup, sum, display,
        mode = this.modes.find(function(mode) { return mode.name === name; }); // eslint-disable-line no-shadow

    // set icon state (color)
    ctrl.classList.toggle('active', !!state);

    // empty the optgroup if hiding; rebuild it if showing
    if (state) { // rebuild it
        // show progress cursor for (at least) 1/3 second
        style = this.el.style;
        style.cursor = 'progress';
        setTimeout(function() { style.cursor = null; }, 333);

        if (mode.selector) {
            optgroup = this.dropdown.querySelector(mode.selector);
            sum = mode.appendOptions.call(this, optgroup);

            // update sum
            optgroup.label = optgroup.label.replace(/ \(\d+\)$/, ''); // remove old sum
            optgroup.label += ' (' + sum + ')';
        } else {
            sum = mode.appendOptions.call(this, this.dropdown);
            if (!this.controllable) {
                ctrl.textContent = sum + ' values';
            }
        }

        display = null;
    } else {
        display = 'none';
    }

    // hide/show the group
    elfor.each(
        mode.selector || ':scope>option,:scope>optgroup:not([class])',
        function iteratee(el) { el.style.display = display; },
        this.dropdown
    );

    // TODO: Reset the width of this.options to the natural width of this.dropdown. To do this, we need to remove the latter's "width: 100%" from the CSS and then set an explicit this.options.style.width based on the computed width of this.dropdown. This is complicated by the fact that it cannot be done before it is in the DOM.
}

function slideDown() {
    // preserve the text box's current text selection, which is about to be lost
    this.selectionStart = this.input.selectionStart;
    this.selectionEnd = this.input.selectionEnd;

    // clean up the select list from last usage
    this.dropdown.selectedIndex = -1; // be kind (remove previous selection)
    this.dropdown.style.scrollTop = 0; // rewind

    // show the drop-down slide down effect
    this.options.style.visibility = 'visible';
    var dropDownHeight = this.dropdown.size * 15;
    this.options.style.height = 2 + 15 + dropDownHeight + 2 + 'px'; // starts the slide down effect

    // while in drop-down, listen for clicks in text box which means abprt
    this.input.addEventListener('mousedown', this.slideUpBound = slideUp.bind(this));

    // wait for transition to end
    this.optionsTransition.begin();
}

function slideUp() {
    // stop listening to input clicks
    this.input.removeEventListener('mousedown', this.slideUpBound);

    // start the slide up effect
    this.options.style.height = 0;

    // schedule the hide to occur after the slide up effect
    this.optionsTransition.begin(function(event) {
        this.style.visibility = 'hidden';
    });
}


module.exports = ComboBox;

},{"../lib/elfor":120,"../lib/queueless":123,"./CellEditor":62,"./Textfield":70}],65:[function(require,module,exports){
/* eslint-env browser */

'use strict';

var CellEditor = require('./CellEditor');

var isChromium = window.chrome,
    winNav = window.navigator,
    vendorName = winNav.vendor,
    isOpera = winNav.userAgent.indexOf('OPR') > -1,
    isIEedge = winNav.userAgent.indexOf('Edge') > -1,
    isIOSChrome = winNav.userAgent.match('CriOS'),
    isChrome = !isIOSChrome &&
        isChromium !== null &&
        isChromium !== undefined &&
        vendorName === 'Google Inc.' &&
        isOpera == false && isIEedge == false; // eslint-disable-line eqeqeq

/**
 * As of spring 2016:
 * Functions well in Chrome except no localization (day, month names; date format).
 * Unimplemented in Safari, Firefox, Internet Explorer.
 * This is a "snmart" control. It detects Chrome:
 * * If Chrome, uses chromeDate overrides format to that required by the value attribute, yyyy-mm-dd. (Note that this is not the format displayed in the control, which is always mm/dd/yyyy.)
 * * Otherwise uses localized date format _but_ falls back to a regular text box.
 * @constructor
 * @extends CellEditor
 */
var Date = CellEditor.extend('Date', {

    initialize: function(grid) {

        var localizerName,
            usesDateInputControl = isChrome;

        if (usesDateInputControl) {
            localizerName = 'chromeDate';
            this.template = '<input type="date">';
        } else {
            localizerName = 'date';
            this.template = '<input type="text">';

            this.selectAll = function() {
                var lastCharPlusOne = this.getEditorValue().length;
                this.input.setSelectionRange(0, lastCharPlusOne);
            };
        }

        this.localizer = grid.localization.get(localizerName);
    }
});


module.exports = Date;

},{"./CellEditor":62}],66:[function(require,module,exports){
/* eslint-env browser */

'use strict';

var popMenu = require('pop-menu');
var Conditionals = require('../Shared').FilterTree.Conditionals;

var ComboBox = require('./ComboBox');
var prototype = require('./CellEditor').prototype;


/**
 * The select list consists of the following sets of drop-down items:
 * * `operators` (icon *&lt;*) The particular selection of operators for this column. Comes from the filter tree.
 * * `distinctValues` (icon *#*) List of distinct column values. Calculated from inspection of column values on _and_ on icon click.
 * * `columnNames` (icon *T*) List other column names. Calculated from inspection of column values on _and_ on icon click.
 *
 * The control area reflects the `this.modes` array (above). It is modeled by a 'menuModes` object, a hash with boolean properties representing the state of each of the sets of menu items outlined above. Missing properties are falsy by implication. The state semantics are:
 *   * `1` or `true` means adds CSS class `active` to icon _and_ shows set's items in drop-down.
 *   * `0` or `false` means removes (CSS class `active` from icon _and_ hides set's items in drop-down.
 *
 * *Persisting changes:* The only change this UI supports (besides the filter text itself) is the menu mode states, which are expected to be "sticky." That is, they are "persisted" (written back) to the filter. However, there is a problem: When the column filter is blank it doesn't actually exist yet in the filter, so there is nowhere to save it. The solution is to read the `menuModes` hash _from_ the filter tree but don't modify it until end of editing. Reading it from the filter tree picks up previous setting if there was an extant column filter or the default if there was not. But then, rather than modifying this structure (because it might be the default and we don't want to overwrite that), we hang a proxy copy off the behavior's column object for this column. This will persist it for the duration of the app session. At end of editing, if and only if there is now a column filter (text is not blank), we copy it to the column filter's subtree node in the filter tree.
 *
 * @constructor
 * @extends ComboBox
 */
var FilterBox = ComboBox.extend('FilterBox', {

    initialize: function() {

        // look in the filter, under column filters, for a column filter for this column
        var root = this.grid.getGlobalFilter(),
            columnName = this.column.name,
            columnFilters = this.grid.getGlobalFilter().columnFilters,
            columnFilterSubtree = root.getColumnFilter(columnName) || {},
            columnSchema = root.schema.lookup(columnName) || {};


        // get the operator list from the node, schema, typeOpMap, or root:
        // (This mimics the code in FilterLeaf.js's `getOpMenu` function becauase the node may not exist yet.)
        this.opMenu =

            // pull operator list from column schema if available
            columnSchema.opMenu ||

            // operator list for the column's type if available
            root.typeOpMap && root.typeOpMap[columnSchema.type || columnFilterSubtree.type] ||

            // default operator list (which itself defaults to `Conditionals.defaultOpMenu`)
            root.opMenu;


        // get the column filter's `menuModes` object -- contains the states of the drop-down option icons:
        this.menuModesSource =

            // first try proxy from last time (because editing may have ended without a column filter to put in the filter tree)
            this.column.menuModes ||

            // ELSE try column filter's `menuModes` WHEN available
            columnFilterSubtree.menuModes ||
            columnFilterSubtree.menuModes ||

            // try use column schema's `menuModes` when defined
            columnSchema.menuModes ||

            // ELSE try the filter default (which itself defaults to operators ON, others OFF; see definition at top of DefaultFilter.js)
            columnFilters.menuModes;

    },


    /**
     * When there's only one mode defined here, the control area portion of the UI is hidden.
     */
    modes: [
        {
            name: 'operators',
            symbol: '<',
            appendOptions: function(dropdown) {
                if (!dropdown.length) {
                    // Various  operator options and/or optgroups vary per column based on `opMenu`.
                    popMenu.build(dropdown, this.opMenu, {
                        group: function(groupName) {
                            return Conditionals.groups[groupName];
                        },
                        prompt: null
                    });
                    // This list of conjunctions is an extra and is for all columns. All operator optgroups are classless.
                    var optgroup = document.createElement('optgroup');
                    optgroup.label = 'Conjunctions';
                    optgroup.appendChild(new Option('and', ' and '));
                    optgroup.appendChild(new Option('or', ' or '));
                    optgroup.appendChild(new Option('nor', ' nor '));
                }
            }
        }, {
            name: 'columnNames',
            label: 'Column Names',
            selector: 'optgroup.submenu-columnNames',
            symbol: 'A',
            backgroundColor: '#eff',
            appendOptions: function(optgroup) {
                var columns = this.grid.behavior.columns,
                    x = this.editPoint.x;

                while (optgroup.firstElementChild) {
                    optgroup.firstElementChild.remove();
                }

                columns.forEach(function(column, index) {
                    if (index !== x) {
                        var name = column.name,
                            option = new Option(name);
                        option.title = '[' + name + ']\r"' + column.header + '"';
                        optgroup.appendChild(option);
                    }
                });
                return columns.length;
            }
        }, {
            name: 'distinctValues',
            label: 'Distinct Values',
            selector: 'optgroup.submenu-distinctValues',
            symbol: '#',
            backgroundColor: '#fef',
            appendOptions: ComboBox.prototype.modes[0].appendOptions
        }
    ],

    /**
     * Write the `menuModes` proxy to the filter tree's column filter subtree node.
     * We look up the node again here because it might be new; or may have been deleted & recreated during editing.
     */
    hideEditor: function() {
        // look in the filter, under column filters, for a column filter for this column
        var filter = this.grid.getGlobalFilter(),
            columnName = this.column.name,
            columnFilterSubtree = filter.getColumnFilter(columnName);

        if (columnFilterSubtree) {
            // write back to filter-tree node for persisting with getState
            columnFilterSubtree.menuModes = this.menuModes;
        }

        this.column.menuModes = this.menuModes;

        ComboBox.prototype.hideEditor.call(this);
    },

    keyup: function(e) {
        if (e) {
            prototype.keyup.call(this, e);

            if (this.grid.resolveProperty('filteringMode') === 'immediate') {
                this.saveEditorValue(this.getEditorValue());
                this.moveEditor();
            }
        }
    },

    insertText: function(e) {
        // insert the drop-downb text at the insertion point or over the selected text
        this.input.focus();
        this.input.setRangeText(this.dropdown.value, this.selectionStart, this.selectionEnd, 'end');

        // close the drop-down
        this.toggleDropDown();
    }

});


module.exports = FilterBox;

},{"../Shared":55,"./CellEditor":62,"./ComboBox":64,"pop-menu":47}],67:[function(require,module,exports){
'use strict';

var Textfield = require('./Textfield');

/**
 * Functions well in Chrome, Safari, Firefox, and Internet Explorer.
 * @constructor
 * @extends Textfield
 */
var Number = Textfield.extend('Number', {

    initialize: function(grid) {
        this.localizer = grid.localization.get('number');
    }

});

module.exports = Number;

},{"./Textfield":70}],68:[function(require,module,exports){
'use strict';

var CellEditor = require('./CellEditor');

/**
 * @constructor
 * @extends CellEditor
 */
var Slider = CellEditor.extend('Slider', {

    template: '<input type="range" lang="{{locale}}" style="{{style}}">'

});

module.exports = Slider;

},{"./CellEditor":62}],69:[function(require,module,exports){
'use strict';

var CellEditor = require('./CellEditor.js');

/**
 * @constructor
 * @extends CellEditor
 */
var Spinner = CellEditor.extend('Spinner', {

    template: '<input type="number" lang="{{locale}}" style="{{style}}">'

});

module.exports = Spinner;

},{"./CellEditor.js":62}],70:[function(require,module,exports){
'use strict';

var CellEditor = require('./CellEditor.js');
var Localization = require('../lib/Localization');


/**
 * As of spring 2016:
 * Functions well in Chrome, Safari, Firefox, and Internet Explorer.
 * @constructor
 * @extends CellEditor
 */
var Textfield = CellEditor.extend('Textfield', {

    template: '<input type="text" lang="{{locale}}" style="{{style}}">',

    localizer: Localization.prototype.string,

    selectAll: function() {
        var lastCharPlusOne = this.getEditorValue().length;
        this.input.setSelectionRange(0, lastCharPlusOne);
    }
});

module.exports = Textfield;

},{"../lib/Localization":114,"./CellEditor.js":62}],71:[function(require,module,exports){
/**
 * @module cellEditors
 */

'use strict';

/**
 *
 * @param {Hypergrid} grid
 * @param {boolean} [privateRegistry=false] - This instance will use a private registry.
 * @constructor
 */
function CellEditors(grid, privateRegistry) {
    this.grid = grid;

    if (privateRegistry) {
        this.editors = {};
    }

    // preregister the standard cell editors
    if (privateRegistry || !this.get('celleditor')) {
        this.add(require('./CellEditor'));
        this.add(require('./ComboBox'));
        this.add(require('./Color'));
        this.add(require('./Date'));
        this.add(require('./FilterBox'));
        this.add(require('./Number'));
        this.add(require('./Slider'));
        this.add(require('./Spinner'));
        this.add(require('./Textfield'));
    }
}

CellEditors.prototype = {
    constructor: CellEditors.prototype.constructor, // preserve constructor

    /**
     * @summary Register a cell editor constructor.
     * @desc Adds a custom cell editor constructor to the `editors` hash using the provided name (or the class name), converted to all lower case.
     *
     * > All native cell editors are "preregistered" in `editors`..
     *
     * @param {string} [name] - Case-insensitive editor key. If not given, `YourCellEditor.prototype.$$CLASS_NAME` is used.
     *
     * @param {YourCellEditor.prototype.constructor} Constructor - A constructor, typically extended from `CellEditor` (or a descendant therefrom).
     *
     * > Note: `$$CLASS_NAME` can be easily set up by providing a string as the (optional) first parameter (`alias`) in your {@link https://www.npmjs.com/package/extend-me|CellEditor.extend} call.
     *
     * @returns {CellEditor} A newly registered constructor extended from {@link CellEditor}.
     *
     * @memberOf module:cellEditors
     */
    add: function(name, Constructor) {
        if (typeof name === 'function') {
            Constructor = name;
            name = undefined;
        }

        name = name || Constructor.prototype.$$CLASS_NAME;
        name = name && name.toLowerCase();
        this.editors[name] = Constructor;
        return Constructor;
    },

    /**
     * @summary Register a synonym for an existing cell editor constructor.
     * @param {string} synonymName
     * @param {string} existingName
     * @returns {CellEditor} The previously registered constructor this new synonym points to.
     * @memberOf CellEditors.prototype
     */
    addSynonym: function(synonymName, existingName) {
        var cellEditor = this.get(existingName);
        return (this.editors[synonymName] = cellEditor);
    },

    /**
     * @param {string} name - Name of a registered editor.
     * @returns {CellEditor} A registered constructor extended from {@link CellEditor}.
     * @memberOf CellEditors.prototype
     */
    get: function(name) {
        return this.editors[name && name.toLowerCase()];
    },

    /**
     * @summary Lookup registered cell editor and return a new instance thereof.
     * @desc Note: Must be called with the Hypergrid object as context!
     * @returns {CellEditor} New instance of the named cell editor.
     * @param {string} name - Name of a registered editor.
     * @param {string} [options] - Properties to add to the instantiated editor primarily for mustache's use.
     * @memberOf CellEditors.prototype
     */
    create: function(name, options) {
        var cellEditor,
            Constructor = this.get(name);

        if (Constructor) {
            if (Constructor.abstract) {
                throw 'Attempt to instantiate an "abstract" cell editor class.';
            }
            cellEditor = new Constructor(this.grid, options);
        }

        return cellEditor;
    },

    /**
     * The cell editor registry containing all the "preregistered" cell editor constructors.
     * @private
     * @memberOf CellEditors.prototype
     */
    editors: {}
};

module.exports = CellEditors;

},{"./CellEditor":62,"./Color":63,"./ComboBox":64,"./Date":65,"./FilterBox":66,"./Number":67,"./Slider":68,"./Spinner":69,"./Textfield":70}],72:[function(require,module,exports){
'use strict';

var CellRenderer = require('./CellRenderer');

/**
 * @constructor
 * @extends CellRenderer
 */
var Button = CellRenderer.extend('Button', {

    /**
     * @summary The default cell rendering function for a button cell.
     * @param {CanvasGraphicsContext} gc
     * @param {object} config
     * @param {Rectangle} config.bounds - The clipping rect of the cell to be rendered.
     * @param {number} config.x - the "translated" index into the `behavior.allColumns` array
     * @param {number} config.normalizedY - the vertical grid coordinate normalized to first data row
     * @param {number} config.untranslatedX - the horizontal grid coordinate measured from first data column
     * @param {number} config.y - the vertical grid coordinate measured from top header row
     */
    paint: function(gc, config) {
        var val = config.value;
        var c = config.x;
        var r = config.y;
        var bounds = config.bounds;
        var x = bounds.x + 2;
        var y = bounds.y + 2;
        var width = bounds.width - 3;
        var height = bounds.height - 3;
        var radius = height / 2;
        var arcGradient = gc.createLinearGradient(x, y, x, y + height);
        if (config.mouseDown) {
            arcGradient.addColorStop(0, '#B5CBED');
            arcGradient.addColorStop(1, '#4d74ea');
        } else {
            arcGradient.addColorStop(0, '#ffffff');
            arcGradient.addColorStop(1, '#aaaaaa');
        }
        gc.fillStyle = arcGradient;
        gc.strokeStyle = '#000000';
        this.roundRect(gc, x, y, width, height, radius, arcGradient, true);

        var ox = (width - config.getTextWidth(gc, val)) / 2;
        var oy = (height - config.getTextHeight(gc.font).descent) / 2;

        if (gc.textBaseline !== 'middle') {
            gc.textBaseline = 'middle';
        }

        gc.fillStyle = '#000000';

        config.backgroundColor = 'rgba(0,0,0,0)';
        gc.fillText(val, x + ox, y + oy);

        //identify that we are a button
        config.buttonCells[c + ',' + r] = true;
    }
});

module.exports = Button;



},{"./CellRenderer":73}],73:[function(require,module,exports){
'use strict';

var Base = require('./../lib/Base');

/** @constructor
 * @desc Instances of `CellRenderer` are used to render the 2D graphics context within the bound of a cell. Extend this base class to implement your own cell renderer
 *
 *
 * See also {@tutorial cell-renderer}.
 */
var CellRenderer = Base.extend('CellRenderer', {
    /**
     * @desc An empty implementation of a cell renderer, see [the null object pattern](http://c2.com/cgi/wiki?NullObject).
     * @param {CanvasGraphicsContext} gc
     * @param {object} config
     * @param {Rectangle} config.bounds - The clipping rect of the cell to be rendered.
     * @param {number} config.x - the "translated" index into the `behavior.allColumns` array
     * @param {number} config.normalizedY - the vertical grid coordinate normalized to first data row
     * @param {number} config.untranslatedX - the horizontal grid coordinate measured from first data column
     * @param {number} config.y - the vertical grid coordinate measured from top header row
     * @memberOf CellRenderer.prototype
     */
    paint: function(gc, config) {},

    /**
     * @desc A simple implementation of rounding a cell.
     * @param {CanvasGraphicsContext} gc
     * @param {number} x - the x grid coordinate of my origin
     * @param {number} y - the y grid coordinate of my origin
     * @param {number} width - the width I'm allowed to draw within
     * @param {number} height - the height I'm allowed to draw within
     * @param {number} radius
     * @param {number} fill
     * @param {number} stroke
     * @memberOf CellRenderer.prototype
     */
    roundRect: function(gc, x, y, width, height, radius, fill, stroke) {

        if (!stroke) {
            stroke = true;
        }
        if (!radius) {
            radius = 5;
        }
        gc.beginPath();
        gc.moveTo(x + radius, y);
        gc.lineTo(x + width - radius, y);
        gc.quadraticCurveTo(x + width, y, x + width, y + radius);
        gc.lineTo(x + width, y + height - radius);
        gc.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
        gc.lineTo(x + radius, y + height);
        gc.quadraticCurveTo(x, y + height, x, y + height - radius);
        gc.lineTo(x, y + radius);
        gc.quadraticCurveTo(x, y, x + radius, y);
        gc.closePath();
        if (stroke) {
            gc.stroke();
        }
        if (fill) {
            gc.fill();
        }
        gc.closePath();
    }
});

CellRenderer.abstract = true; // don't instantiate directly

module.exports = CellRenderer;

},{"./../lib/Base":113}],74:[function(require,module,exports){
'use strict';

var CellRenderer = require('./CellRenderer');

/**
 * @constructor
 * @extends CellRenderer
 */
var ErrorCell = CellRenderer.extend('ErrorCell', {

    /**
     * @summary Writes error message into cell.
     *
     * @desc This function is guaranteed to be called as follows:
     *
     * ```javascript
     * gc.save();
     * gc.beginPath();
     * gc.rect(x, y, width, height);
     * gc.clip();
     * behavior.getCellProvider().renderCellError(gc, message, x, y, width, height);
     * gc.restore();
     * ```
     *
     * Before doing anything else, this function should clear the cell by setting `gc.fillStyle` and calling `gc.fill()`.
     *
     * @param {CanvasGraphicsContext} gc
     * @param {object} config
     * @param {Rectangle} config.bounds - The clipping rect of the cell to be rendered.
     * @param {number} config.x - the "translated" index into the `behavior.allColumns` array
     * @param {number} config.normalizedY - the vertical grid coordinate normalized to first data row
     * @param {number} config.untranslatedX - the horizontal grid coordinate measured from first data column
     * @param {number} config.y - the vertical grid coordinate measured from top header row
     * @memberOf ErrorCell.prototype
     */
    paint: function(gc, config, message) {
        //var images = require('../../images/index');
        var x = config.bounds.x,
            y = config.bounds.y,
            width = config.bounds.width,
            height = config.bounds.height;

        // clear the cell
        // (this makes use of the rect path defined by the caller)
        gc.fillStyle = '#FFD500';
        gc.fill();
        // render cell border
        //gc.strokeStyle = gc.createPattern(images.caution, 'repeat'); // Causes Error
        gc.lineWidth = 5;
        gc.beginPath();
        gc.moveTo(x, y); // caution: do not use rect() here because Chrome does not clip its stroke properly
        gc.lineTo(x + width, y);
        gc.lineTo(x + width, y + height);
        gc.lineTo(x, y + height);
        gc.lineTo(x, y);
        gc.stroke();
        // adjust clip region to prevent text from rendering over right border should it overflow
        gc.beginPath();
        gc.rect(x, y, width - 2, height);
        gc.clip();
        // render message text
        gc.fillStyle = '#A00';
        gc.textAlign = 'start';
        gc.textBaseline = 'middle';
        gc.font = 'bold 6pt "arial narrow", verdana, geneva';
        gc.fillText(message, x + 4, y + height / 2 + 0.5);
    }
});

module.exports = ErrorCell;

},{"./CellRenderer":73}],75:[function(require,module,exports){
'use strict';

var CellRenderer = require('./CellRenderer');

/**
 * @constructor
 * @extends CellRenderer
 */
var LastSelection = CellRenderer.extend('LastSelection', {

    /**
     * @desc A rendering of the last Selection Model
     * @param {CanvasGraphicsContext} gc
     * @param {object} config
     * @param {Rectangle} config.bounds - The clipping rect of the cell to be rendered.
     * @param {number} config.x - the "translated" index into the `behavior.allColumns` array
     * @param {number} config.normalizedY - the vertical grid coordinate normalized to first data row
     * @param {number} config.untranslatedX - the horizontal grid coordinate measured from first data column
     * @param {number} config.y - the vertical grid coordinate measured from top header row
     * @memberOf LastSelection.prototype
     */
    paint: function(gc, config) {
        var x = config.bounds.x,
            y = config.bounds.y,
            width = config.bounds.width,
            height = config.bounds.height;

        // var focusLineStep =  [
        //     [5, 5],
        //     [0, 1, 5, 4],
        //     [0, 2, 5, 3],
        //     [0, 3, 5, 2],
        //     [0, 4, 5, 1],
        //     [0, 5, 5, 0],
        //     [1, 5, 4, 0],
        //     [2, 5, 3, 0],
        //     [3, 5, 2, 0],
        //     [4, 5, 1, 0]
        // ];
        gc.rect(x, y, width, height);
        gc.fillStyle = config.selectionRegionOverlayColor;
        gc.fill();
        gc.lineWidth = 1;
        gc.strokeStyle = config.selectionRegionOutlineColor;

        // animate the dashed line a bit here for fun

        gc.stroke();

        // gc.rect(x, y, width, height);
        //
        // gc.strokeStyle = 'white';
        //
        // //animate the dashed line a bit here for fun
        // gc.setLineDash(focusLineStep[Math.floor(10 * (Date.now() / 300 % 1)) % focusLineStep.length]);
        //
        // gc.stroke();
    }
});

module.exports = LastSelection;



},{"./CellRenderer":73}],76:[function(require,module,exports){
'use strict';

var CellRenderer = require('./CellRenderer');

/**
 * @constructor
 * @extends CellRenderer
 */
var SimpleCell = CellRenderer.extend('SimpleCell', {

    /**
     * @summary The default cell rendering function for rendering a vanilla cell.
     * @desc Great care has been taken in crafting this function as it needs to perform extremely fast. Reads on the gc object are expensive but not quite as expensive as writes to it. We do our best to avoid writes, then avoid reads. Clipping bounds are not set here as this is also an expensive operation. Instead, we truncate overflowing text and content by filling a rectangle with background color column by column instead of cell by cell.  This column by column fill happens higher up on the stack in a calling function from fin-hypergrid-renderer.  Take note we do not do cell by cell border renderering as that is expensive.  Instead we render many fewer gridlines after all cells are rendered.
     * @param {CanvasGraphicsContext} gc
     * @param {object} config
     * @param {Rectangle} config.bounds - The clipping rect of the cell to be rendered.
     * @param {number} config.x - the "translated" index into the `behavior.allColumns` array
     * @param {number} config.normalizedY - the vertical grid coordinate normalized to first data row
     * @param {number} config.untranslatedX - the horizontal grid coordinate measured from first data column
     * @param {number} config.y - the vertical grid coordinate measured from top header row
     * @memberOf SimpleCell.prototype
     */
    paint: function(gc, config) {
        var val = config.value,
            x = config.bounds.x,
            y = config.bounds.y,
            width = config.bounds.width,
            height = config.bounds.height,
            wrapHeaders = config.headerTextWrapping,
            leftPadding = 2, //TODO: fix this
            isHeader = config.y === 0;

        var leftIcon, rightIcon, centerIcon, ixoffset, iyoffset, font;

        // setting gc properties are expensive, let's not do it needlessly

        if (val && val.constructor === Array) {
            leftIcon = val[0];
            rightIcon = val[2];
            val = val[1];
            if (val && typeof val === 'object') {
                if (val.constructor.name === 'HTMLImageElement') { // must be an image
                    centerIcon = val;
                    val = null;
                }
            }
            if (leftIcon && leftIcon.nodeName !== 'IMG') {
                leftIcon = null;
            }
            if (rightIcon && rightIcon.nodeName !== 'IMG') {
                rightIcon = null;
            }
            if (centerIcon && centerIcon.nodeName !== 'IMG') {
                centerIcon = null;
            }
        }

        val = valOrFunc(val, config);
        val = config.formatValue(val);

        font = config.isSelected ? config.foregroundSelectionFont : config.font;

        if (gc.font !== font) {
            gc.font = font;
        }
        if (gc.textAlign !== 'left') {
            gc.textAlign = 'left';
        }
        if (gc.textBaseline !== 'middle') {
            gc.textBaseline = 'middle';
        }

        // fill background only if our bgColor is populated or we are a selected cell
        var backgroundColor, hover, hoverColor, selectColor,
            colors = [];

        if (config.isCellHovered && config.hoverCellHighlight.enabled) {
            hoverColor = config.hoverCellHighlight.backgroundColor;
        } else if (config.isRowHovered && (hover = config.hoverRowHighlight).enabled) {
            hoverColor = config.isGridColumn || !hover.header || hover.header.backgroundColor === undefined ? hover.backgroundColor : hover.header.backgroundColor;
        } else if (config.isColumnHovered && (hover = config.hoverColumnHighlight).enabled) {
            hoverColor = config.isGridRow || !hover.header || hover.header.backgroundColor === undefined ? hover.backgroundColor : hover.header.backgroundColor;
        }
        if (alpha(hoverColor) < 1) {
            if (config.isSelected) {
                selectColor = valOrFunc(config.backgroundSelectionColor, config);
            }
            if (alpha(selectColor) < 1) {
                backgroundColor = valOrFunc(config.backgroundColor, config);
                if (alpha(backgroundColor) > 0) {
                    colors.push(backgroundColor);
                }
            }
            if (selectColor !== undefined) {
                colors.push(selectColor);
            }
        }
        if (hoverColor !== undefined) {
            colors.push(hoverColor);
        }
        layerColors(gc, colors, x, y, width, height);

        // draw text
        var theColor = valOrFunc(config.isSelected ? config.foregroundSelectionColor : config.color, config);
        if (gc.fillStyle !== theColor) {
            gc.fillStyle = theColor;
            gc.strokeStyle = theColor;
        }

        if (isHeader && wrapHeaders) {
            this.renderMultiLineText(gc, config, val);
        } else {
            this.renderSingleLineText(gc, config, val);
        }

        var iconWidth = 0;
        if (leftIcon) {
            iyoffset = Math.round((height - leftIcon.height) / 2);
            gc.drawImage(leftIcon, x + leftPadding, y + iyoffset);
            iconWidth = Math.max(leftIcon.width + 2);
        }
        if (rightIcon && width > 1.75 * height) {
            iyoffset = Math.round((height - rightIcon.height) / 2);
            var rightX = x + width - rightIcon.width;
            if (backgroundColor !== undefined) {
                layerColors(gc, colors, rightX, y, rightIcon.width, height);
            } else {
                gc.clearRect(rightX, y, rightIcon.width, height);
            }
            gc.drawImage(rightIcon, rightX, y + iyoffset);
            iconWidth = Math.max(rightIcon.width + 2);
        }
        if (centerIcon) {
            iyoffset = Math.round((height - centerIcon.height) / 2);
            ixoffset = Math.round((width - centerIcon.width) / 2);
            gc.drawImage(centerIcon, x + width - ixoffset - centerIcon.width, y + iyoffset);
            iconWidth = Math.max(centerIcon.width + 2);
        }
        if (config.cellBorderThickness) {
            gc.beginPath();
            gc.rect(x, y, width, height);
            gc.lineWidth = config.cellBorderThickness;
            gc.strokeStyle = config.cellBorderStyle;

            // animate the dashed line a bit here for fun

            gc.stroke();
            gc.closePath();
        }
        config.minWidth = config.minWidth + 2 * (iconWidth);
    },

    /**
     * @summary Renders single line text.
     * @param {CanvasGraphicsContext} gc
     * @param {object} config
     * @param {Rectangle} config.bounds - The clipping rect of the cell to be rendered.
     * @param {*} val - The text to render in the cell.
     * @memberOf SimpleCell.prototype
     */
    renderMultiLineText: function(gc, config, val) {
        var x = config.bounds.x,
            y = config.bounds.y,
            width = config.bounds.width,
            height = config.bounds.height;
        var lines = fitText(gc, config, val, width);
        if (lines.length === 1) {
            return this.renderSingleLineText(gc, config, squeeze(val));
        }

        var colHEdgeOffset = config.cellPadding,
            halignOffset = 0,
            valignOffset = config.voffset,
            halign = config.halign,
            textHeight = config.getTextHeight(config.font).height;

        switch (halign) {
            case 'right':
                halignOffset = width - colHEdgeOffset;
                break;
            case 'center':
                halignOffset = width / 2;
                break;
            case 'left':
                halignOffset = colHEdgeOffset;
                break;
        }

        var hMin = 0, vMin = Math.ceil(textHeight / 2);

        valignOffset += Math.ceil((height - (lines.length - 1) * textHeight) / 2);

        halignOffset = Math.max(hMin, halignOffset);
        valignOffset = Math.max(vMin, valignOffset);

        gc.save(); // define a clipping region for cell
        gc.beginPath();
        gc.rect(x, y, width, height);
        gc.clip();

        gc.textAlign = halign;

        for (var i = 0; i < lines.length; i++) {
            gc.fillText(lines[i], x + halignOffset, y + valignOffset + (i * textHeight));
        }

        gc.restore(); // discard clipping region
    },

    /**
     * @summary Renders single line text.
     * @param {CanvasGraphicsContext} gc
     * @param {object} config
     * @param {Rectangle} config.bounds - The clipping rect of the cell to be rendered.
     * @param {*} val - The text to render in the cell.
     * @memberOf SimpleCell.prototype
     */
    renderSingleLineText: function(gc, config, val) {
        var x = config.bounds.x,
            y = config.bounds.y,
            width = config.bounds.width,
            height = config.bounds.height;
        var colHEdgeOffset = config.cellPadding,
            halignOffset = 0,
            valignOffset = config.voffset,
            halign = config.halign,
            isCellHovered = config.isCellHovered,
            isLink = config.link;

        var fontMetrics = config.getTextHeight(config.font);
        var textWidth = config.getTextWidth(gc, val);

        //we must set this in order to compute the minimum width
        //for column autosizing purposes
        config.minWidth = textWidth + (2 * colHEdgeOffset);

        switch (halign) {
            case 'right':
                //textWidth = config.getTextWidth(gc, config.value);
                halignOffset = width - colHEdgeOffset - textWidth;
                break;
            case 'center':
                //textWidth = config.getTextWidth(gc, config.value);
                halignOffset = (width - textWidth) / 2;
                break;
            case 'left':
                halignOffset = colHEdgeOffset;
                break;
        }

        halignOffset = Math.max(0, halignOffset);
        valignOffset = valignOffset + Math.ceil(height / 2);

        if (val !== null) {
            gc.fillText(val, x + halignOffset, y + valignOffset);
        }

        if (isCellHovered) {
            gc.beginPath();
            if (isLink) {
                underline(config, gc, val, x + halignOffset, y + valignOffset + Math.floor(fontMetrics.height / 2), 1);
                gc.stroke();
            }
            gc.closePath();
        }
        if (config.strikeThrough === true) {
            gc.beginPath();
            strikeThrough(config, gc, val, x + halignOffset, y + valignOffset + Math.floor(fontMetrics.height / 2), 1);
            gc.stroke();
            gc.closePath();
        }
    }
});


function fitText(gc, config, string, width) {
    return findLines(gc, config, squeeze(string).split(' '), width);
}

function findLines(gc, config, words, width) {

    if (words.length === 1) {
        return words;
    }

    // starting with just the first word
    var stillFits, line = [words.shift()];
    while (
        // so lone as line still fits within current column
    (stillFits = config.getTextWidth(gc, line.join(' ')) < width)
    // AND there are more words available
    && words.length
        ) {
        // add another word to end of line and retest
        line.push(words.shift());
    }

    if (
        !stillFits // if line is now too long
        && line.length > 1 // AND is multiple words
    ) {
        words.unshift(line.pop()); // back off by (i.e., remove) one word
    }

    line = [line.join(' ')];

    if (words.length) { // if there's anything left
        line = line.concat(findLines(gc, config, words, width)); // break it up as well
    }

    return line;
}

// trim string; then reduce all runs of multiple spaces to a single space
function squeeze(string) {
    return (string + '').trim().replace(/\s\s+/g, ' ');
}

function strikeThrough(config, gc, text, x, y, thickness) {
    var fontMetrics = config.getTextHeight(config.font);
    var width = config.getTextWidth(gc, text);
    y = y - (fontMetrics.height * 0.4);

    switch (gc.textAlign) {
        case 'center':
            x -= (width / 2);
            break;
        case 'right':
            x -= width;
            break;
    }

    //gc.beginPath();
    gc.lineWidth = thickness;
    gc.moveTo(x + 0.5, y + 0.5);
    gc.lineTo(x + width + 0.5, y + 0.5);
}

function underline(config, gc, text, x, y, thickness) {
    var width = config.getTextWidth(gc, text);

    switch (gc.textAlign) {
        case 'center':
            x -= (width / 2);
            break;
        case 'right':
            x -= width;
            break;
    }

    //gc.beginPath();
    gc.lineWidth = thickness;
    gc.moveTo(x + 0.5, y + 0.5);
    gc.lineTo(x + width + 0.5, y + 0.5);
}

function layerColors(gc, colors, x, y, width, height) {
    colors.forEach(function(color) {
        gc.fillStyle = color;
        gc.fillRect(x, y, width, height);
    });
}

function valOrFunc(vf, config) {
    var result = config.isGridColumn && config.isGridRow && (typeof vf)[0] === 'f'
        ? vf(config.dataRow, config.columnName)
        : vf;
    return result || result === 0 || result === false ? result : '';
}

function alpha(cssColorSpec) {
    if (cssColorSpec === undefined) {
        // undefined so not visible; treat as transparent
        return 0;
    }

    var matches = cssColorSpec.match(alpha.regex);

    if (matches === null) {
        // an opaque color (a color spec with no alpha channel)
        return 1;
    }

    var A = matches[4];

    if (A === undefined) {
        // cssColorSpec must have been 'transparent'
        return 0;
    }

    return Number(A);
}

alpha.regex = /^(transparent|((RGB|HSL)A\(.*,\s*([\d\.]+)\)))$/i;

module.exports = SimpleCell;

},{"./CellRenderer":73}],77:[function(require,module,exports){
'use strict';

var CellRenderer = require('./CellRenderer');

/**
 * @constructor
 * @extends CellRenderer
 */
var Slider = CellRenderer.extend('Slider', {

    /**
     * @param {CanvasGraphicsContext} gc
     * @param {object} config
     * @param {Rectangle} config.bounds - The clipping rect of the cell to be rendered.
     * @param {number} config.x - the "translated" index into the `behavior.allColumns` array
     * @param {number} config.normalizedY - the vertical grid coordinate normalized to first data row
     * @param {number} config.untranslatedX - the horizontal grid coordinate measured from first data column
     * @param {number} config.y - the vertical grid coordinate measured from top header row
     * @memberOf Slider.prototype
     * @desc Emerson's paint function for a slider button. currently the user cannot interact with it
     */
    paint: function(gc, config) {
        var x = config.bounds.x,
            y = config.bounds.y,
            width = config.bounds.width,
            height = config.bounds.height;
        gc.strokeStyle = 'white';
        var val = this.config.value;
        var radius = height / 2;
        var offset = width * val;
        var bgColor = this.config.isSelected ? this.config.backgroundColor : '#333333';
        var btnGradient = gc.createLinearGradient(x, y, x, y + height);
        btnGradient.addColorStop(0, bgColor);
        btnGradient.addColorStop(1, '#666666');
        var arcGradient = gc.createLinearGradient(x, y, x, y + height);
        arcGradient.addColorStop(0, '#aaaaaa');
        arcGradient.addColorStop(1, '#777777');
        gc.fillStyle = btnGradient;
        this.roundRect(gc, x, y, width, height, radius, btnGradient);
        if (val < 1.0) {
            gc.fillStyle = arcGradient;
        } else {
            gc.fillStyle = '#eeeeee';
        }
        gc.beginPath();
        gc.arc(x + Math.max(offset - radius, radius), y + radius, radius, 0, 2 * Math.PI);
        gc.fill();
        gc.closePath();
        this.config.minWidth = 100;
    }
});

module.exports = Slider;

},{"./CellRenderer":73}],78:[function(require,module,exports){
'use strict';

var CellRenderer = require('./CellRenderer');

/**
 * @constructor
 * @extends CellRenderer
 */
var SparkBar = CellRenderer.extend('SparkBar', {

    /**
     * @desc A simple implementation of a sparkline, because it's a barchart we've changed the name ;).
     * @param {CanvasGraphicsContext} gc
     * @param {object} config
     * @param {Rectangle} config.bounds - The clipping rect of the cell to be rendered.
     * @param {number} config.x - the "translated" index into the `behavior.allColumns` array
     * @param {number} config.normalizedY - the vertical grid coordinate normalized to first data row
     * @param {number} config.untranslatedX - the horizontal grid coordinate measured from first data column
     * @param {number} config.y - the vertical grid coordinate measured from top header row
     * @memberOf SparkBar.prototype
     */
    paint: function(gc, config) {
        var x = config.bounds.x,
            y = config.bounds.y,
            width = config.bounds.width,
            height = config.bounds.height;

        gc.beginPath();
        var val = this.config.value;
        if (!val || !val.length) {
            return;
        }
        var count = val.length;
        var eWidth = width / count;
        var fgColor = this.config.isSelected ? this.config.foregroundSelectionColor : this.config.color;
        if (this.config.backgroundColor || this.config.isSelected) {
            gc.fillStyle = this.config.isSelected ? 'blue' : this.config.backgroundColor;
            gc.fillRect(x, y, width, height);
        }
        gc.fillStyle = fgColor;
        for (var i = 0; i < val.length; i++) {
            var barheight = val[i] / 110 * height;
            gc.fillRect(x + 5, y + height - barheight, eWidth * 0.6666, barheight);
            x = x + eWidth;
        }
        gc.closePath();
        this.config.minWidth = count * 10;
    }
});

module.exports = SparkBar;

},{"./CellRenderer":73}],79:[function(require,module,exports){
'use strict';

var CellRenderer = require('./CellRenderer');

/**
 * @constructor
 * @extends CellRenderer
 */
var SparkLine = CellRenderer.extend('SparkLine', {

    /**
     * @desc A simple implementation of a sparkline.  see [Edward Tufte sparkline](http://www.edwardtufte.com/bboard/q-and-a-fetch-msg?msg_id=0001OR)
     * @param {CanvasGraphicsContext} gc
     * @param {object} config
     * @param {Rectangle} config.bounds - The clipping rect of the cell to be rendered.
     * @param {number} config.x - the "translated" index into the `behavior.allColumns` array
     * @param {number} config.normalizedY - the vertical grid coordinate normalized to first data row
     * @param {number} config.untranslatedX - the horizontal grid coordinate measured from first data column
     * @param {number} config.y - the vertical grid coordinate measured from top header row
     * @memberOf SparkLine.prototype
     */
    paint: function(gc, config) {
        var x = config.bounds.x,
            y = config.bounds.y,
            width = config.bounds.width,
            height = config.bounds.height;

        gc.beginPath();
        var val = this.config.value;
        if (!val || !val.length) {
            return;
        }
        var count = val.length;
        var eWidth = width / count;

        var fgColor = this.config.isSelected ? this.config.foregroundSelectionColor : this.config.color;
        if (this.config.backgroundColor || this.config.isSelected) {
            gc.fillStyle = this.config.isSelected ? this.config.backgroundSelectionColor : this.config.backgroundColor;
            gc.fillRect(x, y, width, height);
        }
        gc.strokeStyle = fgColor;
        gc.fillStyle = fgColor;
        gc.beginPath();
        var prev;
        for (var i = 0; i < val.length; i++) {
            var barheight = val[i] / 110 * height;
            if (!prev) {
                prev = barheight;
            }
            gc.lineTo(x + 5, y + height - barheight);
            gc.arc(x + 5, y + height - barheight, 1, 0, 2 * Math.PI, false);
            x = x + eWidth;
        }
        this.config.minWidth = count * 10;
        gc.stroke();
        gc.closePath();
    }
});

module.exports = SparkLine;

},{"./CellRenderer":73}],80:[function(require,module,exports){
'use strict';

var CellRenderer = require('./CellRenderer');

/**
 * @constructor
 * @extends CellRenderer
 */
var TreeCell = CellRenderer.extend('TreeCell', {

    /**
     * @desc A simple implementation of a tree cell renderer for use mainly with the qtree.
     * @param {number} config.x - the "translated" index into the `behavior.allColumns` array
     * @param {number} config.normalizedY - the vertical grid coordinate normalized to first data row
     * @param {number} config.untranslatedX - the horizontal grid coordinate measured from first data column
     * @param {number} config.y - the vertical grid coordinate measured from top header row
     * @memberOf TreeCell.prototype
     */
    paint: function(gc, config) {
        var x = config.bounds.x,
            y = config.bounds.y,
            width = config.bounds.width,
            height = config.bounds.height;

        var val = this.config.value.data;
        var indent = this.config.value.indent;
        var icon = this.config.value.icon;

        //fill background only if our bgColor is populated or we are a selected cell
        if (this.config.backgroundColor || this.config.isSelected) {
            gc.fillStyle = this.config.isSelected ? this.config.backgroundColor : this.config.backgroundColor;
            gc.fillRect(x, y, width, height);
        }

        if (!val || !val.length) {
            return;
        }
        var valignOffset = Math.ceil(height / 2);

        gc.fillStyle = this.config.isSelected ? this.config.backgroundColor : this.config.backgroundColor;
        gc.fillText(icon + val, x + indent, y + valignOffset);

        var textWidth = this.config.getTextWidth(gc, icon + val);
        var minWidth = x + indent + textWidth + 10;
        this.config.minWidth = minWidth;
    }
});

module.exports = TreeCell;

},{"./CellRenderer":73}],81:[function(require,module,exports){
/**
 * @summary API of cell renderer object constructors, plus some access methods.
 * @module cellRenderers
 */

'use strict';

/**
 * @param {boolean} [privateRegistry=false] - This instance will use a private registry.
 * @constructor
 */
function CellRenderers(privateRegistry) {
    if (privateRegistry) {
        this.singletons = {};
    }

    // preregister the standard cell renderers
    if (privateRegistry || !this.get('emptycell')) {
        this.add('EmptyCell', require('./CellRenderer'));
        this.add(require('./Button'));
        this.add(require('./SimpleCell'));
        this.add(require('./SliderCell'));
        this.add(require('./SparkBar'));
        this.add(require('./LastSelection'));
        this.add(require('./SparkLine'));
        this.add(require('./ErrorCell'));
        this.add(require('./TreeCell'));
    }
}

CellRenderers.prototype = {
    constructor: CellRenderers.prototype.constructor, // preserve constructor

    /**
     * @summary Register and instantiate a cell renderer singleton.
     * @desc Adds a custom cell renderer to the `singletons` hash using the provided name (or the class name), converted to all lower case.
     *
     * > All native cell renderers are "preregistered" in `singletons`. Add more by calling `get`.
     *
     * @param {string} [name] - Case-insensitive renderer key. If not given, `YourCellRenderer.prototype.$$CLASS_NAME` is used.
     *
     * @param {CellRenderer} Constructor - A constructor, typically extended from `CellRenderer` (or a descendant therefrom).
     *
     * > Note: `$$CLASS_NAME` can be easily set up by providing a string as the (optional) first parameter (`alias`) in your {@link https://www.npmjs.com/package/extend-me|CellEditor.extend} call.
     *
     * @returns {CellRenderers} A newly registered constructor extended from {@link CellRenderers}.
     *
     * @memberOf CellRenderers.prototype
     */
    add: function(name, Constructor) {
        if (typeof name === 'function') {
            Constructor = name;
            name = undefined;
        }

        name = name || Constructor.prototype.$$CLASS_NAME;
        name = name && name.toLowerCase();
        return (this.singletons[name] = new Constructor);
    },

    /**
     * @summary Register a synonym for an existing cell renderer singleton.
     * @param {string} synonymName
     * @param {string} existingName
     * @returns {CellRenderers} The previously registered constructor this new synonym points to.
     * @memberOf CellRenderers.prototype
     */
    addSynonym: function(synonymName, existingName) {
        var cellRenderer = this.get(existingName);
        return (this.singletons[synonymName] = cellRenderer);
    },

    /**
     * Fetch a registered cell renderer singleton.
     * @param {string} name
     * @returns {CellRenderers} A registered constructor extended from {@link CellRenderers}.
     * @memberOf CellRenderers.prototype
     */
    get: function(name) {
        return this.singletons[name && name.toLowerCase()];
    },

    /**
     * The cell editor registry containing all the "preregistered" cell renderer singletons.
     * @private
     * @memberOf CellRenderers.prototype
     */
    singletons: {}
};


module.exports = CellRenderers;

},{"./Button":72,"./CellRenderer":73,"./ErrorCell":74,"./LastSelection":75,"./SimpleCell":76,"./SliderCell":77,"./SparkBar":78,"./SparkLine":79,"./TreeCell":80}],82:[function(require,module,exports){
'use strict';

var Base = require('../lib/Base');

var A = 'A'.charCodeAt(0);

/**
 * @constructor
 */
var DataModel = Base.extend('DataModel', {

    next: null,

    grid: null,

    initialize: function(grid) {
        this.grid = grid;
    },

    changed: function() {
        this.grid.behavior.changed();
    },

    getPrivateState: function() {
        return this.grid.getPrivateState();
    },

    applyState: function() {

    },

    alphaFor: function(i) {
        // Name the column headers in A, .., AA, AB, AC, .., AZ format
        // quotient/remainder
        //var quo = Math.floor(col/27);
        var quo = Math.floor(i / 26);
        var rem = i % 26;
        var code = '';
        if (quo > 0) {
            code += this.alpha(quo - 1);
        }
        code += this.alpha(rem);
        return code;
    },

    alpha: function(i) {
        return String.fromCharCode(A + i);
    },

    /**
     * @param {object} config
     * @param {string} declaredRendererName - The proposed cell renderer name (form the render properties).
     * @returns {CellRenderer}
     * @memberOf DataModel.prototype
     */
    getCell: function(config, declaredRendererName) {
        return this.grid.cellRenderers.get(declaredRendererName);
    },

    /**
     * @summary Instantiate a new cell editor.
     * @desc The application developer may override this method to:
     * * Instantiate and return an arbitrary cell editor. The generic implementation here simply returns the declared cell editor. This is `undefined` when there was no such declaration, or if the named cell editor was not registered.
     * * Return `undefined` for no cell editor at all. The cell will not be editable.
     * * Set properties on the instance by passing them in the `options` object. These are applied to the new cell editor object after instantiation but before rendering.
     * * Manipulate the cell editor object (including its DOM elements) after rendering but before DOM insertion.
     *
     * Overriding this method with a null function (that always returns `undefined`) will have the effect of making all cells uneditable.
     *
     * @param {number} columnIndex - Absolute column index. I.e., the position of the column in the data source's original `fields` array, as echoed in `behavior.allColumns[]`.
     * @param {number} rowIndex - Row index of the data row in the currently filtered and sorted list of rows, regardless of vertical scroll position, offset by the number of header rows (all the rows above the first data row including the filter row). I.e., after subtracting out the number of header rows, this is the position of the data row in the `index` array of the data source (i.e., the last data source pipeline).
     * @param {string} declaredEditorName - The proposed cell editor name (from the render properties).
     * @param {object} options - Properties to copy to the new cell editor primarily for mustache's use. Additionally, always includes the following:
     * @param {string} options.format - The value of the `format` render prop. May be `undefined`.
     * @param {object} options.column - For convenience, the column object in `behavior.allColumns[]` to which `columnIndex` refers.
     * @param {Point} options.editPoint - The grid coordinates of the cell to edit.
     * @param {number} options.editPoint.x - The horizontal model coordinate of the cell to edit. This is the grid coordinate regardless of horizontal scroll position. I.e., the position of the column in the ordered list of selected columns (`behavior.columns[]`). (This is the coordinate required by {@link Hypergrid#editAt|editAt}.)
     * @param {number} options.editPoint.y - Same as `rowIndex`.
     *
     * @returns {undefined|CellEditor} An object instantiated from the registered cell editor constructor named in `declaredEditorName`. A falsy return means the cell is not editable because the `declaredEditorName` was not registered.
     *
     * @memberOf DataModel.prototype
     */
    getCellEditorAt: function(columnIndex, rowIndex, declaredEditorName, options) {
        return this.grid.cellEditors.create(declaredEditorName, options);
    }

});

module.exports = DataModel;

},{"../lib/Base":113}],83:[function(require,module,exports){
'use strict';

var DataModel = require('./DataModel');

/**
 * @constructor
 * @extends DataModel
 */
var Default = DataModel.extend('Default', {

    /**
     * @type {object}
     * @memberOf Default.prototype
     */
    dataUpdates: {},

    /**
     * @memberOf Default.prototype
     * @desc This is the most important behavior function.
     * @returns {object} Data point at the given coordinates.
     * @param {number} x - the horizontal coordinate
     * @param {number} x - the vertical coordinate
     */
    getValue: function(x, y) {
        var override = this.dataUpdates['p_' + x + '_' + y];
        if (override) {
            return override;
        }
        if (x === 0) {
            if (y === 0) {
                return '';
            }
            return y;
        }
        if (y === 0) {
            return this.alphaFor(x - 1);
        }
        return (x - 1) + ', ' + this.alpha((y - 1) % 26);
    },

    /**
     * @memberOf Default.prototype
     * @param {number} x
     * @param {number} y
     * @param value
     */
    setValue: function(x, y, value) {
        this.dataUpdates['p_' + x + '_' + y] = value;
    },

    /**
     * @memberOf Default.prototype
     * @returns {number}
     */
    getColumnCount: function() {
        return 27;
    },

    /**
     * @memberOf Default.prototype
     * @returns {number}
     */
    getRowCount: function() {
        //jeepers batman a quadrillion rows!
        return 53;
    }

});

module.exports = Default;

},{"./DataModel":82}],84:[function(require,module,exports){
'use strict';

var DataModel = require('./DataModel');

/**
 * @constructor
 * @extends DataModel
 */
var InMemory = DataModel.extend('InMemory', {

    dataUpdates: {},

    /**
     * @memberOf InMemory.prototype
     * @desc This is the most important behavior function.
     * @returns {object} Data point at the given coordinates.
     * @param {number} x - the x coordinate
     * @param {number} x - the y coordinate
     */
    getValue: function(x, y) {
        var override = this.dataUpdates['p_' + x + '_' + y];
        if (override) {
            return override;
        }
        if (x === 0) {
            if (y === 0) {
                return '';
            }
            return y;
        }
        if (y === 0) {
            return this.alphaFor(x - 1);
        }
        return (x - 1) + ', ' + this.alpha((y - 1) % 26);
    },

    /**
     * @memberOf InMemory.prototype
     * @param {number} x
     * @param {number} y
     * @param value
     */
    setValue: function(x, y, value) {
        this.dataUpdates['p_' + x + '_' + y] = value;
    },

    /**
     * @memberOf InMemory.prototype
     * @returns {number}
     */
    getColumnCount: function() {
        return 27;
    },

    /**
     * @memberOf InMemory.prototype{number}
     * @returns {number}
     */
    getRowCount: function() {
        //jeepers batman a quadrillion rows!
        return 53;
    }

});

module.exports = InMemory;

},{"./DataModel":82}],85:[function(require,module,exports){
'use strict';

var analytics = require('../Shared.js').analytics;
var DataModel = require('./DataModel');
var images = require('../../images');

var UPWARDS_BLACK_ARROW = '\u25b2', // aka ''
    DOWNWARDS_BLACK_ARROW = '\u25bc'; // aka ''

var nullDataSource = {
    isNullObject: function() {
        return true;
    },
    getFields: function() {
        return [];
    },
    getHeaders: function() {
        return [];
    },
    getColumnCount: function() {
        return 0;
    },
    getRowCount: function() {
        return 0;
    },
    getAggregateTotals: function() {
        return [];
    },
    hasAggregates: function() {
        return false;
    },
    hasGroups: function() {
        return false;
    },
    getRow: function() {
        return null;
    },

    viewMakesSense: function() {
        return false;
    },
    setAggregates: function() {},
    setGroupBys: function() {},
    groupBys: [],

};

/**
 * @name dataModels.JSON
 * @constructor
 * @extends DataModel
 */
var JSON = DataModel.extend('dataModels.JSON', {

    //null object pattern for the source object
    resetSources: function() {
        this.sources = {
            source: nullDataSource,
            aggregator: nullDataSource,
            globalfilter: nullDataSource,
            sortercomposite: nullDataSource
        };
        this.dataSource = undefined;
    },

    topTotals: [],
    bottomTotals: [],

    initialize: function() {
        this.resetSources();
        this.selectedData = [];
    },

    clearSelectedData: function() {
        this.selectedData.length = 0;
    },

    /**
     * @param {number} [columnIndex] If given, also checks that the column clicked is the tree column.
     * @returns {boolean}
     * @memberOf dataModels.JSON.prototype
     */
    hasAggregates: function(event) {
        var result = this.sources.aggregator.hasAggregates();
        if (result && event) {
            result = event.gridCell.x === 0;
        }
        return result;
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @returns {boolean}
     */
    hasGroups: function() {
        return this.sources.aggregator.hasGroups();
    },

    getDataSource: function() {
        return this.deprecated('getDataSource()', 'dataSource', '1.0.7');
    },

    getGlobalFilterDataSource: function() {
        return this.sources.globalfilter;
    },

    getData: function() {
        return this.sources.source.data;
    },

    getFilteredData: function() {
        var ds = this.dataSource;
        var count = ds.getRowCount();
        var result = new Array(count);
        for (var y = 0; y < count; y++) {
            result[y] = ds.getRow(y);
        }
        return result;
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param {number} x
     * @param {number} y
     * @returns {*}
     */
    getValue: function(x, y) {
        var hasHierarchyColumn = this.hasHierarchyColumn();
        var headerRowCount = this.grid.getHeaderRowCount();
        var value;

        if (hasHierarchyColumn) {
            if (x === -2) {
                x = 0;
            }
        } else if (this.hasAggregates()) {
            x += 1;
        }
        if (y < headerRowCount) {
            value = this.getHeaderRowValue(x, y);
        } else {
            // if (hasHierarchyColumn) {
            //     y += 1;
            // }
            value = this.dataSource.getValue(x, y - headerRowCount);
        }
        return value;
    },

    getDataIndex: function(y) {
        return this.dataSource.getDataIndex(y - this.grid.getHeaderRowCount());
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param {number} x
     * @param {number} y - negative values refer to _bottom totals_ rows
     * @returns {*}
     */
    getHeaderRowValue: function(x, y) {
        var value;
        if (y === undefined) {
            value = this.getHeaders()[Math.max(x, 0)];
        } else if (y < 0) { // bottom totals rows
            var bottomTotals = this.getBottomTotals();
            value = bottomTotals[bottomTotals.length + y][x];
        } else {
            var isFilterRow = this.grid.isShowFilterRow(),
                isHeaderRow = this.grid.isShowHeaderRow(),
                topTotalsOffset = (isFilterRow ? 1 : 0) + (isHeaderRow ? 1 : 0);
            if (y >= topTotalsOffset) { // top totals rows
                value = this.getTopTotals()[y - topTotalsOffset][x];
            } else if (isHeaderRow && y === 0) {
                value = this.getHeaders()[x];
                var sortString = this.getSortImageForColumn(x);
                if (sortString) { value = sortString + value; }
            } else { // must be filter row
                var filter = this.getGlobalFilter();
                value = filter && filter.getColumnFilterState(this.getFields()[x]) || '';
                var icon = images.filter(value.length);
                return [null, value, icon];
            }
        }
        return value;
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param {number} x
     * @param {number} y
     * @param value
     */
    setValue: function(x, y, value) {
        var hasHierarchyColumn = this.hasHierarchyColumn();
        var headerRowCount = this.grid.getHeaderRowCount();
        if (hasHierarchyColumn) {
            if (x === -2) {
                x = 0;
            }
        } else if (this.hasAggregates()) {
            x += 1;
        }
        if (y < headerRowCount) {
            this.setHeaderRowValue(x, y, value);
        } else {
            this.dataSource.setValue(x, y - headerRowCount, value);
        }
        this.changed();
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param {number} x
     * @param {number} y
     * @param value
     * @returns {*}
     */
    setHeaderRowValue: function(x, y, value) {
        if (value === undefined) {
            return this._setHeader(x, y); // y is really the value
        }
        var isFilterRow = this.grid.isShowFilterRow();
        var isHeaderRow = this.grid.isShowHeaderRow();
        var topTotalsOffset = (isFilterRow ? 1 : 0) + (isHeaderRow ? 1 : 0);
        if (y >= topTotalsOffset) {
            this.getTopTotals()[y - topTotalsOffset][x] = value;
        } else if (x === -1) {
            return; // can't change the row numbers header
        } else if (isHeaderRow && y === 0) {
            return this._setHeader(x, value);
        } else if (isFilterRow) {
            this.setFilter(x, value, { alert: true });
        } else {
            return this._setHeader(x, value);
        }
        return '';
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param {number} colIndex
     * @returns {*}
     */
    getColumnProperties: function(colIndex) {
        //access directly because we want it ordered
        var column = this.grid.behavior.getColumn(colIndex);
        if (column) {
            return column.getProperties();
        }
        return undefined;
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @returns {number}
     */
    getColumnCount: function() {
        var showTree = this.grid.resolveProperty('showTreeColumn') === true;
        var hasAggregates = this.hasAggregates();
        var offset = (hasAggregates && !showTree) ? -1 : 0;
        return this.sources.aggregator.getColumnCount() + offset;
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @returns {number}
     */
    getRowCount: function() {
        var count = this.dataSource.getRowCount();
        count += this.grid.getHeaderRowCount();
        return count;
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @returns {string[]}
     */
    getHeaders: function() {
        return this.sources.aggregator.getHeaders();
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param {string[]} headers
     */
    setHeaders: function(headers) {
        this.dataSource.setHeaders(headers);
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param {string[]} fields
     */
    setFields: function(fields) {
        this.dataSource.setFields(fields);
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @returns {string[]}
     */
    getFields: function() {
        return this.dataSource.getFields();
    },

    /** @typedef {object} dataSourcePipelineObject
     * @property {function} DataSource - A `hyper-analytics`-style  "data source" constructor.
     * @property {*} [options] - When defined, passed as 2nd argument to constructor.
     * @property {string} [parent] - Defines a branch off the main sequence.
     */

    /**
     * @type {dataSourcePipelineObject[]}
     * @memberOf dataModels.JSON.prototype
     */
    pipeline: [
        { type: 'JSDataSource' },
        { type: 'DataSourceAggregator', test: 'hasAggregates' },
        { type: 'DataSourceGlobalFilter' },
        { type: 'DataSourceSorterComposite' },
        { type: 'DataNodeGroupSorter', parent: 'DataSourceAggregator' }
    ],

    /**
     * @summary Instantiates the data source pipeline.
     * @desc Each new pipe is created using the supplied constructor and a reference to the previous data source in the pipeline. A reference to each new pipe is added to `this` dataModel as a property using the pipe's `name`.
     *
     * The first pipe must have a `@@CLASS_NAME` of `'DataSource'`. Hence, the start of the pipeline is `this.source`. The last pipe is assigned the synonym `this.dataSource`.
     *
     * Branches are created when a pipe specifies a name in `parent`.
     * @param {object[]} dataSource - Array of uniform objects containing the grid data.
     * @memberOf dataModels.JSON.prototype
     */
    setData: function(dataSource) {
        this.resetSources();

        this.pipeline.forEach(function(sources, pipe, index) {
            var DataSource = analytics[pipe.type];

            pipe.name = pipe.name || getDataSourceName(pipe.type);

            if (index === 0 && pipe.name !== 'source') {
                throw 'Expected pipeline to begin with source.';
            }

            if (pipe.parent) {
                this.dataSource = this.dataSource || dataSource; // tip of main trunk on first diversion
                dataSource = sources[getDataSourceName(pipe.parent)];
                if (!dataSource) {
                    throw 'Parent data source not in pipeline.';
                }
            }

            dataSource = pipe.options === undefined
                ? new DataSource(dataSource)
                : new DataSource(dataSource, pipe.options);

            sources[pipe.name] = dataSource;
        }.bind(this, this.sources));

        this.source = this.sources.source;
        this.dataSource = this.dataSource || dataSource; // tip of main trunk if never branched

        this.applyAnalytics();
    },

    /**
     * Add a pipe to the data source pipeline.
     * @desc No-op if already added.
     * @param {dataSourcePipelineObject} newPipe - The new pipeline pipe.
     * @param {string} [referencePipe] - One of:
     * * Name of an existing pipeline pipe after which the new pipe will be added. If `null`, inserts at beginning. If not found (or `undefined` or omitted), adds to end.
     * @memberOf dataModels.JSON.prototype
     */
    addPipe: function(newPipe, referencePipe) {
        var referenceIndex,
            added = this.pipeline.find(function(pipe) { return pipe.type === newPipe.type; });

        if (!added) {
            if (referencePipe === null) {
                referenceIndex = 0; // add to beginning
            } else if (
                !this.pipeline.find(function(pipe, index) {
                    referenceIndex = index + 1; // add after found pipe
                    return pipe.type === referencePipe;
                })
            ) {
                referenceIndex = this.pipeline.length; // not found: add to end
            }
            this.pipeline.splice(referenceIndex, 0, newPipe);
        }
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param {Array<Array>} totalRows
     */
    setTopTotals: function(totalRows) {
        this.topTotals = totalRows;
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @returns {Array<Array>}
     */
    getTopTotals: function() {
        return this.hasAggregates() ? this.dataSource.getGrandTotals() : this.topTotals;
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param {Array<Array>} totalRows
     */
    setBottomTotals: function(totalRows) {
        this.bottomTotals = totalRows;
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @returns {Array<Array>}
     */
    getBottomTotals: function() {
        return this.hasAggregates() ? this.dataSource.getGrandTotals() : this.bottomTotals;
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param groups
     */
    setGroups: function(groups) {
        this.sources.aggregator.setGroupBys(groups);
        this.applyAnalytics();
        this.grid.fireSyntheticGroupsChangedEvent(this.getGroups());
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @returns {object[]}
     */
    getGroups: function() {
        var headers = this.getHeaders().slice(0);
        var fields = this.getFields().slice(0);
        var groupBys = this.sources.aggregator.groupBys;
        var groups = [];
        for (var i = 0; i < groupBys.length; i++) {
            var field = headers[groupBys[i]];
            groups.push({
                id: groupBys[i],
                label: field,
                field: fields
            });
        }
        return groups;
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @returns {object[]}
     */
    getAvailableGroups: function() {
        var headers = this.sources.source.getHeaders().slice(0);
        var groupBys = this.sources.aggregator.groupBys;
        var groups = [];
        for (var i = 0; i < headers.length; i++) {
            if (groupBys.indexOf(i) === -1) {
                var field = headers[i];
                groups.push({
                    id: i,
                    label: field,
                    field: field
                });
            }
        }
        return groups;
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @returns {object[]}
     */
    getActiveColumns: function() {
        return this.grid.behavior.columns.filter(function(column) {
            return column.name !== 'tree';
        });
    },
    getVisibleColumns: function() {
        return this.deprecated('getVisibleColumns()', 'getActiveColumns()', '1.0.6', arguments);
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @returns {object[]}
     */
    getHiddenColumns: function() {
        var visible = this.grid.behavior.columns;
        var all = this.grid.behavior.allColumns;
        var hidden = [];
        for (var i = 0; i < all.length; i++) {
            if (visible.indexOf(all[i]) === -1) {
                hidden.push(all[i]);
            }
        }
        hidden.sort(function(a, b) {
            return a.header < b.header;
        });
        return hidden;
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param aggregations
     */
    setAggregates: function(aggregations) {
        this.sources.aggregator.setAggregates(aggregations);
        this.applyAnalytics();
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @returns {boolean}
     */
    hasHierarchyColumn: function() {
        var showTree = this.grid.resolveProperty('showTreeColumn') === true;
        return this.hasAggregates() && this.hasGroups() && showTree;
    },

    /**
     * @memberOf dataModels.JSON.prototype
     */
    applyAnalytics: function(dontApplyAggregator) {
        selectedDataRowsBackingSelectedGridRows.call(this);

        this.pipeline.forEach(function(sources, pipe) {
            var dataSource = sources[pipe.name];

            switch (pipe.type) {
                case 'DataSourceAggregator':
                    if (dontApplyAggregator) {
                        dataSource = undefined;
                    }
                    break;

                case 'DataSourceSorterComposite':
                    if (sources.aggregator && sources.aggregator.viewMakesSense()) {
                        dataSource = sources.groupsorter;
                    }
                    dataSource.setSorts(this.getPrivateState().sorts);
                    break;
            }

            if (dataSource && dataSource.apply) {
                dataSource.apply();
            }
        }.bind(this, this.sources));

        reselectGridRowsBackedBySelectedDataRows.call(this);
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param {number} colIndex
     * @param keys
     */
    toggleSort: function(colIndex, keys) {
        this.incrementSortState(colIndex, keys);
        this.applyAnalytics(true);
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param {number} colIndex
     * @param {boolean} deferred
     */
    unSortColumn: function(columnIndex, deferred) {
        var state = this.getPrivateState(),
            sorts = state.sorts = state.sorts || [],
            sortPosition;

        if (sorts.find(function(sortSpec, index) {
            sortPosition = index;
            return sortSpec.columnIndex === columnIndex;
        })) {
            sorts.splice(sortPosition, 1);
            if (!deferred) {
                this.applyAnalytics(true);
            }
        }
    },

    /**
     * @memberOf dataModels.JSON.prototype
     */
    getSortedColumnIndexes: function() {
        return (this.getPrivateState().sorts || []).slice();
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param {number} colIndex
     * @param {string[]} keys
     */
    incrementSortState: function(columnIndex, keys) {
        var state = this.getPrivateState(),
            sorts = state.sorts = state.sorts || [],
            sortPosition,
            sortSpec = sorts.find(function(spec, index) {
                sortPosition = index;
                return spec.columnIndex === columnIndex;
            });

        if (!sortSpec) { // was unsorted
            if (keys.indexOf('CTRL') < 0) { sorts.length = 0; }
            sorts.unshift({ columnIndex: columnIndex, direction: 1 }); // so make ascending
        } else if (sortSpec.direction > 0) { // was ascending
            sortSpec.direction = -1; // so make descending
        } else { // was descending
            sorts.splice(sortPosition, 1); // so make unsorted
        }

        //Minor improvement, but this check can happe n earlier and terminate earlier
        if (sorts.length > 3) {
            sorts.length = 3;
        }
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param index
     * @param returnAsString
     * @returns {*}
     */
    getSortImageForColumn: function(columnIndex) {
        var sorts = this.getPrivateState().sorts || [],
            sortPosition,
            sortSpec = sorts.find(function(spec, index) {
                sortPosition = index;
                return spec.columnIndex === columnIndex;
            }),
            result = null;

        if (sortSpec) {
            var rank = sorts.length - sortPosition,
                arrow = sortSpec.direction > 0 ? UPWARDS_BLACK_ARROW : DOWNWARDS_BLACK_ARROW;
            result = rank + arrow + ' ';
        }

        return result;
    },

    isDrillDown: function(event) {
        return this.pipeline.find(function(pipe) {
            var test = pipe.test,
                type = typeof test;

            test = type === 'function' && pipe.test ||
                type === 'string' && this[pipe.test];

            return test && test.call(this, event);
        }.bind(this));
    },

    /**
     * @param cell
     * @param event
     * @memberOf dataModels.JSON.prototype
     */
    cellClicked: function(cell, event) {
        if (this.isDrillDown(event)) {
            var y = event.gridCell.y - this.grid.getHeaderRowCount();
            this.toggleRow(y);
        }
    },

    /**
     * @summary Toggle the drill-down control of a the specified row.
     * @desc Operates only on the following rows:
     * * Expandable rows - Rows with a drill-down control.
     * * Revealed rows - Rows not hidden inside of collapsed drill-downs.
     * @param y - Revealed row number. (This is not the row ID.)
     * @param {boolean} [expand] - One of:
     * * `true` - Expand row.
     * * `false` - Collapse row.
     * * `undefined` (or omitted) - Toggle state of row.
     * @returns {boolean|undefined} If any rows expanded or collapsed; `undefined` means row had no drill-down control.
     * @memberOf dataModels.JSON.prototype
     */
    toggleRow: function(y, expand) {
        var changed;
        if (this.isDrillDown()) {
            changed = this.dataSource.click(y, expand);
            if (changed) {
                this.applyAnalytics(true);
                this.changed();
            }
        }
        return changed;
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param {number} y
     * @returns {object}
     */
    getRow: function(y) {
        var headerRowCount = this.grid.getHeaderRowCount();
        if (y < headerRowCount && !this.hasAggregates()) {
            var topTotals = this.getTopTotals();
            return topTotals[y - (headerRowCount - topTotals.length)];
        }
        return this.dataSource.getRow(y - headerRowCount);
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param {number} y
     * @returns {object}
     */
    buildRow: function(y) {
        var colCount = this.getColumnCount();
        var fields = [].concat(this.getFields());
        var result = {};
        if (this.hasAggregates()) {
            result.tree = this.getValue(-2, y);
            fields.shift();
        }
        for (var i = 0; i < colCount; i++) {
            result[fields[i]] = this.getValue(i, y);
        }
        return result;
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param {number} y
     * @returns {object}
     */
    getComputedRow: function(y) {
        var rcf = this.getRowContextFunction([y]);
        var fields = this.getFields();
        var row = {};
        for (var i = 0; i < fields.length; i++) {
            var field = fields[i];
            row[field] = rcf(field)[0];
        }
        return row;
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param {string} fieldName
     * @param {number} y
     * @returns {*}
     */
    getValueByField: function(fieldName, y) {
        var index = this.getFields().indexOf(fieldName);
        if (this.hasAggregates()) {
            y += 1;
        }
        return this.dataSource.getValue(index, y);
    },

    /**
     * @summary Get a reference to the filter attached to the Hypergrid.
     * @returns {FilterTree}
     * @memberOf dataModels.JSON.prototype
     */
    getGlobalFilter: function() {
        return this.getGlobalFilterDataSource().get();
    },

    /**
     * @summary Attach/detach a filter to a Hypergrid.
     * @param {FilterTree} [filter] - The filter object. If undefined, any attached filter is removed, turning filtering OFF.
     * @memberOf dataModels.JSON.prototype
     */
    setGlobalFilter: function(filter) {
        this.getGlobalFilterDataSource().set(filter);
        this.applyAnalytics();
    },

    /**
     * @summary Set the case sensitivity of filter tests against data.
     * @desc Case sensitivity pertains to string compares only. This includes untyped columns, columns typed as strings, typed columns containing data that cannot be coerced to type or when the filter expression operand cannot be coerced.
     *
     * NOTE: This is a shared property and affects all grid managed by this instance of the app.
     * @param {boolean} isSensitive
     * @memberOf dataModels.JSON.prototype
     */
    setGlobalFilterCaseSensitivity: function(isSensitive) {
        this.getGlobalFilter().setCaseSensitivity(isSensitive);
        this.applyAnalytics();
    },

    /**
     * @summary Get a particular column filter's state.
     * @param {string} columnName
     * @param {FilterTreeGetStateOptionsObject} [options] - Passed to the filter's {@link DefaultFilter#getState|getState} method.
     * @param {boolean} [options.syntax='CQL'] - The syntax to use to describe the filter state. Note that `getFilter`'s default syntax, `'CQL'`, differs from the other get state methods.
     * @returns {FilterTreeStateObject}
     * @memberOf dataModels.JSON.prototype
     */
    getFilter: function(columnIndexOrName, options) {
        var isIndex = !isNaN(Number(columnIndexOrName)),
            columnName = isIndex ? this.getFields()[columnIndexOrName] : columnIndexOrName;

        return this.getGlobalFilter().getColumnFilterState(columnName, options);
    },

    /**
     * @summary Set a particular column filter's state.
     * @desc After setting the new filter state, reapplies the filter to the data source.
     * @param {number|string} columnIndexOrName - The _column filter_ to set.
     * @param {string|object} [state] - A filter tree object or a JSON, SQL, or CQL subexpression string that describes the a new state for the named column filter. The existing column filter subexpression is replaced with a new node based on this state. If it does not exist, the new subexpression is added to the column filters subtree (`filter.columnFilters`).
     *
     * If undefined, removes the entire column filter subexpression from the column filters subtree.
     * @param {FilterTreeSetStateOptionsObject} [options] - Passed to the filter's [setState]{@link http://joneit.github.io/filter-tree/FilterTree.html#setState} method. You may mix in members of the {@link http://joneit.github.io/filter-tree/global.html#FilterTreeValidationOptionsObject|FilterTreeValidationOptionsObject}
     * @param {string} [options.syntax='CQL'] - The syntax to use to describe the filter state. Note that `setFilter`'s default syntax, `'CQL'`, differs from the other get state methods.
     * @returns {undefined|Error|string} `undefined` indicates success.
     * @memberOf dataModels.JSON.prototype
     */
    setFilter: function(columnIndexOrName, state, options) {
        var isIndex = !isNaN(Number(columnIndexOrName)),
            columnName = isIndex ? this.getFields()[columnIndexOrName] : columnIndexOrName;

        this.getGlobalFilter().setColumnFilterState(columnName, state, options);
        this.grid.fireSyntheticFilterAppliedEvent();
        this.applyAnalytics();
    },

    /**
     * @param {FilterTreeGetStateOptionsObject} [options] - Passed to the filter's {@link DefaultFilter#getState|getState} method.
     * @returns {FilterTreeStateObject}
     * @memberOf dataModels.JSON.prototype
     */
    getFilters: function(options) {
        return this.getGlobalFilter().getColumnFiltersState(options);
    },

    /**
     * @param {FilterTreeStateObject} state
     * @param {FilterTreeSetStateOptionsObject} [options] - Passed to the filter's [setState]{@link http://joneit.github.io/filter-tree/FilterTree.html#setState} method. You may mix in members of the {@link http://joneit.github.io/filter-tree/global.html#FilterTreeValidationOptionsObject|FilterTreeValidationOptionsObject}
     * @returns {undefined|Error|string} `undefined` indicates success.
     * @memberOf dataModels.JSON.prototype
     */
    setFilters: function(state, options) {
        this.getGlobalFilter().setColumnFiltersState(state, options);
        this.grid.fireSyntheticFilterAppliedEvent();
        this.applyAnalytics();
    },

    /**
     * @param {FilterTreeGetStateOptionsObject} [options] - Passed to the filter's {@link DefaultFilter#getState|getState} method.
     * @returns {FilterTreeStateObject}
     * @memberOf dataModels.JSON.prototype
     */
    getTableFilter: function(options) {
        return this.getGlobalFilter().getTableFilterState(options);
    },

    /**
     * @summary Set a the table filter state.
     * @param {FilterTreeStateObject} state
     * @param {FilterTreeSetStateOptionsObject} [options] - Passed to the filter's [setState]{@link http://joneit.github.io/filter-tree/FilterTree.html#setState} method. You may mix in members of the {@link http://joneit.github.io/filter-tree/global.html#FilterTreeValidationOptionsObject|FilterTreeValidationOptionsObject}
     * @returns {undefined|Error|string} `undefined` indicates success.
     * @memberOf dataModels.JSON.prototype
     */
    setTableFilter: function(state, options) {
        this.getGlobalFilter().setTableFilterState(state, options);
        this.grid.fireSyntheticFilterAppliedEvent();
        this.applyAnalytics();
    },

    /**
     * @memberOf dataModels.JSON.prototype
     */
    applyState: function() {
        this.applyAnalytics();
    },

    /**
     * @memberOf dataModels.JSON.prototype
     */
    reset: function() {
        this.setData([]);
    },

    getUnfilteredValue: function(x, y) {
        return this.sources.source.getValue(x, y);
    },

    getUnfilteredRowCount: function() {
        return this.sources.source.getRowCount();
    }
});

// LOCAL METHODS -- to be called with `.call(this`

/**
 * Accumulate actual data row objects backing current grid row selections.
 * This call should be paired with a subsequent call to `reselectGridRowsBackedBySelectedDataRows`.
 * @private
 * @memberOf dataModels.JSON.prototype
 */
function selectedDataRowsBackingSelectedGridRows() {
    var selectedData = this.selectedData,
        hasRowSelections = this.grid.selectionModel.hasRowSelections(),
        needFilteredDataList = selectedData.length || hasRowSelections;

    if (needFilteredDataList) {
        var filteredData = this.getFilteredData();
    }

    // STEP 1: Remove any filtered data rows from the recently selected list.
    selectedData.forEach(function(dataRow, index) {
        if (filteredData.indexOf(dataRow) >= 0) {
            delete selectedData[index];
        }
    });

    // STEP 2: Accumulate the data rows backing any currently selected grid rows in `this.selectedData`.
    if (hasRowSelections) { // any current grid row selections?
        this.grid.getSelectedRows().forEach(function(selectedRowIndex) {
            var dataRow = filteredData[selectedRowIndex];
            if (selectedData.indexOf(dataRow) < 0) {
                selectedData.push(dataRow);
            }
        });
    }
}

/**
 * Re-establish grid row selections based on actual data row objects accumulated by `selectedDataRowsBackingSelectedGridRows` which should be called first.
 * @private
 * @memberOf dataModels.JSON.prototype
 */
function reselectGridRowsBackedBySelectedDataRows() {
    if (this.selectedData.length) { // any data row objects added from previous grid row selections?
        var selectionModel = this.grid.selectionModel,
            offset = this.grid.getHeaderRowCount(),
            filteredData = this.getFilteredData();

        selectionModel.clearRowSelection();

        this.selectedData.forEach(function(dataRow) {
            var index = filteredData.indexOf(dataRow);
            if (index >= 0) {
                selectionModel.selectRow(offset + index);
            }
        });
    }
}

function getDataSourceName(name) {
    name = analytics[name].prototype.$$CLASS_NAME || name;
    return name.replace(/^Data(Source|Node)/, '').toLowerCase() || 'source';
}


module.exports = JSON;

},{"../../images":4,"../Shared.js":55,"./DataModel":82}],86:[function(require,module,exports){
'use strict';

module.exports = {
    DataModel: require('./DataModel'), // abstract base class
    Default: require('./Default'),
    InMemory: require('./InMemory'),
    JSON: require('./JSON')
};
},{"./DataModel":82,"./Default":83,"./InMemory":84,"./JSON":85}],87:[function(require,module,exports){
/* eslint-env browser */

'use strict';

var LRUCache = require('lru-cache');


/**
 * This module lists the properties that can be set on a {@link Hypergrid} along with their default values.
 * Edit this file to override the defaults.
 * @module defaults
 */

module.exports = {

    /**
     * The font for data cells.
     * @default
     * @type {cssFont}
     * @instance
     */
    noDataMessage: 'no data to display',


    /**
     * The font for data cells.
     * @default
     * @type {cssFont}
     * @instance
     */
    font: '13px Tahoma, Geneva, sans-serif',

    /**
     * Font color for data cells.
     * @default
     * @type {string}
     * @instance
     */
    color: 'rgb(25, 25, 25)',

    /**
     * Background color for data cells.
     * @default
     * @type {string}
     * @instance
     */
    backgroundColor: 'rgb(241, 241, 241)',

    /**
     * Font style for selected cell(s).
     * @default
     * @type {string}
     * @instance
     */
    foregroundSelectionFont: 'bold 13px Tahoma, Geneva, sans-serif',

    /**
     * Font color for selected cell(s).
     * @default
     * @type {string}
     * @instance
     */
    foregroundSelectionColor: 'rgb(0, 0, 128)',
    /**
     * @default
     * @type {boolean}
     * @instance
     */
    sortOnHiddenColumns: true,
    /**
     * Background color for selected cell(s).
     * @default
     * @type {string}
     * @instance
     */
    backgroundSelectionColor: 'rgba(147, 185, 255, 0.625)',


    /********** SECTION: COLUMN HEADER COLORS **********/

    // IMPORTANT CAVEAT: The code is inconsistent regarding the terminology. Is the "column header" section _the row_ of cells at the top (that act as headers for each column) or is it _the column_ of cells (that act as headers for each row)? Oh my.

    /**
     * @default
     * @type {cssFont}
     * @instance
     */
    columnHeaderFont: '12px Tahoma, Geneva, sans-serif',

    /**
     * @default
     * @type {cssColor}
     * @instance
     */
    columnHeaderColor: 'rgb(25, 25, 25)',

    /**
     * Font style for selected columns' headers.
     * @default
     * @type {string}
     * @instance
     */
    columnHeaderForegroundSelectionFont: 'bold 12px Tahoma, Geneva, sans-serif',

    /**
     * @default
     * @type {cssColor}
     * @instance
     */
    columnHeaderBackgroundColor: 'rgb(223, 227, 232)',

    /**
     * @default
     * @type {cssColor}
     * @instance
     */
    columnHeaderForegroundSelectionColor: 'rgb(80, 80, 80)',

    /**
     * @default
     * @type {cssColor}
     * @instance
     */
    columnHeaderBackgroundSelectionColor: 'rgba(255, 220, 97, 0.45)',

    /**
     * @default
     * @type {cssColor}
     * @instance
     */
    columnHeaderForegroundColumnSelectionColor: 'rgb(25, 25, 25)',

    /**
     * @default
     * @type {cssColor}
     * @instance
     */
    columnHeaderBackgroundColumnSelectionColor: 'rgb(255, 180, 0)',


    /********** SECTION: ROW HEADER COLORS **********/

    /**
     * @default
     * @type {cssFont}
     * @instance
     */
    rowHeaderFont: '12px Tahoma, Geneva, sans-serif',

    /**
     * @default
     * @type {cssColor}
     * @instance
     */
    rowHeaderColor: 'rgb(25, 25, 25)',

    /**
     * @default
     * @type {cssColor}
     * @instance
     */
    rowHeaderBackgroundColor: 'rgb(223, 227, 232)',

    /**
     * @default
     * @type {cssColor}
     * @instance
     */
    rowHeaderForegroundSelectionColor: 'rgb(80, 80, 80)',

    /**
     * Font style for selected rows' headers.
     * @default
     * @type {string}
     * @instance
     */
    rowHeaderForegroundSelectionFont: 'bold 12px Tahoma, Geneva, sans-serif',

    /**
     * @default
     * @type {cssColor}
     * @instance
     */
    rowHeaderBackgroundSelectionColor: 'rgba(255, 220, 97, 0.45)',

    /**
     * @default
     * @type {cssColor}
     * @instance
     */
    rowHeaderForegroundRowSelectionColor: 'rgb(25, 25, 25)',

    /**
     * @default
     * @type {cssColor}
     * @instance
     */
    rowHeaderBackgroundRowSelectionColor: 'rgb(255, 180, 0)',


    /********** SECTION: FILTER ROW COLORS **********/

    /**
     * @default
     * @type {cssFont}
     * @instance
     */
    filterFont: '12px Tahoma, Geneva, sans-serif',

    /**
     * @default
     * @type {cssColor}
     * @instance
     */
    filterColor: 'rgb(25, 25, 25)',

    /**
     * @default
     * @type {cssColor}
     * @instance
     */
    filterBackgroundColor: 'white',

    /**
     * @default
     * @type {cssColor}
     * @instance
     */
    filterForegroundSelectionColor: 'rgb(25, 25, 25)',

    /**
     * @default
     * @type {cssColor}
     * @instance
     */
    filterBackgroundSelectionColor: 'rgb(255, 220, 97)',

    /**
     * @default
     * @type {cssColor}
     * @instance
     */
    filterCellBorderStyle: 'rgba(0,0,0,0.8)',

    /**
     * @default
     * @type {number}
     * @instance
     */
    filterCellBorderThickness: 0.4,
    /********** SECTION: TREE COLUMN COLORS **********/
    // The "tree column" contains the hierarchical drill-down controls.

    /**
     * @default
     * @type {cssFont}
     * @instance
     */
    treeColumnFont: '12px Tahoma, Geneva, sans-serif',

    /**
     * @default
     * @type {cssColor}
     * @instance
     */
    treeColumnColor: 'rgb(25, 25, 25)',

    /**
     * @default
     * @type {cssColor}
     * @instance
     */
    treeColumnBackgroundColor: 'rgb(223, 227, 232)',

    /**
     * @default
     * @type {cssColor}
     * @instance
     */
    treeColumnForegroundSelectionColor: 'rgb(25, 25, 25)',

    /**
     * @default
     * @type {cssColor}
     * @instance
     */
    treeColumnBackgroundSelectionColor: 'rgba(255, 220, 97, 0.45)',

    /**
     * @default
     * @type {cssColor}
     * @instance
     */
    treeColumnForegroundColumnSelectionColor: 'rgb(25, 25, 25)',

    /**
     * @default
     * @type {cssColor}
     * @instance
     */
    treeColumnBackgroundColumnSelectionColor: 'rgb(255, 180, 0)',

    /**
     * @default
     * @type {cssColor}
     * @instance
     */
    backgroundColor2: 'rgb(201, 201, 201)',

    /**
     * @default
     * @type {number}
     * @instance
     */
    voffset: 0,

    /**
     * @default
     * @type {string}
     * @instance
     */
    scrollbarHoverOver: 'visible',

    /**
     * @default
     * @type {string}
     * @instance
     */
    scrollbarHoverOff: 'hidden',

    /**
     * @default
     * @type {boolean}
     * @instance
     */
    scrollingEnabled: true,

    /**
     * @default
     * @type {string}
     * @instance
     */
    vScrollbarClassPrefix: '',

    /**
     * @default
     * @type {string}
     * @instance
     */
    hScrollbarClassPrefix: '',

    //these used to be in the constants element

    /**
     * @default
     * @type {string}
     * @instance
     */
    fixedRowAlign: 'center',

    /**
     * @default
     * @type {string}
     * @instance
     */
    fixedColAlign: 'center',

    /**
     * @default
     * @type {number}
     * @instance
     */
    cellPadding: 5,

    /**
     * @default
     * @type {boolean}
     * @instance
     */
    gridLinesH: true,

    /**
     * @default
     * @type {boolean}
     * @instance
     */
    gridLinesV: true,
    /**
     * @default
     * @type {boolean}
     * @instance
     */
    gridLinesVOverflow: false,

    /**
     * @default
     * @type {cssColor}
     * @instance
     */
    lineColor: 'rgb(199, 199, 199)',

    /**
     * @default
     * @type {number}
     * @instance
     */
    lineWidth: 0.4,


    /**
     * @default
     * @type {number}
     * @instance
     */
    defaultRowHeight: 15,

    /**
     * @default
     * @type {number}
     * @instance
     */
    defaultColumnWidth: 100,

    //for immediate painting, set these values to 0, true respectively

    /**
     * @default
     * @type {number}
     * @instance
     */
    repaintIntervalRate: 60,

    /**
     * @default
     * @type {boolean}
     * @instance
     */
    repaintImmediately: false,

    //enable or disable double buffering

    /**
     * @default
     * @type {boolean}
     * @instance
     */
    useBitBlit: false,


    /**
     * @default
     * @type {boolean}
     * @instance
     */
    useHiDPI: true,

    /**
     * @default ['alt', 'esc']
     * @type {string}
     * @instance
     */
    editorActivationKeys: ['alt', 'esc'],

    /**
     * @default
     * @type {boolean}
     * @instance
     */
    readOnly: false,

    // inherited by cell renderers

    /**
     * @default `getTextWidth`
     * @type {function}
     * @instance
     */
    getTextWidth: getTextWidth,

    /**
     * @default `getTextHeight`
     * @type {function}
     * @instance
     */
    getTextHeight: getTextHeight,


    /**
     * @default
     * @type {number}
     * @instance
     */
    fixedColumnCount: 0,

    /**
     * @default
     * @type {number}
     * @instance
     */
    fixedRowCount: 0,

    /**
     * @default
     * @type {number}
     * @instance
     */
    headerColumnCount: 0,


    /**
     * @default
     * @type {boolean}
     * @instance
     */
    showRowNumbers: true,

    /**
     * @default
     * @type {boolean}
     * @instance
     */
    showTreeColumn: true,

    /**
     * @default
     * @type {boolean}
     * @instance
     */
    showHeaderRow: true,

    /**
     * @default
     * @type {boolean}
     * @instance
     */
    showFilterRow: true,


    /** Clicking in a cell "selects" it; it is added to the select region and repainted with "cell selection" colors.
     * @default
     * @type {boolean}
     * @instance
     */
    cellSelection: true,

    /** Clicking in a row header (leftmost column) "selects" the row; the entire row is added to the select region and repainted with "row selection" colors.
     * @default
     * @type {boolean}
     * @instance
     */
    columnSelection: true,

    /** Clicking in a column header (top row) "selects" the column; the entire column is added to the select region and repainted with "column selection" colors.
     * @default
     * @type {boolean}
     * @instance
     */
    rowSelection: true,

    /**
     * @default
     * @type {boolean}
     * @instance
     */
    singleRowSelectionMode: true,

    /**
     * @default
     * @type {cssColor}
     * @instance
     */
    selectionRegionOverlayColor: 'rgba(0, 0, 48, 0.2)',

    /**
     * @default
     * @type {string}
     * @instance
     */
    selectionRegionOutlineColor: 'black',

    /**
     * @default
     * @type {boolean}
     * @instance
     */
    columnAutosizing: true,

    /**
     * @default
     * @type {boolean}
     * @instance
     */
    rowNumberAutosizing: true,

    /**
     * @default
     * @type {boolean}
     * @instance
     */
    headerTextWrapping: false,

    /**
     * @default
     * @type {boolean}
     * @instance
     */
    rowResize: false,

    /**
     * @default
     * @type {boolean}
     * @instance
     */
    editable: true,

    /**
     * @default
     * @type {boolean}
     * @instance
     */
    editOnDoubleClick: true,

    /**
     * @default
     * @type {number}
     * @instance
     */
    doubleClickDelay: 325,

    /**
     * Grid-level property.
     * When user presses a printable character key _or_ BACKSPACE _or_ DELETE:
     * 1. Activate cell editor on current cell (i.e., origin of most recent selection).
     * 2. If cell editor is a text editor:
     *    1. Replace current value with the character the user typed; or
     *    2. Clear it on BACKSPACE, DELETE, or other invalid character (_e.g._ when user types a letter but the cell editor only accepts digits).
     *
     * > In invoked, user has the option to back out by pressing the ESCAPE key.
     *
     * @default
     * @type {boolean}
     * @instance
     */
    editOnKeydown: true,

    /**
     * @default
     * @type {boolean}
     */
    checkboxOnlyRowSelections: false,

    /** @summary Name of a formatter for cell text.
     * The default (`undefined`) falls back to `column.type`.
     * The value `null` does no formatting.
     * @default undefined
     * @type {undefined|null|string}
     * @tutorial localization
     */
    format: undefined,

    /** @summary Name of a cell editor from the {@link module:cellEditors|cellEditors API}..
     * @desc Not editable if named editor is does not exist.
     * @default undefined
     * @type {undefined|null|string}
     * @tutorial cell-editors
     */
    editor: undefined,

    /**
     * Name of cell renderer from the {@link module:cellRenderers|cellRenderers API}.
     * @default
     * @type {string}
     */
    renderer: 'SimpleCell',

    /********** HOVER COLORS **********/

    /** @typedef hoverColors
     * @property {boolean} [enable=false] - `false` means not hilite on hover
     * @property {cssColor} backgroundColor - cell, row, or column background color. Alpha channel will be respected and if given will be painted over the cells predetermined color.
     * @property {cssColor} [header.backgroundColor=backgroundColor] - for columns and rows, this is the background color of the column or row "handle" (header rows or columns, respectively). (Not used for cells.)
     */

    /** On mouse hover, whether to repaint the cell background and how.
     * @type {hoverColors}
     * @default '{ enabled: true, background: rgba(160, 160, 40, 0.30) }'
     */
    hoverCellHighlight: {
        enabled: true,
        backgroundColor: 'rgba(160, 160, 40, 0.45)'
    },

    /** On mouse hover, whether to repaint the row background and how.
     * @type {hoverColors}
     * @default '{ enabled: true, background: rgba(100, 100, 25, 0.15) }'
     */
    hoverRowHighlight: {
        enabled: true,
        backgroundColor: 'rgba(100, 100, 25, 0.30)'

    },

    /** On mouse hover, whether to repaint the column background and how.
     * @type {hoverColors}
     * @default '{ enabled: true, background: rgba(60, 60, 15, 0.15) }'
     */
    hoverColumnHighlight: {
        enabled: true,
        backgroundColor: 'rgba(60, 60, 15, 0.15)'
    },


    /** Display cell font with under-score line drawn over it.
     * > Implementation of links right now is not automatic; you must attach a 'fin-click' listener to the hypergrid object, etc.
     * @type {boolean}
     * @default
     */
    link: false,

    /** Display cell font with strike-through line drawn over it.
     * @type {boolean}
     * @default
     */
    strikeThrough: false,

};

/** @typedef {string} cssColor
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/color_value
 */
/** @typedef {string} cssFont
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/font
 */

var textWidthCache = new LRUCache(2000);

function getTextWidth(gc, string) {
    if (string === null || string === undefined) {
        return 0;
    }
    string = string + '';
    if (string.length === 0) {
        return 0;
    }
    var key = gc.font + string;
    var width = textWidthCache.get(key);
    if (!width) {
        width = gc.measureText(string).width;
        textWidthCache.set(key, width);
    }
    return width;
}

var fontData = {};

function getTextHeight(font) {
    var result = fontData[font];

    if (!result) {
        result = {};

        var text = document.createElement('span');
        text.textContent = 'Hg';
        text.style.font = font;

        var block = document.createElement('div');
        block.style.display = 'inline-block';
        block.style.width = '1px';
        block.style.height = '0px';

        var div = document.createElement('div');
        div.appendChild(text);
        div.appendChild(block);

        div.style.position = 'absolute';
        document.body.appendChild(div);

        try {

            block.style.verticalAlign = 'baseline';

            var blockRect = block.getBoundingClientRect();
            var textRect = text.getBoundingClientRect();

            result.ascent = blockRect.top - textRect.top;

            block.style.verticalAlign = 'bottom';
            result.height = blockRect.top - textRect.top;

            result.descent = result.height - result.ascent;

        } finally {
            document.body.removeChild(div);
        }
        if (result.height !== 0) {
            fontData[font] = result;
        }
    }

    return result;
}

},{"lru-cache":44}],88:[function(require,module,exports){
/* eslint-env browser */

'use strict';

var ListDragon = require('list-dragon');

var Dialog = require('./Dialog');
var stylesheet = require('../lib/stylesheet');

/**
 * @constructor
 * @extends Dialog
 */
var ColumnPicker = Dialog.extend('ColumnPicker', {
    /**
     * @param {Hypergrid} grid
     * @param {object} [options] - May include `Dialog` options.
     */
    initialize: function(grid, options) {
        var behavior = grid.behavior;

        this.grid = grid;

        if (behavior.isColumnReorderable()) {
            // grab the lists from the behavior
            this.selectedGroups = {
                title: 'Groups',
                models: behavior.getGroups()
            };

            this.availableGroups = {
                title: 'Available Groups',
                models: behavior.getAvailableGroups()
            };

            this.inactiveColumns = {
                title: 'Inactive Columns',
                models: behavior.getHiddenColumns().sort(compareByName)
            };

            this.activeColumns = {
                title: 'Active Columns',
                models: behavior.getActiveColumns()
            };

            this.sortOnHiddenColumns = this.wasSortOnHiddenColumns = grid.resolveProperty('sortOnHiddenColumns');

            // parse & add the drag-and-drop stylesheet addendum
            var stylesheetAddendum = stylesheet.inject('list-dragon-addendum');

            // create drag-and-drop sets from the lists
            var listSets = [
                new ListDragon([
                    this.selectedGroups,
                    this.availableGroups
                ], {
                    // add the list-dragon-base stylesheet right before the addendum
                    cssStylesheetReferenceElement: stylesheetAddendum
                }),
                new ListDragon([
                    this.inactiveColumns,
                    this.activeColumns
                ], {
                    // these models have a header property as their labels
                    label: '{header}'
                })
            ];

            // add the drag-and-drop sets to the dialog
            var self = this;
            listSets.forEach(function(listSet) {
                listSet.modelLists.forEach(function(list) {
                    self.append(list.container);
                });
            });
            //Listen to the visible column changes
            listSets[1].modelLists[1].element.addEventListener('listchanged', function(e){
                grid.fireSyntheticOnColumnsChangedEvent();
            });

            this.sortOnHiddenColumns = this.grid.resolveProperty('sortOnHiddenColumns');
        } else {
            var div = document.createElement('div');
            div.style.textAlign = 'center';
            div.style.marginTop = '2em';
            div.innerHTML = 'The selection of visible columns in the grid may not be changed.';
            this.append(div);
        }

        // Add checkbox to control panel for sorting on hidden fields
        var label = document.createElement('label');
        label.innerHTML = '<input type="checkbox"> Allow sorting on hidden columns';
        label.style.fontWeight = 'normal';
        label.style.marginRight = '2em';

        var checkbox = label.querySelector('input');
        checkbox.checked = this.sortOnHiddenColumns;
        checkbox.addEventListener('click', function(e){
            self.sortOnHiddenColumns = checkbox.checked;
            e.stopPropagation();
        });

        var panel = this.el.querySelector('.hypergrid-dialog-control-panel');
        panel.insertBefore(label, panel.firstChild);

        // add the dialog to the DOM
        this.open(options.container);
    },

    onClosed: function() {
        if (this.activeColumns) {
            var behavior = this.grid.behavior,
                columns = behavior.columns,
                tree = columns[0];

            // TODO: breaking encapsulation; should be using setters and getters on the behavior
            columns.length = 0;
            if (tree && tree.label === 'Tree') {
                columns.push(tree);
            }
            this.activeColumns.models.forEach(function(column) {
                columns.push(column);
            });
            var groupBys = this.selectedGroups.models.map(function(e) {
                return e.id;
            });
            behavior.dataModel.setGroups(groupBys);

            if (this.sortOnHiddenColumns !== this.wasSortOnHiddenColumns) {
                this.grid.addProperties({ sortOnHiddenColumns: this.sortOnHiddenColumns });
                behavior.sortChanged(this.inactiveColumns.models);
            }

            behavior.changed();
        }
    }
});

function compareByName(a, b) {
    a = a.header.toString().toUpperCase();
    b = b.header.toString().toUpperCase();
    return a < b ? -1 : a > b ? +1 : 0;
}


module.exports = ColumnPicker;

},{"../lib/stylesheet":124,"./Dialog":89,"list-dragon":43}],89:[function(require,module,exports){
/* eslint-env browser */

'use strict';

var automat = require('automat');

var Base = require('../lib/Base');
var markup = require('../../html');
var images = require('../../images');
var elfor = require('../lib/elfor');

/**
 * Creates and services a DOM element used as a cntainer for a dialog. The standard `markup.dialog` is simply a div with a _control panel_ containing a close box and a settings gear icon.
 *
 * You can supply an alternative dialog template. The interface is:
 * * Class name `hypergrid-dialog`.
 * * At least one child element. Content will be inserted before this first child.
 * * Typically contains a close-box element with class name `hypergrid-dialog-close` and possibly other controls with class name `hypergrid-dialog-xxxx` (where _xxxx_ is a unique name for your control).
 *
 * @constructor
 */
var Dialog = Base.extend('Dialog', {

    /**
     * Creates a basic dialog box in `this.el`.
     * @param {Hypergrid} grid
     * @param {object} [options]
     * @param {string|function} [options.dialogTemplate] - An alternate dialog template. The last child element must be the "control panel."
     * @param {boolean} [options.settings=true] - Control box has settings icon. (Settings icon must be included in template. This option removes it. That is, if explicitly `false` _and_ there is a settings control, remove it.)
     * @param {string|boolean} [options.backgroundImage=images.dialog.src] - A URI for a background image. If explicitly `false`, background image is suppressed.
     * @param {function} [terminate]
     */
    initialize: function(grid, options) {
        options = options || {};

        this.grid = grid;

        // create the backdrop; it is absolute-positioned and stretched
        this.el = automat.firstChild(options.dialogTemplate || markup.dialog, options.dialogReplacements);

        this.originalFirstChild = this.el.firstElementChild;

        if (options.settings === false) {
            var settings = this.el.querySelector('.hypergrid-dialog-settings');
            if (settings) {
                settings.remove();
            }
        }

        // add background image
        if (options.backgroundImage !== false) {
            this.el.style.backgroundImage = 'url(\'' + (options.backgroundImage || images.dialog.src) + '\')';
        }

        // listen for clicks
        this.el.addEventListener('click', onClick.bind(this));

        if (options.terminate) {
            this.terminate = options.terminate;
        }
    },

    /**
     * @summary Adds DOM `Node`s to dialog.
     * @desc Input can be nodes or a template from which to create nodes. The nodes are inserted into the dialog's DOM (`this.el`), right before the "control panel."
     * @param {string|function|Node|Node[]} nodes - See `automat`.
     * @param {...*} [replacements] - See `automat`.
     */
    append: function(nodes, replacements/*...*/) {
        var el = this.el;

        if (typeof nodes === 'string' || typeof nodes === 'function') {
            var args = Array.prototype.slice.call(arguments);
            args.splice(1, 0, el, this.originalFirstChild);
            automat.append.apply(null, args);

        } else if ('length' in nodes) {
            for (var i = 0; i < nodes.length; ++i) {
                el.insertBefore(nodes[i], this.originalFirstChild);
            }

        } else {
            el.insertBefore(nodes, this.originalFirstChild);
        }
    },

    /**
     * Insert dialog into DOM.
     *
     * @param {HTMLElement} [container] - If undefined, dialog is appended to body.
     *
     * If defined, dialog is appended to container. When container is not body, it will be:
     * # made visible before append (it should initially be hidden)
     * # made hidden after remove
     */
    open: function(container) {
        var error;

        if (!(this.opened || this.opening || this.closed || this.closing)) {
            error = this.onOpen();

            if (!error) {
                var el = this.el;

                this.opening = true;

                container = container || document.querySelector('body');

                if (container.tagName !== 'BODY') {
                    container.style.visibility = 'visible';
                }

                // insert the new dialog markup into the DOM
                container.appendChild(el);

                // schedule it for a show transition
                setTimeout(function() { el.classList.add('hypergrid-dialog-visible'); }, 50);

                // at end of show transition, hide all the hypergrids behind it to prevent any key/mouse events from getting to them
                // todo: pause all hypergrids so they don't spin uselessly
                el.addEventListener('transitionend', this.hideAppBound = hideApp.bind(this));
            }
        }

        return error;
    },

    /**
     * Remove dialog from DOM.
     */
    close: function() {
        var error;

        if (this.opened && !(this.closed || this.closing)) {
            error = this.onClose();

            if (!error) {
                var el = this.el;

                this.closing = true;

                // unhide all the hypergrids behind the dialog
                this.appVisible('visible');

                // start a hide transition of dialog revealing grids behind it
                el.classList.remove('hypergrid-dialog-visible');

                // at end of hide transition, remove dialog from the DOM
                el.addEventListener('transitionend', this.removeDialogBound = removeDialog.bind(this));
            }
        }

        return error;
    },

    appSelector: 'canvas.hypergrid',
    appVisible: function(visibility) {
        elfor.each(this.appSelector, function(el) {
            el.style.visibility = visibility;
        });
    },

    onOpen: nullPattern,
    onOpened: nullPattern,
    onClose: nullPattern,
    onClosed: nullPattern,
    terminate: nullPattern
});

function nullPattern() {}

function removeDialog(evt) {
    if (evt.target === this.el && evt.propertyName === 'opacity') {
        if (this.el.parentElement.tagName !== 'BODY') {
            this.el.parentElement.style.visibility = 'hidden';
        }
        this.el.remove();
        delete this.el;

        this.onClosed();
        this.terminate();
        this.closing = false;
        this.closed = true;
    }
}

function hideApp(evt) {
    if (evt.target === this.el && evt.propertyName === 'opacity') {
        this.appVisible('hidden');
        this.el.removeEventListener('transitionend', this.hideAppBound);
        this.onOpened();
        this.opening = false;
        this.opened = true;
    }
}

function onClick(evt) {
    if (this) {
        if (evt.target.classList.contains('hypergrid-dialog-close')) {
            evt.preventDefault(); // ignore href
            this.close();

        } else if (evt.target.classList.contains('hypergrid-dialog-settings')) {
            evt.preventDefault(); // ignore href
            if (this.settings) { this.settings(); }

        } else if (this.onClick && !this.onClick.call(this, evt) && evt.target.tagName === 'A') {
            evt.preventDefault(); // ignore href of handled event
        }
    }

    evt.stopPropagation(); // the click stops here, handled or not
}

module.exports = Dialog;

},{"../../html":2,"../../images":4,"../lib/Base":113,"../lib/elfor":120,"automat":5}],90:[function(require,module,exports){
/* eslint-env browser */

'use strict';

var Tabz = require('tabz');
var popMenu = require('pop-menu');
var automat = require('automat');

var Dialog = require('./Dialog');
var markup = require('../../html');
var copyInput = require('../lib/copy-input');

var tabProperties = {
    tableQB: {
        isTableFilter: true
    },
    tableSQL: {
        isTableFilter: true,
        language: 'SQL'
    },
    columnsQB: {
        isColumnFilter: true
    },
    columnsSQL: {
        isColumnFilter: true,
        language: 'SQL'
    },
    columnsCQL: {
        isColumnFilter: true,
        language: 'CQL'
    }
};

/**
 * @constructor
 * @extends Dialog
 */
var ManageFilters = Dialog.extend('ManageFilters', {

    /**
     * @param {Hypergrid} grid
     * @param {object} [options] - May include `Dialog` options.
     * @param {HTMLElement} [options.container=document.body]
     */
    initialize: function(grid, options) {
        this.filter = grid.getGlobalFilter();

        this.append(markup.filterTrees);

        // initialize the folder tabs
        var tabz = this.tabz = new Tabz({
            root: this.el,
            onEnable: renderFolder.bind(this),
            onDisable: saveFolders.bind(this, null) // null options
        });

        // wire-up the New Column drop-down
        var newColumnDropDown = this.el.querySelector('#add-column-filter-subexpression');
        newColumnDropDown.onmousedown = onNewColumnMouseDown.bind(this);
        newColumnDropDown.onchange = onNewColumnChange.bind(this);

        // put the two subtrees in the two panels
        tabz.folder('#tableQB').appendChild(this.filter.tableFilter.el);
        tabz.folder('#columnsQB').appendChild(this.filter.columnFilters.el);

        // copy the SQL more-info block from the table to the columns tab
        var columnSqlEl = tabz.folder('#columnsSQL');
        var moreSqlInfo = tabz.folder('#tableSQL').firstElementChild.cloneNode(true);
        columnSqlEl.insertBefore(moreSqlInfo, columnSqlEl.firstChild);

        // add it to the DOM
        this.open(options.container);

        // following needed for unclear reasons to get drop-down to display correctly
        newColumnDropDown.selectedIndex = 0;
    },

    onClose: function() {
        return saveFolders.call(this);
    },

    onClosed: function() {
        var behavior = this.grid.behavior;
        behavior.applyAnalytics();
        behavior.changed();
    },

    /**
     * Custom click handlers; called by curtain.onclick in context
     * @param evt
     * @returns {boolean}
     */
    onClick: function(evt) { // to be called with filter object as syntax
        var ctrl = evt.target;

        if (ctrl.classList.contains('more-info')) {
            // find all more-info links and their adjacent blocks (blocks always follow links)
            var els = this.el.querySelectorAll('.more-info');

            // hide all more-info blocks except the one following this link (unless it's already visible in which case hide it too).
            for (var i = 0; i < els.length; ++i) {
                var el = els[i];
                if (el.tagName === 'A') {
                    var found = el === ctrl;
                    el.classList[found ? 'toggle' : 'remove']('hide-info');
                    el = els[i + 1];
                    el.style.display = found && el.style.display !== 'block' ? 'block' : 'none';
                }
            }

        } else if (ctrl.classList.contains('filter-copy')) {
            var isCopyAll = ctrl.childNodes.length; // contains "All"
            if (isCopyAll) {
                ctrl = this.tabz.folder(ctrl).querySelector(copyInput.selectorTextControls);
                copyInput(ctrl, this.filter.columnFilters.getState({ syntax: 'SQL' }));
            } else {
                copyInput(ctrl.parentElement.querySelector(copyInput.selectorTextControls));
            }

        } else {
            return true; // means unhandled
        }
    }
});

/**
 * @param options
 * @param tab
 * @param folder
 * @param [panel] Panel to save (from tab click). If omitted, save both panels (from onclose).
 * @returns {boolean|undefined|string}
 */
function saveFolders(options, tab, folder, panel) {
    return (
        (!panel || panel.id === 'tableFilterPanel') && saveFolder.call(this, this.filter.tableFilter, options) ||
        (!panel || panel.id === 'columnFiltersPanel') && saveFolder.call(this, this.filter.columnFilters, options)
    );
}

/**
 * @this Filter
 * @param {DefaultFilter} subtree
 * @param {object} [options={alert:true,focus:true}] - Side effects as per `FilterTree.prototype.invalid`'s `options`' parameter.
 * @returns {undefined|string} - Validation error text; falsy means valid (no error).
 */
function saveFolder(subtree, options) { // to be called with filter object as syntax
    var isColumnFilters = subtree === this.filter.columnFilters,
        tabQueryBuilder = this.tabz.tab(isColumnFilters ? '#columnsQB' : '#tableQB'),
        tab = this.tabz.enabledTab(tabQueryBuilder),
        folder = this.tabz.folder(tab),
        isQueryBuilder = tab === tabQueryBuilder,
        defaultedOptions = options || {
            alert: true,
            focus: true
        },
        enhancedOptions = {
            alert: defaultedOptions.alert,
            focus: defaultedOptions.focus && isQueryBuilder
        },
        error, ctrl;

    if (isColumnFilters || isQueryBuilder) {
        error = subtree.invalid(enhancedOptions);
    } else { // table filter SQL tab
        ctrl = folder.querySelector('textarea');
        error = this.filter.setTableFilterState(ctrl.value, options);
    }

    if (error && !isQueryBuilder) {
        // If there was a validation error, move the focus from the query builder control to the text box control.
        if (isColumnFilters) {
            // We're in SQL or CQL tab so find text box that goes with this subexpression and focus on it instead of QB control.
            var errantColumnName = error.node.el.parentElement.querySelector('input').value;
            ctrl = folder.querySelector('[name="' + errantColumnName + '"]');
        }
    }

    if (ctrl) {
        decorateFilterInput(ctrl, error);
    }

    return error;
}

function decorateFilterInput(ctrl, error) {
    ctrl.classList.toggle('filter-tree-error', !!error);

    ctrl.focus();

    // find the nearby warning element
    var warningEl;
    do {
        ctrl = ctrl.parentElement;
        warningEl = ctrl.querySelector('.filter-tree-warn');
    } while (!warningEl);

    // show or hide the error
    warningEl.innerHTML = error.message || error || '';
}

function onNewColumnMouseDown(evt) { // to be called with filter object as syntax
    if (saveFolder.call(this, this.filter.columnFilters)) {
        evt.preventDefault(); // do not drop down
    } else {
        // (re)build the drop-down contents, with same prompt, but excluding columns with active filter subexpressions
        var ctrl = evt.target,
            prompt = ctrl.options[0].text.replace('', ''), // use original but w/o ellipsis as .build() appends one
            blacklist = this.filter.columnFilters.children.map(function(columnFilter) {
                return columnFilter.children.length && columnFilter.children[0].column;
            }),
            options = {
                prompt: prompt,
                blacklist: blacklist
            };

        popMenu.build(ctrl, this.filter.root.schema, options);
    }
}

function onNewColumnChange(evt) {
    var ctrl = evt.target,
        tabColumnQB = this.tabz.folder('#tableQB'),
        tab = this.tabz.enabledTab(tabColumnQB.parentElement),
        isQueryBuilder = tab === tabColumnQB,
        tabProps = tabProperties[tab.id];

    this.filter.columnFilters.add({
        state: {
            type: 'columnFilter',
            children: [ { column: ctrl.value } ]
        },
        focus: isQueryBuilder
    });

    if (tabProps.isColumnFilter && tabProps.lanugage) {
        renderFolder.call(this, tab);
    }

    // remove all but the prompt option (first child)
    ctrl.selectedIndex = 0;
    while (ctrl.lastChild !== ctrl.firstChild) {
        ctrl.removeChild(ctrl.lastChild);
    }
}

function renderFolder(tab) { // to be called with filter object as syntax
    var tabProps = tabProperties[tab.id],
        queryLanguage = tabProps.language;

    if (queryLanguage) {
        var globalFilter = this.filter,
            folder = this.tabz.folder(tab);

        if (tabProps.isTableFilter) {

            folder.querySelector('textarea').value = globalFilter.tableFilter.getState({ syntax: 'SQL' });

        } else { // column filter

            var columnFilters = globalFilter.columnFilters.children,
                el = folder.lastElementChild,
                msgEl = el.querySelector('span'),
                listEl = el.querySelector('ol'),
                copyAllLink = el.querySelector('a:first-of-type');

            msgEl.innerHTML = activeFiltersMessage(columnFilters.length);
            listEl.innerHTML = '';

            // for each column filter subtree, append an <li>...</li> element containing:
            // column title, "(copy)" link, and editable text input box containing the subexpression
            columnFilters.forEach(function(filter) {
                var conditional = filter.children[0],
                    item = conditional.schema[0],
                    name = conditional.column,
                    alias = item.alias || name,
                    expression = filter.getState({ syntax: queryLanguage }),
                    isNull = expression === '(NULL IS NULL)' || expression === '',
                    content = isNull ? '' : expression,
                    className = isNull ? 'filter-tree-error' : '',
                    li = automat.firstChild(markup[queryLanguage], alias, name, content, className);

                listEl.appendChild(li);
            });

            folder.onkeyup = setColumnFilterState.bind(this, queryLanguage);

            if (copyAllLink) {
                // if there's a "(copy all)" link, hide it if only 0 or 1 subexpressions
                copyAllLink.style.display = columnFilters.length > 1 ? 'block' : 'none';
            }
        }

    }
}

//var RETURN_KEY = 0x0d, ESCAPE_KEY = 0x1b;
/**
 * Called from key-up events from `#columnSQL` and `#columnCQL` tabs.
 * @this Filter
 * @param {string} queryLanguage
 * @param {KeyboardEvent} evt
 */
function setColumnFilterState(queryLanguage, evt) {
    var ctrl = evt.target;

    // Only handle if key was pressed inside a text box.
    if (ctrl.classList.contains('filter-text-box')) {
        //switch (evt.keyCode) {
        //    case ESCAPE_KEY:
        //        ctrl.value = oldArg;
        //    case RETURN_KEY: // eslint-disable-line no-fallthrough
        //        ctrl.blur();
        //        break;
        //    default:
        var error,
            options = { syntax: queryLanguage, alert: true };

        try {
            error = this.filter.setColumnFilterState(ctrl.name, ctrl.value, options);
        } catch (err) {
            error = err;
        }

        decorateFilterInput(ctrl, error);
        //}
    }
}

function activeFiltersMessage(n) {
    var result;

    switch (n) {
        case 0:
            result = 'There are no active column filters.';
            break;
        case 1:
            result = 'There is 1 active column filter:';
            break;
        default:
            result = 'There are ' + n + ' active column filters:';
    }

    return result;
}


module.exports = ManageFilters;

},{"../../html":2,"../lib/copy-input":117,"./Dialog":89,"automat":5,"pop-menu":47,"tabz":51}],91:[function(require,module,exports){
'use strict';

module.exports.ColumnPicker = require('./ColumnPicker');
module.exports.ManageFilters = require('./ManageFilters');

},{"./ColumnPicker":88,"./ManageFilters":90}],92:[function(require,module,exports){
/* eslint-env browser */

'use strict';

/* NOTE
 *
 * What this file is:
 * * This file is browserify's entry point.
 * * This file creates the `window.fin.Hypergrid` object.
 *
 * What this file is not:
 * * This file is not a node module; it has no reference to `module.exports` or `exports`; it cannot be "required" by any other file.
 * * This file is blacklisted in .npmignore and is not published to npm.
 *
 * Note: The npm "main" entry point (as noted in package.json) is src/Hypergrid.js.
 */

var Hypergrid = require('./Hypergrid');

// Expose some namespaces to users of the hypergrid.js file through `fin.Hypergrid`:
Hypergrid.JSON = require('./lib/json');
Hypergrid.images = require('../images');
Hypergrid.behaviors = require('./behaviors');
Hypergrid.dataModels = require('./dataModels');
Hypergrid.features = require('./features');
Hypergrid.analytics = require('./Shared.js').analytics;
Hypergrid.DefaultFilter = require('./filter/DefaultFilter');
Hypergrid.ColumnSchemaFactory = require('./filter/ColumnSchemaFactory');
Hypergrid.FilterTree = require('./Shared').FilterTree;
Hypergrid.rectangular = require('rectangular');

// Create the `fin` and in particular the `fin.Hypergrid` objects:
(window.fin = window.fin || {}).Hypergrid = Hypergrid;

// Note that while users of the npm module can also access the above namespaces through the Hypergrid object, in reality they also have access to any namespace through `require`, for example:
// var behaviorJSON = require('fin-hypergrid/src/behaviors/JSON');

},{"../images":4,"./Hypergrid":54,"./Shared":55,"./Shared.js":55,"./behaviors":61,"./dataModels":86,"./features":109,"./filter/ColumnSchemaFactory":110,"./filter/DefaultFilter":111,"./lib/json":121,"rectangular":48}],93:[function(require,module,exports){
'use strict';

var Feature = require('./Feature.js');

/**
 * @constructor
 * @extends Feature
 */
var CellClick = Feature.extend('CellClick', {

    /**
     * @memberOf CellClick.prototype
     * @desc Handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleClick: function(grid, event) {
        if (
            event.gridCell.y >= grid.behavior.getHeaderRowCount() &&
            event.gridCell.x >= grid.behavior.getHeaderColumnCount()
        ) {
            grid.cellClicked(event);
        } else if (this.next) {
            this.next.handleClick(grid, event);
        }
    }
});

module.exports = CellClick;

},{"./Feature.js":102}],94:[function(require,module,exports){
'use strict';

var Feature = require('./Feature.js');
var CellEditor = require('../cellEditors/CellEditor');

/**
 * @constructor
 * @extends Feature
 */
var CellEditing = Feature.extend('CellEditing', {

    /**
     * @memberOf CellEditing.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleDoubleClick: function(grid, event) {
        var isDoubleClickEditorActivation = grid.resolveProperty('editOnDoubleClick');
        if (this.checkActivateEditor(grid, event, isDoubleClickEditorActivation)) {
            grid.onEditorActivate(event);
        } else if (this.next) {
            this.next.handleDoubleClick(grid, event);
        }
    },

    handleClick: function(grid, event) {
        var isDoubleClickEditorActivation = grid.resolveProperty('editOnDoubleClick');
        if (this.checkActivateEditor(grid, event, !isDoubleClickEditorActivation)) {
            grid.onEditorActivate(event);
        } else if (this.next) {
            this.next.handleClick(grid, event);
        }
    },

    checkActivateEditor: function(grid, event, isDoubleClickEditorActivation) {
        var headerRowCount = grid.behavior.getHeaderRowCount();
        var headerColumnCount = grid.behavior.getHeaderColumnCount();
        var gridCell = event.gridCell;
        var isFilterRow = grid.isFilterRow(gridCell.y);

        return isDoubleClickEditorActivation &&
            gridCell.x >= headerColumnCount &&
            (isFilterRow || gridCell.y >= headerRowCount);
    },

    /**
     * @desc Handle this event down the feature chain of responsibility.
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     * @memberOf KeyPaging.prototype
     */
    handleKeyDown: function(grid, event) {
        var char, isVisibleChar, isDeleteChar, currentCell, editor;

        if (
            grid.resolveProperty('editOnKeydown') &&
            !grid.cellEditor &&
            (
                (char = event.detail.char) === 'F2' ||
                (isVisibleChar = char.length === 1 && !(event.detail.meta || event.detail.ctrl)) ||
                (isDeleteChar = char === 'DELETE' || char === 'BACKSPACE')
            )
        ) {
            currentCell = grid.selectionModel.getLastSelection();
            if (currentCell) {
                var pseudoEvent = { gridCell: currentCell.origin };
                editor = grid.onEditorActivate(pseudoEvent);
                if (editor instanceof CellEditor) {
                    if (isVisibleChar) {
                        editor.setEditorValue(char);
                    } else if (isDeleteChar) {
                        editor.setEditorValue('');
                    }
                    event.detail.primitiveEvent.preventDefault();
                }
            }
        } else if (this.next) {
            this.next.handleKeyDown(grid, event);
        }
    }

});

module.exports = CellEditing;

},{"../cellEditors/CellEditor":62,"./Feature.js":102}],95:[function(require,module,exports){
'use strict';

var Feature = require('./Feature.js');

/**
 * @constructor
 * @extends Feature
 */
var CellSelection = Feature.extend('CellSelection', {

    /**
     * The pixel location of the mouse pointer during a drag operation.
     * @type {window.fin.rectangular.Point}
     * @memberOf CellSelection.prototype
     */
    currentDrag: null,

    /**
     * the cell coordinates of the where the mouse pointer is during a drag operation
     * @type {Object}
     * @memberOf CellSelection.prototype
     */
    lastDragCell: null,

    /**
     * a millisecond value representing the previous time an autoscroll started
     * @type {number}
     * @default 0
     * @memberOf CellSelection.prototype
     */
    sbLastAuto: 0,

    /**
     * a millisecond value representing the time the current autoscroll started
     * @type {number}
     * @default 0
     * @memberOf CellSelection.prototype
     */
    sbAutoStart: 0,

    /**
     * @memberOf CellSelection.prototype
     * @desc Handle this event down the feature chain of responsibility.
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseUp: function(grid, event) {
        if (this.dragging) {
            this.dragging = false;
        }
        if (this.next) {
            this.next.handleMouseUp(grid, event);
        }
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc Handle this event down the feature chain of responsibility.
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDown: function(grid, event) {
        var isRightClick = event.primitiveEvent.detail.isRightClick;
        var cell = event.gridCell;
        var viewCell = event.viewPoint;
        var dx = cell.x;
        var dy = cell.y;
        var headerRowCount = grid.behavior.getHeaderRowCount();
        var headerColumnCount = grid.behavior.getHeaderColumnCount();
        var columnCount = grid.getColumnCount();
        var isOutside = viewCell.x >= columnCount;

        var isHeader = dy < headerRowCount || dx < headerColumnCount;

        if (!grid.isCellSelection() || isRightClick || isHeader || isOutside) {
            if (this.next) {
                this.next.handleMouseDown(grid, event);
            }
        } else {
            var numFixedColumns = grid.getFixedColumnCount();
            var numFixedRows = grid.getFixedRowCount();

            //if we are in the fixed area do not apply the scroll values
            //check both x and y values independently
            if (viewCell.x < numFixedColumns) {
                dx = viewCell.x;
            }

            if (viewCell.y < numFixedRows) {
                dy = viewCell.y;
            }

            var dCell = grid.newPoint(dx, dy);

            var primEvent = event.primitiveEvent;
            var keys = primEvent.detail.keys;
            this.dragging = true;
            this.extendSelection(grid, dCell, keys);
        }
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc Handle this event down the feature chain of responsibility.
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDrag: function(grid, event) {
        var isRightClick = event.primitiveEvent.detail.isRightClick;

        if (!grid.isCellSelection() || isRightClick || !this.dragging) {
            if (this.next) {
                this.next.handleMouseDrag(grid, event);
            }
        } else {

            var numFixedColumns = grid.getFixedColumnCount();
            var numFixedRows = grid.getFixedRowCount();

            var cell = event.gridCell;
            var viewCell = event.viewPoint;
            var dx = cell.x;
            var dy = cell.y;

            //if we are in the fixed area do not apply the scroll values
            //check both x and y values independently
            if (viewCell.x < numFixedColumns) {
                dx = viewCell.x;
            }

            if (viewCell.y < numFixedRows) {
                dy = viewCell.y;
            }

            var dCell = grid.newPoint(dx, dy);

            var primEvent = event.primitiveEvent;
            this.currentDrag = primEvent.detail.mouse;
            this.lastDragCell = dCell;

            this.checkDragScroll(grid, this.currentDrag);
            this.handleMouseDragCellSelection(grid, dCell, primEvent.detail.keys);
        }
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc Handle this event down the feature chain of responsibility.
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleKeyDown: function(grid, event) {
        var handler;
        if ((handler = this['handle' + event.detail.char])) {
            handler.call(this, grid, event.detail);
        } else if (this.next) {
            this.next.handleKeyDown(grid, event);
        }
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc Handle a mousedrag selection.
     * @param {Hypergrid} grid
     * @param {Object} mouse - the event details
     * @param {Array} keys - array of the keys that are currently pressed down
     */
    handleMouseDragCellSelection: function(grid, gridCell, keys) {

        var headerRowCount = grid.behavior.getHeaderRowCount();
        var headerColumnCount = grid.behavior.getHeaderColumnCount();
        var x = gridCell.x;
        var y = gridCell.y;
        x = Math.max(headerColumnCount, x);
        y = Math.max(headerRowCount, y);

        var previousDragExtent = grid.getDragExtent();
        var mouseDown = grid.getMouseDown();

        //var scrollingNow = grid.isScrollingNow();

        var newX = x - mouseDown.x;
        var newY = y - mouseDown.y;

        if (previousDragExtent.x === newX && previousDragExtent.y === newY) {
            return;
        }

        grid.clearMostRecentSelection();

        grid.select(mouseDown.x, mouseDown.y, newX, newY);
        grid.setDragExtent(grid.newPoint(newX, newY));

        grid.repaint();
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc this checks while were dragging if we go outside the visible bounds, if so, kick off the external autoscroll check function (above)
     * @param {Hypergrid} grid
     * @param {Object} mouse - the event details
     */
    checkDragScroll: function(grid, mouse) {
        if (!grid.resolveProperty('scrollingEnabled')) {
            return;
        }
        var b = grid.getDataBounds();
        var inside = b.contains(mouse);
        if (inside) {
            if (grid.isScrollingNow()) {
                grid.setScrollingNow(false);
            }
        } else if (!grid.isScrollingNow()) {
            grid.setScrollingNow(true);
            this.scrollDrag(grid);
        }
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc this function makes sure that while we are dragging outside of the grid visible bounds, we srcroll accordingly
     * @param {Hypergrid} grid
     */
    scrollDrag: function(grid) {

        if (!grid.isScrollingNow()) {
            return;
        }

        var dragStartedInHeaderArea = grid.isMouseDownInHeaderArea();
        var lastDragCell = this.lastDragCell;
        var b = grid.getDataBounds();
        var xOffset = 0;
        var yOffset = 0;

        var numFixedColumns = grid.getFixedColumnCount();
        var numFixedRows = grid.getFixedRowCount();

        var dragEndInFixedAreaX = lastDragCell.x < numFixedColumns;
        var dragEndInFixedAreaY = lastDragCell.y < numFixedRows;

        if (!dragStartedInHeaderArea) {
            if (this.currentDrag.x < b.origin.x) {
                xOffset = -1;
            }
            if (this.currentDrag.y < b.origin.y) {
                yOffset = -1;
            }
        }
        if (this.currentDrag.x > b.origin.x + b.extent.x) {
            xOffset = 1;
        }
        if (this.currentDrag.y > b.origin.y + b.extent.y) {
            yOffset = 1;
        }

        var dragCellOffsetX = xOffset;
        var dragCellOffsetY = yOffset;

        if (dragEndInFixedAreaX) {
            dragCellOffsetX = 0;
        }

        if (dragEndInFixedAreaY) {
            dragCellOffsetY = 0;
        }

        this.lastDragCell = lastDragCell.plusXY(dragCellOffsetX, dragCellOffsetY);
        grid.scrollBy(xOffset, yOffset);
        this.handleMouseDragCellSelection(grid, lastDragCell, []); // update the selection
        grid.repaint();
        setTimeout(this.scrollDrag.bind(this, grid), 25);
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc extend a selection or create one if there isnt yet
     * @param {Hypergrid} grid
     * @param {Object} gridCell - the event details
     * @param {Array} keys - array of the keys that are currently pressed down
     */
    extendSelection: function(grid, gridCell, keys) {
        var hasCTRL = keys.indexOf('CTRL') >= 0;
        var hasSHIFT = keys.indexOf('SHIFT') >= 0;
        // var scrollTop = grid.getVScrollValue();
        // var scrollLeft = grid.getHScrollValue();

        // var numFixedColumns = 0;//grid.getFixedColumnCount();
        // var numFixedRows = 0;//grid.getFixedRowCount();

        var mousePoint = grid.getMouseDown();
        var x = gridCell.x; // - numFixedColumns + scrollLeft;
        var y = gridCell.y; // - numFixedRows + scrollTop;

        //were outside of the grid do nothing
        if (x < 0 || y < 0) {
            return;
        }

        //we have repeated a click in the same spot deslect the value from last time
        if (
            hasCTRL &&
            x === mousePoint.x &&
            y === mousePoint.y
        ) {
            grid.clearMostRecentSelection();
            grid.popMouseDown();
            grid.repaint();
            return;
        }

        if (!hasCTRL && !hasSHIFT) {
            grid.clearSelections();
        }

        if (hasSHIFT) {
            grid.clearMostRecentSelection();
            grid.select(mousePoint.x, mousePoint.y, x - mousePoint.x + 1, y - mousePoint.y + 1);
            grid.setDragExtent(grid.newPoint(x - mousePoint.x + 1, y - mousePoint.y));
        } else {
            grid.select(x, y, 0, 0);
            grid.setMouseDown(grid.newPoint(x, y));
            grid.setDragExtent(grid.newPoint(0, 0));
        }
        grid.repaint();
    },


    /**
     * @memberOf CellSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     */
    handleDOWNSHIFT: function(grid) {
        this.moveShiftSelect(grid, 0, 1);
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleUPSHIFT: function(grid) {
        this.moveShiftSelect(grid, 0, -1);
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleLEFTSHIFT: function(grid) {
        this.moveShiftSelect(grid, -1, 0);
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleRIGHTSHIFT: function(grid) {
        this.moveShiftSelect(grid, 1, 0);
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleDOWN: function(grid, event) {
        //keep the browser viewport from auto scrolling on key event
        event.primitiveEvent.preventDefault();

        var count = this.getAutoScrollAcceleration();
        this.moveSingleSelect(grid, 0, count);
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleUP: function(grid, event) {
        //keep the browser viewport from auto scrolling on key event
        event.primitiveEvent.preventDefault();

        var count = this.getAutoScrollAcceleration();
        this.moveSingleSelect(grid, 0, -count);
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleLEFT: function(grid) {
        this.moveSingleSelect(grid, -1, 0);
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleRIGHT: function(grid) {
        this.moveSingleSelect(grid, 1, 0);
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc If we are holding down the same navigation key, accelerate the increment we scroll
     * #### returns: integer
     */
    getAutoScrollAcceleration: function() {
        var count = 1;
        var elapsed = this.getAutoScrollDuration() / 2000;
        count = Math.max(1, Math.floor(elapsed * elapsed * elapsed * elapsed));
        return count;
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc set the start time to right now when we initiate an auto scroll
     */
    setAutoScrollStartTime: function() {
        this.sbAutoStart = Date.now();
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc update the autoscroll start time if we haven't autoscrolled within the last 500ms otherwise update the current autoscroll time
     */
    pingAutoScroll: function() {
        var now = Date.now();
        if (now - this.sbLastAuto > 500) {
            this.setAutoScrollStartTime();
        }
        this.sbLastAuto = Date.now();
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc answer how long we have been auto scrolling
     * #### returns: integer
     */
    getAutoScrollDuration: function() {
        if (Date.now() - this.sbLastAuto > 500) {
            return 0;
        }
        return Date.now() - this.sbAutoStart;
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc Augment the most recent selection extent by (offsetX,offsetY) and scroll if necessary.
     * @param {Hypergrid} grid
     * @param {number} offsetX - x coordinate to start at
     * @param {number} offsetY - y coordinate to start at
     */
    moveShiftSelect: function(grid, offsetX, offsetY) {

        var maxColumns = grid.getColumnCount() - 1;
        var maxRows = grid.getRowCount() - 1;

        var maxViewableColumns = grid.getVisibleColumns() - 1;
        var maxViewableRows = grid.getVisibleRows() - 1;

        if (!grid.resolveProperty('scrollingEnabled')) {
            maxColumns = Math.min(maxColumns, maxViewableColumns);
            maxRows = Math.min(maxRows, maxViewableRows);
        }

        var origin = grid.getMouseDown();
        var extent = grid.getDragExtent();

        var newX = extent.x + offsetX;
        var newY = extent.y + offsetY;

        newX = Math.min(maxColumns - origin.x, Math.max(-origin.x, newX));
        newY = Math.min(maxRows - origin.y, Math.max(-origin.y, newY));

        grid.clearMostRecentSelection();
        grid.select(origin.x, origin.y, newX, newY);

        grid.setDragExtent(grid.newPoint(newX, newY));

        if (grid.insureModelColIsVisible(newX + origin.x, offsetX)) {
            this.pingAutoScroll();
        }
        if (grid.insureModelRowIsVisible(newY + origin.y, offsetY)) {
            this.pingAutoScroll();
        }

        grid.repaint();

    },

    /**
     * @memberOf CellSelection.prototype
     * @desc Replace the most recent selection with a single cell selection that is moved (offsetX,offsetY) from the previous selection extent.
     * @param {Hypergrid} grid
     * @param {number} offsetX - x coordinate to start at
     * @param {number} offsetY - y coordinate to start at
     */
    moveSingleSelect: function(grid, offsetX, offsetY) {

        var maxColumns = grid.getColumnCount() - 1;
        var maxRows = grid.getRowCount() - 1;

        var maxViewableColumns = grid.getVisibleColumnsCount() - 1;
        var maxViewableRows = grid.getVisibleRowsCount() - 1;

        var minRows = grid.getHeaderRowCount();
        var minCols = grid.getHeaderColumnCount();

        if (!grid.resolveProperty('scrollingEnabled')) {
            maxColumns = Math.min(maxColumns, maxViewableColumns);
            maxRows = Math.min(maxRows, maxViewableRows);
        }

        var mouseCorner = grid.getMouseDown().plus(grid.getDragExtent());

        var newX = mouseCorner.x + offsetX;
        var newY = mouseCorner.y + offsetY;

        newX = Math.min(maxColumns, Math.max(minCols, newX));
        newY = Math.min(maxRows, Math.max(minRows, newY));

        grid.clearSelections();
        grid.select(newX, newY, 0, 0);
        grid.setMouseDown(grid.newPoint(newX, newY));
        grid.setDragExtent(grid.newPoint(0, 0));

        grid.selectCellAndScrollToMakeVisible(newX, newY);

        // if (grid.insureModelColIsVisible(newX, offsetX)) {
        //     this.pingAutoScroll();
        // }
        // if (grid.insureModelRowIsVisible(newY, offsetY)) {
        //     this.pingAutoScroll();
        // }

        grid.repaint();

    }

});

module.exports = CellSelection;

},{"./Feature.js":102}],96:[function(require,module,exports){
'use strict';

var Feature = require('./Feature.js');

/**
 * @constructor
 * @extends Feature
 */
var ColumnAutosizing = Feature.extend('ColumnAutosizing', {

    /**
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     * @memberOf ColumnAutosizing.prototype
     */
    handleDoubleClick: function(grid, event) {
        var headerRowCount = grid.getHeaderRowCount();
        //var headerColCount = grid.getHeaderColumnCount();
        var gridCell = event.gridCell;
        if (gridCell.y <= headerRowCount) {
            grid.autosizeColumn(gridCell.x);
        } else if (this.next) {
            this.next.handleDoubleClick(grid, event);
        }
    }

});

module.exports = ColumnAutosizing;

},{"./Feature.js":102}],97:[function(require,module,exports){
/* eslint-env browser */
/* global requestAnimationFrame */

'use strict';

// This feature is responsible for column drag and drop reordering.
// This object is a mess and desperately needs a complete rewrite.....

var Feature = require('./Feature.js');

var columnAnimationTime = 150;
var dragger;
var draggerCTX;
var floatColumn;
var floatColumnCTX;

/**
 * @constructor
 * @extends Feature
 */
var ColumnMoving = Feature.extend('ColumnMoving', {

    /**
     * queue up the animations that need to play so they are done synchronously
     * @type {Array}
     * @memberOf CellMoving.prototype
     */
    floaterAnimationQueue: [],

    /**
     * am I currently auto scrolling right
     * @type {boolean}
     * @memberOf CellMoving.prototype
     */
    columnDragAutoScrollingRight: false,

    /**
     * am I currently auto scrolling left
     * @type {boolean}
     * @memberOf CellMoving.prototype
     */
    columnDragAutoScrollingLeft: false,

    /**
     * is the drag mechanism currently enabled ("armed")
     * @type {boolean}
     * @memberOf CellMoving.prototype
     */
    dragArmed: false,

    /**
     * am I dragging right now
     * @type {boolean}
     * @memberOf CellMoving.prototype
     */
    dragging: false,

    /**
     * the column index of the currently dragged column
     * @type {number}
     * @memberOf CellMoving.prototype
     */
    dragCol: -1,

    /**
     * an offset to position the dragged item from the cursor
     * @type {number}
     * @memberOf CellMoving.prototype
     */
    dragOffset: 0,

    /**
     * @memberOf CellMoving.prototype
     * @desc give me an opportunity to initialize stuff on the grid
     * @param {Hypergrid} grid
     */
    initializeOn: function(grid) {
        this.isFloatingNow = false;
        this.initializeAnimationSupport(grid);
        if (this.next) {
            this.next.initializeOn(grid);
        }
    },

    /**
     * @memberOf CellMoving.prototype
     * @desc initialize animation support on the grid
     * @param {Hypergrid} grid
     */
    initializeAnimationSupport: function(grid) {
        if (!dragger) {
            dragger = document.createElement('canvas');
            dragger.setAttribute('width', '0px');
            dragger.setAttribute('height', '0px');

            document.body.appendChild(dragger);
            draggerCTX = dragger.getContext('2d');
        }
        if (!floatColumn) {
            floatColumn = document.createElement('canvas');
            floatColumn.setAttribute('width', '0px');
            floatColumn.setAttribute('height', '0px');

            document.body.appendChild(floatColumn);
            floatColumnCTX = floatColumn.getContext('2d');
        }

    },

    getCanDragCursorName: function() {
        return '-webkit-grab';
    },

    getDraggingCursorName: function() {
        return '-webkit-grabbing';
    },

    /**
     * @memberOf CellMoving.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDrag: function(grid, event) {

        var gridCell = event.gridCell;
        var x;
        //var y;

        var distance = Math.abs(event.primitiveEvent.detail.dragstart.x - event.primitiveEvent.detail.mouse.x);

        if (distance < 10 || this.isFixedColumn(grid, event)) {
            if (this.next) {
                this.next.handleMouseDrag(grid, event);
            }
            return;
        }

        if (this.isHeaderRow(grid, event) && this.dragArmed && !this.dragging) {
            this.dragging = true;
            this.dragCol = gridCell.x;
            this.dragOffset = event.mousePoint.x;
            this.detachChain();
            x = event.primitiveEvent.detail.mouse.x - this.dragOffset;
            //y = event.primitiveEvent.detail.mouse.y;
            this.createDragColumn(grid, x, this.dragCol);
        } else if (this.next) {
            this.next.handleMouseDrag(grid, event);
        }

        if (this.dragging) {
            x = event.primitiveEvent.detail.mouse.x - this.dragOffset;
            //y = event.primitiveEvent.detail.mouse.y;
            this.dragColumn(grid, x);
        }
    },

    /**
     * @memberOf CellMoving.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDown: function(grid, event) {
        if (grid.behavior.isColumnReorderable() && !this.isFixedColumn(grid, event)) {
            if (this.isHeaderRow(grid, event) && event.gridCell.x !== -1) {
                this.dragArmed = true;
                this.cursor = this.getDraggingCursorName();
                grid.clearSelections();
            }
        }
        if (this.next) {
            this.next.handleMouseDown(grid, event);
        }
    },

    /**
     * @memberOf CellMoving.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseUp: function(grid, event) {
        //var col = event.gridCell.x;
        if (this.dragging) {
            this.cursor = null;
            //delay here to give other events a chance to be dropped
            var self = this;
            this.endDragColumn(grid);
            setTimeout(function() {
                self.attachChain();
            }, 200);
        }
        this.dragCol = -1;
        this.dragging = false;
        this.dragArmed = false;
        this.cursor = null;
        grid.repaint();

        if (this.next) {
            this.next.handleMouseUp(grid, event);
        }

    },

    /**
     * @memberOf CellMoving.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseMove: function(grid, event) {

        if (!this.dragging && event.mousePoint.y < 5 && event.viewPoint.y === 0 && !this.isFixedColumn(grid, event)) {
            this.cursor = this.getCanDragCursorName();
        } else {
            this.cursor = null;
        }

        if (this.next) {
            this.next.handleMouseMove(grid, event);
        }

        if (this.isHeaderRow(grid, event) && this.dragging) {
            this.cursor = this.getDraggingCursorName(); //move';
        }
    },

    /**
     * @memberOf CellMoving.prototype
     * @desc this is the main event handler that manages the dragging of the column
     * @param {Hypergrid} grid
     * @param {boolean} draggedToTheRight - are we moving to the right
     */
    floatColumnTo: function(grid, draggedToTheRight) {
        this.floatingNow = true;

        var renderer = grid.getRenderer();
        var colEdges = renderer.getColumnEdges();
        var scrollLeft = grid.getHScrollValue();
        var floaterIndex = grid.renderOverridesCache.floater.columnIndex;
        var draggerIndex = grid.renderOverridesCache.dragger.columnIndex;
        var hdpiratio = grid.renderOverridesCache.dragger.hdpiratio;

        var draggerStartX;
        var floaterStartX;
        var fixedColumnCount = grid.getFixedColumnCount();
        var draggerWidth = grid.getColumnWidth(draggerIndex);
        var floaterWidth = grid.getColumnWidth(floaterIndex);

        var max = grid.getVisibleColumnsCount();

        var doffset = 0;
        var foffset = 0;

        if (draggerIndex >= fixedColumnCount) {
            doffset = scrollLeft;
        }
        if (floaterIndex >= fixedColumnCount) {
            foffset = scrollLeft;
        }

        if (draggedToTheRight) {
            draggerStartX = colEdges[Math.min(max, draggerIndex - doffset)];
            floaterStartX = colEdges[Math.min(max, floaterIndex - foffset)];

            grid.renderOverridesCache.dragger.startX = (draggerStartX + floaterWidth) * hdpiratio;
            grid.renderOverridesCache.floater.startX = draggerStartX * hdpiratio;

        } else {
            floaterStartX = colEdges[Math.min(max, floaterIndex - foffset)];
            draggerStartX = floaterStartX + draggerWidth;

            grid.renderOverridesCache.dragger.startX = floaterStartX * hdpiratio;
            grid.renderOverridesCache.floater.startX = draggerStartX * hdpiratio;
        }
        grid.swapColumns(draggerIndex, floaterIndex);
        grid.renderOverridesCache.dragger.columnIndex = floaterIndex;
        grid.renderOverridesCache.floater.columnIndex = draggerIndex;


        this.floaterAnimationQueue.unshift(this.doColumnMoveAnimation(grid, floaterStartX, draggerStartX));

        this.doFloaterAnimation(grid);

    },

    /**
     * @memberOf CellMoving.prototype
     * @desc manifest the column drag and drop animation
     * @param {Hypergrid} grid
     * @param {number} floaterStartX - the x start coordinate of the column underneath that floats behind the dragged column
     * @param {number} draggerStartX - the x start coordinate of the dragged column
     */
    doColumnMoveAnimation: function(grid, floaterStartX, draggerStartX) {
        var self = this;
        return function() {
            var d = floatColumn;
            d.style.display = 'inline';
            self.setCrossBrowserProperty(d, 'transform', 'translate(' + floaterStartX + 'px, ' + 0 + 'px)');

            //d.style.webkit-webkit-Transform = 'translate(' + floaterStartX + 'px, ' + 0 + 'px)';
            //d.style.webkit-webkit-Transform = 'translate(' + floaterStartX + 'px, ' + 0 + 'px)';

            requestAnimationFrame(function() {
                self.setCrossBrowserProperty(d, 'transition', (self.isWebkit ? '-webkit-' : '') + 'transform ' + columnAnimationTime + 'ms ease');
                self.setCrossBrowserProperty(d, 'transform', 'translate(' + draggerStartX + 'px, ' + -2 + 'px)');
            });
            grid.repaint();
            //need to change this to key frames

            setTimeout(function() {
                self.setCrossBrowserProperty(d, 'transition', '');
                grid.renderOverridesCache.floater = null;
                grid.repaint();
                self.doFloaterAnimation(grid);
                requestAnimationFrame(function() {
                    d.style.display = 'none';
                    self.isFloatingNow = false;
                });
            }, columnAnimationTime + 50);
        };
    },

    /**
     * @memberOf CellMoving.prototype
     * @desc manifest the floater animation
     * @param {Hypergrid} grid
     */
    doFloaterAnimation: function(grid) {
        if (this.floaterAnimationQueue.length === 0) {
            this.floatingNow = false;
            grid.repaint();
            return;
        }
        var animation = this.floaterAnimationQueue.pop();
        animation();
    },

    /**
     * @memberOf CellMoving.prototype
     * @desc create the float column at columnIndex underneath the dragged column
     * @param {Hypergrid} grid
     * @param {number} columnIndex - the index of the column that will be floating
     */
    createFloatColumn: function(grid, columnIndex) {

        var fixedColumnCount = grid.getFixedColumnCount();
        var scrollLeft = grid.getHScrollValue();

        if (columnIndex < fixedColumnCount) {
            scrollLeft = 0;
        }

        var renderer = grid.getRenderer();
        var columnEdges = renderer.getColumnEdges();

        var columnWidth = grid.getColumnWidth(columnIndex);
        var colHeight = grid.div.clientHeight;
        var d = floatColumn;
        var style = d.style;
        var location = grid.div.getBoundingClientRect();

        style.top = (location.top - 2) + 'px';
        style.left = location.left + 'px';
        style.position = 'fixed';

        var hdpiRatio = grid.getHiDPI(floatColumnCTX);

        d.setAttribute('width', Math.round(columnWidth * hdpiRatio) + 'px');
        d.setAttribute('height', Math.round(colHeight * hdpiRatio) + 'px');
        style.boxShadow = '0 10px 20px rgba(0,0,0,0.19), 0 6px 6px rgba(0,0,0,0.23)';
        style.width = columnWidth + 'px'; //Math.round(columnWidth / hdpiRatio) + 'px';
        style.height = colHeight + 'px'; //Math.round(colHeight / hdpiRatio) + 'px';
        style.borderTop = '1px solid ' + renderer.resolveProperty('lineColor');
        style.backgroundColor = renderer.resolveProperty('backgroundColor');

        var startX = columnEdges[columnIndex - scrollLeft];
        startX = startX * hdpiRatio;

        floatColumnCTX.scale(hdpiRatio, hdpiRatio);

        grid.renderOverridesCache.floater = {
            columnIndex: columnIndex,
            ctx: floatColumnCTX,
            startX: startX,
            width: columnWidth,
            height: colHeight,
            hdpiratio: hdpiRatio
        };

        style.zIndex = '4';
        this.setCrossBrowserProperty(d, 'transform', 'translate(' + startX + 'px, ' + -2 + 'px)');
        style.cursor = this.getDraggingCursorName();
        grid.repaint();
    },

    /**
     * @memberOf CellMoving.prototype
     * @desc utility function for setting cross browser css properties
     * @param {HTMLElement} element - descripton
     * @param {string} property - the property
     * @param {string} value - the value to assign
     */
    setCrossBrowserProperty: function(element, property, value) {
        var uProperty = property[0].toUpperCase() + property.substr(1);
        this.setProp(element, 'webkit' + uProperty, value);
        this.setProp(element, 'Moz' + uProperty, value);
        this.setProp(element, 'ms' + uProperty, value);
        this.setProp(element, 'O' + uProperty, value);
        this.setProp(element, property, value);
    },

    /**
     * @memberOf CellMoving.prototype
     * @desc utility function for setting properties on HTMLElements
     * @param {HTMLElement} element - descripton
     * @param {string} property - the property
     * @param {string} value - the value to assign
     */
    setProp: function(element, property, value) {
        if (property in element.style) {
            element.style[property] = value;
        }
    },

    /**
     * @memberOf CellMoving.prototype
     * @desc create the dragged column at columnIndex above the floated column
     * @param {Hypergrid} grid
     * @param {number} x - the start position
     * @param {number} columnIndex - the index of the column that will be floating
     */
    createDragColumn: function(grid, x, columnIndex) {

        var fixedColumnCount = grid.getFixedColumnCount();
        var scrollLeft = grid.getHScrollValue();

        if (columnIndex < fixedColumnCount) {
            scrollLeft = 0;
        }

        var renderer = grid.getRenderer();
        var columnEdges = renderer.getColumnEdges();
        var hdpiRatio = grid.getHiDPI(draggerCTX);
        var columnWidth = grid.getColumnWidth(columnIndex);
        var colHeight = grid.div.clientHeight;
        var d = dragger;
        var location = grid.div.getBoundingClientRect();
        var style = d.style;

        style.top = location.top + 'px';
        style.left = location.left + 'px';
        style.position = 'fixed';
        style.opacity = 0.85;
        style.boxShadow = '0 19px 38px rgba(0,0,0,0.30), 0 15px 12px rgba(0,0,0,0.22)';
        //style.zIndex = 100;
        style.borderTop = '1px solid ' + renderer.resolveProperty('lineColor');
        style.backgroundColor = grid.renderer.resolveProperty('backgroundColor');

        d.setAttribute('width', Math.round(columnWidth * hdpiRatio) + 'px');
        d.setAttribute('height', Math.round(colHeight * hdpiRatio) + 'px');

        style.width = columnWidth + 'px'; //Math.round(columnWidth / hdpiRatio) + 'px';
        style.height = colHeight + 'px'; //Math.round(colHeight / hdpiRatio) + 'px';

        var startX = columnEdges[columnIndex - scrollLeft];
        startX = startX * hdpiRatio;

        draggerCTX.scale(hdpiRatio, hdpiRatio);

        grid.renderOverridesCache.dragger = {
            columnIndex: columnIndex,
            startIndex: columnIndex,
            ctx: draggerCTX,
            startX: startX,
            width: columnWidth,
            height: colHeight,
            hdpiratio: hdpiRatio
        };

        this.setCrossBrowserProperty(d, 'transform', 'translate(' + x + 'px, -5px)');
        style.zIndex = '5';
        style.cursor = this.getDraggingCursorName();
        grid.repaint();
    },

    /**
     * @memberOf CellMoving.prototype
     * @desc this function is the main dragging logic
     * @param {Hypergrid} grid
     * @param {number} x - the start position
     */
    dragColumn: function(grid, x) {

        //TODO: this function is overly complex, refactor this in to something more reasonable
        var self = this;
        //var renderer = grid.getRenderer();
        //var columnEdges = renderer.getColumnEdges();

        var autoScrollingNow = this.columnDragAutoScrollingRight || this.columnDragAutoScrollingLeft;

        var hdpiRatio = grid.getHiDPI(draggerCTX);

        var dragColumnIndex = grid.renderOverridesCache.dragger.columnIndex;

        var minX = 0;
        var maxX = grid.renderer.getFinalVisableColumnBoundary();
        x = Math.min(x, maxX + 15);
        x = Math.max(minX - 15, x);

        //am I at my lower bound
        var atMin = x < minX && dragColumnIndex !== 0;

        //am I at my upper bound
        var atMax = x > maxX;

        var d = dragger;

        this.setCrossBrowserProperty(d, 'transition', (self.isWebkit ? '-webkit-' : '') + 'transform ' + 0 + 'ms ease, box-shadow ' + columnAnimationTime + 'ms ease');

        this.setCrossBrowserProperty(d, 'transform', 'translate(' + x + 'px, ' + -10 + 'px)');
        requestAnimationFrame(function() {
            d.style.display = 'inline';
        });

        var overCol = grid.renderer.getColumnFromPixelX(x + (d.width / 2 / hdpiRatio));

        if (atMin) {
            overCol = 0;
        }

        if (atMax) {
            overCol = grid.getColumnCount() - 1;
        }

        var doAFloat = dragColumnIndex > overCol;
        doAFloat = doAFloat || (overCol - dragColumnIndex >= 1);

        if (doAFloat && !atMax && !autoScrollingNow) {
            var draggedToTheRight = dragColumnIndex < overCol;
            // if (draggedToTheRight) {
            //     overCol = overCol - 1;
            // }
            if (this.isFloatingNow) {
                return;
            }

            this.isFloatingNow = true;
            this.createFloatColumn(grid, overCol);
            this.floatColumnTo(grid, draggedToTheRight);
        } else {

            if (x < minX - 10) {
                this.checkAutoScrollToLeft(grid, x);
            }
            if (x > minX - 10) {
                this.columnDragAutoScrollingLeft = false;
            }
            //lets check for autoscroll to right if were up against it
            if (atMax || x > maxX + 10) {
                this.checkAutoScrollToRight(grid, x);
                return;
            }
            if (x < maxX + 10) {
                this.columnDragAutoScrollingRight = false;
            }
        }
    },

    /**
     * @memberOf CellMoving.prototype
     * @desc autoscroll to the right if necessary
     * @param {Hypergrid} grid
     * @param {number} x - the start position
     */
    checkAutoScrollToRight: function(grid, x) {
        if (this.columnDragAutoScrollingRight) {
            return;
        }
        this.columnDragAutoScrollingRight = true;
        this._checkAutoScrollToRight(grid, x);
    },

    _checkAutoScrollToRight: function(grid, x) {
        if (!this.columnDragAutoScrollingRight) {
            return;
        }
        var scrollLeft = grid.getHScrollValue();
        if (!grid.dragging || scrollLeft > (grid.sbHScroller.range.max - 2)) {
            return;
        }
        var draggedIndex = grid.renderOverridesCache.dragger.columnIndex;
        grid.scrollBy(1, 0);
        var newIndex = draggedIndex + 1;
        console.log(newIndex, draggedIndex);
        grid.swapColumns(newIndex, draggedIndex);
        grid.renderOverridesCache.dragger.columnIndex = newIndex;

        setTimeout(this._checkAutoScrollToRight.bind(this, grid, x), 250);
    },

    /**
     * @memberOf CellMoving.prototype
     * @desc autoscroll to the left if necessary
     * @param {Hypergrid} grid
     * @param {number} x - the start position
     */
    checkAutoScrollToLeft: function(grid, x) {
        if (this.columnDragAutoScrollingLeft) {
            return;
        }
        this.columnDragAutoScrollingLeft = true;
        this._checkAutoScrollToLeft(grid, x);
    },

    _checkAutoScrollToLeft: function(grid, x) {
        if (!this.columnDragAutoScrollingLeft) {
            return;
        }

        var scrollLeft = grid.getHScrollValue();
        if (!grid.dragging || scrollLeft < 1) {
            return;
        }
        var draggedIndex = grid.renderOverridesCache.dragger.columnIndex;
        grid.swapColumns(draggedIndex + scrollLeft, draggedIndex + scrollLeft - 1);
        grid.scrollBy(-1, 0);
        setTimeout(this._checkAutoScrollToLeft.bind(this, grid, x), 250);
    },

    /**
     * @memberOf CellMoving.prototype
     * @desc a column drag has completed, update data and cleanup
     * @param {Hypergrid} grid
     */
    endDragColumn: function(grid) {

        var fixedColumnCount = grid.getFixedColumnCount();
        var scrollLeft = grid.getHScrollValue();

        var columnIndex = grid.renderOverridesCache.dragger.columnIndex;

        if (columnIndex < fixedColumnCount) {
            scrollLeft = 0;
        }

        var renderer = grid.getRenderer();
        var columnEdges = renderer.getColumnEdges();
        var self = this;
        var startX = columnEdges[columnIndex - scrollLeft];
        var d = dragger;
        var changed = grid.renderOverridesCache.dragger.startIndex !== grid.renderOverridesCache.dragger.columnIndex;
        self.setCrossBrowserProperty(d, 'transition', (self.isWebkit ? '-webkit-' : '') + 'transform ' + columnAnimationTime + 'ms ease, box-shadow ' + columnAnimationTime + 'ms ease');
        self.setCrossBrowserProperty(d, 'transform', 'translate(' + startX + 'px, ' + -1 + 'px)');
        d.style.boxShadow = '0px 0px 0px #888888';

        setTimeout(function() {
            grid.renderOverridesCache.dragger = null;
            grid.repaint();
            requestAnimationFrame(function() {
                d.style.display = 'none';
                grid.endDragColumnNotification(); //internal notification
                if (changed){
                    grid.fireSyntheticOnColumnsChangedEvent(); //public notification
                }
            });
        }, columnAnimationTime + 50);

    },

    /**
     * @memberOf CellMoving.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    isHeaderRow: function(grid, event) {
        var gridCell = event.viewPoint;
        var isFixed = gridCell.y === 0;
        return isFixed;
    }

});

module.exports = ColumnMoving;

},{"./Feature.js":102}],98:[function(require,module,exports){
/* eslint-env browser */
/* global requestAnimationFrame */

'use strict';

var Feature = require('./Feature.js');

/**
 * @constructor
 * @extends Feature
 */
var ColumnPicker = Feature.extend('ColumnPicker', {

    /**
     * @memberOf ColumnPicker.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleKeyUp: function(grid, event) {
        var key = event.detail.char.toLowerCase();
        var keys = grid.resolveProperty('editorActivationKeys');
        if (keys.indexOf(key) > -1) {
           grid.toggleDialog('ColumnPicker');
        }
    },

});

module.exports = ColumnPicker;

},{"./Feature.js":102}],99:[function(require,module,exports){
'use strict';

var Feature = require('./Feature.js');

/**
 * @constructor
 * @extends Feature
 */
var ColumnResizing = Feature.extend('ColumnResizing', {

    /**
     * the index of the column wall were currently dragging
     * @type {number}
     * @default -2
     * @memberOf ColumnResizing.prototype
     */
    dragIndex: -2,

    /**
     * the pixel location of the where the drag was initiated
     * @type {number}
     * @default -1
     * @memberOf ColumnResizing.prototype
     */
    dragStart: -1,

    /**
     * the starting width/height of the row/column we are dragging
     * @type {number}
     * @default -1
     * @memberOf ColumnResizing.prototype
     */
    dragIndexStartingSize: -1,

    /**
     * @memberOf ColumnResizing.prototype
     * @desc get the mouse x,y coordinate
     * @returns {number}
     * @param {MouseEvent} event - the mouse event to query
     */
    getMouseValue: function(event) {
        return event.primitiveEvent.detail.mouse.x;
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @desc get the grid cell x,y coordinate
     * @returns {number}
     * @param {window.fin.rectangular.Point} gridCell
     */
    getGridCellValue: function(gridCell) {
        return gridCell.y;
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @desc return the grids x,y scroll value
     * @returns {number}
     * @param {Hypergrid} grid
     */
    getScrollValue: function(grid) {
        return grid.getHScrollValue();
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @desc return the width/height of the row/column of interest
     * @returns {number}
     * @param {Hypergrid} grid
     * @param {number} index - the row/column index of interest
     */
    getAreaSize: function(grid, index) {
        return grid.getColumnWidth(index);
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @desc set the width/height of the row/column at index
     * @returns {number}
     * @param {Hypergrid} grid
     * @param {number} index - the row/column index of interest
     * @param {number} value - the width/height to set to
     */
    setAreaSize: function(grid, index, value) {
        grid.setColumnWidth(index, value);
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @desc return the recently rendered area's width/height
     * @returns {number}
     * @param {Hypergrid} grid
     * @param {number} index - the row/column index of interest
     */
    getPreviousAbsoluteSize: function(grid, index) {
        return grid.getRenderedWidth(index);
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @desc returns the index of which divider I'm over
     * @returns {number}
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    overAreaDivider: function(grid, event) {
        return grid.overColumnDivider(event);
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @desc am I over the column/row area
     * @returns {boolean}
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    isFirstFixedOtherArea: function(grid, event) {
        return this.isFirstFixedRow(grid, event);
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @desc return the cursor name
     * @returns {string}
     */
    getCursorName: function() {
        return 'col-resize';
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDrag: function(grid, event) {
        if (this.dragIndex > -2) {
            //var fixedAreaCount = this.getFixedAreaCount(grid);
            //var offset = this.getFixedAreaSize(grid, fixedAreaCount + areaIndex);
            var mouse = this.getMouseValue(event);
            var scrollValue = this.getScrollValue(grid);
            if (this.dragIndex < this.getFixedAreaCount(grid)) {
                scrollValue = 0;
            }
            var previous = this.getPreviousAbsoluteSize(grid, this.dragIndex - scrollValue);
            var distance = mouse - previous;
            this.setAreaSize(grid, this.dragIndex, distance);
        } else if (this.next) {
            this.next.handleMouseDrag(grid, event);
        }
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @desc get the width/height of a specific row/column
     * @param {Hypergrid} grid
     * @param {number} areaIndex - the row/column index of interest
     */
    getSize: function(grid, areaIndex) {
        return this.getAreaSize(grid, areaIndex);
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @desc return the fixed area rows/columns count
     * @returns {number}
     * @param {Hypergrid} grid
     */
    getOtherFixedAreaCount: function(grid) {
        return grid.getFixedRowCount();
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDown: function(grid, event) {
        var isEnabled = this.isEnabled(grid);
        var overArea = this.overAreaDivider(grid, event);
        if (isEnabled && overArea > -1 && this.isFirstFixedOtherArea(grid, event)) {
            var scrollValue = this.getScrollValue(grid);
            if (overArea < this.getFixedAreaCount(grid)) {
                scrollValue = 0;
            }
            this.dragIndex = overArea - 1 + scrollValue;
            this.dragStart = this.getMouseValue(event);
            this.dragIndexStartingSize = 0;
            this.detachChain();
        } else if (this.next) {
            this.next.handleMouseDown(grid, event);
        }
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseUp: function(grid, event) {
        var isEnabled = this.isEnabled(grid);
        if (isEnabled && this.dragIndex > -2) {
            this.cursor = null;
            this.dragIndex = -2;

            event.primitiveEvent.stopPropagation();
            //delay here to give other events a chance to be dropped
            var self = this;
            grid.synchronizeScrollingBoundries();
            setTimeout(function() {
                self.attachChain();
            }, 200);
        } else if (this.next) {
            this.next.handleMouseUp(grid, event);
        }
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseMove: function(grid, event) {
        if (this.dragIndex > -2) {
            return;
        }
        this.cursor = null;
        if (this.next) {
            this.next.handleMouseMove(grid, event);
        }
        this.checkForAreaResizeCursorChange(grid, event);
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @desc fill this in
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    checkForAreaResizeCursorChange: function(grid, event) {
        var isEnabled = this.isEnabled(grid);
        if (isEnabled && this.overAreaDivider(grid, event) > -1 && this.isFirstFixedOtherArea(grid, event)) {
            this.cursor = this.getCursorName();
        } else {
            this.cursor = null;
        }

    },

    /**
     * @param {Hypergrid} grid
     * @returns {number}
     * @default -2
     * @memberOf ColumnResizing.prototype
     */
    getFixedAreaCount: function(grid) {
        var count = grid.getFixedColumnCount() + (grid.isShowRowNumbers() ? 1 : 0) + (grid.hasHierarchyColumn() ? 1 : 0);
        return count;
    },

    /**
     * @param {Hypergrid} grid
     * @param event
     * @default -2
     * @memberOf ColumnResizing.prototype
     */
    handleDoubleClick: function(grid, event) {
        var isEnabled = this.isEnabled(grid);
        var hasCursor = this.overAreaDivider(grid, event) > -1; //this.cursor !== null;
        var headerRowCount = grid.getHeaderRowCount();
        //var headerColCount = grid.getHeaderColumnCount();
        var gridCell = event.gridCell;
        if (isEnabled && hasCursor && (gridCell.y <= headerRowCount)) {
            grid.autosizeColumn(gridCell.x - 1);
        } else if (this.next) {
            this.next.handleDoubleClick(grid, event);
        }
    },

    /**
     * @param {Hypergrid} grid
     * @returns {boolean}
     * @default -2
     * @memberOf ColumnResizing.prototype
     */
    isEnabled: function(grid) {
        return true;
    }

});

module.exports = ColumnResizing;

},{"./Feature.js":102}],100:[function(require,module,exports){
'use strict';

var Feature = require('./Feature.js');

/**
 * Extra msecs to avoid race condition with fincanvas's double click timer.
 * @type {number}
 * @defaultvalue 50
 * NOTE: 50 msecs seems to work well. 10 and even 25 proved insufficient in Chrome.
 * @private
 */
var RACE_TIME = 50;

/**
 * @constructor
 * @extends Feature
 */
var ColumnSelection = Feature.extend('ColumnSelection', {

    /**
     * The pixel location of the mouse pointer during a drag operation.
     * @type {window.fin.rectangular.Point}
     * @default null
     * @memberOf ColumnSelection.prototype
     */
    currentDrag: null,

    /**
     * The cell coordinates of the where the mouse pointer is during a drag operation.
     * @type {Object}
     * @default null
     * @memberOf ColumnSelection.prototype
     */
    lastDragCell: null,

    /**
     * a millisecond value representing the previous time an autoscroll started
     * @type {number}
     * @default 0
     * @memberOf ColumnSelection.prototype
     */
    sbLastAuto: 0,

    /**
     * a millisecond value representing the time the current autoscroll started
     * @type {number}
     * @default 0
     * @memberOf ColumnSelection.prototype
     */
    sbAutoStart: 0,


    /**
     * @memberOf ColumnSelection.prototype
     * @desc Handle this event down the feature chain of responsibility.
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseUp: function(grid, event) {
        if (this.dragging) {
            this.dragging = false;
        }
        if (this.next) {
            this.next.handleMouseUp(grid, event);
        }
    },

    handleDoubleClick: function(grid, event) {
        if (this.doubleClickTimer) {
            clearTimeout(this.doubleClickTimer); // prevent mouseDown from continuing
            this.doubleClickTimer = undefined;
        }
        if (this.next) {
            this.next.handleDoubleClick(grid, event);
        }
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc * @desc Handle this event down the feature chain of responsibility.
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDown: function(grid, event) {
        if (this.doubleClickTimer) {
            return;
        }

        if ((!grid.isColumnSelection() || event.mousePoint.y < 5) && this.next) {
            this.next.handleMouseDown(grid, event);
            return;
        }

        var isRightClick = event.primitiveEvent.detail.isRightClick;
        var cell = event.gridCell;
        var viewCell = event.viewPoint;
        var dx = cell.x;
        var dy = cell.y;

        var isHeader = grid.isShowHeaderRow() && dy === 0 && dx !== -1;

        if (isRightClick || !isHeader) {
            if (this.next) {
                this.next.handleMouseDown(grid, event);
            }
        } else {
            // HOLD OFF WHILE WAITING FOR DOUBLE-CLICK
            this.doubleClickTimer = setTimeout(function() {
                this.doubleClickTimer = undefined;
                var numFixedColumns = grid.getFixedColumnCount();

                //if we are in the fixed area do not apply the scroll values
                //check both x and y values independently
                if (viewCell.x < numFixedColumns) {
                    dx = viewCell.x;
                }

                var dCell = grid.newPoint(dx, 0);

                var primEvent = event.primitiveEvent;
                var keys = primEvent.detail.keys;
                this.dragging = true;
                this.extendSelection(grid, dCell, keys);
            }.bind(this), grid.resolveProperty('doubleClickDelay') + RACE_TIME);
        }
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDrag: function(grid, event) {

        if ((!grid.isColumnSelection() || this.isColumnDragging(grid)) && this.next) {
            this.next.handleMouseDrag(grid, event);
            return;
        }

        var isRightClick = event.primitiveEvent.detail.isRightClick;

        if (isRightClick || !this.dragging) {
            if (this.next) {
                this.next.handleMouseDrag(grid, event);
            }
        } else {

            var numFixedColumns = grid.getFixedColumnCount();

            var cell = event.gridCell;
            var viewCell = event.viewPoint;
            var dx = cell.x;
            var dy = cell.y;

            //if we are in the fixed area do not apply the scroll values
            //check both x and y values independently
            if (viewCell.x < numFixedColumns) {
                dx = viewCell.x;
            }

            var dCell = grid.newPoint(dx, dy);

            var primEvent = event.primitiveEvent;
            this.currentDrag = primEvent.detail.mouse;
            this.lastDragCell = dCell;

            this.checkDragScroll(grid, this.currentDrag);
            this.handleMouseDragCellSelection(grid, dCell, primEvent.detail.keys);
        }
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleKeyDown: function(grid, event) {
        var handler;
        if (
            grid.getLastSelectionType() === 'column' &&
            (handler = this['handle' + event.detail.char])
        ) {
            handler.call(this, grid, event.detail);
        } else if (this.next) {
            this.next.handleKeyDown(grid, event);
        }
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc Handle a mousedrag selection
     * @param {Hypergrid} grid
     * @param {Object} mouse - the event details
     * @param {Array} keys - array of the keys that are currently pressed down
     */
    handleMouseDragCellSelection: function(grid, gridCell, keys) {
        var x = gridCell.x;
        //            var previousDragExtent = grid.getDragExtent();
        var mouseDown = grid.getMouseDown();

        var newX = x - mouseDown.x;
        //var newY = y - mouseDown.y;

        // if (previousDragExtent.x === newX && previousDragExtent.y === newY) {
        //     return;
        // }

        grid.clearMostRecentColumnSelection();

        grid.selectColumn(mouseDown.x, x);
        grid.setDragExtent(grid.newPoint(newX, 0));

        grid.repaint();
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc this checks while were dragging if we go outside the visible bounds, if so, kick off the external autoscroll check function (above)
     * @param {Hypergrid} grid
     * @param {Object} mouse - the event details
     */
    checkDragScroll: function(grid, mouse) {
        if (!grid.resolveProperty('scrollingEnabled')) {
            return;
        }
        var b = grid.getDataBounds();
        var inside = b.contains(mouse);
        if (inside) {
            if (grid.isScrollingNow()) {
                grid.setScrollingNow(false);
            }
        } else if (!grid.isScrollingNow()) {
            grid.setScrollingNow(true);
            this.scrollDrag(grid);
        }
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc this function makes sure that while we are dragging outside of the grid visible bounds, we srcroll accordingly
     * @param {Hypergrid} grid
     */
    scrollDrag: function(grid) {

        if (!grid.isScrollingNow()) {
            return;
        }

        var lastDragCell = this.lastDragCell;
        var b = grid.getDataBounds();
        var xOffset = 0;
        var yOffset = 0;

        var numFixedColumns = grid.getFixedColumnCount();
        var numFixedRows = grid.getFixedRowCount();

        var dragEndInFixedAreaX = lastDragCell.x < numFixedColumns;
        var dragEndInFixedAreaY = lastDragCell.y < numFixedRows;

        if (this.currentDrag.x < b.origin.x) {
            xOffset = -1;
        }

        if (this.currentDrag.x > b.origin.x + b.extent.x) {
            xOffset = 1;
        }

        var dragCellOffsetX = xOffset;
        var dragCellOffsetY = yOffset;

        if (dragEndInFixedAreaX) {
            dragCellOffsetX = 0;
        }

        if (dragEndInFixedAreaY) {
            dragCellOffsetY = 0;
        }

        this.lastDragCell = lastDragCell.plusXY(dragCellOffsetX, dragCellOffsetY);
        grid.scrollBy(xOffset, yOffset);
        this.handleMouseDragCellSelection(grid, lastDragCell, []); // update the selection
        grid.repaint();
        setTimeout(this.scrollDrag.bind(this, grid), 25);
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc extend a selection or create one if there isnt yet
     * @param {Hypergrid} grid
     * @param {Object} gridCell - the event details
     * @param {Array} keys - array of the keys that are currently pressed down
     */
    extendSelection: function(grid, gridCell, keys) {
        grid.stopEditing();
        //var hasCTRL = keys.indexOf('CTRL') !== -1;
        var hasSHIFT = keys.indexOf('SHIFT') !== -1;

        // var scrollTop = grid.getVScrollValue();
        // var scrollLeft = grid.getHScrollValue();

        // var numFixedColumns = 0;//grid.getFixedColumnCount();
        // var numFixedRows = 0;//grid.getFixedRowCount();

        var mousePoint = grid.getMouseDown();
        var x = gridCell.x; // - numFixedColumns + scrollLeft;
        var y = gridCell.y; // - numFixedRows + scrollTop;

        //were outside of the grid do nothing
        if (x < 0 || y < 0) {
            return;
        }

        //we have repeated a click in the same spot deslect the value from last time
        // if (mousePoint && x === mousePoint.x && y === mousePoint.y) {
        //     grid.clearSelections();
        //     grid.popMouseDown();
        //     grid.repaint();
        //     return;
        // }

        // if (!hasCTRL && !hasSHIFT) {
        //     grid.clearSelections();
        // }

        if (hasSHIFT) {
            grid.clearMostRecentColumnSelection();
            grid.selectColumn(x, mousePoint.x);
            grid.setDragExtent(grid.newPoint(x - mousePoint.x, 0));
        } else {
            grid.toggleSelectColumn(x, keys);
            grid.setMouseDown(grid.newPoint(x, y));
            grid.setDragExtent(grid.newPoint(0, 0));
        }
        grid.repaint();
    },


    /**
     * @memberOf ColumnSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     */
    handleDOWNSHIFT: function(grid) {},

    /**
     * @memberOf ColumnSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleUPSHIFT: function(grid) {},

    /**
     * @memberOf ColumnSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleLEFTSHIFT: function(grid) {
        this.moveShiftSelect(grid, -1);
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleRIGHTSHIFT: function(grid) {
        this.moveShiftSelect(grid, 1);
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleDOWN: function(grid) {

        // var mouseCorner = grid.getMouseDown().plus(grid.getDragExtent());
        // var maxRows = grid.getRowCount() - 1;

        // var newX = mouseCorner.x;
        // var newY = grid.getHeaderRowCount() + grid.getVScrollValue();

        // newY = Math.min(maxRows, newY);

        // grid.clearSelections();
        // grid.select(newX, newY, 0, 0);
        // grid.setMouseDown(new grid.rectangular.Point(newX, newY));
        // grid.setDragExtent(new grid.rectangular.Point(0, 0));

        // grid.repaint();
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleUP: function(grid) {},

    /**
     * @memberOf ColumnSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleLEFT: function(grid) {
        this.moveSingleSelect(grid, -1);
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleRIGHT: function(grid) {
        this.moveSingleSelect(grid, 1);
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc If we are holding down the same navigation key, accelerate the increment we scroll
     * #### returns: integer
     */
    getAutoScrollAcceleration: function() {
        var count = 1;
        var elapsed = this.getAutoScrollDuration() / 2000;
        count = Math.max(1, Math.floor(elapsed * elapsed * elapsed * elapsed));
        return count;
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc set the start time to right now when we initiate an auto scroll
     */
    setAutoScrollStartTime: function() {
        this.sbAutoStart = Date.now();
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc update the autoscroll start time if we haven't autoscrolled within the last 500ms otherwise update the current autoscroll time
     */
    pingAutoScroll: function() {
        var now = Date.now();
        if (now - this.sbLastAuto > 500) {
            this.setAutoScrollStartTime();
        }
        this.sbLastAuto = Date.now();
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc answer how long we have been auto scrolling
     * #### returns: integer
     */
    getAutoScrollDuration: function() {
        if (Date.now() - this.sbLastAuto > 500) {
            return 0;
        }
        return Date.now() - this.sbAutoStart;
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc Augment the most recent selection extent by (offsetX,offsetY) and scroll if necessary.
     * @param {Hypergrid} grid
     * @param {number} offsetX - x coordinate to start at
     * @param {number} offsetY - y coordinate to start at
     */
    moveShiftSelect: function(grid, offsetX) {

        var maxColumns = grid.getColumnCount() - 1;

        var maxViewableColumns = grid.getVisibleColumns() - 1;

        if (!grid.resolveProperty('scrollingEnabled')) {
            maxColumns = Math.min(maxColumns, maxViewableColumns);
        }

        var origin = grid.getMouseDown();
        var extent = grid.getDragExtent();

        var newX = extent.x + offsetX;
        //var newY = grid.getRowCount();

        newX = Math.min(maxColumns - origin.x, Math.max(-origin.x, newX));

        grid.clearMostRecentColumnSelection();
        grid.selectColumn(origin.x, origin.x + newX);

        grid.setDragExtent(grid.newPoint(newX, 0));

        if (grid.insureModelColIsVisible(newX + origin.x, offsetX)) {
            this.pingAutoScroll();
        }

        grid.repaint();

    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc Replace the most recent selection with a single cell selection that is moved (offsetX,offsetY) from the previous selection extent.
     * @param {Hypergrid} grid
     * @param {number} offsetX - x coordinate to start at
     * @param {number} offsetY - y coordinate to start at
     */
    moveSingleSelect: function(grid, offsetX) {

        var maxColumns = grid.getColumnCount() - 1;

        var maxViewableColumns = grid.getVisibleColumnsCount() - 1;

        if (!grid.resolveProperty('scrollingEnabled')) {
            maxColumns = Math.min(maxColumns, maxViewableColumns);
        }

        var mouseCorner = grid.getMouseDown().plus(grid.getDragExtent());

        var newX = mouseCorner.x + offsetX;
        //var newY = grid.getRowCount();

        newX = Math.min(maxColumns, Math.max(0, newX));

        grid.clearSelections();
        grid.selectColumn(newX);
        grid.setMouseDown(grid.newPoint(newX, 0));
        grid.setDragExtent(grid.newPoint(0, 0));

        if (grid.insureModelColIsVisible(newX, offsetX)) {
            this.pingAutoScroll();
        }

        grid.repaint();

    },

    isColumnDragging: function(grid) {
        var dragger = grid.lookupFeature('ColumnMoving');
        if (!dragger) {
            return false;
        }
        var isActivated = dragger.dragging && !this.dragging;
        return isActivated;
    }

});

module.exports = ColumnSelection;

},{"./Feature.js":102}],101:[function(require,module,exports){
'use strict';

var Feature = require('./Feature.js');

/**
 * @constructor
 * @extends Feature
 */
var ColumnSorting = Feature.extend('ColumnSorting', {

    /**
     * @memberOf ColumnSorting.prototype
     * @desc Handle this event down the feature chain of responsibility.
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */

    handleDoubleClick: function(grid, event) {
        var gridCell = event.gridCell;
        if (grid.isShowHeaderRow() && gridCell.y === 0 && gridCell.x !== -1) {
            var keys = event.primitiveEvent.detail.keys;
            grid.toggleSort(gridCell.x, keys);
        } else if (this.next) {
            this.next.handleDoubleClick(grid, event);
        }
    },

    /**
     * @memberOf ColumnSorting.prototype
     * @desc Handle this event down the feature chain of responsibility.
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseMove: function(grid, event) {
        var y = event.gridCell.y;
        if (this.isFixedRow(grid, event) && y < 1) {
            this.cursor = 'pointer';
        } else {
            this.cursor = null;
        }
        if (this.next) {
            this.next.handleMouseMove(grid, event);
        }
    }

});

module.exports = ColumnSorting;

},{"./Feature.js":102}],102:[function(require,module,exports){
'use strict';

var Base = require('../lib/Base');

/**
 * Instances of features are connected to one another to make a chain of responsibility for handling all the input to the hypergrid.
 * @constructor
 */
var Feature = Base.extend('Feature', {

    /**
     * the next feature to be given a chance to handle incoming events
     * @type {Feature}
     * @default null
     * @memberOf Feature.prototype
     */
    next: null,

    /**
     * a temporary holding field for my next feature when I'm in a disconnected state
     * @type {Feature}
     * @default null
     * @memberOf Feature.prototype
     */
    detached: null,

    /**
     * the cursor I want to be displayed
     * @type {string}
     * @default null
     * @memberOf Feature.prototype
     */
    cursor: null,

    /**
     * the cell location where the cursor is currently
     * @type {Point}
     * @default null
     * @memberOf Feature.prototype
     */
    currentHoverCell: null,

    /**
     * @memberOf Feature.prototype
     * @desc set my next field, or if it's populated delegate to the feature in my next field
     * @param {Feature} nextFeature - this is how we build the chain of responsibility
     */
    setNext: function(nextFeature) {
        if (this.next) {
            this.next.setNext(nextFeature);
        } else {
            this.next = nextFeature;
            this.detached = nextFeature;
        }
    },

    /**
     * @memberOf Feature.prototype
     * @desc disconnect my child
     */
    detachChain: function() {
        this.next = null;
    },

    /**
     * @memberOf Feature.prototype
     * @desc reattach my child from the detached reference
     */
    attachChain: function() {
        this.next = this.detached;
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle mouse move down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseMove: function(grid, event) {
        if (this.next) {
            this.next.handleMouseMove(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseExit: function(grid, event) {
        if (this.next) {
            this.next.handleMouseExit(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseEnter: function(grid, event) {
        if (this.next) {
            this.next.handleMouseEnter(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDown: function(grid, event) {
        if (this.next) {
            this.next.handleMouseDown(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseUp: function(grid, event) {
        if (this.next) {
            this.next.handleMouseUp(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleKeyDown: function(grid, event) {
        if (this.next) {
            this.next.handleKeyDown(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleKeyUp: function(grid, event) {
        if (this.next) {
            this.next.handleKeyUp(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleWheelMoved: function(grid, event) {
        if (this.next) {
            this.next.handleWheelMoved(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleDoubleClick: function(grid, event) {
        if (this.next) {
            this.next.handleDoubleClick(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleClick: function(grid, event) {
        if (this.next) {
            this.next.handleClick(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDrag: function(grid, event) {
        if (this.next) {
            this.next.handleMouseDrag(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleContextMenu: function(grid, event) {
        if (this.next) {
            this.next.handleContextMenu(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @desc toggle the column picker
     */

    moveSingleSelect: function(grid, x, y) {
        if (this.next) {
            this.next.moveSingleSelect(grid, x, y);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    isFixedRow: function(grid, event) {
        var gridCell = event.viewPoint;
        var isFixed = gridCell.y < grid.getFixedRowCount();
        return isFixed;
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    isFirstFixedRow: function(grid, event) {
        var gridCell = event.viewPoint;
        var isFixed = gridCell.y < 1;
        return isFixed;
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    isFixedColumn: function(grid, event) {
        var gridCell = event.viewPoint;
        var isFixed = gridCell.x < grid.getFixedColumnCount();
        return isFixed;
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    isFirstFixedColumn: function(grid, event) {
        var gridCell = event.viewPoint;
        var edge = grid.isShowRowNumbers() ? 0 : 1;
        var isFixed = gridCell.x < edge;
        return isFixed;
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    isTopLeft: function(grid, event) {
        var isTopLeft = this.isFixedRow(grid, event) && this.isFixedColumn(grid, event);
        return isTopLeft;
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    setCursor: function(grid) {
        if (this.next) {
            this.next.setCursor(grid);
        }
        if (this.cursor) {
            grid.beCursor(this.cursor);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    initializeOn: function(grid) {
        if (this.next) {
            this.next.initializeOn(grid);
        }
    }

});

module.exports = Feature;

},{"../lib/Base":113}],103:[function(require,module,exports){
'use strict';

var Feature = require('./Feature.js');

/**
 * @constructor
 */
var Filters = Feature.extend('Filters', {

    handleDoubleClick: function(grid, event) {
        if (grid.isFilterRow(event.gridCell.y)) {
            grid.onEditorActivate(event);
        } else if (this.next) {
            this.next.handleDoubleClick(grid, event);
        }
    },

    handleClick: function(grid, event) {
        if (grid.isFilterRow(event.gridCell.y)) {
            grid.onEditorActivate(event);
        } else if (this.next) {
            this.next.handleClick(grid, event);
        }
    }

});

module.exports = Filters;

},{"./Feature.js":102}],104:[function(require,module,exports){
'use strict';

var Feature = require('./Feature.js');

var commands = {
    PAGEDOWN: function(grid) { grid.pageDown(); },
    PAGEUP: function(grid) { grid.pageUp(); },
    PAGELEFT: function(grid) { grid.pageLeft(); },
    PAGERIGHT: function(grid) { grid.pageRight(); }
};

/**
 * @constructor
 */
var KeyPaging = Feature.extend('KeyPaging', {

    /**
     * @desc Handle this event down the feature chain of responsibility.
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     * @memberOf KeyPaging.prototype
     */
    handleKeyDown: function(grid, event) {
        var func = commands[event.detail.char];
        if (func) {
            func(grid);
        } else if (this.next) {
            this.next.handleKeyDown(grid, event);
        }
    }

});

module.exports = KeyPaging;

},{"./Feature.js":102}],105:[function(require,module,exports){
'use strict';

var Feature = require('./Feature.js');

/**
 * @constructor
 */
var OnHover = Feature.extend('OnHover', {

    /**
     * @desc Hhandle this event down the feature chain of responsibility.
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     * @memberOf OnHover.prototype
     */
    handleMouseMove: function(grid, event) {
        var currentHoverCell = grid.getHoverCell();
        if (!event.gridCell.equals(currentHoverCell)) {
            if (currentHoverCell) {
                this.handleMouseExit(grid, currentHoverCell);
            }
            this.handleMouseEnter(grid, event);
            grid.setHoverCell(event.gridCell);
        } else {
            if (this.next) {
                this.next.handleMouseMove(grid, event);
            }
        }
    }

});

module.exports = OnHover;

},{"./Feature.js":102}],106:[function(require,module,exports){
'use strict';

var ColumnResizing = require('./ColumnResizing');

/**
 * @constructor
 * @extends ColumnResizing
 */
var RowResizing = ColumnResizing.extend('RowResizing', {

    /**
     * the index of the row/column we are dragging
     * @type {number}
     * @default -1
     * @memberOf RowResizing.prototype
     */
    dragArea: -1,

    /**
     * the pixel location of the where the drag was initiated
     * @type {number}
     * @default -1
     * @memberOf RowResizing.prototype
     */
    dragStart: -1,

    /**
     * the starting width/height of the row/column we are dragging
     * @type {number}
     * @default -1
     * @memberOf RowResizing.prototype
     */
    dragAreaStartingSize: -1,

    /**
     * @memberOf RowResizing.prototype
     * @desc get the mouse x,y coordinate
     * @returns {number}
     * @param {MouseEvent} event - the mouse event to query
     */
    getMouseValue: function(event) {
        return event.primitiveEvent.detail.mouse.y;
    },

    /**
     * @function
     * @memberOf RowResizing.prototype
     * @desc get the grid cell x,y coordinate
     * @returns {number}
     * @param {Point} gridCell
     */
    getGridCellValue: function(gridCell) {
        return gridCell.x;
    },

    /**
     * @function
     * @memberOf RowResizing.prototype
     * @desc return the grids x,y scroll value
     * @returns {number}
     * @param {Hypergrid} grid
     */
    getScrollValue: function(grid) {
        return grid.getVScrollValue();
    },

    /**
     * @function
     * @memberOf RowResizing.prototype
     * @desc return the width/height of the row/column of interest
     * @returns {number}
     * @param {Hypergrid} grid
     * @param {number} index - the row/column index of interest
     */
    getAreaSize: function(grid, index) {
        return grid.getRowHeight(index);
    },

    /**
     * @function
     * @memberOf RowResizing.prototype
     * @desc set the width/height of the row/column at index
     * @returns {number}
     * @param {Hypergrid} grid
     * @param {number} index - the row/column index of interest
     * @param {number} value - the width/height to set to
     */
    setAreaSize: function(grid, index, value) {
        grid.setRowHeight(index, value);
    },

    /**
     * @function
     * @memberOf RowResizing.prototype
     * @desc returns the index of which divider I'm over
     * @returns {number}
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    overAreaDivider: function(grid, event) {
        return grid.overRowDivider(event);
    },

    /**
     * @function
     * @memberOf RowResizing.prototype
     * @desc am I over the column/row area
     * @returns {boolean}
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    isFirstFixedOtherArea: function(grid, event) {
        return this.isFirstFixedColumn(grid, event);
    },

    /**
     * @function
     * @memberOf RowResizing.prototype
     * @desc return the cursor name
     * @returns {string}
     */
    getCursorName: function() {
        return 'row-resize';
    },

    /**
     * @function
     * @memberOf RowResizing.prototype
     * @desc return the recently rendered area's width/height
     * @returns {number}
     * @param {Hypergrid} grid
     * @param {number} index - the row/column index of interest
     */
    getPreviousAbsoluteSize: function(grid, index) {
        return grid.getRenderedHeight(index);
    },

    /**
     * @function
     * @memberOf RowResizing.prototype
     * @desc return the fixed area rows/columns count
     * @returns {number}
     * @param {Hypergrid} grid
     */
    getOtherFixedAreaCount: function(grid) {
        return grid.getFixedColumnCount();
    },

    /**
     *
     * @param {Hypergrid} grid
     * @returns {number}
     * @default -2
     * @memberOf ColumnResizing.prototype
     */
    getFixedAreaCount: function(grid) {
        return grid.getFixedRowCount() + grid.getHeaderRowCount();
    },

    /**
     *
     * @param {Hypergrid} grid
     * @returns {boolean}
     * @default -2
     * @memberOf ColumnResizing.prototype
     */
    isEnabled: function(grid) {
        return grid.isRowResizeable();
    }

});

module.exports = RowResizing;

},{"./ColumnResizing":99}],107:[function(require,module,exports){
'use strict';

var Feature = require('./Feature.js');

/**
 * @constructor
 */
var RowSelection = Feature.extend('RowSelection', {

    /**
     * The pixel location of the mouse pointer during a drag operation.
     * @type {Point}
     * @default null
     * @memberOf RowSelection.prototype
     */
    currentDrag: null,

    /**
     * The cell coordinates of the where the mouse pointer is during a drag operation.
     * @type {Object}
     * @default null
     * @memberOf RowSelection.prototype
     */
    lastDragCell: null,

    /**
     * a millisecond value representing the previous time an autoscroll started
     * @type {number}
     * @default 0
     * @memberOf RowSelection.prototype
     */
    sbLastAuto: 0,

    /**
     * a millisecond value representing the time the current autoscroll started
     * @type {number}
     * @default 0
     * @memberOf RowSelection.prototype
     */
    sbAutoStart: 0,

    dragArmed: false,

    /**
     * @memberOf RowSelection.prototype
     * @desc Handle this event down the feature chain of responsibility.
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseUp: function(grid, event) {
        if (this.dragArmed) {
            this.dragArmed = false;
            //global row selection
            if (event.gridCell.x === -1 && event.gridCell.y === 0) {
                grid.toggleSelectAllRows();
            }
            grid.fireSyntheticRowSelectionChangedEvent();
        } else if (this.dragging) {
            this.dragging = false;
            grid.fireSyntheticRowSelectionChangedEvent();
        } else if (this.next) {
            this.next.handleMouseUp(grid, event);
        }
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc * @desc Handle this event down the feature chain of responsibility.
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDown: function(grid, event) {

        var isRightClick = event.primitiveEvent.detail.isRightClick;
        var cell = event.gridCell;
        var viewCell = event.viewPoint;
        var dx = cell.x;
        var dy = cell.y;


        var isHeader = grid.isShowRowNumbers() && dx < 0;

        if (!grid.isRowSelection() || isRightClick || !isHeader) {
            if (this.next) {
                this.next.handleMouseDown(grid, event);
            }
        } else {

            var numFixedRows = grid.getFixedRowCount();

            //if we are in the fixed area do not apply the scroll values
            //check both x and y values independently
            if (viewCell.y < numFixedRows) {
                dy = viewCell.y;
            }

            var dCell = grid.newPoint(0, dy);

            var primEvent = event.primitiveEvent;
            var keys = primEvent.detail.keys;
            this.dragArmed = true;
            this.extendSelection(grid, dCell, keys);
        }
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDrag: function(grid, event) {
        var isRightClick = event.primitiveEvent.detail.isRightClick;

        if (!this.dragArmed || !grid.isRowSelection() || isRightClick) {
            if (this.next) {
                this.next.handleMouseDrag(grid, event);
            }
        } else {
            this.dragging = true;
            var numFixedRows = grid.getFixedRowCount();

            var cell = event.gridCell;
            var viewCell = event.viewPoint;
            //var dx = cell.x;
            var dy = cell.y;

            //if we are in the fixed area do not apply the scroll values
            //check both x and y values independently
            if (viewCell.y < numFixedRows) {
                dy = viewCell.y;
            }

            var dCell = grid.newPoint(0, dy);

            var primEvent = event.primitiveEvent;
            this.currentDrag = primEvent.detail.mouse;
            this.lastDragCell = dCell;

            this.checkDragScroll(grid, this.currentDrag);
            this.handleMouseDragCellSelection(grid, dCell, primEvent.detail.keys);
        }
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleKeyDown: function(grid, event) {
        var handler;
        if (
            grid.getLastSelectionType() === 'row' &&
            (handler = this['handle' + event.detail.char])
        ) {
            handler.call(this, grid, event.detail);
        } else if (this.next) {
            this.next.handleKeyDown(grid, event);
        }
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc Handle a mousedrag selection
     * @param {Hypergrid} grid
     * @param {Object} mouse - the event details
     * @param {Array} keys - array of the keys that are currently pressed down
     */
    handleMouseDragCellSelection: function(grid, gridCell, keys) {
        var y = gridCell.y;
        //            var previousDragExtent = grid.getDragExtent();
        var mouseDown = grid.getMouseDown();

        var newY = y - mouseDown.y;
        //var newY = y - mouseDown.y;

        // if (previousDragExtent.x === newX && previousDragExtent.y === newY) {
        //     return;
        // }

        grid.clearMostRecentRowSelection();

        grid.selectRow(mouseDown.y, y);
        grid.setDragExtent(grid.newPoint(0, newY));

        grid.repaint();
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc this checks while were dragging if we go outside the visible bounds, if so, kick off the external autoscroll check function (above)
     * @param {Hypergrid} grid
     * @param {Object} mouse - the event details
     */
    checkDragScroll: function(grid, mouse) {
        if (!grid.resolveProperty('scrollingEnabled')) {
            return;
        }
        var b = grid.getDataBounds();
        var inside = b.contains(mouse);
        if (inside) {
            if (grid.isScrollingNow()) {
                grid.setScrollingNow(false);
            }
        } else if (!grid.isScrollingNow()) {
            grid.setScrollingNow(true);
            this.scrollDrag(grid);
        }
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc this function makes sure that while we are dragging outside of the grid visible bounds, we srcroll accordingly
     * @param {Hypergrid} grid
     */
    scrollDrag: function(grid) {
        if (!grid.isScrollingNow()) {
            return;
        }

        var lastDragCell = this.lastDragCell;
        var b = grid.getDataBounds();
        var xOffset = 0;
        var yOffset = 0;

        var numFixedColumns = grid.getFixedColumnCount();
        var numFixedRows = grid.getFixedRowCount();

        var dragEndInFixedAreaX = lastDragCell.x < numFixedColumns;
        var dragEndInFixedAreaY = lastDragCell.y < numFixedRows;

        if (this.currentDrag.y < b.origin.y) {
            yOffset = -1;
        }

        if (this.currentDrag.y > b.origin.y + b.extent.y) {
            yOffset = 1;
        }

        var dragCellOffsetX = xOffset;
        var dragCellOffsetY = yOffset;

        if (dragEndInFixedAreaX) {
            dragCellOffsetX = 0;
        }

        if (dragEndInFixedAreaY) {
            dragCellOffsetY = 0;
        }

        this.lastDragCell = lastDragCell.plusXY(dragCellOffsetX, dragCellOffsetY);
        grid.scrollBy(xOffset, yOffset);
        this.handleMouseDragCellSelection(grid, lastDragCell, []); // update the selection
        grid.repaint();
        setTimeout(this.scrollDrag.bind(this, grid), 25);
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc extend a selection or create one if there isnt yet
     * @param {Hypergrid} grid
     * @param {Object} gridCell - the event details
     * @param {Array} keys - array of the keys that are currently pressed down
     */
    extendSelection: function(grid, gridCell, keys) {
        grid.stopEditing();
        //var hasCTRL = keys.indexOf('CTRL') !== -1;
        var hasSHIFT = keys.indexOf('SHIFT') !== -1;

        var mousePoint = grid.getMouseDown();
        var x = gridCell.x; // - numFixedColumns + scrollLeft;
        var y = gridCell.y; // - numFixedRows + scrollTop;

        //were outside of the grid do nothing
        if (x < 0 || y < 0) {
            return;
        }

        if (hasSHIFT) {
            grid.clearMostRecentRowSelection();
            grid.selectRow(y, mousePoint.y);
            grid.setDragExtent(grid.newPoint(0, y - mousePoint.y));
        } else {
            grid.toggleSelectRow(y, keys);
            grid.setMouseDown(grid.newPoint(x, y));
            grid.setDragExtent(grid.newPoint(0, 0));
        }
        grid.repaint();
    },


    /**
     * @memberOf RowSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     */
    handleDOWNSHIFT: function(grid) {
        this.moveShiftSelect(grid, 1);
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleUPSHIFT: function(grid) {
        this.moveShiftSelect(grid, -1);
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleLEFTSHIFT: function(grid) {},

    /**
     * @memberOf RowSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleRIGHTSHIFT: function(grid) {},

    /**
     * @memberOf RowSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleDOWN: function(grid) {
        this.moveSingleSelect(grid, 1);
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleUP: function(grid) {
        this.moveSingleSelect(grid, -1);
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleLEFT: function(grid) {},

    /**
     * @memberOf RowSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleRIGHT: function(grid) {

        var mouseCorner = grid.getMouseDown().plus(grid.getDragExtent());
        var maxColumns = grid.getColumnCount() - 1;

        var newX = grid.getHeaderColumnCount() + grid.getHScrollValue();
        var newY = mouseCorner.y;

        newX = Math.min(maxColumns, newX);

        grid.clearSelections();
        grid.select(newX, newY, 0, 0);
        grid.setMouseDown(grid.newPoint(newX, newY));
        grid.setDragExtent(grid.newPoint(0, 0));

        grid.repaint();
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc If we are holding down the same navigation key, accelerate the increment we scroll
     * #### returns: integer
     */
    getAutoScrollAcceleration: function() {
        var count = 1;
        var elapsed = this.getAutoScrollDuration() / 2000;
        count = Math.max(1, Math.floor(elapsed * elapsed * elapsed * elapsed));
        return count;
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc set the start time to right now when we initiate an auto scroll
     */
    setAutoScrollStartTime: function() {
        this.sbAutoStart = Date.now();
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc update the autoscroll start time if we haven't autoscrolled within the last 500ms otherwise update the current autoscroll time
     */
    pingAutoScroll: function() {
        var now = Date.now();
        if (now - this.sbLastAuto > 500) {
            this.setAutoScrollStartTime();
        }
        this.sbLastAuto = Date.now();
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc answer how long we have been auto scrolling
     * #### returns: integer
     */
    getAutoScrollDuration: function() {
        if (Date.now() - this.sbLastAuto > 500) {
            return 0;
        }
        return Date.now() - this.sbAutoStart;
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc Augment the most recent selection extent by (offsetX,offsetY) and scroll if necessary.
     * @param {Hypergrid} grid
     * @param {number} offsetX - x coordinate to start at
     * @param {number} offsetY - y coordinate to start at
     */
    moveShiftSelect: function(grid, offsetY) {

        var maxRows = grid.getRowCount() - 1;

        var maxViewableRows = grid.getVisibleRows() - 1;

        if (!grid.resolveProperty('scrollingEnabled')) {
            maxRows = Math.min(maxRows, maxViewableRows);
        }

        var origin = grid.getMouseDown();
        var extent = grid.getDragExtent();

        var newY = extent.y + offsetY;
        //var newY = grid.getRowCount();

        newY = Math.min(maxRows - origin.y, Math.max(-origin.y, newY));

        grid.clearMostRecentRowSelection();
        grid.selectRow(origin.y, origin.y + newY);

        grid.setDragExtent(grid.newPoint(0, newY));

        if (grid.insureModelRowIsVisible(newY + origin.y, offsetY)) {
            this.pingAutoScroll();
        }

        grid.fireSyntheticRowSelectionChangedEvent();
        grid.repaint();

    },

    /**
     * @memberOf RowSelection.prototype
     * @desc Replace the most recent selection with a single cell selection that is moved (offsetX,offsetY) from the previous selection extent.
     * @param {Hypergrid} grid
     * @param {number} offsetX - x coordinate to start at
     * @param {number} offsetY - y coordinate to start at
     */
    moveSingleSelect: function(grid, offsetY) {

        var maxRows = grid.getRowCount() - 1;

        var maxViewableRows = grid.getVisibleRowsCount() - 1;

        if (!grid.resolveProperty('scrollingEnabled')) {
            maxRows = Math.min(maxRows, maxViewableRows);
        }

        var mouseCorner = grid.getMouseDown().plus(grid.getDragExtent());

        var newY = mouseCorner.y + offsetY;
        //var newY = grid.getRowCount();

        newY = Math.min(maxRows, Math.max(0, newY));

        grid.clearSelections();
        grid.selectRow(newY);
        grid.setMouseDown(grid.newPoint(0, newY));
        grid.setDragExtent(grid.newPoint(0, 0));

        if (grid.insureModelRowIsVisible(newY, offsetY)) {
            this.pingAutoScroll();
        }

        grid.fireSyntheticRowSelectionChangedEvent();
        grid.repaint();

    },

    isSingleRowSelection: function() {
        return true;
    }

});

module.exports = RowSelection;

},{"./Feature.js":102}],108:[function(require,module,exports){
'use strict';

var Feature = require('./Feature.js');

/**
 * @constructor
 */
var ThumbwheelScrolling = Feature.extend('ThumbwheelScrolling', {

    /**
     * @memberOf ThumbwheelScrolling.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleWheelMoved: function(grid, e) {
        if (!grid.resolveProperty('scrollingEnabled')) {
            return;
        }

        var primEvent = e.primitiveEvent,
            deltaX = Math.sign(primEvent.wheelDeltaX || -primEvent.deltaX),
            deltaY = Math.sign(primEvent.wheelDeltaY || -primEvent.deltaY);

        if (deltaX || deltaY) {
            grid.scrollBy(
                -deltaX || 0, // 0 if NaN
                -deltaY || 0
            );
        }
    }

});


module.exports = ThumbwheelScrolling;

},{"./Feature.js":102}],109:[function(require,module,exports){
'use strict';

module.exports = {
    Feature: require('./Feature'), // abstract base class
    CellClick: require('./CellClick'),
    CellEditing: require('./CellEditing'),
    CellSelection: require('./CellSelection'),
    ColumnAutosizing: require('./ColumnAutosizing'),
    ColumnMoving: require('./ColumnMoving'),
    ColumnResizing: require('./ColumnResizing'),
    ColumnSelection: require('./ColumnSelection'),
    ColumnSorting: require('./ColumnSorting'),
    Filters: require('./Filters'),
    KeyPaging: require('./KeyPaging'),
    OnHover: require('./OnHover'),
    ColumnPicker: require('./ColumnPicker'),
    RowResizing: require('./RowResizing'),
    RowSelection: require('./RowSelection'),
    ThumbwheelScrolling: require('./ThumbwheelScrolling')
};

},{"./CellClick":93,"./CellEditing":94,"./CellSelection":95,"./ColumnAutosizing":96,"./ColumnMoving":97,"./ColumnPicker":98,"./ColumnResizing":99,"./ColumnSelection":100,"./ColumnSorting":101,"./Feature":102,"./Filters":103,"./KeyPaging":104,"./OnHover":105,"./RowResizing":106,"./RowSelection":107,"./ThumbwheelScrolling":108}],110:[function(require,module,exports){
'use strict';

var popMenu = require('pop-menu');

/**
 * @constructor
 * @summary Build, organize, and sort a column schema list from a list of columns.
 * @desc FilterTree requires a column schema. As a fallback when you don't have a column schema of your own, the string array returned by behavior.dataModel.getFields() would work as is. This factory object will do a little better than that, taking Hypergrid's column array and creating a more textured column schema, including column aliases and types.
 *
 * CAVEAT: Set up the schema completely before instantiating your filter state. Filter-tree uses the schema (in part) to generate column selection drop-downs as part of its "query builder" UI. Note that the UI is *not* automatically updated if you change the schema later.
 *
 * @param {Column[]} columns
 *
 * @property {menuItem[]} schema - This is the output produced by the factory.
 */
function ColumnSchemaFactory(columns, findOptions) {
    this.schema = columns.map(function(column) {
        return {
            name: column.name,
            alias: column.header,
            type: column.getType()
        };
    });
}

ColumnSchemaFactory.prototype = {

    constructor: ColumnSchemaFactory.prototype.constructor,

    /**
     * Organize schema into submenus.
     * @param {RegExp} columnGroupsRegex - Schema names or aliases that match this are put into a submenu.
     * @param {string} [options.key='name'] - Must be either 'name' or 'alias'.
     */
    organize: function(columnGroupsRegex, options) {
        var key = options && options.key || 'name',
            submenus = {},
            menu = [];

        this.schema.forEach(function(item) {
            var value = item[key],
                group = value.match(columnGroupsRegex);
            if (group) {
                group = group[0];
                if (!(group in submenus)) {
                    submenus[group] = {
                        label: group.toUpperCase(),
                        submenu: []
                    };
                }
                submenus[group].submenu.push(item);
            } else {
                menu.push(item);
            }
        });

        for (var submenuName in submenus) {
            menu.push(submenus[submenuName]);
        }

        this.schema = menu;
    },

    lookup: function(findOptions, value) {
        var args = Array.prototype.slice.call(arguments);
        return popMenu.lookup.apply(this.schema, args);
    },

    walk: function(iteratee) {
        return popMenu.walk.call(this.schema, iteratee);
    },

    /**
     * @summary Sort the schema.
     * @desc Walk the menu structure, sorting each submenu until finally the top-level menu is sorted.
     * @param {string} [prefix=''] - A submenu sort prefix:
     * * Omit to give no special treatment to submenus.
     * * Give `'\u0000'` to place all the submenus at the top of each enclosing submenu.
     * * Give `'\uffff'` to place all the submenus at the bottom of each enclosing submenu.
     */
    sort: function(prefix) {
        this.schema.sort(function recurse(a, b) {
            if (a.label && !a.sorted) {
                a.submenu.sort(recurse);
                a.sorted = true;
            }
            a = a.label ? prefix + a.label : a.alias || a.name || a;
            b = b.label ? prefix + b.label : b.alias || b.name || b;
            return a < b ? -1 : a > b ? 1 : 0;
        });
    }
};

module.exports = ColumnSchemaFactory;

},{"pop-menu":47}],111:[function(require,module,exports){
'use strict';

var _ = require('object-iterators');

var FilterTree = require('../Shared').FilterTree;
var ParserCQL = require('./parser-CQL');

// Add a property `menuModes` to the tree, defaulting to `operators` as the only active mode
FilterTree.Node.optionsSchema.menuModes = {
    default: {
        operators: 1
    }
};

function quote(text) {
    var qt = ParserCQL.qt;
    return qt + text.replace(new RegExp(qt, 'g'), qt + qt) + qt;
}

var likeDresses = [
    { regex: /^(NOT )?LIKE %(.+)%$/i, operator: 'contains' },
    { regex: /^(NOT )?LIKE (.+)%$/i, operator: 'begins' },
    { regex: /^(NOT )?LIKE %(.+)$/i, operator: 'ends' }
];
var regexEscapedLikePatternChars = /\[([_\[\]%])\]/g; // capture all _, [, ], and % chars enclosed in []
var regexLikePatternChar = /[_\[\]%]/; // find any _, [, ], and % chars NOT enclosed in []

// convert certain LIKE expressions to BEGINS, ENDS, CONTAINS
function convertLikeToPseudoOp(result) {
    likeDresses.find(function(dress) {
        var match = result.match(dress.regex);

        if (match) {
            // unescape all LIKE pattern chars escaped with brackets
            var not = (match[1] || '').toLowerCase(),
                operator = dress.operator,
                operand = match[2],
                operandWithoutEscapedChars = operand.replace(regexEscapedLikePatternChars, '');

            // if result has no actua remaining LIKE pattern chars, go with the conversion
            if (!regexLikePatternChar.test(operandWithoutEscapedChars)) {
                operand = operand.replace(regexEscapedLikePatternChars, '$1'); // unescape the escaped chars
                result = not + operator + ' ' + operand;
            }

            return true; // break out of loop
        }
    });

    return result;
}

var conditionalsCQL = new FilterTree.Conditionals();
conditionalsCQL.makeLIKE = function(beg, end, op, originalOp, c) {
    op = originalOp.toLowerCase();
    return op + ' ' + quote(c.operand);
};
conditionalsCQL.makeIN = function(op, c) {
    return op.toLowerCase() + ' (' + c.operand.replace(/\s*,\s*/g, ', ') + ')';
};
conditionalsCQL.make = function(op, c) {
    var numericOperand;
    op = op.toLowerCase();
    if (/\w/.test(op)) { op += ' '; }
    op += c.getType() === 'number' && !isNaN(numericOperand = Number(c.operand))
        ? numericOperand
        : quote(c.operand);
    return op;
};

// replace the default filter tree terminal node constructor with an extension of same
var CustomFilterLeaf = FilterTree.prototype.addEditor({
    getState: function getState(options) {
        var result,
            syntax = options && options.syntax;

        if (syntax === 'CQL') {
            result = this.getSyntax(conditionalsCQL);
            result = convertLikeToPseudoOp(result);
            var defaultOp = this.schema.lookup(this.column).defaultOp || this.root.parserCQL.defaultOp; // mimics logic in parser-CQL.js, line 110
            if (result.toUpperCase().indexOf(defaultOp) === 0) {
                result = result.substr(defaultOp.length);
            }
        } else {
            result = FilterTree.Leaf.prototype.getState.call(this, options);
        }

        return result;
    }
});

FilterTree.prototype.addEditor('Columns');

// Add some node templates by updating shared instance of FilterNode's templates. (OK to mutate shared instance; filter-tree not being used for anything else here. Alternatively, we could have instantiated a new Templates object for our DefaultFilter prototype, although this would only affect tree nodes, not leaf nodes, but that would be ok in this case since the additions below are tree node templates.)
_(FilterTree.Node.prototype.templates).extendOwn({
    columnFilter: [
        '<span class="filter-tree">',
        '   <strong><span>{2} </span></strong><br>',
        '   Match',
        '   <label><input type="radio" class="filter-tree-op-choice" name="treeOp{1}" value="op-or">any</label>',
        '   <label><input type="radio" class="filter-tree-op-choice" name="treeOp{1}" value="op-and">all</label>',
        '   <label><input type="radio" class="filter-tree-op-choice" name="treeOp{1}" value="op-nor">none</label>',
        '   of the following:',
        '   <select>',
        '       <option value="">New expression&hellip;</option>',
        '   </select>',
        '   <ol></ol>',
        '</span>'
    ]
        .join('\n'),

    columnFilters: [
        '<span class="filter-tree filter-tree-type-column-filters">',
        '   Match <strong>all</strong> of the following column filter subexpressions:',
        '   <ol></ol>',
        '</span>'
    ]
        .join('\n')
});

/** @constructor
 *
 * @desc This extension of FilterTree forces a specific tree structure.
 * See {@link makeNewRoot} for a description.
 *
 * See also {@tutorial filter-api}.
 *
 * @param {FilterTreeOptionsObject} options - You should provide a column schema. The easiest approach is to provide a schema for the entire filter tree through `options.schema`.
 *
 * Although not recommended, the column schema can also be embedded in the state object, either at the root, `options.state.schema`, or for any descendant node. For example, a separate schema could be provided for each expression or subexpression that need to render column list drop-downs.
 *
 * NOTE: If `options.state` is undefined, it is defined in `preInitialize()` as a new empty state scaffold (see {@link makeNewRoot}) with the two trunks to hold a table filter and column filters. Expressions and subexpressions can be added to this empty scaffold either programmatically or through the Query Builder UI.
 */

var DefaultFilter = FilterTree.extend('DefaultFilter', {
    preInitialize: function(options) {
        options = options || {};

        // Set up the default "Hyperfilter" profile (see function comments)
        var state = options.state = options.state || this.makeNewRoot();

        // Upon creation of a 'columnFilter' node, force the schema to the one column
        if ((options.type || state && state.type) === 'columnFilter') {
            this.schema = [
                options.parent.root.schema.lookup(state.children[0].column)
            ];
        }

        return [options];
    },

    initialize: function(options) {
        this.cache = {};

        if (!this.parent) {
            this.extractSubtrees();
        }
    },

    postInitialize: function(options) {
        if (this === this.root && !this.parserCQL) {
            this.parserCQL = new ParserCQL(this.conditionals.ops, {
                schema: this.schema,
                defaultOp: options.defaultColumnFilterOperator
            });
        }

        if (this.type === 'columnFilter') {
            this.dontPersist.schema = true;
        }
    },

    /**
     * Create convenience vars to reference the 2 root "Hyperfilter" nodes
     * @memberOf DefaultFilter.prototype
     */
    extractSubtrees: function() {
        var rootNodes = this.root.children;
        this.tableFilter = rootNodes[0];
        this.columnFilters = rootNodes[1];
    },

    /**
     * @summary Make a new empty Hypergrid filter tree state object.
     * @desc This function makes a new default state object as used by Hypergrid, a root with exactly two "trunks."
     *
     * > **Definition:** A *trunk* is defined as a child node with a truthy `keep` property, making this node immune to the usual pruning that would occur when it has no child nodes of its own. To be a true trunk, all ancestor nodes to be trunks as well. Note that the root is a natural trunk; it does not require a `keep` property.
     *
     * The two trunks of the Hypergrid filter are:
     * * The **Table Filter** (left trunk, or `children[0]`), a hierarchy of filter expressions and subexpressions.
     * * The **Column Filters** (right trunk, or `children[1]`), a series of subexpressions, one per active column filter. Each subexpression contains any number of expressions bound to that column but no further subexpressions.
     *
     * The `operator` properties for all subexpressions default to `'op-and'`, which means:
     * * All table filter expressions and subexpressions are AND'd together. (This is just the default and may be changed from the UI.)
     * * All expressions within a column filter subexpression are AND'd together. (This is just the default and may be changed from the UI.)
     * * All column Filters subexpressions are AND'd together. (This may not be changed from UI.)
     * * Finally, the table filter and column filters are AND'd together. (This may not be changed from UI.)
     *
     * @returns {object} A plain object to serve as a filter-tree state object representing a new Hypergrid filter.
     *
     * @memberOf DefaultFilter.prototype
     */
    makeNewRoot: function() {

        this.tableFilter = {
            keep: true,
            children: [
                // table filter expressions and subexpressions go here
            ]
        };

        this.columnFilters = {
            keep: true,
            type: 'columnFilters',
            children: [
                // subexpressions with type 'columnFilter' go here, one for each active column filter
            ]
        };

        var filter = {
            children: [
                this.tableFilter,
                this.columnFilters
            ]
        };

        return filter;
    },

    /**
     * @summary Get the column filter subexpression node.
     * @desc Each column filter subexpression node is a child node of the `columnFilters` trunk of the Hypergrid filter tree.
     * Each such node contains all the column filter expressions for the named column. It will never be empty; if there is no column filter for the named column, it won't exist in `columnFilters`.
     *
     * CAUTION: This is the actual node object. Do not confuse it with the column filter _state_ object (for which see the {@link DefaultFilter#getColumnFilterState|getColumnFilterState()} method).
     * @param {string} columnName
     * @returns {undefined|DefaultFilter} Returns `undefined` if the column filter does not exist.
     */
    getColumnFilter: function(columnName) {
        return this.columnFilters.children.find(function(columnFilter) {
            return columnFilter.children.length && columnFilter.children[0].column === columnName;
        });
    },

    /** @typedef {object} FilterTreeGetStateOptionsObject
     * See the {@link http://joneit.github.io/filter-tree/global.html#FilterTreeGetStateOptionsObject|type definition} in the filter-tree documentation.
     */

    /** @typedef {object} FilterTreeSetStateOptionsObject
     * See the {@link http://joneit.github.io/filter-tree/global.html#FilterTreeSetStateOptionsObject|type definition} in the filter-tree documentation.
     */

    /**
     * @summary Get a particular column filter's state.
     * @param {string} rawColumnName - Column name for case and alias lookup.
     * @param {FilterTreeGetStateOptionsObject} [options] - Passed to the filter's {@link DefaultFilter#getState|getState} method.
     * @param {boolean} [options.syntax='CQL'] - The syntax to use to describe the filter state. Note that `getFilter`'s default syntax, `'CQL'`, differs from the other get state methods.
     * @returns {FilterTreeStateObject}
     * @memberOf DefaultFilter.prototype
     */
    getColumnFilterState: function(rawColumnName, options) {
        var result = '',
            columnSchema = this.schema.lookup(rawColumnName);

        if (columnSchema) {
            var subexpression = this.getColumnFilter(columnSchema.name);

            if (subexpression) {
                if (!(options && options.syntax)) {
                    options = options || {};
                    options.syntax = 'CQL';
                }
                result = subexpression.getState(options);
            }
        }

        return result;
    },

    /**
     * @summary Set a particular column filter's state.
     * @desc Adds CQL support to this.getState(). This function throws parser errors.
     *
     * @param {string} columnName
     *
     * @param {string|object} [state] - A filter tree object or a JSON, SQL, or CQL subexpression string that describes the a new state for the named column filter. The existing column filter subexpression is replaced with a new node based on this state. If it does not exist, the new subexpression is added to the column filters subtree (`this.root.columnFilters`).
     *
     * If undefined, removes the entire column filter subexpression from the column filters subtree.
     *
     * @param {string} rawColumnName - Column name for case and alias lookup.
     *
     * @param {FilterTreeSetStateOptionsObject} [options] - Passed to the filter's [setState]{@link http://joneit.github.io/filter-tree/FilterTree.html#setState} method. You may mix in members of the {@link http://joneit.github.io/filter-tree/global.html#FilterTreeValidationOptionsObject|FilterTreeValidationOptionsObject}
     *
     * @param {boolean} [options.syntax='CQL'] - The syntax to use to describe the filter state. Note that `setColumnFilterState`'s default syntax, `'CQL'`, differs from the other get state methods.
     *
     * @memberOf DefaultFilter.prototype
     */
    setColumnFilterState: function(rawColumnName, state, options) {
        var error,
            subexpression;

        var columnName = this.schema.lookup(rawColumnName).name;

        if (!columnName) {
            throw 'Unknown column name "' + rawColumnName + '"';
        }

        subexpression = this.getColumnFilter(columnName);

        if (state) {
            options = _({}).extend(options); // clone it because we may mutate it below
            options.syntax = options.syntax || 'CQL';

            if (options.syntax === 'CQL') {
                // Convert some CQL state syntax into a filter tree state object.
                // There must be at least one complete expression or `state` will become undefined.
                try {
                    state = this.root.parserCQL.parse(state, columnName);
                    if (state) {
                        options.syntax = 'object';
                    } else {
                        error = new Error('DefaultFilter: No complete expression.');
                    }
                } catch (e) {
                    error = e;
                }
            }

            if (!error) { // parse successful
                if (subexpression) { // subexpression already exists
                    // replace subexpression representing this column
                    subexpression.setState(state, options);
                } else {
                    // add a new subexpression representing this column
                    state = this.parseStateString(state, options); // because .add() only takes object syntax
                    subexpression = this.columnFilters.add(state);
                }
                options.throw = true;
                error = subexpression.invalid(options);
            }
        }

        if (subexpression && (!state || error)) {
            // remove subexpression representing this column
            subexpression.remove();
        }

        if (error) {
            throw error;
        }
    },

    /**
     * @summary Get state of all column filters.
     * @param {FilterTreeGetStateOptionsObject} [options] - Passed to the filter's {@link DefaultFilter#getState|getState} method.
     * @returns {FilterTreeStateObject}
     * @memberOf DefaultFilter.prototype
     */
    getColumnFiltersState: function(options) {
        if (options && options.syntax === 'CQL') {
            throw 'The CQL syntax is intended for use on a single column filter only. It does not support multiple columns or subexpressions.';
        }
        return this.root.columnFilters.getState(options);
    },

    /**
     * @summary Set state of all column filters.
     * @desc Note that the column filters implementation depends on the nodes having certain meta-data; you should not be calling this without these meta-data being in place. Specifically `type = 'columnFilters'` and  `keep = true` for the column filters subtree and`type = 'columnFilter'` for each individual column filter subexpression. In addition the subtree operators should always be `'op-and'`.
     * @param {string} state
     * @param {FilterTreeSetStateOptionsObject} [options] - Passed to the filter's [setState]{@link http://joneit.github.io/filter-tree/FilterTree.html#setState} method. You may mix in members of the {@link http://joneit.github.io/filter-tree/global.html#FilterTreeValidationOptionsObject|FilterTreeValidationOptionsObject}
     *
     * @returns {undefined|Error|string} `undefined` indicates success.
     *
     * @memberOf DefaultFilter.prototype
     */
    setColumnFiltersState: function(state, options) {
        var error;

        if (state) {
            this.root.columnFilters.setState(state, options);
            error = this.root.columnFilters.invalid(options);
        }

        return error;
    },

    /**
     * @param {FilterTreeGetStateOptionsObject} [options] - Passed to the filter's {@link DefaultFilter#getState|getState} method.
     * @returns {FilterTreeStateObject}
     * @memberOf DefaultFilter.prototype
     */
    getTableFilterState: function(options) {
        if (options && options.syntax === 'CQL') {
            throw 'The CQL syntax is intended for use on a single column filter only. It does not support multiple columns or subexpressions.';
        }
        return this.root.tableFilter.getState(options);
    },

    /**
     * @param {string} state
     * @param {FilterTreeSetStateOptionsObject} [options] - Passed to the filter's [setState]{@link http://joneit.github.io/filter-tree/FilterTree.html#setState} method. You may mix in members of the {@link http://joneit.github.io/filter-tree/global.html#FilterTreeValidationOptionsObject|FilterTreeValidationOptionsObject}
     * @returns {undefined|Error|string} `undefined` indicates success.
     * @memberOf DefaultFilter.prototype
     */
    setTableFilterState: function(state, options) {
        var error;

        if (state) {
            this.root.tableFilter.setState(state, options);
            error = this.root.tableFilter.invalid(options);
        } else {
            this.root.tableFilter.children.length = 0;
        }

        return error;
    },

    /**
     * @desc The CQL syntax should only be requested for a subtree containing homogeneous column names and no subexpressions.
     *
     * @param {string} [options.syntax='object'] - If `'CQL'`, walks the tree, returning a string suitable for a Hypergrid filter cell. All other values are forwarded to the prototype's `getState` method for further interpretation.
     *
     * NOTE: CQL is not intended to be used outside the context of a `columnFilters` subexpression.
     *
     * @returns {FilterTreeStateObject}
     *
     * @memberOf DefaultFilter.prototype
     */
    getState: function getState(options) {
        var result,
            syntax = options && options.syntax;

        if (syntax === 'CQL') {
            var operator = this.operator.substr(3); // remove the 'op-' prefix
            result = '';
            this.children.forEach(function(child, idx) {
                if (child) {
                    if (child instanceof CustomFilterLeaf) {
                        if (idx) {
                            result += ' ' + operator + ' ';
                        }
                        result += child.getState(options);
                    } else if (child.children.length) {
                        throw new Error('DefaultFilter: Expected a conditional but found a subexpression. Subexpressions are not supported in CQL (Column Query Language, the filter cell syntax).');
                    }
                }
            });
        } else {
            result = FilterTree.prototype.getState.call(this, options);
        }

        return result;
    },

    loadColumnPropertiesFromSchema: function(columns) {
        this.root.schema.walk(function(columnSchema) {
            var column = columns.find(function(thisColumn) {
                return thisColumn.name === columnSchema.name || columnSchema;
            });
            if (column) {
                column.type = columnSchema.type || column.type;
                column.header = columnSchema.alias || column.header;
            }
        });
    }
});


module.exports = DefaultFilter;

},{"../Shared":55,"./parser-CQL":112,"object-iterators":46}],112:[function(require,module,exports){
'use strict';

var _ = require('object-iterators');

var REGEXP_BOOLS = /\b(AND|OR|NOR)\b/gi,
    EXP = '(.*?)', BR = '\\b',
    PREFIX = '^' + EXP + BR,
    INFIX = BR + EXP + BR,
    POSTFIX = BR + EXP + '$';

function ParserCqlError(message) {
    this.message = message;
}
ParserCqlError.prototype = Object.create(Error.prototype);
ParserCqlError.prototype.name = 'ParserCqlError';

/**
 * @constructor
 *
 * @summary Column Query Language (CQL) parser
 *
 * @author Jonathan Eiten jonathan@openfin.com
 *
 * @desc See {@tutorial CQL} for the grammar.
 *
 * @param {object} operatorsHash - Hash of valid operators. Each is an object, the only property of interest being `complex` which if truthy means operand may be a list of multiple operands.
 * @param {object} [options]
 * @param {menuItem[]} [options.schema] - Column schema for column name/alias validation. Throws an error if name fails validation (but see `resolveAliases`). Omit to skip column name validation.
 * @param {boolean} [options.defaultOp='='] - Default operator for column when not defined in column schema.
 */
function ParserCQL(operatorsHash, options) {
    var operators = [];

    this.schema = options && options.schema;
    this.defaultOp = (options && options.defaultOp || '=').toUpperCase();

    _(operatorsHash).each(function(props, op) {
        if (op !== 'undefined') {
            operators.push(op);
        }
    });

    // Put larger ones first so that in case a smaller one is a substring of a larger one (such as '<' is to '<='), larger one will be matched first.
    operators = operators.sort(descendingByLength);

    // Escape all symbolic (non alpha) operators.
    operators = operators.map(function(op) { return /[^\w]/.test(op) ? '\\' + op.split('').join('\\') : op; });

    var symbolicOperators = operators.filter(function(op) { return op[0] === '\\'; }),
        alphaOperators = operators.filter(function(op) { return op[0] !== '\\'; }).join('|');

    if (alphaOperators) {
        alphaOperators = '\\b(' + alphaOperators + ')\\b';
    }
    /** @summary Regex to match any operator.
     * @desc Matches symbolic operators (made up of non-alpha characters) or identifier operators (word-boundary-isolated runs of alphanumeric characters).
     * @type {RegExp}
     */
    this.REGEX_OPERATOR = new RegExp(symbolicOperators.concat(alphaOperators).join('|'), 'ig');

    operators = operators.join('|') // pipe them
        .replace(/\s+/g, '\\s+'); // arbitrary string of whitespace chars -> whitespace regex matcher

    /** @summary Regex to match an operator + optional operator
     * @desc THe operator is optional. The operand may (or may not) be enclosed in parentheses.
     * @desc Match list:
     * 0. _input string_
     * 1. operator
     * 2. outer operand (may include parentheses)
     * 3. inner operand without parentheses (when an operand was given with parentheses)
     * 4. inner operand (when an operand was given without parentheses)
     * @type {RegExp}
     * @private
     * @memberOf ParserCQL.prototype
     */
    this.REGEX_EXPRESSION = new RegExp('^\\s*(' + operators + ')?\\s*(\\(\\s*(.+?)\\s*\\)|(.+?))\\s*$', 'i');

    this.REGEX_LITERAL_TOKENS = new RegExp('\\' + ParserCQL.qt + '(\\d+)' + '\\' + ParserCQL.qt, 'g');

}

/** @summary Operand quotation mark character.
 * @desc Should be a single character (length === 1).
 * @default '"'
 * @type {string}
 */
ParserCQL.qt = '"';

ParserCQL.prototype = {

    constructor: ParserCQL.prototype.constructor,

    /**
     * @summary Extract the boolean operators from an expression chain.
     * @desc Returns list of homogeneous operators transformed to lower case.
     *
     * Throws an error if all the boolean operators in the chain are not identical.
     * @param {string} cql
     * @returns {string[]}
     */
    captureBooleans: function(cql) {
        var booleans = cql.match(REGEXP_BOOLS);

        if (booleans) {
            var heterogeneousOperator = booleans.find(function(op, i) {
                booleans[i] = op.toLowerCase();
                return booleans[i] !== booleans[0];
            });

            if (heterogeneousOperator) {
                throw new ParserCqlError('Expected homogeneous boolean operators. You cannot mix AND, OR, and NOR operators here because the order of operations is ambiguous. Everything after your ' + heterogeneousOperator.toUpperCase() + ' was ignored. Tip: You can group operations with subexpressions but only in the QueryBuilder or by using parentheses in SQL.');
            }
        }

        return booleans;
    },

    /**
     * @summary Break an expression chain into a list of expressions.
     * @param {string} cql
     * @param {string[]} booleans
     * @returns {string[]}
     */
    captureExpressions: function(cql, booleans) {
        var expressions, re;

        if (booleans) {
            re = new RegExp(PREFIX + booleans.join(INFIX) + POSTFIX, 'i');
            expressions = cql.match(re);
            expressions.shift(); // discard [0] (input)
        } else {
            expressions = [cql];
        }

        return expressions;
    },

    /**
     * @summary Make a list of children out of a list of expressions.
     * @desc Uses only _complete_ expressions (a value OR an operator + a value).
     *
     * Ignores _incomplete_ expressions (empty string OR an operator - a value).
     *
     * @param {string} columnName
     * @param {string[]} expressions
     * @param {string[]} literals - list of literals indexed by token
     *
     * @returns {expressionState[]} where `expressionState` is one of:
     * * `{column: string, operator: string, operand: string}`
     * * `{column: string, operator: string, operand: string, editor: 'Columns'}`
     */
    makeChildren: function(columnName, expressions, literals) {
        var self = this;
        return expressions.reduce(function(children, exp) {
            if (exp) {
                var parts = exp.match(self.REGEX_EXPRESSION);
                if (parts) {
                    var op = parts[1],
                        outerLiteral = parts[2],
                        innerLiteral = parts.slice(3).find(function(part) {
                            return part !== undefined;
                        });

                    op = (op || '').replace(/\s+/g, ' ').trim().toUpperCase();

                    var parenthesized = /^\(.*\)$/.test(outerLiteral),
                        innerOperators = innerLiteral.match(self.REGEX_OPERATOR);

                    if (!parenthesized && innerOperators) {
                        if (op === '' && outerLiteral === innerOperators[0]) {
                            throw new ParserCqlError('Expected an operand.');
                        }

                        throw new ParserCqlError(
                            'Expected operand but found additional operator(s): ' +
                            innerOperators
                                .toString() // convert to comma-separated list
                                .toUpperCase()
                                .replace(/,/g, ', ') // add spaces after the commas
                                .replace(/^([^,]+), ([^,]+)$/, '$1 and $2') // replace only comma with "and"
                                .replace(/(.+,.+), ([^,]+)$/, '$1, and $2') // add "and" after last of several commas
                        );
                    }

                    op = op ||
                        self.schema && self.schema.lookup(columnName).defaultOp || // column's default operator from schema
                        self.defaultOp; // grid's default operator

                    var child = {
                        column: columnName,
                        operator: op
                    };

                    var fieldName = self.schema && self.schema.lookup(innerLiteral);
                    if (fieldName) {
                        child.operand = fieldName.name || fieldName;
                        child.editor = 'Columns';
                    } else {
                        // Find and expand all collapsed literals.
                        child.operand = innerLiteral.replace(self.REGEX_LITERAL_TOKENS, function(match, index) {
                            return literals[index];
                        });
                    }

                    children.push(child);
                }

                return children;
            }
        }, []);
    },

    /**
     * @summary Make a "locked" subexpression definition object from an expression chain.
     * @desc _Locked_ means it is locked to a single field.
     *
     * When there is only a single expression in the chain, the `operator` is omitted (defaults to `'op-and'`).
     *
     * @param {string} cql - A compound CQL expression, consisting of one or more simple expressions all separated by the same logical operator).
     *
     * @param {string} columnName

     * @returns {undefined|{operator: string, children: string[], schema: string[]}}
     * `undefined` when there are no complete expressions
     *
     * @memberOf module:CQL
     */
    parse: function(cql, columnName) {
        // reduce all runs of white space to a single space; then trim
        cql = cql.replace(/\s\s+/g, ' ').trim();

        var literals = [];
        cql = tokenizeLiterals(cql, ParserCQL.qt, literals);

        var booleans = this.captureBooleans(cql),
            expressions = this.captureExpressions(cql, booleans),
            children = this.makeChildren(columnName, expressions, literals),
            operator = booleans && booleans[0],
            state;

        if (children.length) {
            state = {
                type: 'columnFilter',
                children: children
            };

            if (operator) {
                state.operator = 'op-' + operator;
            }
        }

        return state;
    }
};

function descendingByLength(a, b) {
    return b.length - a.length;
}

/**
 * @summary Collapse literals.
 * @desc Allows reserved words to exist inside a quoted string.
 * Literals are collapsed to a quoted numerical index into the `literals` array.
 * @param {string} text
 * @param {string} qt
 * @param {string[]} literals - Empty array in which to return extracted literals.
 * @returns {string}
 */
function tokenizeLiterals(text, qt, literals) {
    literals.length = 0;

    for (
        var i = 0, j = 0, k, innerLiteral;
        (j = text.indexOf(qt, j)) >= 0;
        j = j + 1 + (i + '').length + 1, i++
    ) {
        k = j;
        do {
            k = text.indexOf(qt, k + 1);
            if (k < 0) {
                throw new ParserCqlError('Quotation marks must be paired; nested quotation marks must be doubled.');
            }
        } while (text[++k] === qt);

        innerLiteral = text
            .slice(++j, --k) // extract
            .replace(new RegExp(qt + qt, 'g'), qt); // unescape escaped quotation marks

        literals.push(innerLiteral);

        text = text.substr(0, j) + i + text.substr(k); // collapse
    }

    return text;
}

module.exports = ParserCQL;

},{"object-iterators":46}],113:[function(require,module,exports){
'use strict';

var deprecated = require('./deprecated');
var Base = require('extend-me').Base;

Base.prototype.deprecated = deprecated;
Base.prototype.HypergridError = HypergridError;


function HypergridError(message) {
    this.message = message;
}
HypergridError.prototype = Object.create(Error.prototype);
HypergridError.prototype.name = 'HypergridError';


module.exports = Base;

},{"./deprecated":118,"extend-me":7}],114:[function(require,module,exports){
/* eslint-env browser */

/**
 * @module localization
 */

'use strict';

var Base = require('./Base');
var deprecated = require('./deprecated');


/**
 * @param {string} defaultLocale
 * @param {string} [locale=defaultlocale]
 * @param {object} [options]
 * @constructor
 */
var Formatter = Base.extend({
    initialize: function(defaultLocale, locale, options) {
        if (typeof locale === 'object') {
            options = locale;
            locale = defaultLocale;
        }

        this.locale = locale;

        if (options) {
            if (typeof options.invalid === 'function') {
                this.invalid = options.invalid;
            }

            if (options.expectation) {
                this.expectation = options.expectation;
            }
        }
    }
});

/**
 * @summary Create a number localizer.
 * @implements localizerInterface
 * @desc Create an object conforming to {@link localizerInterface} for numbers, using {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NumberFormat|Intl.NumberFormat}.
 * @param {string} defaultLocale
 * @param {string} [locale=defaultLocale] - Passed to the {@link Intl.NumberFormat|https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NumberFormat} constructor.
 * @param {object} [options] - Passed to the `Intl.NumberFormat` constructor.
 * @param {boolean} [options.acceptStandardDigits=false] - Accept standard digits and decimal point interchangeably with localized digits and decimal point. (This option is interpreted here; it is not used by `Intl.NumberFormat`.)
 * @constructor
 * @extends Formatter
 * @tutorial localization
 */
var NumberFormatter = Formatter.extend('NumberFormatter', {
    initialize: function(defaultLocale, locale, options) {
        if (typeof locale === 'object') {
            options = locale;
        }

        options = options || {};

        this.format = new Intl.NumberFormat(this.locale, options).format;

        var mapperOptions = { useGrouping: false },
            mapper = new Intl.NumberFormat(this.locale, mapperOptions).format;

        this.demapper = demap.bind(this);

        /**
         * @summary A string containing the valid characters.
         * @desc Contains all localized digits + localized decimal point.
         * If we're accepting standard digits, will also contain all the standard digits + standard decimal point (if different than localized versions).
         * @type {string}
         * @private
         * @desc Localized digits and decimal point. Will also include standardized digits and decimal point if `options.acceptStandardDigits` is truthy.
         *
         * For internal use by the {@link NumberFormatter#standardize|standardize} method.
         * @memberOf NumberFormatter.prototype
         */
        this.map = mapper(10123456789.5).substr(1, 11); // localized '0123456789.'

        if (options.acceptStandardDigits && this.map !== '0123456789.') {
            this.map += '0123456789.';  // standard '0123456789.'
        }

        /** @summary A regex that tests `true` on first invalid character.
         * @type {RegExp}
         * @private
         * @desc Valid characters include:
         *
         * * Localized digits
         * * Localized decimal point
         * * Standard digits (when `options.acceptStandardDigits` is truthy)
         * * Standard decimal point (when `options.acceptStandardDigits` is truthy)
         * * Cosmetic characters added by formatter as per `options` (for human-friendly readability).
         *
         * Any characters outside this set are considered invalid.
         *
         * Set by the constructor; consumed by the {@link module:localization~NumberFormatter#invalid|invalid} method.
         *
         * Testing a string against this pattern yields `true` if at least one invalid character or `false` if all characters are valid.
         * @memberOf NumberFormatter.prototype
         */
        this.invalids = new RegExp(
            '[^' +
            this.format(11111).replace(this.map[1], '') + // thousands separator if in use
            this.map + // digits + decimal point
            ']'
        );
    },

    /** @summary Tests for invalid characters.
     * @desc Tests a localized string representation of a number that it contains any invalid characters.
     *
     * The number may be unformatted or it may be formatted with any of the permitted formatting characters, as implied by the constructor's `options` (passed to `Intl.NumberFormat`). Any other characters are considered invalid.
     *
     * However, standard digits and the standard decimal point are considered valid if the value of `options.acceptStandardDigits` as provided to the constructor was truthy. (Of course, these are always valid for locales that use them.)
     *
     * Use this method to:
     * 1. Filter out invalid characters on a `onkeydown` event; or
     * 2. Test an edited string prior to calling the {@link module:localization~NumberFormatter#standardize|standardize}.
     *
     * NOTE: This method does not check grammatical syntax; it only checks for invalid characters.
     *
     * @param number
     * @returns {boolean|string} Falsy means valid which in this case means contains only valid characters.
     * @memberOf NumberFormatter.prototype
     */
    invalid: function(number) {
        return this.invalids.test(number);
    },

    expectation:
        'Expected a number with optional commas (thousands grouping separator), optional decimal point, and an optional fractional part.\n' +
        'Comma separators are part of the format and will always be displayed for values >= 1000.\n' +
        'Edited values are always saved in their entirety even though the formatted value is rounded to the specified number of decimal places.',

    /**
     * This method will:
     * * Convert localized digits and decimal point characters to standard digits and decimal point characters.
     * * "Clean" the string by ignoring all other characters.
     * * Coerce the string to a number primitive.
     * @param {string} formattedLocalizedNumber - May or may not be formatted.
     * @returns {number} Number primitive.
     * @throws {string} Invalid number.
     * @memberOf NumberFormatter.prototype
     */
    parse: function(formattedLocalizedNumber) {
        var number = Number(
            formattedLocalizedNumber.split('').map(this.demapper).join('')
        );

        if (isNaN(number)) {
            throw 'Invalid Number';
        }

        return number;
    }
});

function demap(c) {
    var d = this.map.indexOf(c) % 11;
    return d < 0 ? '' : d < 10 ? d : '.';
}

/**
 * @implements localizerInterface
 * @param {string} defaultLocale
 * @param {string} [locale=defaultlocale] - Passed to the {@link Intl.DateFormat|https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateFormat} constructor.
 * @param {object} [options] - Passed to the `Intl.DateFormat` constructor.
 * @constructor
 * @extends Formatter
 */
var DateFormatter = Formatter.extend('DateFormatter', {
    initialize: function(defaultLocale, locale, options) {
        if (typeof locale === 'object') {
            options = locale;
        }

        options = options || {};

        /** @summary Transform a date object into human-friendly string representation.
         * @method
         */
        this.format = new Intl.DateTimeFormat(this.locale, options).format;

        // Get digits because may be chinese or "real Arabic" numerals.
        var testOptions = { useGrouping: false, style: 'decimal' },
            localizeNumber = new Intl.NumberFormat(this.locale, testOptions).format,
            localizedDigits = this.localizedDigits = localizeNumber(10123456789).substr(1, 10); // all localized digits in numerical order

        this.digitFormatter = formatDigit.bind(this);
        this.digitParser = parseDigit.bind(this);

        // Localize a test date with the default numeric parts to find out the resulting order of these parts.
        var yy = 1987,
            mm = 12,
            dd = 30,
            YY = this.transformNumber(this.digitFormatter, yy),
            MM = this.transformNumber(this.digitFormatter, mm),
            DD = this.transformNumber(this.digitFormatter, dd),
            testDate = new Date(yy, mm - 1, dd),
            localizeDate = new Intl.DateTimeFormat(this.locale).format,
            localizedDate = localizeDate(testDate), // all localized digits + localized punctuation
            missingDigits = new Intl.NumberFormat(this.locale).format(456),
            localizedNumberPattern = this.localizedNumberPattern = new RegExp('[' + localizedDigits + ']+', 'g'),
            parts = localizedDate.match(localizedNumberPattern);

        this.partsMap = {
            yy: parts.indexOf(YY),
            mm: parts.indexOf(MM),
            dd: parts.indexOf(DD)
        };

        if (options.acceptStandardDigits) {
            missingDigits += '1234567890';
        }

        /** @summary A regex that tests `true` on first invalid character.
         * @type {RegExp}
         * @private
         * @desc Valid characters include:
         *
         * * Localized digits
         * * Standard digits (when `options.acceptStandardDigits` is truthy)
         * * Localized punctuation to delimit date parts
         *
         * Any characters outside this set are considered invalid. Note that this only currently implemented when all three date parts are numeric
         *
         * Set by the constructor; consumed by the {@link NumberFormatter#valid|valid} method.
         *
         * Testing a string against this pattern yields `true` if at least one invalid character or `false` if all characters are valid.
         * @memberOf DateFormatter.prototype
         */
        this.invalids = new RegExp(
            '[^' +
            localizedDate +
            missingDigits +
            ']'
        );
    },

    /** @summary Tests for invalid characters.
     * @desc Tests a localized string representation of a number that it contains any invalid characters.
     *
     * The date is assumed to contain localized digits and punctuation as would be returned by `Intl.DateFormat` with the given `locale` and `options`. Any other characters are considered invalid.
     *
     * However, standard digits and the standard decimal point are also considered valid if the value of `options.acceptStandardDigits` as provided to the constructor was truthy. (Of course, these are always valid for locales that use them.)
     *
     * Use this method to:
     * 1. Filter out invalid characters on a `onkeydown` event; or
     * 2. Test an edited string prior to calling the {@link module:localization~DateFormatter#standardize|standardize}.
     *
     * NOTE: The current implementation only supports date formats using all numerics (which is the default for `Intl.DateFormat`).
     *
     * NOTE: This method does not check grammatical syntax; it only checks for invalid characters.
     *
     * @param number
     * @returns {boolean} Contains only valid characters.
     * @memberOf DateFormatter.prototype
     */
    invalid: function(number) {
        return this.invalids.test(number);
    },

    /**
     * This method will:
     * * Convert localized date to Date object.
     * * "Clean" the string by ignoring all other characters.
     * * Coerce the string to a number primitive.
     * @param {string} localizedDate
     * @returns {Date}
     * @throws {string} Invalid date.
     * @memberOf DateFormatter.prototype
     */
    parse: function(localizedDate) {
        var date,
            parts = localizedDate.match(this.localizedNumberPattern);

        if (parts && parts.length === 3) {
            var y = this.transformNumber(this.digitParser, parts[this.partsMap.yy]),
                m = this.transformNumber(this.digitParser, parts[this.partsMap.mm]) - 1,
                d = this.transformNumber(this.digitParser, parts[this.partsMap.dd]);

            date = new Date(y, m, d);
        } else {
            throw 'Invalid Date';
        }

        return date;
    },

    /**
     * Transform a number to or from a string representation with localized digits.
     * @param {function} digitTransformer - A function bound to `this`.
     * @param {number} number
     * @returns {string}
     * @private
     * @memberOf DateFormatter.prototype
     */
    transformNumber: function(digitTransformer, number) {
        return number.toString().split('').map(digitTransformer).join('');
    }
});

function formatDigit(d) {
    return this.localizedDigits[d];
}

function parseDigit(c) {
    var d = this.localizedDigits.indexOf(c);
    if (d < 0) { d = ''; }
    return d;
}

/**
 * All members are localizers (conform to {@link localizerInterface}) with exception of `get`, `set`, and localizer constructors which are named (by convention) ending in "Formmatter".
 *
 * The application developer is free to add localizers and localizer factory methods. See the {@link Localization#construct|construct} convenience method which may be helpful in this regard.
 * @param locale
 * @param {object} [numberOptions]
 * @param {object} [dateOptions]
 * @constructor
 */
function Localization(locale, numberOptions, dateOptions) {
    this.locale = locale;

    /**
     * @name number
     * @see The {@link NumberFormatter|NumberFormatter} class
     * @memberOf Localization.prototype
     */
    this.int = this.float = this.construct('number', NumberFormatter, numberOptions);

    /**
     * @see The {@link DateFormatter|DateFormatter} class
     * @memberOf Localization.prototype
     */
    this.construct('date', DateFormatter, dateOptions);
}

Localization.prototype = {
    constructor: Localization.prototype.constructor,

    /** @summary Creates a localizer from a localizer factory object using the default locale.
     * @desc Performs the following actions:
     * 1. Binds `Constructor` to `locale`.
     * 2. Adds the newly bound constructor to this object (for future reference) with the key "NameFormatter" (where "Name" is the localizer name, all lower case but with an initial capital).
     * 3. Uses the newly bound constructor to create a new localized localizer with the provided options.
     * 4. Adds new localizer to this object via {@link Localization#add|add}.
     *
     * @param {string} localizerName
     * @param {Constructor
     * @param {object} {factoryOptions}
     * @returns {localizeInerface} The new localizer.
     */
    construct: function(localizerName, Constructor, factoryOptions) {
        var constructorName = localizerName[0].toUpperCase() + localizerName.substr(1).toLowerCase() + 'Formatter',
            BoundConstructor = Constructor.bind(null, this.locale),
            localizer = new BoundConstructor(factoryOptions);

        this[constructorName] = BoundConstructor;

        return this.add(localizerName, localizer);
    },

    /** @summary Register a localizer.
     * @desc Checks the provided localizer that it conforms to {@link localizerInterface}
     * and adds it to the object using localizerName all lower case as the key.
     * @param {string} name
     * @param {localizerInterface} localizer
     * @memberOf Localization.prototype
     * @returns {localizeInerface} The provided localizer.
     */
    add: function(name, localizer) {
        if (typeof name === 'object') {
            localizer = name;
            name = undefined;
        }

        if (
            typeof localizer !== 'object' ||
            typeof localizer.format !== 'function' ||
            typeof localizer.parse !== 'function' ||
            localizer.invalid && typeof localizer.invalid !== 'function' ||
            localizer.expectation && typeof localizer.expectation !== 'string'
        ) {
            throw 'Expected localizer object to conform to interface.';
        }

        name = name || localizer.name;
        name = name && name.toLowerCase();
        this[name] = localizer;

        return localizer;
    },
    deprecated: deprecated,
    set: function(name) {
        return this.deprecated('set(name, localizer)', 'add(name, localizer)', '1.0.6', arguments);
    },

    /**
     *
     * @param localizerName
     * @returns {localizerInterface}
     * @memberOf Localization.prototype
     */
    get: function(name) {
        return this[name && name.toLowerCase()] || this.string;
    },

    ///  ///  ///  ///  ///    LOCALIZERS    ///  ///  ///  ///  ///

    // Special localizer for use by Chrome's date input control.
    chromeDate: {
        format: function(date) {
            if (date != null) {
                if (typeof date !== 'object') {
                    date = new Date(date);
                }

                var yy = date.getFullYear(),
                    m = date.getMonth() + 1, mm = m < 10 ? '0' + m : m,
                    d = date.getDate(), dd = d < 10 ? '0' + d : d;

                date = yy + '-' + mm + '-' + dd;
            } else {
                date = null;
            }
            return date;
        },
        parse: function(str) {
            var date,
                parts = str.split('-');
            if (parts && parts.length === 3) {
                date = new Date(parts[0], parts[1] - 1, parts[2]);
            } else {
                date = null;
            }
            return date;
        }
    },

    null: {
        format: function(value) {
            return value;
        },
        parse: function(str) {
            return str;
        }
    },

    string: {
        format: function(value) {
            return value + '';
        },
        parse: function(str) {
            return str + '';
        }
    }
};

module.exports = Localization;

},{"./Base":113,"./deprecated":118}],115:[function(require,module,exports){
/* eslint-env browser */
/* global requestAnimationFrame */

'use strict';

var _ = require('object-iterators');

var Base = require('./Base');
var images = require('../../images');

/** @typedef {object} CanvasRenderingContext2D
 * @see [CanvasRenderingContext2D](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D)
 */

/**
 * @constructor
 * @desc fin-hypergrid-renderer is the canvas enabled top level sub component that handles the renderering of the Grid.
 *
 * It relies on two other external subprojects
 *
 * 1. fin-canvas: a wrapper to provide a simpler interface to the HTML5 canvas component
 * 2. rectangular: a small npm module providing Point and Rectangle objects
 *
 * The fin-hypergrid-renderer is in a unique position to provide critical functionality to the fin-hypergrid in a hightly performant manner.
 * Because it MUST iterate over all the visible cells it can store various bits of information that can be encapsulated as a service for consumption by the fin-hypergrid component.
 *
 * Instances of this object have basically four main functions.
 *
 * 1. render fixed row headers
 * 2. render fixed col headers
 * 3. render main data cells
 * 4. render grid lines
 *
 * Same parameters as {@link Renderer#initialize|initialize}, which is called by this constructor.
 *
 */
var Renderer = Base.extend('Renderer', {

    //the shared single item "pooled" cell object for drawing each cell
    cell: {
        x: 0,
        y: 0,
        width: 0,
        height: 0
    },

    scrollHeight: 0,

    viewHeight: 0,

    reset: function() {
        this.bounds = {
            width: 0,
            height: 0
        };
        this.columnEdges = [];
        this.columnEdgesIndexMap = [];
        this.renderedColumnMinWidths = [];
        this.rowEdges = [];
        this.rowEdgesIndexMap = [];
        this.visibleColumns = [];
        this.visibleRows = [];
        this.insertionBounds = [];
    },

    /**
     * @summary Constructor logic
     * @desc This method will be called upon instantiation of this class or of any class that extends from this class.
     * > All `initialize()` methods in the inheritance chain are called, in turn, each with the same parameters that were passed to the constructor, beginning with that of the most "senior" class through that of the class of the new instance.
     * @memberOf Renderer.prototype
     */
    initialize: function(grid) {
        this.grid = grid;
        this.reset();
    },

    //this function computes the grid coordinates used for extremely fast iteration over
    //painting the grid cells. this function is very fast, for thousand rows X 100 columns
    //on a modest machine taking usually 0ms and no more that 3 ms.
    computeCellsBounds: function() {

        //var startTime = Date.now();

        var scrollTop = this.getScrollTop(),
            scrollLeft = this.getScrollLeft(),

            numColumns = this.getColumnCount(),
            numFixedColumns = this.getFixedColumnCount(),

            numRows = this.getRowCount(),
            numFixedRows = this.getFixedRowCount(),

            bounds = this.getBounds(),
            grid = this.grid,
            numberOfBottomTotalsRows = grid.behavior.dataModel.getBottomTotals().length,
            viewWidth = bounds.width || grid.canvas.width, // if 0, we must be in bootstrap
            viewHeight = bounds.height - numberOfBottomTotalsRows * grid.behavior.getDefaultRowHeight(),

            insertionBoundsCursor = 0,
            previousInsertionBoundsCursorValue = 0,

            start = 0,
            x = 0, y = 0,
            c, r,
            vx, vy,
            width, height,
            firstVX, lastVX,
            firstVY, lastVY;

        this.getColumnEdges().length = 0;
        this.rowEdges.length = 0;

        this.columnEdges[0] = 0;
        this.rowEdges[0] = 0;
        this.scrollHeight = 0;

        this.visibleColumns.length = 0;
        this.visibleRows.length = 0;
        this.columnEdgesIndexMap = [];
        this.rowEdgesIndexMap = [];

        this.insertionBounds = [];

        if (this.grid.isShowRowNumbers()) {
            start--;
            this.columnEdges[-1] = -1;
        }

        for (c = start; c < numColumns; c++) {
            vx = c;
            if (c >= numFixedColumns) {
                vx = vx + scrollLeft;
                if (firstVX === undefined) {
                    firstVX = vx;
                }
                lastVX = vx;
            }
            if (x > viewWidth || numColumns <= vx) {
                break;
            }
            width = grid.getColumnWidth(vx);
            x = x + width;
            this.columnEdges[c + 1] = Math.round(x);
            this.visibleColumns[c] = vx;
            this.columnEdgesIndexMap[vx] = c;

            insertionBoundsCursor = insertionBoundsCursor + Math.round(width / 2) + previousInsertionBoundsCursorValue;
            this.insertionBounds.push(insertionBoundsCursor);
            previousInsertionBoundsCursorValue = Math.round(width / 2);
        }

        for (r = 0; r < numRows; r++) {
            vy = r;
            if (r >= numFixedRows) {
                vy = vy + scrollTop;
                if (firstVY === undefined) {
                    firstVY = vy;
                }
                lastVY = vy;
            }
            if (y > viewHeight || numRows <= vy) {
                break;
            }
            height = grid.getRowHeight(vy);
            y = y + height;
            this.rowEdges[r + 1] = Math.round(y);
            this.visibleRows[r] = vy;
            this.rowEdgesIndexMap[vy] = r;
        }
        this.viewHeight = viewHeight;
        this.dataWindow = this.grid.newRectangle(firstVX, firstVY, lastVX - firstVX, lastVY - firstVY);
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {Object} a property value at a key, delegates to the grid
     */
    resolveProperty: function(key) {
        return this.grid.resolveProperty(key);
    },

    /**
     * @memberOf Renderer.prototype
     * @summary Notify the fin-hypergrid everytime we've repainted.
     * @desc This is the entry point from fin-canvas.
     * @param {CanvasRenderingContext2D} gc
     */
    paint: function(gc) {
        if (this.grid) {
            if (!this.hasData()) {
                var message = this.grid.resolveProperty('noDataMessage');
                gc.font = '20px Arial';
                gc.fillText(message, 20, 30);
            } else {
                this.renderGrid(gc);
                this.grid.gridRenderedNotification();
            }
        }
    },

    hasData: function() {
        var data = this.grid.behavior.getData();
        if (data) {
            return data.length > 0;
        }
        return false;
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} Answer how many rows we rendered
     */
    getVisibleRowsCount: function() {
        return this.visibleRows.length - 1;
    },

    getVisibleScrollHeight: function() {
        return this.viewHeight - this.grid.getFixedRowsHeight();
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number[]} Rows we just rendered.
     */
    getVisibleRows: function() {
        return this.visibleRows;
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} Numer of columns we just rendered.
     */
    getVisibleColumnsCount: function() {
        return this.visibleColumns.length - 1;
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} Columns we just rendered.
     */
    getVisibleColumns: function() {
        return this.visibleColumns;
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} The column index whne the mouseEvent coordinates are over a column divider.
     */
    overColumnDivider: function(x) {
        x = Math.round(x);
        var edges = this.getColumnEdges();
        var whichCol = edges.indexOf(x - 1);
        if (whichCol < 0) {
            whichCol = edges.indexOf(x);
        }
        if (whichCol < 0) {
            whichCol = edges.indexOf(x - 2);
        }
        if (whichCol < 0) {
            whichCol = edges.indexOf(x + 1);
        }
        if (whichCol < 0) {
            whichCol = edges.indexOf(x - 3);
        }

        return whichCol;
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} The row index when the mouseEvent coordinates are over a row divider.
     */
    overRowDivider: function(y) {
        y = Math.round(y);
        var which = this.rowEdges.indexOf(y + 1);
        if (which < 0) {
            which = this.rowEdges.indexOf(y);
        }
        if (which < 0) {
            which = this.rowEdges.indexOf(y - 1);
        }
        return which;
    },

    /**
     * @memberOf Renderer.prototype
     * @param {Point} cell
     * @returns {Rectangle} Bounding rect of the given `cell`.
     */
    getBoundsOfCell: function(cell) {
        return this._getBoundsOfCell(cell.x, cell.y);
    },

    /**
     * @memberOf Renderer.prototype
     * @param {number} c - The horizontal coordinate.
     * @param {number} r - The vertical coordinate.
     * @returns {Rectangle} Bounding rect of cell with the given coordinates.
     */
    _getBoundsOfCell: function(c, r) {
        var xOutside = false,
            yOutside = false,
            cell = this.cell;

        var y, x = this.columnEdgesIndexMap[c];
        if (x === undefined) {
            x = this.columnEdgesIndexMap[c - 1];
            xOutside = true;
        }

        var oy, ox = this.columnEdges[x],
            cy, cx = this.columnEdges[x + 1],
            ey, ex = cx - ox;

        cell.x = xOutside ? cx : ox;
        cell.width = xOutside ? 0 : ex;

        if (r < 0) { // bottom totals rows
            var behavior = this.grid.behavior,
                bounds = this.getBounds();

            ey = behavior.getDefaultRowHeight();
            oy = bounds.height + r * ey;
            cy = oy + ey;
        } else {
            y = this.rowEdgesIndexMap[r];
            if (y === undefined) {
                y = this.rowEdgesIndexMap[r - 1];
                yOutside = true;
            }

            oy = this.rowEdges[y];
            cy = this.rowEdges[y + 1];
            ey = cy - oy;
        }

        cell.y = yOutside ? cy : oy;
        cell.height = yOutside ? 0 : ey;

        return cell;
    },

    /**
     * @memberOf Renderer.prototype
     * @desc answer the column index under the coordinate at pixelX
     * @param {number} pixelX - The horizontal coordinate.
     * @returns {number} The column index under the coordinate at pixelX.
     */
    getColumnFromPixelX: function(pixelX) {
        var width = 0,
            fixedColumnCount = this.getFixedColumnCount(),
            scrollLeft = this.grid.getHScrollValue(),
            edges = this.getColumnEdges();

        for (var c = 1; c < edges.length - 1; c++) {
            width = edges[c] - (edges[c] - edges[c - 1]) / 2;
            if (pixelX < width) {
                if (c > fixedColumnCount) {
                    c = c + scrollLeft;
                }
                return c - 1;
            }
        }
        if (c > fixedColumnCount) {
            c = c + scrollLeft;
        }
        return c - 1;
    },


    /**
     * @memberOf Renderer.prototype
     * @desc Answer specific data cell coordinates given mouse coordinates in pixels.
     * @param {Point} point
     * @returns {Point} Cell coordinates
     */
    getGridCellFromMousePoint: function(point) {

        var behavior = this.grid.behavior;
        var width = 0;
        var height = 0;
        var x, y, c, r;
        var previous = 0;
        var columnEdges = this.getColumnEdges();
        var fixedColumnCount = this.getFixedColumnCount(); // + gridSize;
        var fixedRowCount = this.getFixedRowCount();

        // var fixedColumnCount = this.getFixedColumnCount();
        // var fixedRowCount = this.getFixedRowCount();
        var scrollX = this.getScrollLeft();
        var scrollY = this.getScrollTop();

        for (c = 0; c < columnEdges.length; c++) {
            width = columnEdges[c];
            if (point.x < width) {
                x = Math.max(0, point.x - previous - 2);
                break;
            }
            previous = width;
        }
        c--;
        previous = 0;
        for (r = 0; r < this.rowEdges.length; r++) {
            height = this.rowEdges[r];
            if (point.y < height) {
                y = Math.max(0, point.y - previous - 2);
                break;
            }
            previous = height;
        }
        r--;
        if (point.x < 0) {
            c = -1;
        }
        if (point.y < 0) {
            r = -1;
        }

        var viewPoint = this.grid.newPoint(c, r);

        //compensate if we are scrolled
        if (c >= fixedColumnCount) {
            c = c + scrollX;
        }
        if (r >= fixedRowCount) {
            r = r + scrollY;
        }

        var translatedIndex = -1;

        var column = behavior.getActiveColumn(c);
        if (column) {
            translatedIndex = column.index;
        }

        return {
            gridCell: this.grid.newPoint(c, r),
            mousePoint: this.grid.newPoint(x, y),
            viewPoint: viewPoint,
            dataCell: this.grid.newPoint(translatedIndex, r),
        };
    },

    /**
     * @memberOf Renderer.prototype
     * @summary Determines if a column is visible.
     * @param {number} colIndex - the column index*
     * @returns {boolean} The given column is fully visible.
     */
    isColumnVisible: function(colIndex) {
        var isVisible = this.visibleColumns.indexOf(colIndex) !== -1;
        return isVisible;
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} The width x coordinate of the last rendered column
     */
    getFinalVisableColumnBoundary: function() {
        var isMaxX = this.isLastColumnVisible();
        var chop = isMaxX ? 2 : 1;
        var colWall = this.getColumnEdges()[this.getColumnEdges().length - chop];
        var result = Math.min(colWall, this.getBounds().width - 200);
        return result;
    },

    /**
     * @memberOf Renderer.prototype
     * @summary Determines visibility of a row.
     * @param {number} rowIndex - the row index
     * @returns {boolean} The given row is fully visible.
     */
    isRowVisible: function(rowIndex) {
        var isVisible = this.visibleRows.indexOf(rowIndex) !== -1;
        return isVisible;
    },

    /**
     * @memberOf Renderer.prototype
     * @summary Determines if a cell is selected.
     * @param {number} x - the x cell coordinate
     * @param {number} y - the y cell coordinate*
     * @returns {boolean} The given cell is fully visible.
     */
    isSelected: function(x, y) {
        return this.grid.isSelected(x, y);
    },

    /**
     * @memberOf Renderer.prototype
     * @desc This is the main forking of the renderering task.
     * @param {CanvasRenderingContext2D} gc
     */
    renderGrid: function(gc) {
        gc.beginPath();

        this.paintCells(gc);
        this.paintGridlines(gc);
        this.renderOverrides(gc);
        this.renderLastSelection(gc);
        gc.closePath();
    },

    renderLastSelection: function(gc) {
        gc.beginPath();
        this._renderLastSelection(gc);
        gc.closePath();
    },

    _renderLastSelection: function(gc) {

        /*

            Compute the Bounds of the Last Selection that is visible

         */

        var selections = this.grid.selectionModel.getSelections();
        if (!selections || selections.length === 0) {
            return;
        }
        var selection = this.grid.selectionModel.getLastSelection();
        var mouseDown = selection.origin;
        if (mouseDown.x === -1) {
            //no selected area, lets exit
            return;
        }

        var visibleColumns = this.getVisibleColumns();
        var visibleRows = this.getVisibleRows();
        var lastVisibleColumn = visibleColumns[visibleColumns.length - 1];
        var lastVisibleRow = visibleRows[visibleRows.length - 1];

        var extent = selection.extent;

        var dpOX = Math.min(mouseDown.x, mouseDown.x + extent.x);
        var dpOY = Math.min(mouseDown.y, mouseDown.y + extent.y);

        //lets check if our selection rectangle is scrolled outside of the visible area
        if (dpOX > lastVisibleColumn) {
            return; //the top of our rectangle is below visible
        }
        if (dpOY > lastVisibleRow) {
            return; //the left of our rectangle is to the right of being visible
        }

        var dpEX = Math.max(mouseDown.x, mouseDown.x + extent.x) + 1;
        dpEX = Math.min(dpEX, 1 + lastVisibleColumn);

        var dpEY = Math.max(mouseDown.y, mouseDown.y + extent.y) + 1;
        dpEY = Math.min(dpEY, 1 + lastVisibleRow);

        var o = this._getBoundsOfCell(dpOX, dpOY);
        var ox = Math.round((o.x === undefined) ? this.grid.getFixedColumnsWidth() : o.x);
        var oy = Math.round((o.y === undefined) ? this.grid.getFixedRowsHeight() : o.y);
        // var ow = o.width;
        // var oh = o.height;
        var e = this._getBoundsOfCell(dpEX, dpEY);
        var ex = Math.round((e.x === undefined) ? this.grid.getFixedColumnsWidth() : e.x);
        var ey = Math.round((e.y === undefined) ? this.grid.getFixedRowsHeight() : e.y);
        // var ew = e.width;
        // var eh = e.height;
        var x = Math.min(ox, ex);
        var y = Math.min(oy, ey);
        var width = 1 + ex - ox;
        var height = 1 + ey - oy;
        if (x === ex) {
            width = ox - ex;
        }
        if (y === ey) {
            height = oy - ey;
        }
        if (width * height < 1) {
            //if we are only a skinny line, don't render anything
            return;
        }

        /*

          Render the selection model around the bounds

         */

        var config = {
            bounds: {
                x: x,
                y: y,
                width: width,
                height: height
            },
            selectionRegionOverlayColor: this.grid.resolveProperty('selectionRegionOverlayColor'),
            selectionRegionOutlineColor: this.grid.resolveProperty('selectionRegionOutlineColor')
        };
        this.grid.cellRenderers.get('lastselection').paint(gc, config);
    },

    /**
     * @memberOf Renderer.prototype
     * @desc iterate the renderering overrides and manifest each
     * @param {CanvasRenderingContext2D} gc
     */
    renderOverrides: function(gc) {
        var cache = this.grid.renderOverridesCache;
        for (var key in cache) {
            if (cache.hasOwnProperty(key)) {
                var override = cache[key];
                if (override) {
                    this.renderOverride(gc, override);
                }
            }
        }
    },

    /**
     * @memberOf Renderer.prototype
     * @desc copy each overrides specified area to it's target and blank out the source area
     * @param {CanvasRenderingContext2D} gc
     * @param {OverrideObject} override - an object with details contain an area and a target context
     */
    renderOverride: function(gc, override) {
        //lets blank out the drag row
        var hdpiRatio = override.hdpiratio;
        //var edges = this.getColumnEdges();
        var startX = override.startX; //hdpiRatio * edges[override.columnIndex];
        var width = override.width + 1;
        var height = override.height;
        var targetCTX = override.ctx;
        var imgData = gc.getImageData(startX, 0, Math.round(width * hdpiRatio), Math.round(height * hdpiRatio));
        targetCTX.putImageData(imgData, 0, 0);
        gc.fillStyle = this.resolveProperty('backgroundColor2');
        gc.fillRect(Math.round(startX / hdpiRatio), 0, width, height);
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} Current vertical scroll value.
     */
    getScrollTop: function() {
        return this.grid.getVScrollValue();
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} Current horizontal scroll value.
     */
    getScrollLeft: function() {
        return this.grid.getHScrollValue();
    },

    getColumnEdges: function() {
        return this.columnEdges;
    },

    getRowEdges: function() {
        return this.rowEdges;
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {boolean} The last col was rendered (is visible)
     */
    isLastColumnVisible: function() {
        var lastColumnIndex = this.getColumnCount() - 1;
        return this.visibleColumns.indexOf(lastColumnIndex) !== -1;
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} The rendered column width at index
     */
    getRenderedWidth: function(index) {
        return this.getColumnEdges()[index];
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} The rendered row height at index
     */
    getRenderedHeight: function(index) {
        return this.rowEdges[index];
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {fin-canvas} my [fin-canvas](https://github.com/stevewirts/fin-canvas)
     */
    getCanvas: function() {
        return this.grid.getCanvas();
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {boolean} User is currently dragging a column for reordering.
     */
    isDraggingColumn: function() {
        return this.grid.isDraggingColumn();
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} The row to goto for a page up.
     */
    getPageUpRow: function() {
        var grid = this.grid,
            scrollHeight = this.getVisibleScrollHeight(),
            headerRows = this.grid.getFixedRowCount(),
            top = this.dataWindow.origin.y - headerRows,
            scanHeight = 0;
        while (scanHeight < scrollHeight && top > -1) {
            scanHeight = scanHeight + grid.getRowHeight(top);
            top--;
        }
        return top + 1;
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} The row to goto for a page down.
     */
    getPageDownRow: function() {
        var headerRows = this.grid.getFixedRowCount();
        var rowNum = this.dataWindow.corner.y - headerRows - 1;
        return rowNum;
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} The number of columns.
     */
    getColumnCount: function() {
        return this.grid.getColumnCount();
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} The number of rows.
     */
    getRowCount: function() {
        return this.grid.getRowCount();
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} The number of fixed columns.
     */
    getFixedColumnCount: function() {
        return this.grid.getFixedColumnCount();
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} The number of fixed rows.
     */
    getFixedRowCount: function() {
        return this.grid.getFixedRowCount();
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} The number of header rows.
     */
    getHeaderRowCount: function() {
        return this.grid.getHeaderRowCount();
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} The number of header columns.
     */
    getHeaderColumnCount: function() {
        return this.grid.getHeaderColumnCount();
    },

    /** @summary Smart render the grid.
     * @desc Paint all the cells of a grid, including all "fixed" columns and rows.
     * We snapshot the context to insure against its pollution.
     * `try...catch` surrounds each cell paint in case a cell editor throws an error.
     * The error message is error-logged to console AND displayed in cell.
     * @memberOf Renderer.prototype
     * @param {CanvasRenderingContext2D} gc
     */
    paintCells: function(gc) {
        var message,
            config = {},
            x, y,
            c, r,

            columnEdges = this.getColumnEdges(),
            rowEdges = this.rowEdges,

            visibleCols = this.getVisibleColumns(),
            visibleRows = this.getVisibleRows(),

            behavior = this.grid.behavior,

            clipX = 0,
            clipY = 0,
            clipWidth,
            clipHeight = this.getBounds().height,

            loopStart = this.grid.isShowRowNumbers() ? -1 : 0,
            loopLength = visibleCols.length; // regardless of loopStart, due to definition of .length

        this.buttonCells = {};

        if (loopLength) { // this if prevents painting just the fixed columns when there are no visible columns

            // For each column...
            for (x = loopStart; x < loopLength; x++, clipX += clipWidth) {

                c = visibleCols[x];
                this.renderedColumnMinWidths[c] = 0;

                gc.save();

                // Clip to visible portion of column to prevent overflow to right. Previously we clipped to entire visible grid and dealt with overflow by overpainting with next column. However, this strategy fails when transparent background (no background color).
                // TODO: if extra clip() calls per column affect performance (not the clipping itself which was happening anyway, but the clip calls which set up the clipping), use previous strategy when there is a background color
                clipWidth = columnEdges[x + 1] - clipX;
                gc.beginPath();
                gc.rect(clipX, clipY, clipWidth, clipHeight);
                gc.clip();

                // For each row (of each column)...
                for (y = 0; y < visibleRows.length; y++) {

                    r = visibleRows[y];

                    try {

                        this._paintCell(gc, c, r);

                        //if (r === 9 && c === 2) { throw Error('She sells sea shells by the sea shore.'); }

                    } catch (e) {

                        message = e && (e.message || e) || 'Unknown error.';

                        console.error(message);

                        var rawGc = gc.gc || gc, // Don't log these canvas calls
                            errY = rowEdges[y],
                            errHeight = rowEdges[y + 1] - errY;

                        rawGc.save(); // define clipping region
                        rawGc.beginPath();
                        rawGc.rect(clipX, errY, clipWidth, errHeight);
                        rawGc.clip();
                        config = {
                            bounds: {
                                y: errY,
                                x: clipX,
                                height: errHeight,
                                width: clipWidth
                            }
                        };

                        this.grid.cellRenderers.get('errorcell').paint(rawGc, config, message);

                        rawGc.restore(); // discard clipping region

                    }
                }

                // Bottom totals rows...
                for (y = -behavior.dataModel.getBottomTotals().length; y; y++) {
                    this._paintCell(gc, c, y);
                }

                gc.restore(); // Remove column's clip region (and anything else renderCellError() might have set)
            }
        }

        setNumberColumnWidth(gc, behavior, this.grid.getRowCount());
    },

    /**
     * @memberOf Renderer.prototype
     * @desc We opted to not paint borders for each cell as that was extremely expensive. Instead we draw gridlines here. Also we record the widths and heights for later.
     * @param {CanvasRenderingContext2D} gc
     */
    paintGridlines: function(gc) {
        var x, y, c, r = 0;

        var colWidths = this.getColumnEdges();
        var rowHeights = this.rowEdges;
        var viewHeight;
        var viewWidth = colWidths[colWidths.length - 1];
        var drawThemH = this.resolveProperty('gridLinesH');
        var drawThemVOverflow = this.resolveProperty('gridLinesVOverflow');
        var drawThemV = this.resolveProperty('gridLinesV');
        var lineColor = this.resolveProperty('lineColor');
        if (drawThemVOverflow){
            viewHeight = this.getBounds().height;
        } else {
            viewHeight = rowHeights[rowHeights.length - 1];
        }

        gc.beginPath();

        if (drawThemV) {
            for (c = 0; c < colWidths.length + 1; c++) {
                x = colWidths[c] + 0.5;
                gc.moveTo(x, 0);
                gc.lineTo(x, viewHeight);
            }
        }

        if (drawThemH) {
            for (r = 0; r < rowHeights.length - 1; r++) {
                y = rowHeights[r] + 0.5;
                gc.moveTo(0, y);
                gc.lineTo(viewWidth, y);
            }

            // Bottom totals rows...
            var behavior = this.grid.behavior,
                rowHeight = behavior.getDefaultRowHeight();
            for (r = -behavior.dataModel.getBottomTotals().length, y = this.getBounds().height; r; r++) {
                y -= rowHeight;
                gc.moveTo(0, y);
                gc.lineTo(viewWidth, y);
            }
        }

        gc.closePath();

        gc.strokeStyle = lineColor;
        gc.lineWidth = this.resolveProperty('lineWidth');
        gc.stroke();
    },

    /**
     * @memberOf Renderer.prototype
     * @param {CanvasRenderingContext2D} gc
     * @param x
     * @param y
     */
    paintCell: function(gc, x, y) {
        gc.moveTo(0, 0);

        var c = this.getVisibleColumns()[x],
            r = this.getVisibleRows()[y];

        if (c) { //something is being viewed at at the moment (otherwise returns undefined)
            this._paintCell(gc, c, r);
        }
    },

    _paintCell: function(gc, c, r) {

        var grid = this.grid,
            behavior = grid.behavior,
            baseProperties = behavior.getColumnProperties(c);

        if (baseProperties.isNull) {
            return;
        }

        var columnProperties = baseProperties,

            headerRowCount = behavior.getHeaderRowCount(),
            isGridRow = r >= headerRowCount,
            isFooterRow = r < 0,
            isHeaderRow = !isGridRow && !isFooterRow,
            isFilterRow = grid.isFilterRow(r),

            headerColumnCount = behavior.getHeaderColumnCount(),
            isGridColumn = c >= headerColumnCount,
            isShowRowNumbers = grid.isShowRowNumbers(),
            isHierarchyColumn = grid.isHierarchyColumn(c),

            isRowSelected = grid.isRowSelected(r),
            isColumnSelected = grid.isColumnSelected(c),
            isCellSelected = grid.isCellSelected(c, r),
            isCellSelectedInColumn = grid.isCellSelectedInColumn(c),
            isCellSelectedInRow = grid.isCellSelectedInRow(r),
            areAllRowsSelected = grid.areAllRowsSelected(),
            cellProperties;

        if ((isShowRowNumbers && c === -1) || isHierarchyColumn) {
            if (isRowSelected) {
                cellProperties = Object.create(baseProperties.rowHeaderRowSelection);
                cellProperties.isSelected = true;
            } else {
                cellProperties = Object.create(baseProperties.rowHeader);
                cellProperties.isSelected = isCellSelectedInRow;
            }
            cellProperties.isUserDataArea = false;
        } else if (isHeaderRow || isFooterRow) {
            if (isFilterRow) {
                cellProperties = Object.create(baseProperties.filterProperties);
                cellProperties.isSelected = false;
            } else if (isColumnSelected) {
                cellProperties = Object.create(baseProperties.columnHeaderColumnSelection);
                cellProperties.isSelected = true;
            } else {
                cellProperties = Object.create(baseProperties.columnHeader);
                cellProperties.isSelected = isCellSelectedInColumn;
            }
            cellProperties.isUserDataArea = false;
        } else if (isHierarchyColumn) {
            cellProperties = Object.create(baseProperties.rowHeader);
            cellProperties.isSelected = isCellSelectedInRow;
        } else {
            cellProperties = Object.create(baseProperties);
            cellProperties.isSelected = isCellSelected || isRowSelected || isColumnSelected;
            cellProperties.isUserDataArea = true;
        }

        var rowNum = r - headerRowCount + 1;

        if (c === -1) {
            if (r === 0) { // header row gets "master" checkbox
                cellProperties.value = [images.checkbox(areAllRowsSelected), '', null];
            } else if (isFilterRow) { // no checkbox but show filter icon
                cellProperties.value = [images.filter(false), '', null];
            } else if (isHeaderRow || isFooterRow) { // no checkbox on "totals" rows
                cellProperties.value = '';
            } else {
                cellProperties.value = [images.checkbox(isRowSelected), rowNum, null];
            }
            cellProperties.halign = 'right';
        } else {
            // set dataRow and columnName used by valOrFunc (needed when func)
            var column = behavior.getActiveColumn(c);
            cellProperties.dataRow = grid.getRow(r);
            cellProperties.columnName = column.name;

            cellProperties.value = grid.getValue(c, r);
            cellProperties.halign = grid.getColumnAlignment(c);
        }

        cellProperties.isGridColumn = isGridColumn;
        cellProperties.isGridRow = isGridRow;
        cellProperties.isColumnHovered = grid.isColumnHovered(c) && isGridColumn;
        cellProperties.isRowHovered = grid.isRowHovered(r) && isGridRow;
        cellProperties.isCellHovered = grid.isHovered(c, r) && isGridColumn && isGridRow;
        cellProperties.bounds = this._getBoundsOfCell(c, r);
        cellProperties.isCellSelected = isCellSelected;
        cellProperties.isRowSelected = isRowSelected;
        cellProperties.isColumnSelected = isColumnSelected;
        cellProperties.isInCurrentSelectionRectangle = grid.isInCurrentSelectionRectangle(c, r);

        if (grid.mouseDownState) {
            var point = grid.mouseDownState.gridCell;
            cellProperties.mouseDown = point.x === c && point.y === r;
        }

        var cell = behavior.getCellRenderer(cellProperties, c, r);

        behavior.cellPropertiesPrePaintNotification(cellProperties);

        //declarative cell properties
        if (isGridRow && isGridColumn) {
            var overrides = behavior.getCellProperties(column.index, r);
            _(cellProperties).extendOwn(overrides);
        }

        //allow the renderer to identify itself if it's a button
        cellProperties.buttonCells = this.buttonCells;

        cellProperties.formatValue = grid.getFormatter(cellProperties.isUserDataArea && cellProperties.format);
        cell.paint(gc, cellProperties);

        this.renderedColumnMinWidths[c] = Math.max(cellProperties.minWidth || 0, this.renderedColumnMinWidths[c]);
        columnProperties.preferredWidth = this.renderedColumnMinWidths[c];
    },

    isViewableButton: function(c, r) {
        var key = c + ',' + r;
        return this.buttonCells[key] === true;
    },

    getRowNumbersWidth: function() {
        var colEdges = this.getColumnEdges();
        if (colEdges.length === 0) {
            return 0;
        }
        return colEdges[0];
    },

    startAnimator: function() {
        var self = this;
        requestAnimationFrame(function animate() {
            self.animate();
            requestAnimationFrame(animate);
        });
    },

    animate: function() {
        var ctx = this.getCanvas().canvasCTX;
        ctx.beginPath();
        ctx.save();
        this.renderLastSelection(ctx);
        ctx.restore();
        ctx.closePath();
    },

    getBounds: function() {
        return this.bounds;
    },

    setBounds: function(bounds) {
        return (this.bounds = bounds);
    }

});

function setNumberColumnWidth(gc, behavior, maxRow) {
    var columnProperties = behavior.getColumnProperties(-1),
        cellProperties = columnProperties.rowHeader,
        icon = images.checked;

    gc.font = cellProperties.font;

    columnProperties.preferredWidth = icon.width + 7 + cellProperties.getTextWidth(gc, maxRow + 1);
}

module.exports = Renderer;

},{"../../images":4,"./Base":113,"object-iterators":46}],116:[function(require,module,exports){
'use strict';

var RangeSelectionModel = require('sparse-boolean-array');

/**
 *
 * @constructor
 * @desc We represent selections as a list of rectangles because large areas can be represented and tested against quickly with a minimal amount of memory usage. Also we need to maintain the selection rectangles flattened counter parts so we can test for single dimension contains. This is how we know to highlight the fixed regions on the edges of the grid.
 */

function SelectionModel(grid) {

    this.grid = grid;

    /**
     * @name selections
     * @type {Rectangle[]}
     * @summary The selection rectangles.
     * @desc Created as an empty array upon instantiation by the {@link SelectionModel|constructor}.
     * @memberOf SelectionModel.prototype
     */
    this.selections = [];

    /**
     * @name flattenedX
     * @type {Rectangle[]}
     * @summary The selection rectangles flattened in the horizontal direction (no width).
     * @desc Created as an empty array upon instantiation by the {@link SelectionModel|constructor}.
     * @memberOf SelectionModel.prototype
     */
    this.flattenedX = [];

    /**
     * @name flattenedY
     * @type {Rectangle[]}
     * @summary The selection rectangles flattened in the vertical direction (no height).
     * @desc Created as an empty array upon instantiation by the {@link SelectionModel|constructor}.
     * @memberOf SelectionModel.prototype
     */
    this.flattenedY = [];

    /**
     * @name rowSelectionModel
     * @type {RangeSelectionModel}
     * @summary The selection rectangles.
     * @desc Created as a new RangeSelectionModel upon instantiation by the {@link SelectionModel|constructor}.
     * @memberOf SelectionModel.prototype
     */
    this.rowSelectionModel = new RangeSelectionModel();

    /**
     * @name columnSelectionModel
     * @type {RangeSelectionModel}
     * @summary The selection rectangles.
     * @desc Created as a new RangeSelectionModel upon instantiation by the {@link SelectionModel|constructor}.
     * @memberOf SelectionModel.prototype
     */
    this.columnSelectionModel = new RangeSelectionModel();

    this.setLastSelectionType('');
}

SelectionModel.prototype = {

    constructor: SelectionModel.prototype.constructor,

    /**
     * @type {boolean}
     * @memberOf SelectionModel.prototype
     */
    allRowsSelected: false,

    /**
     * @memberOf SelectionModel.prototype
     * @returns {*}
     */
    getLastSelection: function() {
        var sels = this.selections;
        var sel = sels[sels.length - 1];
        return sel;
    },

    /**
     * @memberOf SelectionModel.prototype
     * @returns {*}
     */
    getLastSelectionType: function() {
        return this.lastSelectionType;
    },

    /**
     * @param type
     * @memberOf SelectionModel.prototype
     */
    setLastSelectionType: function(type) {
        this.lastSelectionType = type;
    },

    /**
     * @memberOf SelectionModel.prototype
     * @description Select the region described by the given coordinates.
     *
     * @param {number} ox - origin x coordinate
     * @param {number} oy - origin y coordinate
     * @param {number} ex - extent x coordinate
     * @param {number} ey - extent y coordinate
     * @param {boolean} silent - whether to fire selection changed event
     */
    select: function(ox, oy, ex, ey, silent) {
        var newSelection = this.grid.newRectangle(ox, oy, ex, ey);
        newSelection.firstSelectedCell = this.grid.newPoint(ox, oy); //Cache the first selected cell before it gets normalized to top-left origin
        newSelection.lastSelectedCell = (
            (newSelection.firstSelectedCell.x === newSelection.origin.x && newSelection.firstSelectedCell.y === newSelection.origin.y)
            ?
                newSelection.corner
                :
                newSelection.origin
        );
        this.selections.push(newSelection);
        this.flattenedX.push(newSelection.flattenXAt(0));
        this.flattenedY.push(newSelection.flattenYAt(0));
        this.setLastSelectionType('cell');
        if (!silent) {this.grid.selectionChanged();}
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param {number} ox - origin x coordinate
     * @param {number} oy - origin y coordinate
     * @param {number} ex - extent x coordinate
     * @param {number} ey - extent y coordinate
     */
    toggleSelect: function(ox, oy, ex, ey) {

        var selected, index;

        selected = this.selections.find(function(selection, idx) {
            index = idx;
            return (
                selection.origin.x === ox && selection.origin.y === oy &&
                selection.extent.x === ex && selection.extent.y === ey
            );
        });

        if (selected) {
            this.selections.splice(index, 1);
            this.flattenedX.splice(index, 1);
            this.flattenedY.splice(index, 1);
            this.grid.selectionChanged();
        } else {
            this.select(ox, oy, ex, ey);
        }
    },

    /**
     * @memberOf SelectionModel.prototype
     * @desc Remove the last selection that was created.
     */
    clearMostRecentSelection: function(dontClearRowSelections) {
        dontClearRowSelections = dontClearRowSelections === true;
        if (!dontClearRowSelections) {
            this.setAllRowsSelected(false);
        }
        if (this.selections.length) { --this.selections.length; }
        if (this.flattenedX.length) { --this.flattenedX.length; }
        if (this.flattenedY.length) { --this.flattenedY.length; }
        //this.getGrid().selectionChanged();
    },

    /**
     * @memberOf SelectionModel.prototype
     */
    clearMostRecentColumnSelection: function() {
        this.columnSelectionModel.clearMostRecentSelection();
        this.setLastSelectionType('column');
    },

    /**
     * @memberOf SelectionModel.prototype
     */
    clearMostRecentRowSelection: function() {
        this.rowSelectionModel.clearMostRecentSelection();
        this.setLastSelectionType('row');
    },

    /**
     * @memberOf SelectionModel.prototype
     */
    clearRowSelection: function() {
        this.rowSelectionModel.clear();
        this.setLastSelectionType('row');
    },

    /**
     * @memberOf SelectionModel.prototype
     * @returns {*}
     */
    getSelections: function() {
        return this.selections;
    },

    /**
     * @memberOf SelectionModel.prototype
     * @returns {boolean} There are active selection(s).
     */
    hasSelections: function() {
        return this.selections.length !== 0;
    },

    /**
     * @memberOf SelectionModel.prototype
     * @returns {boolean}
     */
    hasRowSelections: function() {
        return !this.rowSelectionModel.isEmpty();
    },

    /**
     * @memberOf SelectionModel.prototype
     * @returns {boolean}
     */
    hasColumnSelections: function() {
        return !this.columnSelectionModel.isEmpty();
    },

    /**
     * @memberOf SelectionModel.prototype
     * @return {boolean} Selection covers a specific column.
     * @param {number} y
     */
    isCellSelectedInRow: function(y) {
        return this._isCellSelected(this.flattenedX, 0, y);
    },

    /**
     * @memberOf SelectionModel.prototype
     * @returns Selection covers a specific row.
     * @param {number} x
     */
    isCellSelectedInColumn: function(x) {
        return this._isCellSelected(this.flattenedY, x, 0);
    },

    /**
     * @memberOf SelectionModel.prototype
     * @summary Selection query function.
     * @returns {boolean} The given cell is selected (part of an active selection).
     * @param {Rectangle[]} selections - Selection rectangles to search through.
     * @param {number} x
     * @param {number} y
     */
    isSelected: function(x, y) {
        return (
            this.isColumnSelected(x) ||
            this.isRowSelected(y) ||
            this._isCellSelected(this.selections, x, y)
        );
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param x
     * @param y
     * @returns {*}
     */
    isCellSelected: function(x, y) {
        return this._isCellSelected(this.selections, x, y);
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param selections
     * @param x
     * @param y
     * @returns {boolean}
     * @private
     */
    _isCellSelected: function(selections, x, y) {
        var self = this;
        return !!selections.find(function(selection) {
            return self.rectangleContains(selection, x, y);
        });
    },

    /**
     * @memberOf SelectionModel.prototype
     * @desc empty out all our state
     *
     */
    clear: function(dontClearRowSelections) {
        dontClearRowSelections = dontClearRowSelections === true;
        this.selections.length = 0;
        this.flattenedX.length = 0;
        this.flattenedY.length = 0;
        this.columnSelectionModel.clear();
        if (!dontClearRowSelections) {
            this.setAllRowsSelected(false);
            this.rowSelectionModel.clear();
        }
        //this.getGrid().selectionChanged();
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param {number} ox - origin x coordinate
     * @param {number} oy - origin y coordinate
     * @param {number} ex - extent x coordinate
     * @param {number} ey - extent y coordinate
     * @returns {boolean}
     */
    isRectangleSelected: function(ox, oy, ex, ey) {
        return !!this.selections.find(function(selection) {
            return (
                selection.origin.x === ox && selection.origin.y === oy &&
                selection.extent.x === ex && selection.extent.y === ey
            );
        });
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param x
     * @returns {*}
     */
    isColumnSelected: function(x) {
        return this.columnSelectionModel.isSelected(x);
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param y
     * @returns {boolean|*}
     */
    isRowSelected: function(y) {
        return this.allRowsSelected || this.rowSelectionModel.isSelected(y);
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param x1
     * @param x2
     */
    selectColumn: function(x1, x2) {
        this.columnSelectionModel.select(x1, x2);
        this.setLastSelectionType('column');
    },

    /**
     * @memberOf SelectionModel.prototype
     */
    selectAllRows: function() {
        this.clear();
        this.setAllRowsSelected(true);
    },

    /**
     * @memberOf SelectionModel.prototype
     * @returns {boolean}
     */

    setAllRowsSelected: function(isIt) {
        this.allRowsSelected = isIt;
    },

    areAllRowsSelected: function() {
        return this.allRowsSelected;
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param y1
     * @param y2
     */
    selectRow: function(y1, y2) {
        this.rowSelectionModel.select(y1, y2);
        this.setLastSelectionType('row');
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param x1
     * @param x2
     */
    deselectColumn: function(x1, x2) {
        this.columnSelectionModel.deselect(x1, x2);
        this.setLastSelectionType('column');
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param y1
     * @param y2
     */
    deselectRow: function(y1, y2) {
        this.rowSelectionModel.deselect(y1, y2);
        this.setLastSelectionType('row');
    },

    /**
     * @memberOf SelectionModel.prototype
     * @returns {*}
     */
    getSelectedRows: function() {
        if (this.areAllRowsSelected()) {
            var headerRows = this.grid.getHeaderRowCount();
            var rowCount = this.grid.getRowCount() - headerRows;
            var result = new Array(rowCount);
            for (var i = 0; i < rowCount; i++) {
                result[i] = i + headerRows;
            }
            return result;
        }
        return this.rowSelectionModel.getSelections();
    },

    /**
     * @memberOf SelectionModel.prototype
     * @returns {*|Array.Array.number}
     */
    getSelectedColumns: function() {
        return this.columnSelectionModel.getSelections();
    },

    /**
     * @memberOf SelectionModel.prototype
     * @returns {boolean}
     */
     isColumnOrRowSelected: function() {
        return !this.columnSelectionModel.isEmpty() || !this.rowSelectionModel.isEmpty();
    },

    /**
     * @memberOf SelectionModel.prototype
     * @returns {Array}
     */
    getFlattenedYs: function() {
        var result = [];
        var set = {};
        this.selections.forEach(function(selection) {
            var top = selection.origin.y;
            var size = selection.extent.y + 1;
            for (var r = 0; r < size; r++) {
                var ti = r + top;
                if (!set[ti]) {
                    result.push(ti);
                    set[ti] = true;
                }
            }
        });
        result.sort(function(x, y) {
            return x - y;
        });
        return result;
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param offset
     */
    selectRowsFromCells: function(offset, dontClearRowSelections) {
        offset = offset || 0;
        dontClearRowSelections = dontClearRowSelections === true;

        var sm = this.rowSelectionModel;

        if (!dontClearRowSelections) {
            this.setAllRowsSelected(false);
            sm.clear();
        }

        this.selections.forEach(function(selection) {
            var top = selection.origin.y,
                extent = selection.extent.y;
            top += offset;
            sm.select(top, top + extent);
        });
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param offset
     */
    selectColumnsFromCells: function(offset) {
        offset = offset || 0;

        var sm = this.columnSelectionModel;
        sm.clear();

        this.selections.forEach(function(selection) {
            var left = selection.origin.x,
                extent = selection.extent.x;
            left += offset;
            sm.select(left, left + extent);
        });
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param x
     * @param y
     * @returns {*}
     */
    isInCurrentSelectionRectangle: function(x, y) {
        var last = this.selections[this.selections.length - 1];
        return last && this.rectangleContains(last, x, y);
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param rect
     * @param x
     * @param y
     * @returns {boolean}
     */
    rectangleContains: function(rect, x, y) { //TODO: explore why this works and contains on rectanglular does not
        var minX = rect.origin.x;
        var minY = rect.origin.y;
        var maxX = minX + rect.extent.x;
        var maxY = minY + rect.extent.y;

        if (rect.extent.x < 0) {
            minX = maxX;
            maxX = rect.origin.x;
        }

        if (rect.extent.y < 0) {
            minY = maxY;
            maxY = rect.origin.y;
        }

        var result =
            x >= minX &&
            y >= minY &&
            x <= maxX &&
            y <= maxY;

        return result;
    }
};

module.exports = SelectionModel;

},{"sparse-boolean-array":50}],117:[function(require,module,exports){
/* eslint-env browser */

'use strict';

/**
 *
 * @param {HTMLElement} [containingEl=document]
 * @param {string} [prefix='']
 * @param {string} [separator='']
 * @param {string} [suffix='']
 * @param {function} [transformer=multiLineTrim] - Function to transform each input control's text value.
 */
function copyAll(containingEl, prefix, separator, suffix, transformer) {
    var texts = [], lastTextEl, text;

    Array.prototype.forEach.call((containingEl || document).querySelectorAll(copyAll.selector), function(textEl) {
        text = (transformer || multiLineTrim)(textEl.value);
        if (text) { texts.push(text); }
        lastTextEl = textEl;
    });

    if (lastTextEl) {
        copy(lastTextEl, (prefix || '') + texts.join(separator || '') + (suffix || ''));
    }
}

/**
 * 1. Trim the text in the given input element
 * 2. select it
 * 3. copy it to the clipboard
 * 4. deselect it
 * 5. return it
 * @param {HTMLElement|HTMLTextAreaElement} el
 * @param {string} [text=el.value] - Text to copy.
 * @returns {undefined|string} Trimmed text in element or undefined if unable to copy.
 */
function copy(el, text) {
    var result, textWas;

    if (text) {
        textWas = el.value;
        el.value = text;
    } else {
        text = el.value;
    }

    el.value = multiLineTrim(text);

    try {
        el.select();
        result = document.execCommand('copy');
    } catch (err) {
        result = false;
    } finally {
        if (textWas !== undefined) {
            el.value = textWas;
        }
        el.blur();
    }
    return result;
}

function multiLineTrim(s) {
    return s.replace(/^\s*(.*?)\s*$/, '$1');
}

copy.all = copyAll;
copy.multiLineTrim = multiLineTrim;
copy.selectorTextControls = 'input:not([type]), input[type=text], textarea';

module.exports = copy;

},{}],118:[function(require,module,exports){
'use strict';

// console.warn polyfill as needed
// used for deprecation warnings
if (!console.warn) {
    console.warn = function() {
        console.log.apply(console, ['WARNING:'].concat(Array.prototype.slice.call(arguments)));
    };
}

var warned = {};

var regexIsMethod = /\)$/;

/**
 * User is warned and new property is returned or new method is called and the result is returned.
 * @param {string} methodName - Deprecated method name with parentheses (required) containing argument list (optional).
 * @param {string} dotProps - Dot-separated new property name to invoke or method name to call. Method names are indicated by including parentheses with optional argument list. The arguments in each list are drawn from the arguments presented in the `methodName` parameter.
 * @param {string} since - Version in which the name was deprecated.
 * @param {Arguments|Array} [args] - Actual arguments. Only needed when arguments are listed in `methodName`. The order of the arguments must match.
 * @param {string} [notes] - Notes to add to message.
 * @returns {*} Return value of new property or method call.
 */
var deprecated = function(methodName, dotProps, since, args, notes) {
    if (!regexIsMethod.test(methodName)) {
        throw 'Expected method name to have parentheses.';
    }

    if (typeof args === 'string') {
        // `args` omitted
        notes = args;
        args = undefined;
    }

    var chain = dotProps.split('.'),
        formalArgList = argList(methodName),
        result = this;

    if (!(methodName in warned)) {
        warned[methodName] = deprecated.warnings;
    }
    if (warned[methodName]) {
        var memberType = regexIsMethod.test(dotProps) ? 'method' : 'property';
        var warning = 'The .' + methodName + ' method is deprecated as of v' + since +
            ' in favor of the .' + chain.join('.') + ' ' + memberType + '.' +
            ' (Will be removed in a future release.)';

        if (notes) {
            warning += ' ' + notes;
        }

        console.warn(warning);

        --warned[methodName];
    }

    function mapToFormalArg(argName) {
        var index = formalArgList.indexOf(argName);
        if (index === -1) {
            throw 'Actual arg "' + argName + '" not found in formal arg list ' + formalArgList;
        }
        return args[index];
    }

    for (var i = 0, last = chain.length - 1; i <= last; ++i) {
        var link = chain[i],
            actualArgList = regexIsMethod.test(link) ? argList(link) : undefined,
            actualArgs = [];

        if (actualArgList) {
            actualArgs = actualArgList.map(mapToFormalArg);
            link = link.match(/(\w+)/)[1];
            result = result[link].apply(result, actualArgs);
        } else {
            result = result[link];
        }
    }

    return result;
};

deprecated.warnings = 5; // just enough to be annoying

function argList(s) {
    return s.match(/^\w+\((.*)\)$/)[1].match(/(\w+)/g);
}

module.exports = deprecated;

},{}],119:[function(require,module,exports){
/* eslint-env browser */

/** @module effects */

/** @typedef {function} effectFunction
 * @desc Element to perform transitions upon is `options.el` if defined or `this.el`.
 * @param {object} [options]
 * @param {HTMLElement} [options.el=this.el]
 * @param {function} [options.callback] Function to call at conclusion of transitions.
 * @param {string} [options.duration='0.065s'] - Duration of each transition.
 * @param {object} [options.styles=defaultGlowerStyles] - Hash of CSS styles and values to transition. (For {@link effects~glower|glower} only.
 */

'use strict';

/**
 * Shake element back and fourth a few times as if to say, "Nope!"
 * @type {effectFunction}
 * @memberOf module:effects
 */
exports.shaker = function(options) {
    options = options || {};
    var context = this,
        el = options.el || context.el,
        duration = options.duration || '0.065s',
        computedStyle = window.getComputedStyle(el),
        transitions = computedStyle.transition.split(','),
        position = computedStyle.position,
        x = parseInt(computedStyle.left),
        dx = -3,
        shakes = 6;

    transitions.push('left ' + duration);
    el.style.transition = transitions.join(',');
    el.addEventListener('transitionend', shaker);
    shaker();
    function shaker(event) {
        if (!event || event.propertyName === 'left') {
            el.style.left = x + dx + 'px';
            if (!shakes--) {
                el.removeEventListener('transitionend', shaker);
                transitions.pop();
                el.style.transition = transitions.join(',');
                el.style.position = position;
                if (options.callback) {
                    options.callback.call(context, options);
                }
            }
            dx = shakes ? -dx : 0;
        }
    }
};

var defaultGlowerStyles = {
    'background-color': 'yellow',
    'box-shadow': '0 0 10px red'
};

/**
 * Transition styles on element for a moment and revert as if to say, "Whoa!."
 * @type {effectFunction}
 * @memberOf module:effects
 */
exports.glower = function(options) {
    options = options || {};
    var context = this,
        el = options.el || context.el,
        duration = options.duration || '0.25s',
        styles = options.styles || defaultGlowerStyles,
        values = styles.length,
        computedStyle = window.getComputedStyle(el),
        styleWas = {},
        transition = computedStyle.transition,
        transitions = transition.split(',');

    Object.keys(styles).forEach(function(style) {
        styleWas[style] = {
            style: computedStyle[style],
            undo: true
        };
        transitions.push(style + ' ' + duration);
    });

    el.style.transition = transitions.join(',');
    el.addEventListener('transitionend', glower);
    Object.keys(styles).forEach(function(style) {
        el.style[style] = styles[style];
    });

    function glower(event) {
        var was = styleWas[event.propertyName];
        if (was.undo) {
            el.style[event.propertyName] = was.style;
            was.undo = false;
        } else if (!--values) {
            el.removeEventListener('transitionend', glower);
            el.style.transition = transition;
            if (options.callback) {
                options.callback.call(context, options);
            }
        }
    }
};

},{}],120:[function(require,module,exports){
/* eslint-env browser */

'use strict';

module.exports.each = function(selector, iteratee, context) {
    return Array.prototype.forEach.call((context || document).querySelectorAll(selector), iteratee);
};

module.exports.find = function(selector, iteratee, context) {
    return Array.prototype.find.call((context || document).querySelectorAll(selector), iteratee);
};

},{}],121:[function(require,module,exports){
/* eslint-env browser */

'use strict';

var HTTP_STATE_DONE = 4,
    HTTP_STATUS_OK = 200;

module.exports.get = function(url, callback) {
    var httpRequest = new XMLHttpRequest();

    httpRequest.open('GET', url, true);

    httpRequest.onreadystatechange = function() {
        if (
            httpRequest.readyState === HTTP_STATE_DONE &&
            httpRequest.status === HTTP_STATUS_OK
        ) {
            callback(JSON.parse(httpRequest.responseText));
        }
    };

    httpRequest.send(null);
};

},{}],122:[function(require,module,exports){
'use strict';

Math.sign = Math.sign || function(x) {
    x = +x; // convert to a number
    if (x === 0 || isNaN(x)) {
        return x;
    }
    return x > 0 ? 1 : -1;
};

},{}],123:[function(require,module,exports){
'use strict';

function Queueless(element, context) {
    this.element = element;
    this.context = context;
    this.transitioning = false;
}

Queueless.prototype.begin = function(callback) {
    var self = this;

    this.transitioning = true;

    this.element.addEventListener('transitionend', function end(transEvent) {
        self.element.removeEventListener('transitionend', end);

        if (callback) {
            callback.call(this, transEvent, self);
        }

        self.transitioning = false;
    });
};

module.exports = Queueless;

},{}],124:[function(require,module,exports){
/* eslint-env browser */

'use strict';

var automat = require('automat');

var css = require('../../css');

// note the position of the  first "natural" stylesheet. We will insert our stylesheets before this node.
var head = document.querySelector('head');
var refNode = Array.prototype.slice.call(head.children).find(function(child) {
    return child.tagName === 'STYLE' ||
        child.tagName === 'LINK' &&
        child.getAttribute('rel') === 'stylesheet' &&
        child.getAttribute('type') === 'text/css';
});

exports.prefix = 'injected-stylesheet-';

exports.inject = function(id, replacements) {
    var stylesheet = document.querySelector('#' + this.prefix + id);

    if (!stylesheet) {
        stylesheet = css[id];
        stylesheet = '<style>\n' + stylesheet + '\n</style>\n';
        var args = [stylesheet, head, refNode].concat(Array.prototype.slice.call(arguments, 1));
        stylesheet = automat.append.apply(null, args)[0];
        stylesheet.id = this.prefix + id;
    }

    return stylesheet;
};

},{"../../css":1,"automat":5}]},{},[92])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcGFjay9fcHJlbHVkZS5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvY3NzL2luZGV4LmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9odG1sL2luZGV4LmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9pbWFnZXMvaW1hZ2VzLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9pbWFnZXMvaW5kZXguanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL25vZGVfbW9kdWxlcy9hdXRvbWF0L2luZGV4LmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvY3NzLWluamVjdG9yL2luZGV4LmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvZXh0ZW5kLW1lL2luZGV4LmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvZmlsdGVyLXRyZWUvaHRtbC9pbmRleC5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvbm9kZV9tb2R1bGVzL2ZpbHRlci10cmVlL2luZGV4LmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvZmlsdGVyLXRyZWUvanMvQ29uZGl0aW9uYWxzLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvZmlsdGVyLXRyZWUvanMvRmlsdGVyTGVhZi5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvbm9kZV9tb2R1bGVzL2ZpbHRlci10cmVlL2pzL0ZpbHRlck5vZGUuanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL25vZGVfbW9kdWxlcy9maWx0ZXItdHJlZS9qcy9GaWx0ZXJUcmVlLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvZmlsdGVyLXRyZWUvanMvVGVtcGxhdGVzLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvZmlsdGVyLXRyZWUvanMvZXh0ZW5zaW9ucy9jb2x1bW5zLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvZmlsdGVyLXRyZWUvanMvcGFyc2VyLVNRTC5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvbm9kZV9tb2R1bGVzL2ZpbHRlci10cmVlL2pzL3N0eWxlc2hlZXQuanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL25vZGVfbW9kdWxlcy9maWx0ZXItdHJlZS9qcy90cmVlLW9wZXJhdG9ycy5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvbm9kZV9tb2R1bGVzL2ZpbmJhcnMvaW5kZXguanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL25vZGVfbW9kdWxlcy9maW5jYW52YXMvaW5kZXguanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL25vZGVfbW9kdWxlcy9maW5jYW52YXMvanMvR3JhcGhpY3NDb250ZXh0LmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvZmluY2FudmFzL2pzL2djLWNvbnNvbGUtbG9nZ2VyLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvZmluY2FudmFzL2pzL3BvbHltZXJnZXN0dXJlcy5kZXYuanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL25vZGVfbW9kdWxlcy9oeXBlci1hbmFseXRpY3MvZ2VuZXJhdGVTYW1wbGVEYXRhLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvaHlwZXItYW5hbHl0aWNzL2luZGV4LmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvaHlwZXItYW5hbHl0aWNzL2pzL0Jhc2UuanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL25vZGVfbW9kdWxlcy9oeXBlci1hbmFseXRpY3MvanMvRGF0YU5vZGVCYXNlLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvaHlwZXItYW5hbHl0aWNzL2pzL0RhdGFOb2RlR3JvdXAuanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL25vZGVfbW9kdWxlcy9oeXBlci1hbmFseXRpY3MvanMvRGF0YU5vZGVHcm91cFNvcnRlci5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvbm9kZV9tb2R1bGVzL2h5cGVyLWFuYWx5dGljcy9qcy9EYXRhTm9kZUxlYWYuanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL25vZGVfbW9kdWxlcy9oeXBlci1hbmFseXRpY3MvanMvRGF0YU5vZGVUcmVlLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvaHlwZXItYW5hbHl0aWNzL2pzL0RhdGFTb3VyY2UuanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL25vZGVfbW9kdWxlcy9oeXBlci1hbmFseXRpY3MvanMvRGF0YVNvdXJjZUFnZ3JlZ2F0b3IuanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL25vZGVfbW9kdWxlcy9oeXBlci1hbmFseXRpY3MvanMvRGF0YVNvdXJjZUdsb2JhbEZpbHRlci5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvbm9kZV9tb2R1bGVzL2h5cGVyLWFuYWx5dGljcy9qcy9EYXRhU291cmNlSW5kZXhlZC5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvbm9kZV9tb2R1bGVzL2h5cGVyLWFuYWx5dGljcy9qcy9EYXRhU291cmNlU29ydGVyLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvaHlwZXItYW5hbHl0aWNzL2pzL0RhdGFTb3VyY2VTb3J0ZXJDb21wb3NpdGUuanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL25vZGVfbW9kdWxlcy9oeXBlci1hbmFseXRpY3MvanMvRGF0YVNvdXJjZVRyZWV2aWV3LmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvaHlwZXItYW5hbHl0aWNzL2pzL3V0aWwvTWFwcHkuanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL25vZGVfbW9kdWxlcy9oeXBlci1hbmFseXRpY3MvanMvdXRpbC9hZ2dyZWdhdGlvbnMuanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL25vZGVfbW9kdWxlcy9oeXBlci1hbmFseXRpY3MvanMvdXRpbC9oZWFkZXJpZnkuanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL25vZGVfbW9kdWxlcy9oeXBlci1hbmFseXRpY3MvanMvdXRpbC9zdGFibGVTb3J0LmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvbGlzdC1kcmFnb24vaW5kZXguanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL25vZGVfbW9kdWxlcy9scnUtY2FjaGUvbGliL2xydS1jYWNoZS5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvbm9kZV9tb2R1bGVzL211c3RhY2hlL211c3RhY2hlLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvb2JqZWN0LWl0ZXJhdG9ycy9pbmRleC5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvbm9kZV9tb2R1bGVzL3BvcC1tZW51L2luZGV4LmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvcmVjdGFuZ3VsYXIvaW5kZXguanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL25vZGVfbW9kdWxlcy9yZWdleHAtbGlrZS9pbmRleC5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvbm9kZV9tb2R1bGVzL3NwYXJzZS1ib29sZWFuLWFycmF5L2luZGV4LmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvdGFiei9pbmRleC5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvbm9kZV9tb2R1bGVzL3RlbXBsZXgvaW5kZXguanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL25vZGVfbW9kdWxlcy91bnN0cnVuZ2lmeS9pbmRleC5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvc3JjL0h5cGVyZ3JpZC5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvc3JjL1NoYXJlZC5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvc3JjL2JlaGF2aW9ycy9CZWhhdmlvci5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvc3JjL2JlaGF2aW9ycy9Db2x1bW4uanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL3NyYy9iZWhhdmlvcnMvSlNPTi5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvc3JjL2JlaGF2aW9ycy9Mb2NhbC5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvc3JjL2JlaGF2aW9ycy9OdWxsLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9zcmMvYmVoYXZpb3JzL2luZGV4LmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9zcmMvY2VsbEVkaXRvcnMvQ2VsbEVkaXRvci5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvc3JjL2NlbGxFZGl0b3JzL0NvbG9yLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9zcmMvY2VsbEVkaXRvcnMvQ29tYm9Cb3guanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL3NyYy9jZWxsRWRpdG9ycy9EYXRlLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9zcmMvY2VsbEVkaXRvcnMvRmlsdGVyQm94LmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9zcmMvY2VsbEVkaXRvcnMvTnVtYmVyLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9zcmMvY2VsbEVkaXRvcnMvU2xpZGVyLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9zcmMvY2VsbEVkaXRvcnMvU3Bpbm5lci5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvc3JjL2NlbGxFZGl0b3JzL1RleHRmaWVsZC5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvc3JjL2NlbGxFZGl0b3JzL2luZGV4LmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9zcmMvY2VsbFJlbmRlcmVycy9CdXR0b24uanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL3NyYy9jZWxsUmVuZGVyZXJzL0NlbGxSZW5kZXJlci5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvc3JjL2NlbGxSZW5kZXJlcnMvRXJyb3JDZWxsLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9zcmMvY2VsbFJlbmRlcmVycy9MYXN0U2VsZWN0aW9uLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9zcmMvY2VsbFJlbmRlcmVycy9TaW1wbGVDZWxsLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9zcmMvY2VsbFJlbmRlcmVycy9TbGlkZXJDZWxsLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9zcmMvY2VsbFJlbmRlcmVycy9TcGFya0Jhci5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvc3JjL2NlbGxSZW5kZXJlcnMvU3BhcmtMaW5lLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9zcmMvY2VsbFJlbmRlcmVycy9UcmVlQ2VsbC5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvc3JjL2NlbGxSZW5kZXJlcnMvaW5kZXguanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL3NyYy9kYXRhTW9kZWxzL0RhdGFNb2RlbC5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvc3JjL2RhdGFNb2RlbHMvRGVmYXVsdC5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvc3JjL2RhdGFNb2RlbHMvSW5NZW1vcnkuanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL3NyYy9kYXRhTW9kZWxzL0pTT04uanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL3NyYy9kYXRhTW9kZWxzL2luZGV4LmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9zcmMvZGVmYXVsdHMuanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL3NyYy9kaWFsb2dzL0NvbHVtblBpY2tlci5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvc3JjL2RpYWxvZ3MvRGlhbG9nLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9zcmMvZGlhbG9ncy9NYW5hZ2VGaWx0ZXJzLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9zcmMvZGlhbG9ncy9pbmRleC5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvc3JjL2Zha2VfY2E1YmI5ODguanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL3NyYy9mZWF0dXJlcy9DZWxsQ2xpY2suanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL3NyYy9mZWF0dXJlcy9DZWxsRWRpdGluZy5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvc3JjL2ZlYXR1cmVzL0NlbGxTZWxlY3Rpb24uanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL3NyYy9mZWF0dXJlcy9Db2x1bW5BdXRvc2l6aW5nLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9zcmMvZmVhdHVyZXMvQ29sdW1uTW92aW5nLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9zcmMvZmVhdHVyZXMvQ29sdW1uUGlja2VyLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9zcmMvZmVhdHVyZXMvQ29sdW1uUmVzaXppbmcuanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL3NyYy9mZWF0dXJlcy9Db2x1bW5TZWxlY3Rpb24uanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL3NyYy9mZWF0dXJlcy9Db2x1bW5Tb3J0aW5nLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9zcmMvZmVhdHVyZXMvRmVhdHVyZS5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvc3JjL2ZlYXR1cmVzL0ZpbHRlcnMuanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL3NyYy9mZWF0dXJlcy9LZXlQYWdpbmcuanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL3NyYy9mZWF0dXJlcy9PbkhvdmVyLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9zcmMvZmVhdHVyZXMvUm93UmVzaXppbmcuanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL3NyYy9mZWF0dXJlcy9Sb3dTZWxlY3Rpb24uanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL3NyYy9mZWF0dXJlcy9UaHVtYndoZWVsU2Nyb2xsaW5nLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9zcmMvZmVhdHVyZXMvaW5kZXguanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL3NyYy9maWx0ZXIvQ29sdW1uU2NoZW1hRmFjdG9yeS5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvc3JjL2ZpbHRlci9EZWZhdWx0RmlsdGVyLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9zcmMvZmlsdGVyL3BhcnNlci1DUUwuanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL3NyYy9saWIvQmFzZS5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvc3JjL2xpYi9Mb2NhbGl6YXRpb24uanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL3NyYy9saWIvUmVuZGVyZXIuanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL3NyYy9saWIvU2VsZWN0aW9uTW9kZWwuanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL3NyYy9saWIvY29weS1pbnB1dC5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvc3JjL2xpYi9kZXByZWNhdGVkLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9zcmMvbGliL2VmZmVjdHMuanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL3NyYy9saWIvZWxmb3IuanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL3NyYy9saWIvanNvbi5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvc3JjL2xpYi9wb2x5ZmlsbHMuanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL3NyYy9saWIvcXVldWVsZXNzLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9zcmMvbGliL3N0eWxlc2hlZXQuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3V0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcFVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNWdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9OQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2wxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4ckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9LQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeGxCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5VEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbm5CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hpQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMTZHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xvREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMVJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNWNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0UUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1WUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDLzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2p5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdk5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVpQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5cUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN2lCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDelNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpfXZhciBmPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChmLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGYsZi5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuZ3JpZCA9IFtcbicuaHlwZXJncmlkLWlucHV0IHsnLFxuJ1x0cG9zaXRpb246IGFic29sdXRlOycsXG4nXHRkaXNwbGF5OiBub25lOycsXG4nXHRvdXRsaW5lOiAwOycsXG4nXHRwYWRkaW5nOiAwOycsXG4nXHRib3JkZXI6IHNvbGlkIDJweCBibGFjazsnLFxuJ1x0Ym94LXNpemluZzogYm9yZGVyLWJveDsnLFxuJ1x0Ym94LXNoYWRvdzogd2hpdGUgMCAwIDFweCAxcHg7JyxcbidcdGJhY2tncm91bmQtY29sb3I6IGl2b3J5OycsXG4nXHRjb2xvcjogYmxhY2s7JyxcbidcdGZvbnQtc2l6ZTogN3B0OycsXG4nXHRsaW5lLS1oZWlnaHQ6IDA7Jyxcbid9JyxcbidkaXYuaHlwZXJncmlkLWlucHV0ID4gaW5wdXQgeycsXG4nXHRwb3NpdGlvbjogYWJzb2x1dGU7JyxcbidcdGhlaWdodDogMTAwJTsnLFxuJ1x0cmlnaHQ6IDIwcHg7JyxcbidcdGxlZnQ6IDA7JyxcbidcdHdpZHRoOiAxMDAlOycsXG4nXHRvdXRsaW5lOiAwOycsXG4nXHRwYWRkaW5nOiAwOycsXG4nJyxcbidcdGJvcmRlcjogNXB4IHNvbGlkIHRyYW5zcGFyZW50OycsXG4nXHRib3JkZXItcmlnaHQtd2lkdGg6IDIwcHg7JyxcbidcdGJvcmRlci1ib3R0b20td2lkdGg6IDA7JyxcbidcdGJvcmRlci10b3Atd2lkdGg6IDA7JyxcbidcdGJveC1zaXppbmc6IGJvcmRlci1ib3g7JyxcbicnLFxuJ1x0Zm9udC1zaXplOiA3cHQ7JyxcbidcdGxpbmUtLWhlaWdodDogMDsnLFxuJ1x0Y29sb3I6IGJsYWNrOycsXG4nXHRiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDsnLFxuJ30nLFxuJ2Rpdi5oeXBlcmdyaWQtaW5wdXQgPiBzcGFuIHsnLFxuJ1x0cG9zaXRpb246IGFic29sdXRlOycsXG4nXHRib3gtc2l6aW5nOiBib3JkZXItYm94OycsXG4nXHR3aWR0aDogMjBweDsnLFxuJ1x0aGVpZ2h0OiAxMDAlOycsXG4nXHRyaWdodDogMDsnLFxuJ1x0dGV4dC1hbGlnbjogY2VudGVyOycsXG4nXHRmb250LXNpemU6IDE1cHg7JyxcbidcdGxpbmUtaGVpZ2h0OiAxMXB4OycsXG4nfScsXG4nZGl2Lmh5cGVyZ3JpZC1pbnB1dCBzcGFuW3RpdGxlXSB7JyxcbidcdGNvbG9yOiBsaWdodGdyZXk7JyxcbidcdGN1cnNvcjogcG9pbnRlcjsnLFxuJ30nLFxuJ2Rpdi5oeXBlcmdyaWQtaW5wdXQgc3Bhblt0aXRsZV06aG92ZXIgeycsXG4nXHRjb2xvcjogZ3JleTsnLFxuJ30nLFxuJ2Rpdi5oeXBlcmdyaWQtaW5wdXQgc3Bhblt0aXRsZV06YWN0aXZlLCBkaXYuaHlwZXJncmlkLWlucHV0IHNwYW5bdGl0bGVdLmFjdGl2ZSB7JyxcbidcdGNvbG9yOiBibHVlOycsXG4nfScsXG4nZGl2Lmh5cGVyZ3JpZC1pbnB1dCA+IHNwYW46OmFmdGVyIHsnLFxuJ1x0Y29udGVudDogXFwnXFxcXDI1QkVcXCc7JyxcbidcdGZvbnQtc2l6ZTogMjBweDsnLFxuJ30nLFxuJ2Rpdi5oeXBlcmdyaWQtaW5wdXQgPiBkaXYgeycsXG4nXHRwb3NpdGlvbjogYWJzb2x1dGU7JyxcbidcdGhlaWdodDogMTM3cHg7JyxcbidcdGxlZnQ6IC0ycHg7JyxcbidcdHJpZ2h0OiAtMnB4OycsXG4nXHR0b3A6IDEzcHg7JyxcbidcdGhlaWdodDogMDsnLFxuJ1x0dHJhbnNpdGlvbjogaGVpZ2h0IC4yNXM7JyxcbidcdHZpc2liaWxpdHk6IGhpZGRlbjsnLFxuJ1x0Ym94LXNoYWRvdzogd2hpdGUgMCAwIDFweCAxcHg7JyxcbidcdGJveC1zaXppbmc6IGJvcmRlci1ib3g7JyxcbidcdGJvcmRlcjogMnB4IHNvbGlkIGJsYWNrOycsXG4nXHRiYWNrZ3JvdW5kLWNvbG9yOiBpdm9yeTsnLFxuJ1x0LXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTsnLFxuJ1x0LW1vei11c2VyLXNlbGVjdDogbm9uZTsnLFxuJ1x0LW1zLXVzZXItc2VsZWN0OiBub25lOycsXG4nfScsXG4nZGl2Lmh5cGVyZ3JpZC1pbnB1dCA+IGRpdiA+IGRpdiB7JyxcbidcdHBvc2l0aW9uOiBhYnNvbHV0ZTsnLFxuJ1x0aGVpZ2h0OiAxM3B4OycsXG4nXHR3aWR0aDogMTAwJTsnLFxuJ1x0dGV4dC1hbGlnbjogY2VudGVyOycsXG4nfScsXG4nZGl2Lmh5cGVyZ3JpZC1pbnB1dCA+IGRpdiBzcGFuW3RpdGxlXSB7JyxcbidcdGZvbnQtd2VpZ2h0OiBib2xkOycsXG4nXHRmb250LXNpemU6IDEwcHg7JyxcbidcdGZvbnQtZmFtaWx5OiB2ZXJkYW5hLCBnZW5ldmEsIHNhbnMtc2VyaWY7JyxcbidcdG1hcmdpbi1sZWZ0OiA2cHg7JyxcbidcdG1hcmdpbi1yaWdodDogNnB4OycsXG4nfScsXG4nZGl2Lmh5cGVyZ3JpZC1pbnB1dCA+IGRpdiBzcGFuOm5vdChbdGl0bGVdKSB7JyxcbidcdGZvbnQtc3R5bGU6IGl0YWxpYzsnLFxuJ1x0cGFkZGluZy10b3A6IDFweDsnLFxuJ30nLFxuJ2Rpdi5oeXBlcmdyaWQtaW5wdXQgPiBkaXYgc2VsZWN0IHsnLFxuJ1x0cG9zaXRpb246IGFic29sdXRlOycsXG4nXHRib3JkZXI6IDA7JyxcbidcdG91dGxpbmU6IDA7JyxcbidcdGJvcmRlci10b3A6IDJweCBzb2xpZCBibGFjazsnLFxuJ1x0d2lkdGg6IDEwMCU7JyxcbidcdGJvdHRvbTogMDsnLFxuJ1x0dG9wOjE0cHg7JyxcbidcdGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50OycsXG4nfSdcbl0uam9pbignXFxuJyk7XG5cbmV4cG9ydHNbJ2xpc3QtZHJhZ29uLWFkZGVuZHVtJ10gPSBbXG4nZGl2LmRyYWdvbi1saXN0LCBsaS5kcmFnb24tcG9wIHsnLFxuJ1x0Zm9udC1mYW1pbHk6IFJvYm90bywgc2Fucy1zZXJpZjsnLFxuJ1x0dGV4dC10cmFuc2Zvcm06IGNhcGl0YWxpemU7IH0nLFxuJ2Rpdi5kcmFnb24tbGlzdCB7JyxcbidcdHBvc2l0aW9uOiBhYnNvbHV0ZTsnLFxuJ1x0dG9wOiA0JTsnLFxuJ1x0bGVmdDogNCU7JyxcbidcdGhlaWdodDogOTIlOycsXG4nXHR3aWR0aDogMjAlOyB9JyxcbidkaXYuZHJhZ29uLWxpc3Q6bnRoLWNoaWxkKDIpIHsgbGVmdDogMjglOyB9JyxcbidkaXYuZHJhZ29uLWxpc3Q6bnRoLWNoaWxkKDMpIHsgbGVmdDogNTIlOyB9JyxcbidkaXYuZHJhZ29uLWxpc3Q6bnRoLWNoaWxkKDQpIHsgbGVmdDogNzYlOyB9JyxcbidkaXYuZHJhZ29uLWxpc3QgPiBkaXYsIGRpdi5kcmFnb24tbGlzdCA+IHVsID4gbGksIGxpLmRyYWdvbi1wb3AgeyBsaW5lLWhlaWdodDogNDZweDsgfScsXG4nZGl2LmRyYWdvbi1saXN0ID4gdWwgeyB0b3A6IDQ2cHg7IH0nLFxuJ2Rpdi5kcmFnb24tbGlzdCA+IHVsID4gbGk6bm90KDpsYXN0LWNoaWxkKTo6YmVmb3JlLCBsaS5kcmFnb24tcG9wOjpiZWZvcmUgeycsXG4nXHRjb250ZW50OiBcXCdcXFxcMmIyNFxcJzsnLFxuJ1x0Y29sb3I6ICNiNmI2YjY7JyxcbidcdGZvbnQtc2l6ZTogMzBweDsnLFxuJ1x0bWFyZ2luOiA4cHggMTRweCA4cHggOHB4OyB9JyxcbidsaS5kcmFnb24tcG9wIHsgb3BhY2l0eTouODsgfSdcbl0uam9pbignXFxuJyk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuQ1FMID0gW1xuJzxsaT4nLFxuJ1x0PGxhYmVsIHRpdGxlPVwiJHsxfVwiPicsXG4nXHRcdDxhIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImZpbHRlci1jb3B5XCI+PC9hPicsXG4nXHRcdDxkaXYgY2xhc3M9XCJmaWx0ZXItdHJlZS1yZW1vdmUtYnV0dG9uXCIgdGl0bGU9XCJkZWxldGUgY29uZGl0aW9uYWxcIj48L2Rpdj4nLFxuJ1x0XHQ8c3Ryb25nPiV7MH06PC9zdHJvbmc+JyxcbidcdFx0PGlucHV0IG5hbWU9XCIkezF9XCIgY2xhc3M9XCJmaWx0ZXItdGV4dC1ib3ggJHszfVwiIHZhbHVlPVwiJXsyfVwiPicsXG4nXHQ8L2xhYmVsPicsXG4nXHQ8ZGl2IGNsYXNzPVwiZmlsdGVyLXRyZWUtd2FyblwiPjwvZGl2PicsXG4nPC9saT4nXG5dLmpvaW4oJ1xcbicpO1xuXG5leHBvcnRzLlNRTCA9IFtcbic8bGk+JyxcbidcdDxsYWJlbCB0aXRsZT1cIiR7MX1cIj4nLFxuJ1x0XHQ8YSB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJmaWx0ZXItY29weVwiPjwvYT4nLFxuJ1x0XHQ8ZGl2IGNsYXNzPVwiZmlsdGVyLXRyZWUtcmVtb3ZlLWJ1dHRvblwiIHRpdGxlPVwiZGVsZXRlIGNvbmRpdGlvbmFsXCI+PC9kaXY+JyxcbidcdFx0PHN0cm9uZz4lezB9Ojwvc3Ryb25nPicsXG4nXHRcdDx0ZXh0YXJlYSBuYW1lPVwiJHsxfVwiIHJvd3M9XCIxXCIgY2xhc3M9XCJmaWx0ZXItdGV4dC1ib3ggJHszfVwiPiV7Mn08L3RleHRhcmVhPicsXG4nXHQ8L2xhYmVsPicsXG4nXHQ8ZGl2IGNsYXNzPVwiZmlsdGVyLXRyZWUtd2FyblwiPjwvZGl2PicsXG4nPC9saT4nXG5dLmpvaW4oJ1xcbicpO1xuXG5leHBvcnRzLmRpYWxvZyA9IFtcbic8ZGl2IGlkPVwiaHlwZXJncmlkLWRpYWxvZ1wiPicsXG4nJyxcbidcdDxzdHlsZT4nLFxuJ1x0XHQjaHlwZXJncmlkLWRpYWxvZyB7JyxcbidcdFx0XHRwb3NpdGlvbjogYWJzb2x1dGU7JyxcbidcdFx0XHR0b3A6IDA7JyxcbidcdFx0XHRsZWZ0OiAwOycsXG4nXHRcdFx0Ym90dG9tOiAwOycsXG4nXHRcdFx0cmlnaHQ6IDA7JyxcbidcdFx0XHRiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZTsnLFxuJ1x0XHRcdGZvbnQ6IDEwcHQgc2Fucy1zZXJpZjsnLFxuJ1x0XHRcdG9wYWNpdHk6IDA7JyxcbidcdFx0XHR0cmFuc2l0aW9uOiBvcGFjaXR5IDFzOycsXG4nXHRcdFx0Ym94LXNoYWRvdzogcmdiYSgwLCAwLCAwLCAwLjI5ODAzOSkgMHB4IDE5cHggMzhweCwgcmdiYSgwLCAwLCAwLCAwLjIxOTYwOCkgMHB4IDE1cHggMTJweDsnLFxuJ1x0XHR9JyxcbidcdFx0I2h5cGVyZ3JpZC1kaWFsb2cuaHlwZXJncmlkLWRpYWxvZy12aXNpYmxlIHsnLFxuJ1x0XHRcdG9wYWNpdHk6IDE7JyxcbidcdFx0XHR0cmFuc2l0aW9uOiBvcGFjaXR5IDFzOycsXG4nXHRcdH0nLFxuJycsXG4nXHRcdCNoeXBlcmdyaWQtZGlhbG9nIC5oeXBlcmdyaWQtZGlhbG9nLWNvbnRyb2wtcGFuZWwgeycsXG4nXHRcdFx0cG9zaXRpb246IGFic29sdXRlOycsXG4nXHRcdFx0dG9wOiAwcHg7JyxcbidcdFx0XHRyaWdodDogMTJweDsnLFxuJ1x0XHR9JyxcbidcdFx0I2h5cGVyZ3JpZC1kaWFsb2cgLmh5cGVyZ3JpZC1kaWFsb2ctY29udHJvbC1wYW5lbCBhIHsnLFxuJ1x0XHRcdGNvbG9yOiAjOTk5OycsXG4nXHRcdFx0Zm9udC1zaXplOiAzM3B4OycsXG4nXHRcdFx0dHJhbnNpdGlvbjogdGV4dC1zaGFkb3cgLjM1cywgY29sb3IgLjM1czsnLFxuJ1x0XHRcdHRleHQtZGVjb3JhdGlvbjogbm9uZTsnLFxuJ1x0XHR9JyxcbidcdFx0I2h5cGVyZ3JpZC1kaWFsb2cgLmh5cGVyZ3JpZC1kaWFsb2ctY2xvc2U6YWZ0ZXIgeycsXG4nXHRcdFx0Y29udGVudDogXFwnXFxcXEQ3XFwnOycsXG4nXHRcdH0nLFxuJ1x0XHQjaHlwZXJncmlkLWRpYWxvZyAuaHlwZXJncmlkLWRpYWxvZy1zZXR0aW5nczphZnRlciB7JyxcbidcdFx0XHRmb250LWZhbWlseTogQXBwbGUgU3ltYm9sczsnLFxuJ1x0XHRcdGNvbnRlbnQ6IFxcJ1xcXFwyNjk5XFwnOycsXG4nXHRcdH0nLFxuJ1x0XHQjaHlwZXJncmlkLWRpYWxvZyAuaHlwZXJncmlkLWRpYWxvZy1jb250cm9sLXBhbmVsIGE6aG92ZXIgeycsXG4nXHRcdFx0Y29sb3I6IGJsYWNrOycsXG4nXHRcdFx0dGV4dC1zaGFkb3c6IDAgMCA2cHggIzMzN2FiNzsnLFxuJ1x0XHRcdHRyYW5zaXRpb246IHRleHQtc2hhZG93IC4zNXMsIGNvbG9yIC4zNXM7JyxcbidcdFx0fScsXG4nXHRcdCNoeXBlcmdyaWQtZGlhbG9nIC5oeXBlcmdyaWQtZGlhbG9nLWNvbnRyb2wtcGFuZWwgYTphY3RpdmUgeycsXG4nXHRcdFx0Y29sb3I6ICNkMDA7JyxcbidcdFx0XHR0cmFuc2l0aW9uOiBjb2xvciAwczsnLFxuJ1x0XHR9JyxcbidcdDwvc3R5bGU+JyxcbicnLFxuJ1x0PHNwYW4gY2xhc3M9XCJoeXBlcmdyaWQtZGlhbG9nLWNvbnRyb2wtcGFuZWxcIj4nLFxuJ1x0XHQ8YSBjbGFzcz1cImh5cGVyZ3JpZC1kaWFsb2ctc2V0dGluZ3NcIiB0aXRsZT1cIihUaGVyZSBhcmUgbm8gc2V0dGluZ3MgZm9yIE1hbmFnZSBGaWx0ZXJzIGF0IHRoaXMgdGltZS4pXCI+PC9hPicsXG4nXHRcdDxhIGNsYXNzPVwiaHlwZXJncmlkLWRpYWxvZy1jbG9zZVwiPjwvYT4nLFxuJ1x0PC9zcGFuPicsXG4nJyxcbic8L2Rpdj4nXG5dLmpvaW4oJ1xcbicpO1xuXG5leHBvcnRzLmZpbHRlclRyZWVzID0gW1xuJzxzdHlsZT4nLFxuJ1x0I2h5cGVyZ3JpZC1kaWFsb2cgPiBkaXYgeycsXG4nXHRcdHBvc2l0aW9uOiBhYnNvbHV0ZTsnLFxuJ1x0XHR0b3A6IDA7JyxcbidcdFx0bGVmdDogMDsnLFxuJ1x0XHRib3R0b206IDA7JyxcbidcdFx0cmlnaHQ6IDA7JyxcbidcdH0nLFxuJ1x0I2h5cGVyZ3JpZC1kaWFsb2cgPiBkaXY6Zmlyc3Qtb2YtdHlwZSB7JyxcbidcdFx0cGFkZGluZzogMWVtIDFlbSAxZW0gMC41ZW07JyxcbidcdFx0bWFyZ2luLWxlZnQ6IDUwJTsnLFxuJ1x0fScsXG4nXHQjaHlwZXJncmlkLWRpYWxvZyA+IGRpdjpsYXN0LW9mLXR5cGUgeycsXG4nXHRcdHBhZGRpbmc6IDFlbSAwLjVlbSAxZW0gMWVtOycsXG4nXHRcdG1hcmdpbi1yaWdodDogNTAlOycsXG4nXHR9JyxcbidcdCNoeXBlcmdyaWQtZGlhbG9nID4gZGl2ID4gcDpmaXJzdC1jaGlsZCB7JyxcbidcdFx0bWFyZ2luLXRvcDogMDsnLFxuJ1x0fScsXG4nXHQjaHlwZXJncmlkLWRpYWxvZyA+IGRpdiA+IHAgPiBzcGFuOmZpcnN0LWNoaWxkIHsnLFxuJ1x0XHRmb250LXNpemU6IGxhcmdlcjsnLFxuJ1x0XHRsZXR0ZXItc3BhY2luZzogMnB4OycsXG4nXHRcdGZvbnQtd2VpZ2h0OiBib2xkOycsXG4nXHRcdGNvbG9yOiAjNjY2OycsXG4nXHRcdG1hcmdpbi1yaWdodDogMWVtOycsXG4nXHR9JyxcbidcdCNoeXBlcmdyaWQtZGlhbG9nIGlucHV0LCAjaHlwZXJncmlkLWRpYWxvZyB0ZXh0YXJlYSB7JyxcbidcdFx0b3V0bGluZTogMDsnLFxuJ1x0XHRsaW5lLWhlaWdodDogaW5pdGlhbDsnLFxuJ1x0fScsXG4nJyxcbidcdC50YWJ6IHsgei1pbmRleDogMCB9JyxcbidcdC50YWJ6ID4gcDpmaXJzdC1jaGlsZCwgLnRhYnogPiBzZWN0aW9uID4gcDpmaXJzdC1jaGlsZCwgLnRhYnogPiBzZWN0aW9uID4gZGl2ID4gcDpmaXJzdC1jaGlsZCB7IG1hcmdpbi10b3A6IDAgfScsXG4nJyxcbidcdCNoeXBlcmdyaWQtZGlhbG9nIGEubW9yZS1pbmZvIHsgZm9udC1zaXplOiBzbWFsbGVyOyB9JyxcbidcdCNoeXBlcmdyaWQtZGlhbG9nIGEubW9yZS1pbmZvOjphZnRlciB7IGNvbnRlbnQ6IFxcJyhtb3JlIGluZm8pXFwnOyB9JyxcbidcdCNoeXBlcmdyaWQtZGlhbG9nIGEubW9yZS1pbmZvLmhpZGUtaW5mbyB7IGNvbG9yOiByZWQ7IH0nLFxuJ1x0I2h5cGVyZ3JpZC1kaWFsb2cgYS5tb3JlLWluZm8uaGlkZS1pbmZvOjphZnRlciB7IGNvbnRlbnQ6IFxcJyhoaWRlIGluZm8pXFwnOyB9JyxcbidcdCNoeXBlcmdyaWQtZGlhbG9nIGRpdi5tb3JlLWluZm8geycsXG4nXHRcdGJvcmRlcjogMXB4IHRhbiBzb2xpZDsnLFxuJ1x0XHRib3JkZXItcmFkaXVzOiA4cHg7JyxcbidcdFx0cGFkZGluZzogMCA4cHggLjJlbTsnLFxuJ1x0XHRkaXNwbGF5OiBub25lOycsXG4nXHRcdGJhY2tncm91bmQtY29sb3I6IGl2b3J5OycsXG4nXHRcdGJveC1zaGFkb3c6IDNweCAzcHggNXB4ICM3MDcwNzA7JyxcbidcdFx0bWFyZ2luLWJvdHRvbTogMWVtOycsXG4nXHR9JyxcbidcdCNoeXBlcmdyaWQtZGlhbG9nIGRpdi5tb3JlLWluZm8gPiBwIHsgbWFyZ2luOiAuNWVtIDA7IH0nLFxuJycsXG4nXHQjaHlwZXJncmlkLWRpYWxvZyAudGFieiB1bCB7JyxcbidcdFx0cGFkZGluZy1sZWZ0OiAxLjVlbTsnLFxuJ1x0XHRsaXN0LXN0eWxlLXR5cGU6IGNpcmNsZTsnLFxuJ1x0XHRmb250LXdlaWdodDogYm9sZDsnLFxuJ1x0fScsXG4nXHQjaHlwZXJncmlkLWRpYWxvZyAudGFieiB1bCA+IGxpID4gdWwgeycsXG4nXHRcdGxpc3Qtc3R5bGUtdHlwZTogZGlzYzsnLFxuJ1x0XHRmb250LXdlaWdodDogbm9ybWFsOycsXG4nXHR9JyxcbidcdCNoeXBlcmdyaWQtZGlhbG9nIC50YWJ6IGxpIHsnLFxuJ1x0XHRtYXJnaW46IC4zZW0gMDsnLFxuJ1x0fScsXG4nXHQjaHlwZXJncmlkLWRpYWxvZyAudGFieiBsaSA+IGNvZGUgeycsXG4nXHRcdGJhY2tncm91bmQ6ICNlMGUwZTA7JyxcbidcdFx0bWFyZ2luOiAwIC4xZW07JyxcbidcdFx0cGFkZGluZzogMCA1cHg7JyxcbidcdFx0Ym9yZGVyLXJhZGl1czogNHB4OycsXG4nXHR9JyxcbicnLFxuJ1x0I2h5cGVyZ3JpZC1kaWFsb2cgLnRhYnogPiBzZWN0aW9uLmZpbHRlci1leHByZXNzaW9uLXN5bnRheCA+IGRpdjpsYXN0LWNoaWxkIG9sIHsnLFxuJ1x0XHRwYWRkaW5nLWxlZnQ6IDEuNmVtOycsXG4nXHR9JyxcbidcdCNoeXBlcmdyaWQtZGlhbG9nIC50YWJ6ID4gc2VjdGlvbi5maWx0ZXItZXhwcmVzc2lvbi1zeW50YXggPiBkaXY6bGFzdC1jaGlsZCBvbCA+IGxpID4gbGFiZWwgeycsXG4nXHRcdHdpZHRoOiAxMDAlOycsXG4nXHRcdGZvbnQtd2VpZ2h0OiBub3JtYWw7JyxcbidcdFx0ZGlzcGxheTogaW5saW5lOycsXG4nXHR9JyxcbidcdCNoeXBlcmdyaWQtZGlhbG9nIC50YWJ6IC5maWx0ZXItdHJlZS13YXJuIHsnLFxuJ1x0XHRjb2xvcjogZGFya3JlZDsnLFxuJ1x0XHRmb250LXNpemU6IHNtYWxsZXI7JyxcbidcdFx0Zm9udC1zdHlsZTogaXRhbGljOycsXG4nXHRcdGxpbmUtaGVpZ2h0OiBpbml0aWFsOycsXG4nXHR9JyxcbidcdCNoeXBlcmdyaWQtZGlhbG9nIC50YWJ6ID4gc2VjdGlvbi5maWx0ZXItZXhwcmVzc2lvbi1zeW50YXggPiB0ZXh0YXJlYSwnLFxuJ1x0I2h5cGVyZ3JpZC1kaWFsb2cgLnRhYnogPiBzZWN0aW9uLmZpbHRlci1leHByZXNzaW9uLXN5bnRheCA+IGRpdjpsYXN0LWNoaWxkIHRleHRhcmVhLCcsXG4nXHQjaHlwZXJncmlkLWRpYWxvZyAudGFieiA+IHNlY3Rpb24uZmlsdGVyLWV4cHJlc3Npb24tc3ludGF4ID4gZGl2Omxhc3QtY2hpbGQgaW5wdXQgeycsXG4nXHRcdGRpc3BsYXk6IGJsb2NrOycsXG4nXHRcdHBvc2l0aW9uOiByZWxhdGl2ZTsnLFxuJ1x0XHRtaW4td2lkdGg6IDEwMCU7JyxcbidcdFx0bWF4LXdpZHRoOiAxMDAlOycsXG4nXHRcdGJveC1zaXppbmc6IGJvcmRlci1ib3g7JyxcbidcdFx0Ym9yZGVyOiAxcHggc29saWQgYmxhY2s7JyxcbidcdFx0cGFkZGluZzogLjRlbSAuN2VtOycsXG4nXHRcdGZvbnQtZmFtaWx5OiBtb25vc3BhY2U7JyxcbidcdFx0Zm9udC1zaXplOiA5cHQ7JyxcbidcdFx0bWFyZ2luLXRvcDogM3B4OycsXG4nXHR9JyxcbidcdCNoeXBlcmdyaWQtZGlhbG9nIC50YWJ6ID4gc2VjdGlvbi5maWx0ZXItZXhwcmVzc2lvbi1zeW50YXggPiB0ZXh0YXJlYSB7JyxcbidcdFx0aGVpZ2h0OiA5NiU7JyxcbidcdH0nLFxuJ1x0I2h5cGVyZ3JpZC1kaWFsb2cgLnRhYnogYS5maWx0ZXItY29weSB7JyxcbidcdFx0ZGlzcGxheTogYmxvY2s7JyxcbidcdFx0ZmxvYXQ6IHJpZ2h0OycsXG4nXHRcdGZvbnQtc2l6ZTogc21hbGxlcjsnLFxuJ1x0fScsXG4nXHQjaHlwZXJncmlkLWRpYWxvZyAudGFieiBhLmZpbHRlci1jb3B5OmJlZm9yZSB7JyxcbidcdFx0Y29udGVudDogXFwnKGNvcHlcXCc7JyxcbidcdH0nLFxuJ1x0I2h5cGVyZ3JpZC1kaWFsb2cgLnRhYnogYS5maWx0ZXItY29weTphZnRlciB7JyxcbidcdFx0Y29udGVudDogXFwnKVxcJzsnLFxuJ1x0fScsXG4nXHQjaHlwZXJncmlkLWRpYWxvZyAudGFieiBhLmZpbHRlci1jb3B5OmFjdGl2ZSB7JyxcbidcdFx0Y29sb3I6IHJlZDsnLFxuJ1x0fScsXG4nPC9zdHlsZT4nLFxuJycsXG4nPGRpdj4nLFxuJ1x0PHNlbGVjdCBpZD1cImFkZC1jb2x1bW4tZmlsdGVyLXN1YmV4cHJlc3Npb25cIiBzdHlsZT1cImZsb2F0OnJpZ2h0OyBtYXJnaW4tbGVmdDoxZW07IG1hcmdpbi1yaWdodDo0ZW07XCI+JyxcbidcdFx0PG9wdGlvbiB2YWx1ZT1cIlwiPk5ldyBjb2x1bW4gZmlsdGVyJmhlbGxpcDs8L29wdGlvbj4nLFxuJ1x0PC9zZWxlY3Q+JyxcbicnLFxuJ1x0PHA+JyxcbidcdFx0PHNwYW4+Q29sdW1uIEZpbHRlcnM8L3NwYW4+JyxcbidcdFx0PGEgY2xhc3M9XCJtb3JlLWluZm9cIj48L2E+JyxcbidcdDwvcD4nLFxuJ1x0PGRpdiBjbGFzcz1cIm1vcmUtaW5mb1wiPicsXG4nXHRcdDxwPlRoZSB0YWJsZSBmaWx0ZXIgY2FuIGJlIHZpZXdlZCBpbiB0aGUgUXVlcnkgQnVpbGRlciBvciBhcyBTUUwgV0hFUkUgY2xhdXNlIHN5bnRheC4gQm90aCBpbnRlcmZhY2VzIG1hbmlwdWxhdGUgdGhlIHNhbWUgdW5kZXJseWluZyBmaWx0ZXIgZGF0YSBzdHJ1Y3R1cmUuPC9wPicsXG4nXHRcdDxwPkFsbCBjb2x1bW4gZmlsdGVycyBhcmUgQU5EJnJzcXVvO2QgdG9nZXRoZXIuIEVhY2ggZ3JpZCByb3cgaXMgZmlyc3QgcXVhbGlmaWVkIGJ5IHRoZSB0YWJsZSBmaWx0ZXIgYW5kIHRoZW4gc3VjY2Vzc2l2ZWx5IHF1YWxpZmllZCBieSBlYWNoIGNvbHVtbiBmaWx0ZXIgc3ViZXhwcmVzc2lvbi48L3A+JyxcbidcdDwvZGl2PicsXG4nJyxcbidcdDxkaXYgY2xhc3M9XCJ0YWJ6XCIgaWQ9XCJjb2x1bW5GaWx0ZXJzUGFuZWxcIj4nLFxuJycsXG4nXHRcdDxoZWFkZXIgaWQ9XCJjb2x1bW5zUUJcIiBjbGFzcz1cImRlZmF1bHQtdGFiXCI+JyxcbidcdFx0XHRRdWVyeSBCdWlsZGVyJyxcbidcdFx0PC9oZWFkZXI+JyxcbicnLFxuJ1x0XHQ8c2VjdGlvbj4nLFxuJ1x0XHQ8L3NlY3Rpb24+JyxcbicnLFxuJ1x0XHQ8aGVhZGVyIGlkPVwiY29sdW1uc1NRTFwiIGNsYXNzPVwidGFiei1iZzJcIj4nLFxuJ1x0XHRcdFNRTCcsXG4nXHRcdDwvaGVhZGVyPicsXG4nJyxcbidcdFx0PHNlY3Rpb24gY2xhc3M9XCJmaWx0ZXItZXhwcmVzc2lvbi1zeW50YXggdGFiei1iZzJcIj4nLFxuJ1x0XHRcdDxkaXY+JyxcbidcdFx0XHRcdDxwPicsXG4nXHRcdFx0XHRcdDxzcGFuPjwvc3Bhbj4nLFxuJ1x0XHRcdFx0XHQ8YSB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJmaWx0ZXItY29weVwiIHRpdGxlPVwiVGhlIHN0YXRlIG9mIHRoZSBjb2x1bW4gZmlsdGVycyBzdWJ0cmVlIGV4cHJlc3NlZCBpbiBTUUwgc3ludGF4IChhbGwgdGhlIGNvbHVtbiBmaWx0ZXIgc3ViZXhwcmVzc2lvbnMgc2hvd24gYmVsb3cgQU5EJnJzcXVvO2QgdG9nZXRoZXIpLlwiPicsXG4nXHRcdFx0XHRcdFx0YWxsPC9hPicsXG4nXHRcdFx0XHQ8L3A+JyxcbidcdFx0XHRcdDxvbD48L29sPicsXG4nXHRcdFx0PC9kaXY+JyxcbidcdFx0PC9zZWN0aW9uPicsXG4nJyxcbidcdFx0PGhlYWRlciBpZD1cImNvbHVtbnNDUUxcIiBjbGFzcz1cInRhYnotYmcxXCI+JyxcbidcdFx0XHRDUUwnLFxuJ1x0XHQ8L2hlYWRlcj4nLFxuJycsXG4nXHRcdDxzZWN0aW9uIGNsYXNzPVwiZmlsdGVyLWV4cHJlc3Npb24tc3ludGF4IHRhYnotYmcxXCI+JyxcbidcdFx0XHQ8cD4nLFxuJ1x0XHRcdFx0PGVtPicsXG4nXHRcdFx0XHRcdDxzbWFsbD5Db2x1bW4gZmlsdGVyIGNlbGxzIGFjY2VwdCBhIHNpbXBsaWZpZWQsIGNvbXBhY3QsIGFuZCBpbnR1aXRpdmUgc3ludGF4LCB3aGljaCBpcyBob3dldmVyIG5vdCBhcyBmbGV4aWJsZSBvciBjb25jaXNlIGFzIFNRTCBzeW50YXggb3IgdXNpbmcgdGhlIFF1ZXJ5IEJ1aWxkZXIuPC9zbWFsbD4nLFxuJ1x0XHRcdFx0XHQ8YSBjbGFzcz1cIm1vcmUtaW5mb1wiPjwvYT4nLFxuJ1x0XHRcdFx0PC9lbT4nLFxuJ1x0XHRcdDwvcD4nLFxuJ1x0XHRcdDxkaXYgY2xhc3M9XCJtb3JlLWluZm9cIj4nLFxuJ1x0XHRcdFx0PHVsPicsXG4nXHRcdFx0XHRcdDxsaT4nLFxuJ1x0XHRcdFx0XHRcdFNpbXBsZSBleHByZXNzaW9ucycsXG4nXHRcdFx0XHRcdFx0PHVsPicsXG4nXHRcdFx0XHRcdFx0XHQ8bGk+QWxsIHNpbXBsZSBleHByZXNzaW9ucyB0YWtlIHRoZSBmb3JtIDxpPm9wZXJhdG9yIGxpdGVyYWw8L2k+IG9yIDxpPm9wZXJhdG9yIGlkZW50aWZpZXI8L2k+LiBUaGUgKGxlZnQgc2lkZSkgY29sdW1uIGlzIGFsd2F5cyBpbXBsaWVkIGFuZCBpcyB0aGUgc2FtZSBmb3IgYWxsIHNpbXBsZSBleHByZXNzaW9ucyBpbiBhIGNvbXBvdW5kIGV4cHJlc3Npb24uIFRoaXMgaXMgYmVjYXVzZSBjb2x1bW4gZmlsdGVycyBhcmUgYWx3YXlzIHRpZWQgdG8gYSBrbm93biBjb2x1bW4uPC9saT4nLFxuJycsXG4nXHRcdFx0XHRcdFx0XHQ8bGk+SWYgdGhlIG9wZXJhdG9yIGlzIGFuIGVxdWFscyBzaWduICg9KSwgaXQgbWF5IGJlIG9taXR0ZWQuPC9saT4nLFxuJycsXG4nXHRcdFx0XHRcdFx0XHQ8bGk+QmVzaWRlcyBvcGVyYXRvcnMsIG5vIG90aGVyIHB1bmN0dWF0aW9uIGlzIHBlcm1pdHRlZCwgbWVhbmluZyB0aGF0IG5vIHF1b3RhdGlvbiBtYXJrcyBhbmQgbm8gcGFyZW50aGVzZXMuPC9saT4nLFxuJycsXG4nXHRcdFx0XHRcdFx0XHQ8bGk+SWYgYSBsaXRlcmFsIGV4YWN0bHkgbWF0Y2hlcyBhIGNvbHVtbiBuYW1lIG9yIGFsaWFzLCB0aGUgb3BlcmFuZCBpcyBub3QgdGFrZW4gbGl0ZXJhbGx5IGFuZCBpbnN0ZWFkIHJlZmVycyB0byB0aGUgdmFsdWUgaW4gdGhhdCBjb2x1bW4uIChUaGVyZSBhcmUgcHJvcGVydGllcyB0byBjb250cm9sIHdoYXQgY29uc3RpdHV0ZXMgc3VjaCBhIG1hdGNoOiBDb2x1bW4gbmFtZSwgYWxpYXMsIG9yIGVpdGhlcjsgYW5kIHRoZSBjYXNlLXNlbnNpdGl2aXR5IG9mIHRoZSBtYXRjaC4pPC9saT4nLFxuJycsXG4nXHRcdFx0XHRcdFx0XHQ8bGk+QXMgbGl0ZXJhbHMgYXJlIHVucXVvdGVkLCBhbnkgb3BlcmF0b3Igc3ltYm9sIG9yIG9wZXJhdG9yIHdvcmQgKGluY2x1ZGluZyBsb2dpY2FsIG9wZXJhdG9ycyBmb3IgY29tcG91bmQgZXhwcmVzc2lvbnMpIHRlcm1pbmF0ZXMgYSBsaXRlcmFsLjwvbGk+JyxcbicnLFxuJ1x0XHRcdFx0XHRcdFx0PGxpPkFuIGltcG9ydGFudCBjb3JvbGxhcnkgdG8gdGhlIGFib3ZlIGZlYXR1cmVzIGlzIHRoYXQgb3BlcmF0b3JzIG1heSBub3QgYXBwZWFyIGluIGxpdGVyYWxzLjwvbGk+JyxcbidcdFx0XHRcdFx0XHQ8L3VsPicsXG4nXHRcdFx0XHRcdDwvbGk+JyxcbicnLFxuJ1x0XHRcdFx0XHQ8bGk+JyxcbidcdFx0XHRcdFx0XHRDb21wb3VuZCBleHByZXNzaW9ucycsXG4nXHRcdFx0XHRcdFx0PHVsPicsXG4nXHRcdFx0XHRcdFx0XHQ8bGk+Q29tcG91bmQgZXhwcmVzc2lvbnMgYXJlIGZvcm1lZCBieSBjb25uZWN0aW5nIHNpbXBsZSBleHByZXNzaW9ucyB3aXRoIHRoZSBsb2dpY2FsIG9wZXJhdG9ycyA8Y29kZT5BTkQ8L2NvZGU+LCA8Y29kZT5PUjwvY29kZT4sIDxjb2RlPk5PUjwvY29kZT4sIG9yIDxjb2RlPk5BTkQ8L2NvZGU+IChcIm5vdCBhbmRcIikuPC9saT4nLFxuJycsXG4nXHRcdFx0XHRcdFx0XHQ8bGk+SG93ZXZlciwgYWxsIGxvZ2ljYWwgb3BlcmF0b3JzIHVzZWQgaW4gYSBjb21wb3VuZCBjb2x1bW4gZmlsdGVyIGV4cHJlc3Npb24gbXVzdCBiZSBob21vZ2VuZW91cy4gWW91IG1heSBub3QgbWl4IHRoZSBhYm92ZSBsb2dpY2FsIG9wZXJhdG9ycyBpbiBhIHNpbmdsZSBjb2x1bW4uIChJZiB5b3UgbmVlZCB0byBkbyB0aGlzLCBjcmVhdGUgYSB0YWJsZSBmaWx0ZXIgZXhwcmVzc2lvbiBpbnN0ZWFkLik8L2xpPicsXG4nXHRcdFx0XHRcdFx0PC91bD4nLFxuJ1x0XHRcdFx0XHQ8L2xpPicsXG4nJyxcbidcdFx0XHRcdFx0PGxpPicsXG4nXHRcdFx0XHRcdFx0SGlkZGVuIGxvZ2ljJyxcbidcdFx0XHRcdFx0XHQ8dWw+JyxcbidcdFx0XHRcdFx0XHRcdDxsaT5JZiB0aGUgY29sdW1uIGlzIGFsc28gcmVmZXJlbmNlZCBpbiBhIHRhYmxlIGZpbHRlciBleHByZXNzaW9uIChvbiB0aGUgbGVmdCBzaWRlIG9mIGEgc2ltcGxlIGV4cHJlc3Npb24pLCB0aGUgY29sdW1uIGZpbHRlciBpcyBmbGFnZ2VkIGluIGl0cyBncmlkIGNlbGwgd2l0aCBhIHNwZWNpYWwgc3RhciBjaGFyYWN0ZXIuIFRoaXMgaXMganVzdCBhIGZsYWc7IGl0IGlzIG5vdCBwYXJ0IG9mIHRoZSBzeW50YXguIDxzcGFuIHN0eWxlPVwiY29sb3I6cmVkOyBmb250LXN0eWxlOml0YWxpY1wiPk5vdCB5ZXQgaW1wbGVtZW50ZWQuPC9zcGFuPjwvbGk+JyxcbidcdFx0XHRcdFx0XHQ8L3VsPicsXG4nXHRcdFx0XHRcdDwvbGk+JyxcbidcdFx0XHRcdDwvdWw+JyxcbidcdFx0XHQ8L2Rpdj4nLFxuJycsXG4nXHRcdFx0PGRpdj4nLFxuJ1x0XHRcdFx0PHA+PHNwYW4+PC9zcGFuPjwvcD4nLFxuJ1x0XHRcdFx0PG9sPjwvb2w+JyxcbidcdFx0XHQ8L2Rpdj4nLFxuJ1x0XHQ8L3NlY3Rpb24+JyxcbidcdDwvZGl2PicsXG4nPC9kaXY+JyxcbicnLFxuJzxkaXY+JyxcbidcdDxwPicsXG4nXHRcdDxzcGFuPlRhYmxlIEZpbHRlcjwvc3Bhbj4nLFxuJ1x0XHQ8YSBjbGFzcz1cIm1vcmUtaW5mb1wiPjwvYT4nLFxuJ1x0PC9wPicsXG4nXHQ8ZGl2IGNsYXNzPVwibW9yZS1pbmZvXCI+JyxcbidcdFx0PHA+VGhlIHRhYmxlIGZpbHRlciBjYW4gYmUgdmlld2VkIGluIHRoZSBRdWVyeSBCdWlsZGVyIG9yIGFzIFNRTCBXSEVSRSBjbGF1c2Ugc3ludGF4LiBCb3RoIGludGVyZmFjZXMgbWFuaXB1bGF0ZSB0aGUgc2FtZSB1bmRlcmx5aW5nIGZpbHRlciBkYXRhIHN0cnVjdHVyZS48L3A+JyxcbidcdFx0PHA+JyxcbidcdFx0XHRUaGVzZSBmaWx0ZXIgc3ViZXhwcmVzc2lvbnMgYXJlIGJvdGggcmVxdWlyZWQgKDxjb2RlPkFORDwvY29kZT4mcnNxdW87ZCB0b2dldGhlciksIHJlc3VsdGluZyBpbiBhIHN1YnNldCBvZiA8ZW0+cXVhbGlmaWVkIHJvd3M8L2VtPiB3aGljaCBoYXZlIHBhc3NlZCB0aHJvdWdoIGJvdGggZmlsdGVycy4nLFxuJ1x0XHRcdEl0XFwncyBjYWxsZWQgYSA8ZGZuPnRyZWU8L2Rmbj4gYmVjYXVzZSBpdCBjb250YWlucyBib3RoIDxkZm4+YnJhbmNoZXM8L2Rmbj4gYW5kIDxkZm4+bGVhdmVzPC9kZm4+LicsXG4nXHRcdFx0VGhlIGxlYXZlcyByZXByZXNlbnQgPGRmbj5jb25kaXRpb25hbCBleHByZXNzaW9uczwvZGZuPiAob3Igc2ltcGx5IDxkZm4+Y29uZGl0aW9uYWxzPC9kZm4+KS4nLFxuJ1x0XHRcdFRoZSBicmFuY2hlcywgYWxzbyBrbm93biBhcyA8ZGZuPnN1YnRyZWVzPC9kZm4+LCBjb250YWluIGxlYXZlcyBhbmQvb3Igb3RoZXIgYnJhbmNoZXMgYW5kIHJlcHJlc2VudCBzdWJleHByZXNzaW9ucyB0aGF0IGdyb3VwIGNvbmRpdGlvbmFscyB0b2dldGhlci4nLFxuJ1x0XHRcdEdyb3VwZWQgY29uZGl0aW9uYWxzIGFyZSBldmFsdWF0ZWQgdG9nZXRoZXIsIGJlZm9yZSBjb25kaXRpb25hbHMgb3V0c2lkZSB0aGUgZ3JvdXAuJyxcbidcdFx0PC9wPicsXG4nXHQ8L2Rpdj4nLFxuJycsXG4nXHQ8ZGl2IGNsYXNzPVwidGFielwiIGlkPVwidGFibGVGaWx0ZXJQYW5lbFwiPicsXG4nXHRcdDxoZWFkZXIgaWQ9XCJ0YWJsZVFCXCI+JyxcbidcdFx0XHRRdWVyeSBCdWlsZGVyJyxcbidcdFx0PC9oZWFkZXI+JyxcbicnLFxuJ1x0XHQ8c2VjdGlvbj4nLFxuJ1x0XHQ8L3NlY3Rpb24+JyxcbicnLFxuJ1x0XHQ8aGVhZGVyIGlkPVwidGFibGVTUUxcIiBjbGFzcz1cInRhYnotYmcyXCI+JyxcbidcdFx0XHRTUUwnLFxuJ1x0XHQ8L2hlYWRlcj4nLFxuJycsXG4nXHRcdDxzZWN0aW9uIGNsYXNzPVwiZmlsdGVyLWV4cHJlc3Npb24tc3ludGF4IHRhYnotYmcyXCI+JyxcbidcdFx0XHQ8ZGl2PicsXG4nXHRcdFx0XHQ8cD4nLFxuJ1x0XHRcdFx0XHRTUUwgV0hFUkUgY2xhdXNlIHN5bnRheCB3aXRoIGNlcnRhaW4gcmVzdHJpY3Rpb25zLicsXG4nXHRcdFx0XHRcdDxhIGNsYXNzPVwibW9yZS1pbmZvXCI+PC9hPicsXG4nXHRcdFx0XHQ8L3A+JyxcbidcdFx0XHRcdDxkaXYgY2xhc3M9XCJtb3JlLWluZm9cIj4nLFxuJ1x0XHRcdFx0XHQ8dWw+JyxcbidcdFx0XHRcdFx0XHQ8bGk+JyxcbidcdFx0XHRcdFx0XHRcdFNpbXBsZSBleHByZXNzaW9ucycsXG4nXHRcdFx0XHRcdFx0XHQ8dWw+JyxcbidcdFx0XHRcdFx0XHRcdFx0PGxpPkFsbCBzaW1wbGUgZXhwcmVzc2lvbnMgbXVzdCBiZSBvZiB0aGUgZm9ybSA8aT5jb2x1bW4gb3BlcmF0b3IgbGl0ZXJhbDwvaT4gb3IgPGk+Y29sdW1uIG9wZXJhdG9yIGlkZW50aWZpZXI8L2k+LiBUaGF0IGlzLCB0aGUgbGVmdCBzaWRlIG11c3QgcmVmZXIgdG8gYSBjb2x1bW4gKG1heSBub3QgYmUgYSBsaXRlcmFsKTsgd2hlcmVhcyB0aGUgcmlnaHQgc2lkZSBtYXkgYmUgZWl0aGVyLjwvbGk+JyxcbicnLFxuJ1x0XHRcdFx0XHRcdFx0XHQ8bGk+Q29sdW1uIG5hbWVzIG1heSBiZSBxdW90ZWQgd2l0aCB0aGUgY3VycmVudGx5IHNldCBxdW90ZSBjaGFyYWN0ZXJzICh0eXBpY2FsbHkgZG91YmxlLXF1b3RlcykuIElmIHVucXVvdGVkLCB0aGV5IG11c3QgY29uc2lzdCBvZiBjbGFzc2ljIGlkZW50aWZpZXIgc3ludGF4IChhbHBoYW51bWVyaWNzIGFuZCB1bmRlcnNjb3JlLCBidXQgbm90IGJlZ2lubmluZyB3aXRoIGEgbnVtZXJhbCkuPC9saT4nLFxuJycsXG4nXHRcdFx0XHRcdFx0XHRcdDxsaT5BbGwgbGl0ZXJhbHMgbXVzdCBiZSBxdW90ZWQgc3RyaW5ncyAodXNpbmcgc2luZ2xlIHF1b3RlcykuIChJbiBhIGZ1dHVyZSByZWxlYXNlIHdlIGV4cGVjdCB0byBzdXBwb3J0IHVucXVvdGVkIG51bWVyaWMgc3ludGF4IGZvciBjb2x1bW5zIGV4cGxpY2l0bHkgdHlwZWQgYXMgbnVtZXJpYy4pPC9saT4nLFxuJ1x0XHRcdFx0XHRcdFx0PC91bD4nLFxuJ1x0XHRcdFx0XHRcdDwvbGk+JyxcbicnLFxuJ1x0XHRcdFx0XHRcdDxsaT4nLFxuJ1x0XHRcdFx0XHRcdFx0Q29tcG91bmQgZXhwcmVzc2lvbnMnLFxuJ1x0XHRcdFx0XHRcdFx0PHVsPicsXG4nXHRcdFx0XHRcdFx0XHRcdDxsaT5Db21wb3VuZCBleHByZXNzaW9ucyBhcmUgZm9ybWVkIGJ5IGNvbm5lY3Rpbmcgc2ltcGxlIGV4cHJlc3Npb25zIHdpdGggdGhlIGxvZ2ljYWwgb3BlcmF0b3JzIDxjb2RlPkFORDwvY29kZT4gb3IgPGNvZGU+T1I8L2NvZGU+LjwvbGk+JyxcbicnLFxuJ1x0XHRcdFx0XHRcdFx0XHQ8bGk+SG93ZXZlciwgYWxsIGxvZ2ljYWwgb3BlcmF0b3JzIGF0IGVhY2ggbGV2ZWwgaW4gYSBjb21wbGV4IGV4cHJlc3Npb24gKGVhY2ggcGFyZW50aGVzaXplZCBzdWJleHByZXNzaW9uKSBtdXN0IGJlIGhvbW9nZW5lb3VzLCA8aT5pLmUuLDwvaT4gZWl0aGVyIDxjb2RlPkFORDwvY29kZT4gb3IgPGNvZGU+T1I8L2NvZGU+IGJ1dCBub3QgYSBtaXh0dXJlIG9mIHRoZSB0d28uIEluIG90aGVyIHdvcmRzLCB0aGVyZSBpcyBubyBpbXBsaWNpdCBvcGVyYXRvciBwcmVjZWRlbmNlOyBncm91cGluZyBvZiBleHByZXNzaW9ucyBtdXN0IGFsd2F5cyBiZSBleHBsaWNpdGx5IHN0YXRlZCB3aXRoIHBhcmVudGhlc2VzLjwvbGk+JyxcbicnLFxuJ1x0XHRcdFx0XHRcdFx0XHQ8bGk+VGhlIHVuYXJ5IGxvZ2ljYWwgb3BlcmF0b3IgPGNvZGU+Tk9UPC9jb2RlPiBpcyBzdXBvb3J0ZWQgYmVmb3JlIHBhcmVudGhlc2VzIG9ubHkuIFdoaWxlIHRoZSBRdWVyeSBCdWlsZGVyIGFuZCB0aGUgQ29sdW1uIEZpbHRlciBhbGxvdyB0aGV5IHN5bnRheCA8Y29kZT4maGVsbGlwOyBOT1QgPGk+b3BlcmF0b3I8L2k+ICZoZWxsaXA7PC9jb2RlPiAod2hlcmUgPGNvZGU+PGk+b3BlcmF0b3I8L2k+PC9jb2RlPiBpcyA8Y29kZT5JTjwvY29kZT4sIDxjb2RlPkxJS0U8L2NvZGU+LCA8aT5ldGMuPC9pPiksIHRoZXNlIG11c3QgYmUgZXhwcmVzc2VkIGhlcmUgd2l0aCBwYXJlbnRoZXRoZXM6IDxjb2RlPk5PVCAoJmhlbGxpcDsgPGk+b3BlcmF0b3I8L2k+ICZoZWxsaXA7KTwvY29kZT4uPC9saT4nLFxuJycsXG4nXHRcdFx0XHRcdFx0XHRcdDxsaT5XaGlsZSB0aGUgUXVlcnkgQnVpbGRlciBhbmQgQ29sdW1uIEZpbHRlciBzeW50YXggc3VwcG9ydCB0aGUgcHNldWRvLW9wZXJhdG9ycyA8Y29kZT5OT1I8L2NvZGU+IGFuZCA8Y29kZT5OQU5EPC9jb2RlPiwgaW4gU1FMIHRoZXNlIG11c3QgYmUgZXhwcmVzc2VkIGFzIDxjb2RlPk5PVCAoJmhlbGxpcDsgT1IgJmhlbGxpcDspPC9jb2RlPiBhbmQgPGNvZGU+Tk9UICgmaGVsbGlwOyBBTkQgJmhlbGxpcDspPC9jb2RlPiwgcmVzcGVjdGl2ZWx5LjwvbGk+JyxcbicnLFxuJ1x0XHRcdFx0XHRcdFx0XHQ8bGk+VGhlIFF1ZXJ5IEJ1aWxkZXIgYW5kIENvbHVtbiBGaWx0ZXIgc3ludGF4IGFsc28gc3VwcG9ydCB0aGUgcHNldWRvLW9wZXJhdG9ycyA8Y29kZT5CRUdJTlMgYWJjPC9jb2RlPiwgPGNvZGU+RU5EUyB4eXo8L2NvZGU+LCBhbmQgPGNvZGU+Q09OVEFJTlMgZGVmPC9jb2RlPi4gVGhlc2UgYXJlIGV4cHJlc3NlZCBpbiBTUUwgYnkgPGNvZGU+TElLRSBcXCdhYmMlXFwnPC9jb2RlPiwgPGNvZGU+TElLRSBcXCcleHl6XFwnPC9jb2RlPiwgYW5kIDxjb2RlPkxJS0UgXFwnJWRlZiVcXCc8L2NvZGU+LCByZXNwZWN0aXZlbHkuPC9saT4nLFxuJ1x0XHRcdFx0XHRcdFx0PC91bD4nLFxuJ1x0XHRcdFx0XHRcdDwvbGk+JyxcbidcdFx0XHRcdFx0PC91bD4nLFxuJ1x0XHRcdFx0PC9kaXY+JyxcbidcdFx0XHQ8L2Rpdj4nLFxuJ1x0XHRcdDxkaXYgY2xhc3M9XCJmaWx0ZXItdHJlZS13YXJuXCI+PC9kaXY+JyxcbidcdFx0XHQ8dGV4dGFyZWE+PC90ZXh0YXJlYT4nLFxuJ1x0XHQ8L3NlY3Rpb24+JyxcbicnLFxuJ1x0PC9kaXY+Jyxcbic8L2Rpdj4nXG5dLmpvaW4oJ1xcbicpO1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7IC8vIFRoaXMgZmlsZSBnZW5lcmF0ZWQgYnkgZ3VscC1pbWFnaW5lLTY0IGF0IDExOjU0OjI1IFBNIG9uIDcvMTcvMjAxNlxuXHRcIkh5cGVyYmxvdHRlciBUYWJsZWQgUmVkdWNlZCBSb3dzXCI6IHtcblx0XHR0eXBlOiBcImltYWdlL3BuZ1wiLFxuXHRcdGRhdGE6IFwiaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQXRRQUFBRG5DQVlBQUFBK1hNSGFBQUFNRjJsRFExQkpRME1nVUhKdlptbHNaUUFBU0ltVlZ3ZFlVOGtXbmx0U0NBa3RFQUVwb1RkQmVwWGVCUUhwWUNNa0FVSUpJUkJVN01paWdtc1hDMVowQlVUQnRRQ3lWa1N4c0FqWTZ3WVJGV1ZkTE5oUWVaTUUwSFZmK2Q3NXZybno1OHc1Wi81ejdzek5EQUNLOWl5QklCTlZBaUNMbnllTURQUmh4aWNrTWtsaWdBQmxRQUp1Z01GaTV3cThJeUpDQVpUUi91L3k3aWEwaG5MTlVoTHJuK1AvVlpRNTNGdzJBRWdFeE1tY1hIWVd4RWNCd0RYWkFtRWVBSVFPcURlWW5TZVE0TGNRcXdvaFFRQ0laQWxPbFdFdENVNldZV3VwVFhTa0w4UitBSkNwTEpZd0ZRQUZTWHhtUGpzVnhsRVFRR3pONS9ENEVPK0MySU9keHVKQUxJWjRRbFpXTnNTS1ZJaE5rNytMay9xM21NbGpNVm1zMURFc3kwVXFaRDllcmlDVE5mZi9MTWYvbHF4TTBlZ2MrckJSMDRSQmtaS2NZZDJxTXJKREpCaHlSMDd3azhQQ0lWYUIrQ0tQSTdXWDRMdHBvcUNZRWZ0K2RxNHZyQmxnQUlBQ0Rzc3ZCR0pZUzVRaHlvanhIc0cyTEtIVUY5cWpZYnk4NE9nUm5Dek1qaHlKaitiek04TkNSK0lzVCtNR2orSWQzRnovcUZHYkZGNUFNTVJ3cGFGSEM5S2k0MlE4MFpaOFhtd1l4QW9RZCtSbVJJV00rRDRzU1BNTkc3VVJpaUlsbkEwaGZwc2lESWlVMldEcVdibWplV0ZXYkpaMExuV0l2ZkxTb29Oa3ZsZzhOemMrZEpRRGgrdm5MK09BY2JqOG1CRnVHRnhkUHBFanZzV0N6SWdSZTJ3SE56TXdVbFpuN0ZCdWZ0U29iMWNlWEdDeU9tQ1AwbG1USTJUOHNYZUN2SWhvR1RjY0I2SEFGL2dCSmhEQmxneXlRVHJndGZjMzlNTmZzcEVBd0FKQ2tBcTR3SEpFTStvUkp4M2h3MmNVS0FCL1FzUUZ1V04rUHRKUkxzaUgraTlqV3RuVEVxUklSL09sSGhuZ0NjUlp1Q2J1Z2J2aG9mRHBCWnN0N295N2pQb3hGVWRuSmZvVC9ZaEJ4QUNpMlJnUE5tU2RDWnNROFA2TkxnVDJYSmlkaEF0L05JZHY4UWhQQ0oyRVI0UWJCREhoRG9nRmo2VlJScXhtOFFxRlB6Qm5naWxBREtNRmpHU1hER1AyamRyZ3hwQzFBKzZEdTBQK2tEdk93RFdCSlc0UE0vSEdQV0Z1RGxEN1BVUFJHTGR2dGZ4eFBnbnI3L01aMFN1WUt6aU1zRWdlZXpPK1kxWS9Sdkg5cmtZYzJJZjhhSWt0eDQ1Z3JkaFo3QkoyQW1zQVRPdzAxb2kxWVNjbGVHd2xQSmF1aE5IWklxWGNNbUFjM3FpTmRZMTFuL1huZjh6T0dtRWdsTDV2a01lZGt5ZlpFTDdaZ3JsQ1htcGFIdE1iZnBHNXpHQSsyMm9DMDliYXhoRUF5ZmRkOXZsNHc1Qit0eEhHNVcrNm5ETUF1SlJBWmVvM0hjc0FnT05QQUtDLys2WXplQTIzMXhvQVRuYXdSY0o4bVE2WFBBaUFBaFRoenRBQU9zQUFtTUtjYklFai9CL3hBdjVnTWdnSDBTQUJ6SVJWVHdOWmtQVnNNQjhzQWNXZ0ZLd0JHOEZXc0JQc0FWWGdJRGdNR3NBSmNCWmNBRmRBQjdnQjdzRzEwUXRlZ0FId0Rnd2hDRUpDYUFnZDBVQjBFU1BFQXJGRm5CRVB4QjhKUlNLUkJDUUpTVVg0aUFpWmp5eEZTcEYxeUZaa04xS04vSW9jUjg0aWw1Qk81QTdTamZRaHI1RlBLSVpTVVZWVUd6VkdKNkxPcURjYWdrYWpNOUJVTkFjdFFJdlFWZWhtdEFJOWdOYWpaOUVyNkExVWpMNUFCekdBeVdNTVRBK3p4Snd4WHl3Y1M4UlNNQ0cyRUN2QnlyQUtyQlpyZ3UvNkdpYkcrckdQT0JHbjQwemNFcTdQSUR3R1orTTUrRUo4SmI0VnI4THI4UmI4R3Q2TkQrQmZDVFNDRnNHQzRFb0lKc1FUVWdtekNjV0VNc0krd2pIQ2ViaDNlZ252aUVRaWcyaENkSUo3TTRHWVRweEhYRW5jVHF3am5pRjJFbnVJZ3lRU1NZTmtRWEluaFpOWXBEeFNNV2tMNlFEcE5LbUwxRXY2UUpZbjY1SnR5UUhrUkRLZlhFZ3VJKzhubnlKM2taK1NoK1NVNUl6a1hPWEM1VGh5YytWV3krMlZhNUs3S3Rjck4wUlJwcGhRM0NuUmxIVEtFc3BtU2kzbFBPVSs1WTI4dkx5K3ZJdjhWSG1lL0dMNXpmS0g1Qy9LZDh0L3BLcFF6YW0rMU9sVUVYVVZ0Wko2aG5xSCtvWkdveG5UdkdpSnREemFLbG8xN1J6dEllMkRBbDNCU2lGWWdhT3dTS0Zjb1Y2aFMrR2xvcHlpa2FLMzRrekZBc1V5eFNPS1Z4WDdsZVNVakpWOGxWaEtDNVhLbFk0cjNWSWFWS1lyMnlpSEsyY3ByMVRlcjN4Sitaa0tTY1ZZeFYrRm8xS2tza2ZsbkVvUEhhTWIwSDNwYlBwUytsNzZlWHF2S2xIVlJEVllOVjIxVlBXZ2FydnFnSnFLbXIxYXJOb2N0WEsxazJwaUJzWXdaZ1F6TWhtckdZY1pOeG1meG1tUDh4N0hIYmRpWE8yNHJuSHYxY2VyZTZsejFVdlU2OVJ2cUgvU1lHcjRhMlJvck5WbzBIaWdpV3VhYTA3Vm5LMjVRL084WnY5NDFmRnU0OW5qUzhZZkhuOVhDOVV5MTRyVW1xZTFSNnROYTFCYlJ6dFFXNkM5UmZ1Y2RyOE9ROGRMSjExbmc4NHBuVDVkdXE2SExrOTNnKzVwM2VkTU5hWTNNNU81bWRuQ0hORFQwZ3ZTRStudDFtdlhHOUkzMFkvUkw5U3YwMzlnUURGd05rZ3gyR0RRYkRCZ3FHczR4WEMrWVkzaFhTTTVJMmVqTktOTlJxMUc3NDFOak9PTWx4azNHRDh6VVRjSk5pa3dxVEc1YjBvejlUVE5NYTB3dlc1R05ITTJ5ekRiYnRaaGpwbzdtS2VabDV0ZnRVQXRIQzE0RnRzdE9pY1FKcmhNNEUrb21IRExrbXJwYlpsdldXUFpiY1d3Q3JVcXRHcXdlam5SY0dMaXhMVVRXeWQrdFhhd3pyVGVhMzNQUnNWbXNrMmhUWlBOYTF0elc3WnR1ZTExTzVwZGdOMGl1MGE3Vi9ZVzlsejdIZmEzSGVnT1V4eVdPVFE3ZkhGMGNoUTYxanIyT1JrNkpUbHRjN3Jsck9vYzRielMrYUlMd2NYSFpaSExDWmVQcm82dWVhNkhYZjl5czNUTGNOdnY5bXlTeVNUdXBMMlRldHoxM1ZudXU5M0ZIa3lQSkk5ZEhtSlBQVStXWjRYbkl5OERMNDdYUHErbjNtYmU2ZDRIdkYvNldQc0lmWTc1dlBkMTlWM2dlOFlQOHd2MEsvRnI5MWZ4ai9IZjZ2OHdRRDhnTmFBbVlDRFFJWEJlNEprZ1FsQkkwTnFnVzhIYXdlemc2dUNCeVU2VEYweHVDYUdHUklWc0RYa1VhaDRxREcyYWdrNlpQR1g5bFB0aFJtSDhzSVp3RUI0Y3ZqNzhRWVJKUkU3RWIxT0pVeU9tbGs5OUVta1RPVCt5TllvZU5TdHFmOVM3YUovbzFkSDNZa3hqUkRITnNZcXgwMk9yWTkvSCtjV3RpeFBIVDR4ZkVIOGxRVE9CbDlDWVNFcU1UZHlYT0RqTmY5ckdhYjNUSGFZWFQ3ODV3MlRHbkJtWFptck96Sng1Y3BiaUxOYXNJMG1FcExpay9VbWZXZUdzQ3RaZ2NuRHl0dVFCdGk5N0Uvc0Z4NHV6Z2RQSGRlZXU0ejVOY1U5WmwvSXMxVDExZldwZm1tZGFXVm8vejVlM2xmY3FQU2g5Wi9yN2pQQ015b3poekxqTXVpeHlWbExXY2I0S1A0UGZrcTJUUFNlN1UyQWhLQmFJYzF4ek51WU1DRU9FKzNLUjNCbTVqWG1xOEtqVEpqSVYvU1RxenZmSUw4Ly9NRHQyOXBFNXluUDRjOXJtbXM5ZE1mZHBRVURCTC9Qd2VleDV6ZlAxNWkrWjM3M0FlOEh1aGNqQzVJWE5pd3dXRlMzcVhSeTR1R29KWlVuR2t0OExyUXZYRmI1ZEdyZTBxVWk3YUhGUnowK0JQOVVVS3hRTGkyOHRjMXUyY3ptK25MZThmWVhkaWkwcnZwWndTaTZYV3BlV2xYNWV5VjU1K1dlYm56Zi9QTHdxWlZYN2FzZlZPOVlRMS9EWDNGenJ1YlpxbmZLNmduVTk2NmVzcjkvQTNGQ3k0ZTNHV1JzdmxkbVg3ZHhFMlNUYUpONGN1cmx4aStHV05WcytiMDNiZXFQY3A3eHVtOWEyRmR2ZWIrZHM3OXJodGFOMnAvYk8wcDJmZHZGMjNkNGR1THUrd3JpaWJBOXhULzZlSjN0ajk3Yis0dnhMOVQ3TmZhWDd2bFR5SzhWVmtWVXQxVTdWMWZ1MTlxK3VRV3RFTlgwSHBoL29PT2gzc0xIV3NuWjNIYU91OUJBNEpEcjAvTmVrWDI4ZURqbmNmTVQ1U08xUm82UGJqdEdQbGRRajlYUHJCeHJTR3NTTkNZMmR4eWNmYjI1eWF6cjJtOVZ2bFNmMFRwU2ZWRHU1K2hUbFZOR3A0ZE1GcHdmUENNNzBuMDA5MjlNOHEvbmV1Zmh6MTF1bXRyU2ZEemwvOFVMQWhYT3QzcTJuTDdwZlBISEo5ZEx4eTg2WEc2NDRYcWx2YzJnNzlydkQ3OGZhSGR2cnJ6cGRiZXh3NldqcW5OUjVxc3V6Nit3MXYyc1hyZ2RmdjNJajdFYm56WmlidDI5TnZ5Vyt6Ym45N0U3bW5WZDM4KzhPM1Z0OG4zQy81SUhTZzdLSFdnOHIvakQ3bzA3c0tEN1o3ZGZkOWlqcTBiMGVkcytMeDdtUFAvY1dQYUU5S1h1cSs3VDZtZTJ6RTMwQmZSM1BwejN2ZlNGNE1kUmYvS2Z5bjl0ZW1yNDgrcGZYWDIwRDhRTzlyNFN2aGwrdmZLUHhwdkt0L2R2bXdZakJoKyt5M2cyOUwvbWc4YUhxby9QSDFrOXhuNTRPemY1TStyejVpOW1YcHE4aFgrOFBadzBQQzFoQ2x2UW9nTUdHcHFRQThMb1NBRm9DUER2QWV4eEZRWGIva2dvaXV6TktFZmhQV0haSGt3bzh1VlI2QVJDekdJQlFlRWJaQVpzUnhGVFlTNDdmMFY0QXRiTWJheU9TbTJKbks0dEZoYmNZd29maDRUZmFBSkNhQVBnaUhCNGUyajQ4L0dVdkpIc0hnRE01c251ZlJJandqTC9MVElMYTJ5amdSL2tYSG8xc2VQVW1qSjBBQUVBQVNVUkJWSGdCN0owRmZGVEhFOGQvRjRjRWR3L3UwT0x1N3U0dUxkcWlMYlRRMHFLbEZPZVB0bENnYUlFV0xWcGNpN3U3QkF1U0VFLytNeHZ1dUF1WDVISzVKSGU1MlEvaDNyMjN1Mi8zKys2OU56czdNNnNwWGJGRkdDUUpBU0VnQklTQUVCQUNRa0FJQ0FFaFlCWUJCN05LU1NFaElBU0VnQkFRQWtKQUNBZ0JJU0FFRkFFUnFPV0hJQVNFZ0JBUUFrSkFDQWdCSVNBRVlrRkFCT3BZd0pPaVFrQUlDQUVoSUFTRWdCQVFBa0pBQkdyNURRZ0JJU0FFaElBUUVBSkNRQWdJZ1ZnUUVJRTZGdkNrcUJBUUFrSkFDQWdCSVNBRWhJQVFFSUZhZmdOQ1FBZ0lBU0VnQklTQUVCQUNRaUFXQkp5aUs1czVVM28wcUZjTkdvMUdaWDM2N0FXMjdkaUh3SUFnTFB0dENzNmV2NElwMHhaRlY0MGNGd0pDUUFnSUFTRWdCSVNBRUJBQ1ZrbkF3VUdEN0ZsUzQ4blROL0FuR1ZlYk1xWlBqb0NBWUhpL2ZxZmRaZlF6V2cwMUM5VGR1N1JFOG1RZUNBc0xROS9lN2RHdmQwZWpsUm5iT1g3TUVQeHY1Zy9xVU40OE9iQi8xMHFVS2xIRVdGYlpKd1NFZ0JBUUFrSkFDQWdCSVNBRTRwV0Fob1RwWW9XeW9YQ0JMQ2hiTWpmYzNKelYrVDJ6cGtHSllwNG9VeklYVXFkeWo3Sk4wV3FvdVhSSVNDZzJidG1GNnpmdUltMmFWQ2hwUkNCT250d0REZXRWaGJ1N084NWR1SUxqSjg2aFF2a1N5SjByTzl5U3VOS3hhc2lmUHhlY25CeFJ2MjVWM0w3ekFPL2UrYUZoL2VwSWxTb0ZmYitQWFhzT0kxOGVUNnEvS0Fudm9iaDc3eEdPSERzZFpRZmtvQkFRQWtKQUNBZ0JJU0FFaElBUU1KZUFBMWxocEVxWlZCWDNjSGRCMlJLNThlaUpOL0xteWtBV0dvQ1Rvd05TcC9UQVMyL2ZTRThScllaYXYyVEtsTW1STDE5TzNMcDlYMzgzU2ZLdW1QbkxhTlNyVTFWcHNuK2U4RFhxMUtxRWQ3NSs4UFAzSjFWNUlONzYrT0xWcTdkS3kvM3E5VnNFaDRSZzVGZDkwYmhSRFRnNE9HREU4TS9ScUg0MXNCWjc4QmZkVUx0bUphUk9uZHpnUFBKRkNBZ0JJU0FFaElBUUVBSkNRQWhZa2dBcmprK2N2ZzEvLzNCVER4YXE4K1VPRjZiNVBQY2V2c1ROdTAralBLVkpHbW9YRnljc1dUaFpTZW1CUWNHWS9iK2xCcFVXS1p3UG5wNVowYXZQTjdoeDh5NlNrYmE2VmZONitLei9LRHg2OUJTcFVxZkEvb01uOFBqSlUzVHIzQUpIanA2Q0kwbjdGY3A5aXRFL1RGZGE2RHlreWE1V3BSeiszWGNFYjk3NDRJdWhZK0hyRzdXOWlrRWo1SXNRRUFKQ1FBZ0lBU0VnQklTQUVEQ0RnSTl2QUk2ZHVvWHlwZlBBeGRsUlY4UDloOTY0Y09VaHdrTERkUHVNYlppa29RNE1ERWEzM2wraFFyVzIyTFo5SDRZTzZtbFFWOUlrYmtvTHpjSTBwNHVYcnBOMk9ZVkJub2hmMHFST2lTUlVic3FrRVRqMDcycGxIdUxpNnFLeWhZU0dpakFkRVpoOEZ3SkNRQWdJQVNFZ0JJU0FFSWd6QW1uVEpJY3ptU2JycDFRcDNlRktpdVhvVXZRNUl0Unc0Y0pWMUtoV1BzSmVLSTJ6aDBkUytQaThReklQZHdRR2Z2Q1EvQ2d6N1dBSHg2RGdZQXdhT2c1bnpsM1daV0U3YkVsQ1FBZ0lBU0VnQklTQUVCQUNRaUMrQ0hobVQ0ZEMrVElwYXd3K1p5akpxV3hicmJXcFBuYnFwczRreEZpYlROSlFhd3NxTTQzeUpmSGloYmQybC9xOGZmZUJDcXRYcjNabGNrcE1paXFWU3VIQ3hldnFXRUJnSUJsemgwdjd3U1JBaDVLem9TTjlmL3o0R1psMnZFV2xpcVZVdmlxVlNxTlF3VHdHOWNvWElTQUVoSUFRRUFKQ1FBZ0lBU0VRbHdTY3ljUWpmd1NiNlFOSHJ1c0VhQmFxYzVIQUhWVXlTYURXMmxBZjJMMEt4WXNWeFBUWlN3enF2SC8vTWViTVhZNituM1hFanMyTFZWU1FoYit0Vm5uMkhUaUdRb1h5NE1mdnZzUTl5c2RtSVpNbmZvMU1GSTV2TnBWcDNLQUdEdTlkalJIRFBrZjZkR2tNNnBVdlFrQUlDQUVoSUFTRWdCQVFBa0lnTGdrRUJZWGczS1g3Q0NVN2FYWkFaSnRwSDE5L1pWUE5qb3F2M3J6RGpkdGVVVFpCVTdwaWk2aXRyS01zTGdlRmdCQVFBa0pBQ0FnQklTQUVoSUR0RTJCTEREYjEwSGRBNUVoMFpLaXNoTzJvZWhoakcrcW9LcE5qUWtBSUNBRWhJQVNFZ0JBUUFrTEFGZ2x3K0x5SUtaUUNaWmlTVERMNU1LVWl5U01FaElBUUVBSkNRQWdJQVNFZ0JPeVJnQWpVOW5qVnBjOUNRQWdJQVNFZ0JJU0FFQkFDRmlNZ0FyWEZVRXBGUWtBSUNBRWhJQVNFZ0JBUUF2WklRQVJxZTd6cTBtY2hJQVNFZ0JBUUFrSkFDQWdCaXhFUWdkcGlLS1VpSVNBRWhJQVFFQUpDUUFnSUFYc2tJQUsxUFY1MTZiTVFFQUpDUUFnSUFTRWdCSVNBeFFpSVFHMHhsRktSRUJBQ1FrQUlDQUVoSUFTRWdEMFNjUEo2L01nZSt5MTlGZ0pDUUFnSUFTRWdCSVNBRUJBQ0ZpR2djWFhMWmljckpXb0ltSjEwMVNJL0RhbEVDQWdCSVNBRWhJQVFFQUpDd0JRQ1l2SmhDaVhKSXdTRWdCQVFBa0pBQ0FnQklTQUVJaUVnQW5Va1lHUzNFQkFDUWtBSUNBRWhJQVNFZ0JBd2hZQUkxS1pRa2p4Q1FBZ0lBU0VnQklTQUVCQUNRaUFTQWlKUVJ3SkdkZ3NCSVNBRWhJQVFFQUpDUUFnSUFWTUlpRUJ0Q2lYSkl3U0VnQkFRQWtKQUNBZ0JJU0FFSWlFZ0FuVWtZR1MzRUJBQ1FrQUlDQUVoSUFTRWdCQXdoWUFJMUtaUWtqeENRQWdJQVNFZ0JJU0FFQkFDUWlBU0FpSlFSd0pHZGdzQklTQUVoSUFRRUFKQ1FBZ0lBVk1JSktoQTdlanNnUXpGMnB2U1RxVEtWUjFKMHVRMUthOWtFZ0pDUUFnSWdZUWxrS0Z3Uzdna1NaT3dqWkN6Q3dFTEVkQTRPQ0xUSjUzZzRPQmlvUnJ0dDVxWXlINjJSTWxzZ1RwWjVoTDR0UHNPbE9peEczbnIvUVFISjdjWTk5dlIxUU1aVFJXb2MxWkQwalI1WW53T0tXQi9CTEtWL3dJRm1zeWhqdlBxbUVDdW1qOGdUYjc2YWx2K0V3SkNJR1lFa3FUSWp1SmR0cUJFejM5UmRzQnB0ZTFaZFdTMGxhUWpnZG94U2VwbzgwbUdoQ1hBd3MwblhiZVpKU2p5Z0lrSFRva3RPYm9tUThIbUMrazN2MGZKT1N6dmFPQ0lETVU3UXVNb0FyV3g2NTIrY0FzbEMycVBKYzlhQ2tYYnJZWkdFLzRlMXU3bno1aklmdnJsckgzYmJJSGFzOG9JWE44NkZLZCtxNlg2bURaZmd3VHRhK1pQbTZQeTBCMUlYeWk4UFFuYUdEbDVnaFBnR1EyUERFVVN2QjNTQUNGZzZ3VDhYdC9EMmFVTmNYUDdTTHk2YzFCdDM5azMwZGE3SmUyM0FBRWVNUEhBS2JHbDdCVUg0KzJELzNEcTF4cTQ4Yy9YOEt6MkxUUU9ab3RMaVEyUDBmNjh1bnNJSGhrLzFRM01VbWF2Z3BjM2RpRXNMTXhvL3NTNDA4bjhUb1hCeVMwVkZRL0QvU056MUtndGYrTlplSGJwTHpEWTRwMyt4c1UvdTZKd3E2VUk5UFZDMHJUNThQektadkJJenlWWlJsemQyQjhCYng3QnlUMk5Hc1c0cHN3T2ZrZy92N3lSdEluMWtLUFNjSUNtV0I0ZW53K3ZjeXVqYkdiR1lnMlFwMlovMG1CblE3NjZRMGxiN29JbjU3WkdXVVlPSm00Q3p5NzlqYXhsKytMcXB2NjZqdktVWGE1YVB5SjU1bEowazRmaTZ0LzlFQkxzaDZMdFZ5UHc3Uk1rU2VVSnJ3dnJrU3BuVlRnNEo4R2x0UjBSUVB0elZCMkJsSjVWVlQzWE4zOEIzK2RYZFhYS2hoQ3dWd0xHbnROOGIrVnROQjNCdnMvaDVKRmVvWEZKbWdiNUdzMkVVOUswQ0h6ekVGZm8yVitJdEg5M0QvNENQKy9iNnZsLzdvOW1DQW55czFlVVZ0ZHZZODlLL3pjUGtJZG1vejNTRjBGd3dDdGMzeklFbmxXR3FYZDdocUp0NFhWK3RkWDF3OXdHOGUvNEdqM3JPZmw2WGNRTGtsMmdjU0tSeEFVRm12NVA5ZmtlL1g2OUxxeFZzNS9aS3c0bGdadmtsV056YU4rZk5JdXpHVUYwRHlSTmx3OVBUaTNGZytQejFIdEhlMi93KytYS3hnRUlDL0ZIdm9iVFNXT2JIRDZQVCtIR2ptOFFGaHBpYnJNVHRGeWd6MU1Fdlh0R2JQTEM5OWxscE14WkdkZTNEUVBQZ09Sck5BMXVLVDBSNVBjQzE2amYrcWw0cDQyNC9OZG5DQW53UWRFT2EzRnVXVlBrYmZBTG5KT2tnbXVxSFBCNWRBYU9MdTVJbXI0Z0hoMmJoMGVuZjFmdjZCeFZ2MUhYNC9ISlgvSDR6SEw5S2hOczIrd2gxNTI5RTVHenhuZHFhcDBGWkwrWE4vRGl4azZreUZFUlNWUG5KbUg1SVlMZnZhUWZvWVkwMlVOd1lXMW5wTTViQnhmV2RNRHRQVDhnWFlFbXF0TmhRZjVLOEw2d3NnMnlsT3hKOE4yUnJmd2dsZS9zN3cyUXFVUTN1TGlIUDVnam8vVHM4bDZjV05nWno2N3V4L0dGbmNEZkpkazNBZCtuRnhFYUVvaGtXVXJwUVBCdjYvVzlJemk5cEI2ZTBVTXZkZDdhNmxob1VBRDkzanJoNXU3dmtUeExDWnhkMWdqUExySmdYUVB1NlFyQUxVVTJuS0V5OXc5TlJjWVNYWFQxeVlZUXNGY0NiT0puN0RtZHRWdy85YncvdDZJbGdueThGQjVITWd1NGQzZ0czVU4xU1ZnSWhudmEvSGg1Y3pkU1pxOUFzMGlGNGZQMGdnalRWdlpETXZhc2RFdWVoWlFPT1hIbTkzcDRkSEl4bkVqZ3ViTi9DdDQ5djVhb2hHbnRwUWdKOWxlYm9hR0JlSFJxTVFtL2dlcjdyVjJqNlgzUkVlbUx0RkxmV1pBK3Y2SUZMdjNaQlJtS3RndmZSd1lpOStrM3o4SmhXcEoxTkE3T3lGTG1NOXpZT2d4OGI0UUV2VlA1TXBmK0RQY096Y0RweFhYZzRwR0o3bzBDYXI5dC9oY0c3MXQ3U2ZsVUdhN0pNcEhvNXdEL1YzZUlVMHY0UGI5QmZheE5BNU10eUZ5bWowbmRZK2FuRjlXRWU2Wml1SGR3S3M0dGI0NjBaRmJDTExPVzdZOUxKRXVlVzk1VW1lR1lZM0pzVWlOaW1NbHNEZlhiSjJmb0FWbEh3V090MysxZFkvRG03bUZrSWh1andPeVA4T3IyUHRVVWZvQ0dCSkxtUWVOSUFyWTNRa2tMRWZ6dUZaeEphOEVwSk5BWG9mVEREZko5UmcvYlVMQTJnMys0Z2U4ZnhzSHZYdERvTFlYS0c5bC8vT01NOEEybWVyamNpOGl5eVg1N0lrRFRUQStQelVYMnlzT1VscG03SGhMa3EyWklNbjNTbVRUUTdqUWR0VU1SNGQ5ZldHaVErbDN5S0p1MTE4RitMMG1qbGdhdUtYTWdlZFl5U3VQQW1WL2ZQYWpLeUg5Q3dKNEpPTG1sTlBxY2RpWXR0UCtyZTNRUGhhaG5QVE1LSWExVXptb2pBSHFSSnFFQktyLzh2Ry85aTV3MXYxY3pRYnd0eWJvSUdIdFcrcE9TelBmWkpSUnB0NVlFekYvaFN3TWh0MVI1ckt2aGNkd2FWdElFK3JKTTRrRy80eVRxYkN5dkZHNjluTFN6eituM25EUjhIMm1aQTk0K2ZpLzdhRWk4MXBEQVRJcEhFakQxN3cxV1BxYW9VWjZVUHdHcW5JYmtKRnRPTDIvdFFlNWFQeENqWjhvOGpMWHRTVkxud3V2N1IxVzMzajIvcnQ2bnB2UXhKSUJrUXhyTWhQaTlSaUN4WlEwMnp4QTRrWDE3a2pTNVVhalZNcktQQ0NQR1BrcDRONlhPdU01amxrRHQ1SmFDak05L0pyT05BZkFtd1RscG1ueElucTBNWGo4NFJwMTdpN1FGbStEYXB2RHBFbE03b0hGMHBoK29LejJrZzlUVUNZLzYrR0x3S0ljMlRLMUc4Z2tCSFFFMnpRajI5MGFLYk9WSU0zMll0TTJGa0lTbW5jNnZha2NEdnc1S1lOWmxqbVNESDViZU4zZmhPdG5SU1JJQ1F1QTlBUnFBOGpNNjRuT2FGU2dPRG9hdmxiUUZtK0hOL2VOcTJqdC9vMW1xQXYvWDkrbmw2RWJUd2xYeCtOUVN3V3BsQkl3OUt4MmMzVWpyT3BPdXJ5T1pma3hSNytWM3oyOWFXY3N0MDV4Zy8xZHdTNTZORkhSUHlQUWdOWmtGa2luQ0g4MC9xbHhwUzhzTndPWDFQWlhTc0dDekJSL2wwZTdnZDRsakJJZEczbmVEZk5IZWVwM1ZaclBwVDlaSWF4eGNrYTVnVTVxVm1xNzZ3Z29ySnpKeDRhUnhKTG1PQnR1eFNpUVBzam5OK1pXdGRKcitXTlZud2NLR1R6NFRLdzRKZUVQYTRIZndyREVhUGc5UGtBRGRsS1orMkVtRlZQNjM5NU9LdnczNGdXbkthTXN0WlZaa0xrRm1IVHg2ODc1Qm11WW5OTEo3U05PSlg1TEdrTFROWkRJU1FIVkpFZ0xtRUhod2RCNXBsemVwb2p5VDRaSWlLekxRVkIwNzBuamYzaHR0bFQ2UHp5cUhsQXhGMnloekpOWmNQNzM4ZDdUbEpJTVFTTXdFZ3VnK01QYWM1b0ZydGdwZjRBMjlGOXhTZXlvRS9MNUlTVTdyR1FQZTB1QzJESjZjK1VPOVZOK1FBb1o5YWdMNU9TOHBRUW13VFcvcXZMVklJOGd6eXI3S3B5VGlzOUtOVEJMeTFKK0NoeWNXS0hNNmJqQXIwSnpkMDVIcFRqSDRlSjFMMEQ1WTh1UnNicENEN01NZm4xNkdWSjRWMWJzaWxNeFRQMG84RXhNY2dIU0ZtdE5zWm5ZU0dKMC95cUxkd1ZyYXJPVUhxSHVEN1l3NWVkL1pUL2ZMUUhoZFhFZWEyOUo0ZUhTT1RkOFByQVI5OCtBNDBoWnFBdDhuRjFRZlgxN2ZRYk5SWXhCQ3lsSTIvL0E2dDBydDEvN25UMDdQR1VuQnhZTnoxdnhIbDlqaXdkLzdGbkg3a3N6RkxwS1pURUV5bTVtaUZMRFJsWTNyNDQ1T1RpbkdtSE9TbHpkMnc1a002ZmxIOU9UMFVvSjRURlhqeE9ZWmRGTyt1bmVRaEdIK0Z3YWZKK2RVWjFsOTcrdDFnWGVUVThOYnNxdTVUcmJXRDhLbkJnbm0vU096cUtnL2FRUjNLMXN0MWxqZjJmK1RtcXBud2RyUCs0NmFpamZXWHI0WUdZdlVpOElaOGVQUUxjYnFrWDIyVDRDbjE5aUduNTFoV1VQTmpsQ3NyV1k3Zi8vWGQ5VnY2K25sRFRSRjl3TCtMKytvYVNXRDMrV0w2MVNEaHJRVFQvSHV4VFZ5c2oxSTNzdkYxYlRjOHl1YjZMY2NaUHVRcEFkQ0lJWUVkTTl0dWo4NEdYdE9jMlFFRi9lMFNwbkNkdEwrWkYvNzlzbHBOVlhMbXV2bjE3YUFUUWQ0WU9wS3ZqZHNaLzMyOGVrWXRrU3lXNUlBWDFlZVNuY21YeVdYcE9uZ1NPOWRubm1PK0t4ODgrZ2szajI5VElPZ1QyZzZmejllWHQrdWhHOTJVT1RJYVA2djdscXlXUWxhbHovSkd2NHZiOE1qVTNIbGxQaUlITjlZWVJoUm52SHhPayt6TDBmSVViT3dNZ2NNZVAyQVRHRXUwb0F4VEFtVXJJRW1nVWdOTnQ3Y1A2RzdOMXc4TXBBZndSNHlqZjFYRFdLUzBob2JyKzhkb3ZmVXRRVHR0eVZPemc3Ky9ONWt4MFJPYlByeWp0Ni95V2pROWVMNlAvVGMyTU1vZGUvZHR6VDRUa3ArRlg0dmIrSWRPWUR5d0l6NStkRnpKcGdHNDV4WU9OZG55YzhXTndybnliL1g1MWMycW5lNXlwakEvMmxjM2JKWkxLYUpSL3FpTktvYmpyc0hwc1Q3YUpVRjZneEtvTjRTQ1ZKK2JGaXNxNUdjUTNZTEFTRWdCSVJBZEFRNGlrS095c054WS90WFpGZWFlQVN4NlBvdHgrMlhRTW9jbGNpZU9EY3BadnlSNmRQdTVNakl6b20rOWdza0VmYmNvZ0oxcXB4VlZQZzhqajFvZlVrRWF1dTdKdElpSVNBRTdKRUFoOXhqSnlPZS9aRWtCT3lCQU0rNHB5UC9NdWVrNlVtcnVvbG1BTzdaUTdmdHFvOFdGYWl0bTV3STFOWjlmYVIxUWtBSUNBRWhJQVNFZ0JDd1RRSm14NkcyemU1S3E0V0FFQkFDUWtBSUNBRWhJQVNFZ0dVSmlFQnRXWjVTbXhBUUFrSkFDQWdCSVNBRWhJQ2RFUkNCMnM0dXVIUlhDQWdCSVNBRWhJQVFFQUpDd0xJRVJLQzJMRStwVFFnSUFTRWdCSVNBRUJBQ1FzRE9DSWhBYldjWFhMb3JCSVNBRUJBQ1FrQUlDQUVoWUZrQ0lsQmJscWZVSmdTRWdCQVFBa0pBQ0FnQklXQm5CRVNndHJNTEx0MFZBa0pBQ0FnQklTQUVoSUFRc0N3QlRaRm1LKzFrK1VDSlEyM1puNDdVSmdTRWdCQVFBa0pBQ0FnQkljQUVuTklWYmlra2hJQVFFQUpDUUFnSUFTRWdCSVNBRURDVGdKaDhtQWxPaWdrQklTQUVoSUFRRUFKQ1FBZ0lBU2JnZFAvd3pIZ25FUkx3QnNIMEY3OUpURDdpbDdlY1RRZ0lBU0VnQkdKRWdGVmNvdVl5RFZrb1plTS9TVUlnRWdLdXliTkdjaVJ1ZG10YzNiS0pEWFhjc0pWYWhZQVFFQUpDUUFpWVRvQ0ZhVWZUczl0MXpoRHF2UWpVZHYwVHNMYk95MWpZMnE2SXRFY0lDQUVoSUFTRWdCQVFBa0xBcGdpSVFHMVRsMHNhS3dTRWdCQVFBa0pBQ0FnQklXQnRCRVNndHJZckl1MFJBa0pBQ0FnQklTQUVoSUFRc0NrQ0lsRGIxT1dTeGdvQklTQUVoSUFRRUFKQ1FBaFlHd0VScUszdGlraDdoSUFRRUFKQ1FBZ0lBU0VnQkd5S2dBalVOblc1cExGQ1FBZ0lBU0VnQklTQUVCQUMxa1pBQkdwcnV5TFNIaUVnQklTQUVCQUNRa0FJQ0FHYklpQUN0VTFkTG1tc0VCQUNRa0FJQ0FFaElBU0VnTFVSRUlIYTJxNkl0RWNJQ0FFaEVBTUN3NGIyeDlvMWk1QTJUZW9ZbEpLc1FrQUlDQUVoWUVrQ2prNU9LY1pZc2tMcnJZdVhIcGNrQklTQUVFZzhCRHc4UExCMDZVeVVLRkVNMWFwVnhMTm5MM0QxMmsycjZXQ083Tmt3Y3NRWDhQWitoY2VQdmF5bVhWYmJFSDVOaVpyTHRNdkRhenpieVRyUHBnR1JYQWxOUUpZZVQrZ3JJT2NYQWtKQUNKaEJvSGl4UXBnMWF5S1dMRmtOSHg4ZjdObHpFTU9HOVVlRkNxVXhidHhVN05pNTE0eGFUU3ZpNXVhSzFxMmE0Tnk1aXpoNzdwSXFsQ1ZMSnVUSW5oVTVjdkJmTnVUTzdhbmFranQzRG5oNVBjZkZpMWR3OSs2RDkzLzNjZlBtSGJYdDlmUVp1R3lONnBXd2JkdHVQSC94MHJSR0pNWmNMRXpMMHVPbVhWbFpldHcwVHBJcjNnaFlyVUJkcjI1MWxDcjFDVmF0L2dzM2J0eU9GSWduUGJnN2RteUZDeGN1NGUrTjJ5UE5CL0RRWDRhelVRQ1NRM1pJSUxyNzU4SDlNeVNzK2FKQXdZb0pTaWY4ZWZBcE5tNzhCK2ZPaHd0d0NkcWdCRDc1d0FFOVVhZE9kZlR0Tnh3UEhqdzJhRTNHRE9tVllKMC9mMjc4L1BNYzdEOXd4T0M0SmI0MGFWd1hhOVlzeElzWDNyaDA2Um9jSFIzeDhPRmpKU1RmdS9jUWQrN2N3OTE3RCtEcjh3NGpSZ3pFNHNXcmNKSHk1Y2lSQmJsemVjTFRNeHV5dnhlK00yWk1oMXkwTDB1V2pGaSsvRS8wNmozRUVrMjB6VHFzU0tCMmRYTkIyMWJOY1BUWVNWeTcvdkdzUjhNR3RmQkpzU0lJRFEzRjRTTW5zTStFMzFucVZDblFvWDBycEV5UkhJOGVQY0VmcTljaHdEL1E0RnBseTVZWmJWbzFoWnVySzY1Y3ZZRjFHelliSE5kOWlRZUJPaXhqRUJ4eUJpRXNpQ1NJeTBrUTVtdkNURGRmdzRMKzBLUU1SZWd6UjJodXVBS2h1bGFIYnpqVFJ5RS9hTnpERVByWUNabzdMallubmd6bzN4TXBVNmFJMExId3Izei9MLy9qVC9YRnlja1JiZHMwUTg2YzJkVzdaTldxdi9ERTY2bEJPVmU2MWgwN3RFVG16Qm5oNStkUHN0eTJLT1UrTHN6dmhFOC9MUVlIQjQzS3UyNzlaZ1FIODQvaVEyclpvaEVLRk1nTGYvOEFlbDc5amZzUEhuNDRHR0dyY2FNNktGNjhDUDc1WnpmK08zazJ3bEhUdmxxdFFIM3d3Q1lTcUl1VHBtVWF4bzJmRm1sdkJuMzVPU1pOK3BhMEg5ZFFzbFN0U1BPSlFCMEZHamxrdHdTaXUzK3NSYUNlTm5Vcyt2YnRpbDY5QnRPRGVwM2RYaSsyazE2NGNDb09IejZCYWRNWDBBdUUzdlNSSkJhc1I1QzVCUXZXRXlmT0pLSG5Qemc1T2FpWFN5UkZUTjdOQTdGRGh6Wmo1TWp4V0xwc2pjbmxJc3ZZb0g1TjlPN2RXV21zK1FVOGFQQjNVZll0c25wc2ZyOFZDTlFzU0hmcDJBYkRoL1JIOW14WjBLcGREMnpldXNzQTdiZ3hJekIwY0YvMVcrTEJsS09qQTBhT25vQ1pzeGNhNU5QL2tvV0VwVjNiL2xTQ1ZWQlFFSnlkbmRWZ3IzbnJidkI5NTZleWZsSzhNUDdadEFvcFNPQU9EZ21CczVNVGZsMjhBdjIvSEtGZlZmaDJIQXZVbWsvOTRGcUhCTjQzWVhBZ21aaVQzMHBYYUx5Y3dyOFkrNThFWmFkMnZuREtCSVI0MDJSREtpRDRaaGlDTjNoOEVLcmR3dURjNlIwY1U5S3VOMlRoazBxRG9BdGhDTm5xYmxOQ05jdG8yYk5uTWFEQXY0TTA5SXphdEdrSFdyZnBSYzhiUjZ4WnZRZ05HdFJFVUZDdyt2NzQ4VlBVck5VU3QyL2ZVMlhkM1pOaXcvckZxRktsUE42KzlZVzdleEw0K3I1RHc0WWRjZnpFYVlQNnRWOW1UQitQeno3clJIVUdJU1FrRkVtU3VHSERocTNvM0tXL1RxaGVSTS9KVHAxYTZjNzc2dFZyMUtyVm1nYjJWN1hWNkQ3VHAwdUxFeWUySTBPR2RCZzBhRFRtemY5ZGR5d21HM3o3V2wwcVZEQWZDaGZPcDlyVnJGbjlLTnZYb2tVRGRUeHZYaytVSkR0Q1NVSkFDSmhPUU80ZjAxa2xkRTQyaVZoUEw1NUprMmJpNXlsem9oVTRXUXMwYVBBb0RCZzRFbDI2dElIWGsvTzRlK2NrMk80NnRxbHk1WEtxSFpZUXBya3RXOG5VbzNtTGJxcTlWMGtydVd6cGJIcjVzaHBQVW53U3lKOHZEeTZjMm85WjB5YVFZRVRTb0pIRWVmcCszZzNuTGx4RzdvSmxVYkJZUlR4Ni9BUkR2K3lEMUttTmwrRnFSbjh6UkprQ0RmdjZCNlJLbnhmTFYveUpLcFhMbzF2WDlycXpUSnN5bG9TakpHaEdRbmEyWEovaTJJbFQ2TnFsTFdyWHJLckxFeThiU2NMZ1VpVVVRYWZDRURqUEhmNXozWlh3NjF6WlAxdzNGMGtqTkVYODRKU2VCTytsTGdoYTZBNi85VTV3eWsxYTdWd0J1aEthVW41d3BGdlE3MWMzQkM2Z3VyYzR3TGt3eWRLWkloOGM2d3BiMFVhbHlvMlJQVWNKZzc5SmsyWWhMQ3dNSzFhc1Z5MWxEWEg5K2pYd0J5bEJVcVhPaStIRGZ3VFBTUDAwYWJTdUo0MGExZ1kvVDM3N2JTWFNwUytJeG8wN3c4WEZCV1BHRE5mbDBkK29YYXNxZXZic1FBUDY0eVRRbDZBQldpbWNQSGtPVFp2V0F4L2pWS2QyTmJSdjN3TGJ0KzlGeGt4RjBLUEhJQ1JMNW9HWk04ZnJWNlhiSGppd2x4S21kVHZNM0xCS2dacEhLandGd0ZxWVBIbHk0aE5Td3h0TGZLeHc0ZndxbjZPakUycldyR0lzbSt3VEFrTEFDQUc1ZjR4QXNiSmRHZEtuVTRMbHBJbWo2S1hRQVUyYWRNYXg0NmRpMUVxMlZlN1ZlekRaTVQ4allkb2RuVHUxamxGNVk1bmJ0R21LbFNzM0dEc1U2MzJ6WnYrS3RXdi94c29WOHl3aS9NZTZRWFpVUVViUzBMRk5lNXNPdmJGMHVmR1poN0psU3BBV01Tbm1MMXlLbHkrOThaQk1OOWF1MjR6MDZkT2lkTW5pa2RLcVdhTUtIang4aE45Ky80TzB6NkdZTm5PK210NXYyYXloS3BNbnR5ZUtGeTJFRXlkUFkvdU9mOEVheFVtVFo4RkJvMEdMWnVHS3MwZ3J0L0NCc0d5QjBKQldPdmkwVzdqV21PVGhvUE1PY01wS3dyRnI1S2FqRHZsSUNIOFlCczJUOE1HZzVwWXJRbGxUblRzNHZJVWtjVG5sb1R5M1NDNzNmbThzZjlVTm9lOUlVNTNMdGdScVk4ZzdkMjZ0bmpQLy9udElIVzdWcXJIU0VNK2R1MFJwanVmTlgwTG1HWGRRcVZKWnBFcEpLbnBLTFZzMlVua1dMMTZwdnUvZWM0QXNEcTZTbzNWUnBFdVhSdTNULzY5eDR6cHFSdVNYWCtiaTFlczM2bS9ldk4vSjlNTUJoUXJsVjFsWnVLYWZEUW5RQzVXMmUrV3FEVGg5K2dLWmlCUkYzank1OUt0VE15YTllM2ZFblR2M0RmYWI4OFVxQmVwV3JScmgrZk9YWUVndUxzN0tlOTFZNS9nR1RabzBDZWJQWDRvblQ3em9aVlBYV0RiWkp3U0VnQkVDNXR3L3FWT2x4RysvVG9mM3kydnc5N3VISjQ4dlVCU0hMdzFxWjF1NEc5ZVBxZU52WHQvRStuV0xrUzFyWm9NOFBNVi8vdHhlK0wyN0M1KzN0L0hQdGxYS29jMGdVeFJmV0t2QjU1OC9id3JWczA5dGV6MjVnTjY5T2htVSt2cXJnWGowOEp3Ni92clZEU3haUEJQY0IxdElzOG5oOE83ZGt6aDFjaWV1WGJ1RlRwMzdxWmVIdVcwdlZyd0cyU2tYUit2V2pjMnRRcFhMazhkVDJVTEdwZlBnZXBxK1hibHluWm9LdG9SR1BWWWR0cVBDYkFkZHFWcGpiTnk4UGRKZWYvcEpVYVdGMUxkSHZYVHBDZ2t3R21USmJIaWZheXRoUjFXMm0zN3c0QkhldlNNdEx5V2VlbjlDZzd5Y250blY5eXlaTTVFaXpZM3N0VW5hZko4dVg3bEsrZCtoVU1Gd1FVbTdQNjQvSFZLRkFvRWFhTjYrRjNycGhLRXZhZHVWNU90a2huYTZ1cmFRTk9XWWdyN3ArOVJTTlNHdlNBRFh5b1ZVaFVOeURVSmZrTFNuVFNSSGg3SHBSenJLYk1PcFhObVNLRmd3THprVzAyRG85V3ZWazZ6MDNQZjE5ZFZGSG1JYjUzUGt4Snc4ZVRKbGlzYVoySmVDcjdIK2RiOTE2NDRhVE9mMHpQRVJrVjI3OXVPNzd5WWJtRzc0K1lXYkRMSDlOU2YyeWVCdDl1ZlFwdi8rTzZ0TVE5aVdXejhOSHRSSGFjVFhyOStxdjl1c2Jhc1RxTm5idTFpeHdqaDI3QlMyL2JOSGpYYTAwOUlSZThpamtKY3ZYNEVCNzkxN1JKbUpzTG1JSkNFZ0JLSW5ZTTc5TTJQR2VKcEthNDR0VzNiUzlOMFA0T241MGFPSDZMU2ViVm8zb1FIdUZMSnJDeUg3M1hGS2kxbVhuRWRXcjE2b0JyL2NLcmFUWExac2pwcmFaUnRjbmg3a1dhbGZmdmtoK2taSHlNRWFrYk5uTDJEcTFQbjBRbmNnbjR1UkttSUVaK3ZYdHp0Tkd3N0RyVnQzOGRWWFArS3Z2N2FCTmF1VDlLWWJJMVJuRlY5WjhHQ05kSTBhbFJBUUVLZzQva1oycExGTmJHL05HcDNqeDArcktWRno2K01wK2lWTFZwcGIzT1J5TEZTUEdUT1pZbXd2Qk51RFM3SU9BbW5KRkNRMGxFd2hBajlvVkxVQ0ZDdkFva29hMGlMcXA5Y2tlTEV0dFg1aVRhTTIzYUdvTVA3a3RPanFTazU3OFpnMFNVTVFSbjAwY0NaODkxNElkb3BFUTAzQ3NvWVYyaCt3aExmWVR3TUg1L2RsbkVPaDRlNitWMWhydXhUcVI4ZWpNTTNXNXJQbVQ5Wkc4N1ZidlhxRFFUTjVvS1YvVFRtMEorOWpLd1JPS1ZPU3ZUd0oycS9wMmFSTno1NjlWSG5ZTmpwaTJyaHB1eko1MHhlV2E5V3FwdW80citld3p1ZmdQMjNpZHhWLzEvK05GaTFTa095c1c5S00yQ1p5cnI2aXpXcjI1NGRmcnRsVldMWmdkWXFsbWp5NWgrcmcyN2MrT0hyMGxETHI0T2xwL1pRNVV3WnlXaXhHaHVSbjhJS21uZGo3MzgzTlRiMlk5ZlBKdGhBUUFoOFRNT2YrNGFteWhnMXI0ZFNwODZRdDdRK2VtdS9aYXhCcEF2elFvVU1MZFJLMlJRc09EcWJJTy8wd2ZjWUNmTjVuR0QxZy82YXB0aUk2KzdhR3BGM21sK2lJRVdOVm5uNzl2NktCODFNYVNCZjZ1S0hSN05tK2ZZOXF5emZmamxkMmVpbFNKRU54R3BCejZ0V3JJejJrM3lybm1KbXpGcUZydDRHNGZQbWFzdWxqZXpwclN5eElqL3AyQ0QzN2ZsVm1iSVVLVjBhS2xIbkl2bmlYUlpzNmI5NFNjdWpwYkZhZGJOZGN0V3A1N041enlLenlNUzEwaU16K09BUWcyNDViV3FqbTBIKzhJTTZ5cFhQRVhqdW1GeWFHK1RsY0lnL21jcEUyT2dWcEp6bHhoSWgwYWJXcVc1RHB5R01hUVBxakdKbDlhRlBCQXZsMEEzSHRQdm0wUGdLc2NXN1JvcUZTWGh3OGRFelhRSjZSNEJtbVlrVUw2dlpGMUJEckRwaTV3YitYMXEwYjRjeVo4emh3TVB6Y3JPRm1ZVHhmdmx5Nldrc2FNVWY2OXR2QlNoQ2Y5Tk5NWGI3WWJGaWRRTTJqbkRkdmZIRG84SEhWcjNWa204WDJXanc5clo4cVZTcW5wZzNXcjkraWRoOGtrSzlldlFHYmkwZ1NBa0lnYWdMbTNELzhJT1NIMU5tekYzV1ZzejBjZTBVdlhMaE1lZWJuelp0VDJhTDlkL0tNTHM4bTBpaXdacUFzVFFseUdqOWhPcEtueUkwLzZkN214Tm9KMXNTeStWWk0wNTA3RDNSRldBUEJLUldGNWtxWklnV0ZZTXBBb2R5ZUdDd293bE9GMzMzM2s2Nk1OV3hvQmVtTkc1ZXJ1TTYxNjdRR2EySGlLdDI1ZTE5TjJlZk83Um5qVTlTcFhWWEZ1NDRxdWtpTUs0Mm1BQXZWM2J0L1NiTWFzNUUvWCs1b2NrZC9tQWNGYkhLMCtMY1o1QUJWUjVuQTFLaGVNZnFDa2lOV0JIYnUzcWNjdjc0YU5wQk1RekppeGkvamRMTkpYUEVOc3ZVL1RiTk54VWhyK0htdkxzaEZ6NXQ1czM4eTY3a1FxNFpLNFJnVHFGbWpNakpsU285VnEvNVd6M050Qld2V2JGVDJ6aVBJTEpDdk9ac0gxcXBsS010cDg1cnp5YkxoM0xtVGFVRHNwR2J5dEhYd2JDUkgveGc1OGtzeU44eENzNVhkMExadEUrMWg5Vm0rWENtS1BsSkRoZXJVUmh3eHlHREdGNnVhWkVoREhzSmx5NWFnbDJzQXVuZHJyN3JEUnVtczhlTHA2ZmtMZnRkMXNWMjdaaXIrWmZueXBaUU5EaDlnVFJtYmk3RFpDTWRFbFNRRWhJQnhBdWJjUHp4VnhvSXhDNy82YWRueXRlb3JoMUxqRUZvYzgxTS9zVm1XTnJTUmRuK1h6bTNvWWZlRldnUkVPeDNJZmhPV1NEekx4OU9JM0JZT3E2U2Z0bXpkcWY4MVFiYXpaczJFNXVSa3haRXRXTEJqelE3SGFhNVJzeVU5Nnd6YkcxY05aUCtVM3IwNlk4VElzVEU2Qlp2WWpCdzVMa1psTEpINTZyVWJHRERnR3dySHRZenN0OTlSQ01YaDVKeDUydVNxV1lpdVVya3NDYzlOYU1hekFIYnUzSXRSb3lkaE9vVWVaRTAxUnhUWVE0NVU4Y1hmNUlZbm9vempKdnlDU2hYS1lDalpyUElmT3pNK2Z2S1VURWMrUEUrK0dQd3R0bTlaalJsVHczOWpGMmthbmtPb3ZhSFpha25XUzZCYnQ3YnF2YkI1OHc2RFJtNzRhd3VaMmpWQTgrWU5LRWI5Y1dYWGZJbHM1emsyOUpzM0gwdzhEQXJGNE12WUg3OUd5WkxGOE5OUHMzR1FvbjVvMDg1ZCs4Z3NiWldLQm5MOStoSGw5SGlCb3RJVUozTkQvajF4K3Y3NzRXUzc3VWN6cll1MHhXTDlhVlVDTlU4bGF1MXB2dnFxdjY1emJCdko1aDA4VGYySWxxOWxweUlXdkNrNkMwMHR0OVRMcDZHcFpDZXcyWWcycUxqdW9Hd0lBU0dnQ01UMy9jT0NPQWZmMXlaMldwdzNiN0x5dXVZNDg3eHdFOXRVbTZPaDF0WnBTNSs5ZXBJZ08ySUFDWWc5TVg3OGROU3UwemJlQlRuMnBCODFhckFTSmlNT2dDSmp5VEd3UFR5U2dqWGNDWkZZcU9ZWkIxYWlqQm8xaEdZdTNXbUFCeFc3bGswSzd0RkNNbmVwYmV5dHo0dmU4QXFOQ3hjdVYrR3orRVg2Nzc4SGxhUDdXVnJkVVpzNEFncW5qUnQza0JLbkxSWXVXcTYreTMrUkUyQkhRcjZmOVcxUnRSRWI5TzJxSTlid2lPSVBWNjdlQkEwYmhKdDhIVDMySC9idC9rc3RCcVROeTQ2S0pjdldRdjE2dFdqQmx3QThmZlljZjYvN25aeHliMnF6eE10bnFBOHR5T0pBQW9iK0hMNzdlNmZCNEEvUE1vUEdoSkRKTmZuR0tSdHAvUU5KYVgvUSt6SkJEZ2pqOFVNRXljdUI4OFJldnRRL2E3eHQ1OG5qaVlvVnkrRDgrY3UwYXVxSGU0c2J3TE9QN1R2MG9XdGVTeTNhd3BZRTdHUERLN3ZlZWgrSG1oVXVMUGR4N0hHdEhYWDY5R25VTEpyV3lkQllaOXExYlVxbWExMndlL2NCakIzM3kwZFpPRndvYTZwNVp2Vy8vODRvQVZvNUt0NS9pSEpsUzFHYlN5dDU4ZktsZ3dabHAwOGZTN091bjVtMW1GbUV5MnBRYjd4L2FkMjZxUnBKVksvZUhDZFBuZE9kZjhqZ1BwZ3c0UnNLdFZJT2F5aWNFc2NzVEowNkpYNzQ0UmZvMjc2d2dmbUJBMytUMlVkakVhaDE5R1JEQ0JnU01QZitZUTB5UHlBelpqUjBFT05JRzk3ZXI1VzJrODJ1T000bzI5UzllZk5XblpoWHYyTE5OdHUxY1dyWnNySFNXSC81NVNoYWtTcmNOSVJYVzdOa1lxR1BWM2hrOHcvOXhGT09CUXJrd2RDaDM4ZG9pV3NPSjhZMm9LWUtuL3JuakxnZEVoSk16Nm1qSkJST2luRUl2SWgxeGVZN2g3M2pFSHFtQ3BIc2pMcHk1Vit4T1dXc3k3WnUzVXRGQnpoMi9JeHVFTUlhNWh6WnM2blpqdHk1YzFLNHJXSzBTRXduWlNySU52VHNRS24vUGpIV0NQWUgyTFA3VDdKZjM2aXVzN0U4c2krY3dCa3l5K0Q3T1gvZTNHQk5JS2VDRklXRDR3OC9mUFFvUEZNay83K21aOEtLVmV2VjBlNWQyNUU5ZFhKczNtWTRhK1QxOURtV0xGMmw4a3o0OFJzUzNoMng5Ui9MK2hGRTByd1B1MVZFRDFvaE1VVXdORS9EeFNRVitZTW0zL1FqZjN3b1FGdjBDQXVqaUI2YWRDUThzL3pNZm9na2tIUGtqNUI3NzNNR1V6WUtnT0dRUGhRa2Y0Y25jbExVSktQSUh6ZmZDOTNhL1RieTJhaGhYUnBvdXl2VGljaWF2T1g5d2tCRmFIYW9TSkVDS29hMFZuaG1wL0ZpeFFxaUlHbXRlVlZPVGpsejVsQkM5KzA3ZDQxV3lUNTFVMm14cnljMHc5R2JWbGJsOTVLeHRHdjNmcldiclJiS2x2MlVmR2l1cXdFY0M5WkRobnluZnNmYWNyeVFJTWZyWnpPVnJWdDNhM2ZINkZOLy9CV2pncGJPekMvZ0NoVktxVEFuRVI5K0hNQ2JwMjU1bXBwVEN3b1d6bFBJUE5yUlQrZEpwYzgybGF5OVp2TVJTVUpBQ0h4TXdOejdoN1ZIYkVwVm1hYk9DK1RQb3lwdVMxRXplSmFJblFFNTdkeTVUd25jSElxSUV6dVNEUnpZVTAydGFXT1Rob1dGS3JzNnJhTnhoL1l0VlF4YlZjQ0MveDBub1lzZnBKMDZ0bEsxNXNxVkEvMzdkMGRSY3BEaGtHKzhpdGRudERwZnU3Yk5vendyYTJCMjdGaEQ0ZXRpLzFKbkhoeTlvMzZEamdrcVRIT0hWNUJBclhVbWpSTEErNE1jSVdWOVpNdEFtMUtCQmZMd2RXT2JhbjNUREI3a3NQWjZ4ODY5bUR0dk1RM3N4cWw0M1QxNkRGWUx4VVI4bnhockJ0ZkhpMUt3cmFla3FBbXd0bytuelh0Mjd3aU8rTUcyc1czSmxPWXBDY0luM2kvWnpJUHFJYlRRUzhYeXBUK3F6SWxXMCt2UXJnVW1qaDJsRm9SWnZXYkRSM25jeVo5aStKQitHTkN2QjA2Zk9ZZTkrK1BIQ1ZiWGtFZk9DS01JYkU0bFdZS212UlNRd3JsWUtJSWZrSlFjOEY3dzVYalV4VWtsclJlWE91U0dvMW9sRVZuQ1RiZkNhRUVYQnhKRlFtNisxMTFTa1dBU25KMDlOUWhMUzlJMXB3TCtVQnJxV3lSWjIyRGkxUWg1NExxWklqOUZsU3JRYjRGbkl2bTV5ekdrdFlsWE9HVHp2SjQ5TzZwanZEaExrU0w1bGZNN1J3VGh4TTlwWHRXWHRkaHNOLzM3a2xuS242Y2JPWnF6MVVKVWljTThybG81bnhaMlNhYmlVbk5lWHZhZUZRa0x5UGRIKzdkLy94RlZEYTkvc2lwQ3BKS282dGMvWmpVQ2RjVUtwU21JZDFvVkxrKy9nYng5OHRSWkF1Q2xCT1VjRkxPd1NwV3lGS2Y2QlU2ZC9xREYxcGJadCsrSW1qNWc4eEZKUWtBSUdCTGc2QmJtM2o4Y2RZZnRaL21CZHVyVUxqeCtkSTYwZnpQVmN0RXNqSERpaUF3ODlUZHk1RUJhbWU4aVRkVWVVZlp5WThkT3hZV0w0V0dKRml4WVNnSlJNSldkZ2JkdmJwRlR5VTlLNEdiSEV1M1VzV0dyemZ2MnpiZmo2Q1gvRElzV1RWWHhzcytkL1ZlRjN4bzFhcUtxc0dTSjRpcFUzNnhaNDZPTWdSMGNGSzc5WUUzb1FETFRpRTFpVzkweFkzNDJFQWhqVTE5c3l2SzBLNjh3VnFONjVXaXI0VlZvMlJuVkVocjZhRTltZ1F3c2RLK2dPTll4U1J4TmhWZm9OY2RaTXlibnNmVzhWNi9meE95NXY2bEI5ZlZMeDNEcDdBRTFjUDVweWl5MTBBdjNyMEhkV3BndzlodE0rZWtIZys3K1BPbDd2SHAyQTc4dG1LNWlEN2Z0OEpteW85YlB0SG5EY2p4OWRCbGphWG56YTNTdWpsMzdVdDd3K01MNitlSjBtMExkQmU2bkZReUxBaTU5Zk9IVzF4Y2FqekFFN2VPNGVPRm4xaFR5aDFzOUNvTlgvRVBid2k0a1FmQVR3SzFESUp4NytTQkppMkFFWGFjQ3RNQ0xOb1dkVElJUU11OUkwaTBBTHIycDdnYTAwQXVKTXBySHRpZFFWeVNiK0FJRmNpdmxabVIrYXczcTE2TG4vRTF5Wmw0SFQ4OXNhclhFdmZzT2EzRlFlT1RkWUxtdGMrZFd0R2JBZVRMVCtKMXNyUU1Nbk1lSERPbURiNy85a3Q0UEtjQ2hXZGx1bW1kSlZ0RGlUL2Z1bnRMOW5UNzFRYk5jaFN3WlhubGZ4NUVqVzhoMnVwQ3lhRmhETTFCeG1hekc1SVBYZVo4d1lRWWlHclZ6NTFtZHp5OGhEdGJORjJUaHdqK1Vwb3dOeWlNbWZsbnpxQ2FpNDFURWZQSmRDTmdqQVRhQmlNbjl3L0dkOVoyR09EYncxYXMzVWE5ZVRhVWhZRE9RTld2K3drdnZWd29uYXd1cWtjbFdheks3NHFEK2ZGL3YzWHZJUUJ1N2ZjZGUxSzdkQnRWcEtXMStLTzZqaDJ2ZXZMbVVOcGx0ZEwxZmhkZWxmMzA0UE42TEY5NFVCZU95MnMwTG5Zd2JONTFzNDA3cnNySG1qUGRwODl5OGVSZGx5dFJUc2FkNVNXU2U1dnQ3NHpabHM4MkZlRWJybTIvR3EvMTN5ZjQyc3NUbUk4V0tWeWZ0aVRPMmJWMUIydXA5U2lNYVdmN0k5ck5ReXYzYjkxNFRFbG0rK053L2Q5NFNqQnM3a2h6eURrUjUydTdkMjVOMktkejVOTXFNTm42UVk2ZHpEUERXYlhyWmVFOWkzM3hlclpEdnVXdlhiMzlVMmZjL1RzYVJvLytoQkswOHg2WWVoNCtjQUM4S28wMjc5dXpEbUxFLzQ0eGVSQ0ErdG52UGZ2V3N1RS8zMjRhL3Q4TFh5RHQ4MWRxL2NJQkNyMTI1ZWgxYnR1NVFxeXBxNjQzUHo3RFRTZUQzSUJnT3VRTVJSc3BremVXazBQaSsxMDV6UTY2NUljQ0ZaSkJMSDRSbGtHSTZlSVU3Z3ZQN1E1TTZGSUhQeUJiN0JoM1h0Mmp6MXlCb3FUdUNPRS95VUlRK2RvTG1Ec1haZmkrb3gyY2ZZM3N1MWl4UG1qU2I1TGJ0a1ZiRlBqS3NjR0ZiNmIvKzNtWVFkWWtMc1J6WHRGbFg4R3huOXV4WmxEQ3QvNXptUEt4c2VmdldWL2x2c01LR24vUEdrcjVNeUhHcUowK2VvMHdQK1hkMCszYlV2aC84M2doL3A1d3hWclZKK3pTdWJ0bHM4REthMUxjSW1maEdzSk91UnVpNWZCVUNRc0F5QkZoN09mZC9QNk5Cd3c0eDFqTHYzTEdXWW1NUHdkMTdVVC9ZTGROUzAydmhXTXlEaDR5bVZld2VHeTNFbXZsdFcxZWllbzBXUm84bnRwMjhRaVdIWTkxRFRvenhubmpPMkRIZXoycWJKK1NKSTMxQjFUWjdJYTJPaGtEVktoVm9JYkUvU0hIek4zcjBIQlJON29ROTdPamtsR0pNd2pZaHZzNnVON0tNcjFQS2VZU0FFRWhVQkx4SkU4OExGWEE4NXYxNkdybm9Pc25PZit5RUU1ZnhwYU5yUTJUSDMxQzdXclpvSEtrQTJhWjFNeFZkNHlocEpPMGg4VXFTczJkUHBJV0MxcXZRclBIYVozNU5XWTBoWnJ6MlBPWW5ZLzJZNk1oaXpzM0dTalJ0VWhmc2I5UDdzeUhLVnR1YW15OGFhbXUrT3RJMklTQUVySkxBaHZWa0trSDI0cVk0dlBIQ0xSczNMa09kdW0yczFnWjUvNzZOMUw3V1J0dkgydW5PdERJbU93VGFTMktuV3JZeE56VUNpc1c0aUliYWRKU2lvVGFkbGVTTUZ3SXlGbzRYekhJU0lTQUVFaE9CZ1YrTXBFVkJ4cW80enRIMWE5aXcvcVR4L05Xb3NCcGQyZmc2dnBiQ2tiWnY5eUdtdi9hOHZGZ1BoMEswSjJHYSs4NWg5SGdSR3g0TXhVWGlNSXlTaElBUVNGd0VSS0JPWE5kVGVpTUVoRUE4RUdCNzQxbXpmbFVPZlZHZGptMnUyY004cnIzTG8ycURLY2ZZNGJCTGwvRHdndnI1V2FpMEIyZEUvVDd6ZGx5RzBSdE9BNnc3ZDA1aTFMZERJcDVXdmdzQklXRERCRVNndHVHTEowMFhBa0lnNFFpd2tNekxpRmV0RW5tSXppay9qNkhZeHVNU3JwRW1ucGtYclRsNzloTEtsaWxoVUtKT25Xb1UzM21md1Q1NytXTHBNSG9jNVdYeGJ6Tm9IWVVHQ2lHdjdDaEpDQWlCeEVOQUJPckVjeTJsSjBKQUNNUXpnUUVEUnFvbGJZMlpCdFNwWFUzRjZPWUZjV3doeloyN1JDMkhybTBydDUvancrb3ZvcUk5WmkrZnZKb2xoOUV6TjNHb1JZNmJ1MlA3V25UdjNnRlRwdndQNVNzMGhGdVM3Rmk2YkkyNTFVbzVJU0FFckpDQUNOUldlRkdrU1VKQUNOZ0dBYll0bmpKbER2Mk5NV2d3aDVvYk5Xb3d4YytmYkxEZm1yL3dhb084aERDdjVzaUp6VDJXL0w3U21wc2M1MjA3ZSs2aWlzVmNnMkttUjVkWWVDNVQrbE1WQlNaRCtuUVlQV29JL3FYRkxIaTF6alp0ZW1MQXdCR3dsY0ZWZEgyVjQwSkFDSHhNUUtKOGZNeEU5Z2dCSVNBRVlrUmcrclJ4dEJMWUFWMVlQTGFUZmZYcWRmeEhpWWhScXovTzNLUnhYWlNnRlNSbnoxNmtsZ211MzZEOXg1bnNiQSt2cUxsangycXNKUk9mRlN2V3E5N3pnQ25EKzRFSEQwTFNwRW1OL1Bsem8zWHJ4dkR5ZWthTEMxMmlCWlNXWSt1MlBUSFQ4TE9LUytKUW0vWUxreWdmcG5HU1hQRkd3Q25lemlRbkVnSkNRQWdrVWdLalJrK2lhZjNWT0V4TFh2T3FYZzBhMUVUdE9tMXRycmM3ZHU2bHBlQW5vMnpaVDdGeTVRYWJhMzljTk5qSnlSSHU3a2xSaFd6bEh6eWdkYVVwQlFRRUtNR1p0NzI4bnVMaXhhdTRkZXVPY2tDZE8zY3A1czVieklja0NRRWhZRWNFUkVOdFJ4ZGJ1aW9FaEVEY0VlalF2aVVXTEpoQ2k2QThSbzhlWCtJUUNkZTJsdkxueTBQT2lYdElZQXhFbHF5ZnFGak10dGFIdUdndk8ycytmUFE0MHRVa0xYWk8wVkNiamxJMDFLYXprcHp4UWtBMDFQR0NXVTRpQklSQVlpZncrdlZyMGs0NzR0S2xhellwVFBQMVlUdnFIajBHSzd0Zlh0aEVVamlCWThkUENRb2hJQVNFUUpRRVJFTWRKUjQ1S0FTRWdCQXduUUJyZUgzZitjYTlKdFAwSnBtVmsyMkUvZjBEekNvcmhXSkJRRFRVcHNNVERiWHByQ1JudkJBUWdUcGVNTXRKaElBUUVBSkNRQWhFUTBBRTZtZ0E2UjBXZ1ZvUGhteGFBd0dLOU1OM3NCMGtCdzBRR21ZSEhaVXVDZ0VoSUFTRWdFMFM0TmN4dmFva21VQ0FXWVdha0UreUNBRUxFQWdKQ1VOWU5ES2tVM0NRdmZ3aStTa2xBclVGZmxkU2hSQVFBa0pBQ0FnQklTQUVoSUFlQVR0UlQrdjFXRGFGZ0JBUUFrSkFDQWdCSVNBRWhJQUZDWWhBYlVHWVVwVVFFQUpDUUFnSUFTRWdCSVNBL1JFUWdkcitycm4wV0FnSUFTRWdCSVNBRUJBQ1FzQ0NCRVNndGlCTXFVb0lDQUVoSUFTRWdCQVFBa0xBL2dpSVFHMS8xMXg2TEFTRWdBMFF5SjNiRXdNSDlJU0hoNGNOdEZhYUtBU0VnQkN3YndLeVVxSjlYMy9wdlJBUUFsWktZTXJQWTFDL2ZnMGxVRStjTk1OS1d5bk5FZ0pDUUFnSUFTWWdHbXI1SFFnQklTQUVvaUJBd2ZxVnByaEc5VXBSNUxMOG9ZY1BIK1BBZ2FOS3FMWjg3VktqRUJBQ1FrQUlXSktBQ05TV3BDbDFDUUVoa09nSWxDeFJGRTJhMU1XR0RZdkJTM0xIUjBxWklqbEtsQ2lHK2cwNll2LytvNmhUdTFwOG5GYk9JUVNFZ0JBUUFtWVNFSUhhVEhCU1RBZ0lBZnNnY1BiY1JWeTllaE1iTis1QTcxNmQ0cVhUQXdiMHdyeDV2eU00T0FpTEZpM0haNTkxanBmenlrbUVnQkFRQWtMQVBBSWlVSnZIVFVvSkFTRmdKd1Q4L1FNd1lPQklkTzh4Q0MxYU5JeHpMVFZycHhzMHFJa1ZLemNvd25mdTNrZFlXQml5WnMxa0o4U2xtMEpBQ0FnQjJ5UGc2T1NVWW96dE5kdWNGdlBTNDVLRWdCQVFBdVlSQ0EwTlJWaG9HQ3BVS0kzangwK2JWNGtKcFlZTjY0L2R1dy9nOUpuenV0eStQdS9RdkhsRDdQbjNvRzZmUFc2dzZjdkFnVDF4OU9oSitBY0UyQ01DNmJNUUVBSldTa0EwMUZaNllhUlpRa0FJV0I4QjFockhwWlk2b25aYVMyRHJ0bDJvV3JVODJFSFNudE9vVVlQUnAwOVhkTzdjMnA0eFNOL2pnQUNyM1BLR2hzUkJ6VEdyTWhlMXdURm1SU1MzbFJBUWdkcEtMb1EwUXdna2RnSzllbllFLzlseVlwdm14WXRYeFprdHRiN3RkRVJPR3pkdVI1UEdkU1B1dHB2dkxabzN3SXNYM2hnL2ZqcVp4TlN5bTM1TFIrT0hRTmV3QUV4MkNFWkN6MlgzY2dqQ2p3aEk4SGJFRC9YRWRaWjRGYWdQSDlxQ3QyOXVvbXlaRWxGUzdOU3hGZno5N21IK3ZDbEc4ejI0ZndhdnZLK2p4S2ZGREk1WHJWSUJ2ajUzc0d6cEhJUDk4a1VJMkJPQmlSTytWZmRQdjc3ZHJhcmJ2Y2locjJ2WGRtYTFhZHJVc2FwUG5UcTJOS3U4SlF2RmxaWTZNdTIwdHUzTGxxMUY5KzdtOGRQV1lhdWZMRXczYjk0SXJkdjB4dGh4VS9IOCtVdmt5ZU1aNis1MDc5WU9iVm8zaVhVOVhBRXZ3RFBpNnk5UXVGQitpOVNYVUpYVXJWTU41OC90aGQrN3UvUSt2WTM5K3pZaVg5N2NCczM1L0xPdTZuN2s5N1QrWDNUMzU1ZGZmSVluankrb01yZHVIa2V6cHZVTTZ0WC9VcnhZWVhpL3ZJWm5UeS9CTTBjMi9VTVczODZMRUl4d2NzVFhvVTRJZTE5N0J0cGFvZkhISytkUTNITUt3YWd3ZjdoRWMyYldMUGNod2Z3aUNlWStWTzZvUXlBYWhBWWFsT0k2UmxCZGQ2aE9ybnNqQ2MvNTlEVGpVK0NLSmc2T3FCR2huRUVsTnZSbDZpOC9HdnhHdEwrWFJnMXJHL1NpWW9VeTJMbGpMZDY4dm9HalI3WVpISXY0aGN0cTY5SC81UGVFTnVYUGx3Y3NjMnAveC85c1c0VWMyYk5xRDZ0UFU5dG1VQ2lLTC9HMnNBcy9aQW9XekF0bloyZlVxbFVGeDQ2ZmlyUlpiZHFFUCtDcVY2K0lwRW1UNE4wN3Y0L3ljdmlxNGNQN29YMkhQaDhka3gxQ3dKNEpOR29VL3FCcTBhSUIvamQzc1ZXaDhQVjlaMVh0TWFjeCtscnFXYk4vTmFjS28yVzZkKytnaSt4aExNTVRyNmQ0OWVvMStFVng5ZG9OWTFrUzVUNnRNTjI5eDVjcTZnbDNjdTNhaldqZHFpbGlzK0JOeGd6cE1IZnVaTVhzNHNXcnVIanBhcXo0ZGU3VUdtUEdERVBmdmwyeGJObWZGTzd3TUE0Zk9Ra2ZINTlZMVJ1ZmhVdDhXaFFyVnN4VDc5enZ2cHVNSERteXFrSGMycldMVUxsS0U3eDU4MVkxSjMvKzNBZ0pDY1Z2djYyQWw5ZHpYUlBQbmJ1czI0NjQwYjVkYzB5YytBMHVYTGlDbVRQL1VaeCsvWFU2N3QxcmpWT25QL2dMYU11TkhQa2xraVJ4dzl1M2NjdVBOZEtqTmNIWUhCeUthdzVKMU9sWk1KNlBRT1RTT0tGdlFEQ3lhRUl4d3NVWmJ3UDhNY1BCVGR2RWp6NzdoQVpnZ3FzelpnVUY0UVRWMTkwaERFdGRuVkNiNmpqdEVDNXVqU1JodWcvVk5Ua2dDSGRwS1pCK2pocHNjQ0xmakZEZ05kWDRrblRUODBKQ01OWkpnNE8wejlZOUJkS21UWTNBd0VBc1dMQ2NubDl2ZE15dVhidWwyK2FadDk5L253WDJVL245OTdYNDc3OHp1bVBHTmxLUTR6YW5OV3MyUXIrZS8vNEw5MjFodVhIVnF2bnc5TXlHcVZQbnFjRnV6NTRkcUEyL29HNjl0cm9xVFdtYkxyTUpHL0VtVUZldFdnR3VyaTRLYU5PbTlURit3blNqelV1VE9oVktsLzRVTDErK1FwWXNtWlEyKzkrOWg0em01V2svMW5aSEpad2JMU2c3aFVBaUpjRDNBejlFdkwxZm8zanhJc2laTXp0dTM3NW5OYjE5OGVLRjFiUWxOZzFoTGZYT0hhdXhrRUxhY1JTUTJDWldFRFJwVWdlMTYzeDQyQnVyYzk2OEpTU0lkTU9nd2FPTUhVNTArenEwYjBFTDI5U2lDQ3NmaEdudTVJNmRlekY0OE9leEVxaWZlRDNEMDZmUHNaS3U1WlFwWTlDNFNSZWR3RzRPeUpRcGsyUG56bjBrcEM4QkR4eXJWQ2xQYmV4RGRRWXJKOVo5K3c3aitJblQ2dmVTUDE5dUdoVGROT2MwY1ZxbWYvK2VTb2p0Mm5VZ05tL1pxYzdGUW5YTm1wVlJ1dFFuMkwzbmdOckhnb2kvdno4SnhvdHcvY1lId1NpcXh2WHIxeDErZnY1ay96NUFEUWl2WExtQjVjdm5nTS9aczljZ2c2S3NyZVJJTjVhNHR3d3FOdklsRjJtbjZ6bzVvV1lBNmFiZjIzc1VDQTFHRFJLTVd3VUdZNGREdUY0NmM1QS91cEFXZXk0SnVZWTY1L0JLazlKSFAyZEhMQW9NSUFFOUNjSm8vdjh3YWJsUGhvV2lMV21zVDhNSkxBWjJvWFBORGd6Q3RQZUMrUlVTbm8rN2FsQStKQkQvYU1MUHRZNCtSenVHb21KSUVQWm9uSTIwMm5aMnBVdVhWdDBQUC93NHhlamdpSVhmQ1RTckdrQk94blhydHNYWmM1ZWk3UnpQQm9XU2cvalNwV3V3YS9mK2ovSlhwWHN2Zi80ODZsNzhkdFJFZGR6VE15dXFWYXRJbGcxRmRRTzQ2TnIyVWNYUjdJZzNnYnBseTRaNDl1d0Z0bTdkamZidG02TlkwVUk0ZC81amNGV3JWZ1EvbU9iTVdVS3hWenVoVHAxcU1DWlE4NFBRdzhPZHROVDkwYXAxejJpNktZZUZnSDBRcUYyN0tqUWFCOUl5clVlL2Z0M0FMeVpqQWpVL2NDclFNUWNIRFc3Y3VJMTE2emZUaXo5RVFXSTc1K1RKaytQMDZYTXF6OGFOLytEOGhYRE5FMCsxRmFPcFdFNFhMMTdCMzNSTW0wcVZMSTU2OVdyaW4zOTJrekJmR0preVpjQ2pSMTc0WThVNjliRGtlTW92WDNwcnM2dnAzc0tGQzZnSDR3a1NOSXc5R0hXWkkyendGSFNiTmsxSmdObXJCaEI1OCtiQzY5ZHY4TWNmNi9EUys1VXVkOW8wcVZXKzFEUlE1d2YyUC8vczBmVkZsOG1NRFV0cnFUbStOZHRtYzcxUnBVT0hUMkRjdUpFcWRGOThDQnRSdFNXdWp3MGMwRlA5L2pwM0dmQVJGKzQ3eHdabnN3Q09FMjVPS2trTDU3QmQrdGNqeHFKdm4rNWtyakVRNDhaUE5hY3FaZVpScFVvNUE2RjgzLzRqcWk0ZUxGV3BYSjZFaGVvWVBYb0lNbVJJajN6NWN0RjFuRzcyK2N4cXBBbUYySXlHdFlpc1JkYW1RNGVPZzU4cnlaSWwwKzVDK3ZUcGxOYVJaMDFNU2F4UnpKczNwM3JXYUdkWGR1N2FTemJ4TDBtQlZ2eWpLcjc3YnFpU0YxZ3hrQ05IbG8rT1czSkhnN0JnUEF4eElPMzBCOEcxQkFuWi9pUmRuOVVUWnY4TmRVQTNFcGpUa2lEM1NDdDU2elVrRldsWEhVbTF2VC9NRVdIdkJmTVhsTzgybVhPa2U1K1BiV3gvcFFIV1gyRWtlcjNQODh6MlRsV1NBQUJBQUVsRVFWVEJBVzhSQ2c4S2phbmQ1MFViLzlIenVEVnB4dmZnUTd2MFRtY3ptNmxTcFNDQjJzK29NTTJkNEhkUnJsdzVhRkQ3UDVPRWFTNVRvRUFlbWlFaGt4bWFzVE9XUHZta3FIcTNIVHg0VEhkNHk1WmQ2aDdNbmR0VEoxQkgxelpkWVJNMzRrV2daaTBadjRRNUZOVGZmMjhqTzhvMnFGR2prbEdCdW5YcnhtbzBNK2QvdjVJd1hRVThmVDN5bS9FZmRZZk5RTFp2MzR0MjdacVMwRkFhL0tLUkpBVHNuVUNUSnZYQVMxYi8vUE1jZE96WWdvVEpKbGoreDU4R1dINzg0V3NNRzlZUFFVSGhlaFpYVjFmbDVOVzEyMENWajIyZCtZSEZ3cmFMaXd2dTNyMkh5MWV1WWU3L0pxdm9DaXlZY3VKeTY5WnRCcGRqWWJ3VWFiQkdqUnFFYnQzYUttR2E4emc2T3BDbXJoeTZkZjhDaTM3OWczZXA5TDg1UDZGSGovWnFhdG1KTkRiOHgyMytma3o0Rkx3MlgyU2ZMSkR3dVhyMGFJZU1HZE1yb2R5SnRFZHQyelpEdGVyTlZIdjRJYzAyZVZteVpGUlQxZTd1U2ZITk4xL1M4MmNnTm03YUhsblZKdSszbEphYUJTNk9IQktkZGxyYnNEVnJOb0hOQzFnN0hoZUpYeml2U2FoNlRzSk9RcVdvaEdsdG05anNnN21aSzFCMzc5NmVCakVyVlhWejV5M0dwbzNMU1VBdlpQSkxYZHNPanJ3eWE5WkVNbzB3MUtKcmo3UHd6eHAxL3VQVXBYTWIrcTEvVDFQVjFtZTJVN1ZhTTlWRy9mL3kwdUNWNysvbnp6L01MckhTaTdYTkhkcTNSTHAwcWZINHNSZlcvcmxKWnhLaVg1NjNVNlZNUWM4Q1I1bzUrekRsejZZY1Q1KytvQUZHV29Qc1BHaXZXTEUwMk9TRUI4MXhuV3FRRUh5QnRNajZXdWRNbWpDOEpzSDVyVmJDcFVZOHBXMVgra3hIMnV0SGVzSzN0bjBQU1RBdVFJSTVXWEhvRXVkUFN6dDJVdjFjRlEvMUoyaklaT1M5TU0wWkM1TkE3MDV4UFc3cXhmWWcwUnBIU1VCdlJjODBGOUp6NkxlTnk5aFM0dCtLajQ4dkJ0Qk1CRy9mdS9jUXE5ZjhyUlFjM0k4U0pZcVRFZ2owM25xQ1lVUDdxWGZPcVZObjhjLzJmeVB0SnMrUUJKRlpEVnMrMUt0WFF5bFQyUHpENitrelZTWlhydXpLSklrdEhiU0pIWm81cFNFbGl6WkYxelp0UGxNLzlTNjlxVVZpbnE5eXBYSTB1blhIbjNUREhUN3lueHA1Tm10Vy82T0tVcVpJb1c0a0hoMnpWbzFIRkR4OUhaa1RJOXZHQkFRRWdtMnRKQWtCZXlmd0NabDRzS0M1ZCs5aHNPYm81TWx6eW55S3phaTBxV2lSUWhUSHR4Zk9ucjFJbXArU3lKYTlCQzVkdW9iR2pldVFrMWRPYlRhbEFWMjY5RStVSzljQW16ZnZRdk5tRFVoQWI2WHE1akw4dDIzYmJpWFFkT3pRU2xlT04xaXJsRGRmT2VUT1hZYUU4UWMwWlY4VG1Vam8xYVpQUHlsQ2RiWEU0Y1AvSVZQbVlpaFlxQkk5VEIrcDFRQXpwRGQ4dVdyTFJQYnBRTTQ3cFVyVlFlWXN4VlI5bjFEZDVjcVdVdGtuVGhoRkwrdDBaQ0l4QXVrekZFYkprclhWUS95Nzc0WkZWbDJNOXV0cnFXTlVNRUptVTdYVDJtSXJWNjZMTTBHREY0KzVlR0UvL1haMllqakZ3MmJCdlE1cEoxbWJ5dzQ5MnJCOVBBamdkck1BYXVsa2lqRE41OXhIUzdLem40MDVpYWVNZVVyNDVLbHp1dUo5K3czSDdOa1RZN3h3ejZodkI1Rzk1Z2JjdlhkZlYxZFVHMHVYclVHR2pJV3hoZ1lFMXA1NGxxbDI3U3JLVHZYb3NmOTB6V1hOWHViTUdURmp4bGdhMkE2bUdlVkorSlBzckhuUWFpeDVreWFSTllvUmhXZTJtZFZQUENqbVFlK0RCNC9KUGp0OHNLTi8zTkxiYkEyZG13VFpTeVE4NjZkd1MycjlQU0NOZGN4VGRYSXN6RXhLaFhWNm1tNnVoU2tOSTF2cThWVHJVbWNIVENNYjR6UHZiYXkxWjdsT2F1NnM5SHhMclhPVDFCNnhuVSsrbnNtU2VTZ0Z6WlFwMzZ2ZnlvSUZVN0NVN0tYNUdLZENoZktxaGFzbVRCaUpNV09HSzBYSit2V0xNWVRNcFNKTDZlazl3YVlpNDhlUFZIWHlBSFgzN25YSVRMOVhUbTV1ZkdVTmsxWVJwTjFyU3R1MGVVMzlqQmVCdWxXclJqU0NlSXREaDQ2cEVleXhZNmRRdEdoQmd4YzRON2g4K1pKSW16YU5tb2JqNzd0MjdWZWpXcDV1TXBaWWE4Yk9IenhLWWFGZGtoQ3dad0xWcW9YN0tiQ0pCaWRlS3B0SDRHeEdwVTErL243a0dEU0RwcDRuNFJXWlNMQ1RFVHRrc1NZNlBkbTZhUlBiZ0U2YlBnOW56bDZnZksrVkFNY3Z2L0hqcDZreVhHN1NwRm1rdVFwV1FyVzJISC9PbkxtQVREMmVLS0grMUtuejlKSk5nbXpaUGt6YnVyaTRrdmJiZ1Y2d3dhb1lhOVFIRGZwT3RVbHJkcUpmWDFUYlBPTjE2ZkkxMWFZdFpQUEpEMGtXb2ptVktmT0owdFl2WHJKQ2ZiOXk5UVk1aWgwakcxRlhKUXlvbmJIOEw3WVJQN1RhYWE3SDFNVFg3U3IxaFlWY1N5ZWVkV0RCaDUzTDJLUkhRNnFqa2lVL1FXdUtoREZxMUJEUzRpN0Z2M3ZXNDhEK2phU1ZuVUJPUVl0MFFuWnMyc0t6akN2SkdXN2MySkYwdnVJd1p1WVJzWDRlMFBBQ08yeldGTlBVdmwwejVkaW9YNDZGdUZtemZzV1k3Ny9TM3gzbE5pdDdDaGZPandVTGwwV1p6MVlQanZsK09MMlRVMlBhdExsS1M2M3RCeXU3dG0zYlE0UGhpc2lUdHh6NFBxOUNVL2ZOeUQvS1dHSnpyT3ZYYnl1ZkRtMTBydXBrejVvL2Z5NkQ3TzNhTmdkUDEwK2Z2bEE5ZHd3T3hzR1hwQ1NzcHFhWnVOZGFHdzBMbmlNbDFUMkpIQXYvSkUzcUZUM3RNNStDTGFVcmtUTmlDeEtpblVrN2UwOWZaZjIrRGF3Ulo4RStwVjRFa1BlSGJPYkQzZDJkRkRJN2xUSTFaNjdTSlBkVlU0TXpWdURVSXhNb1RtblNwRkh2QTFZRXNXS2tXUEhxeW9kdTZOQytOUHVSeG1oZldUWThjT0FZbVlRMW9tZDVNYnFYTjZtb1A2d3NNaldaMGpaVDY5TG1pM09CbW9HVUtmT3Awb2c5ZnZKVW5mZlBQemVya1d5bGlvWVB3cFl0RzZzWE5EdHZjR0lIamlkVWhxZXhJMHN6Wnkya3FTYy9mUHZ0NE1peXlINGhZQmNFZVBxYnA3VU9IUW8zZnpwdzRJaHlIR0l6S20xaWUrbkpQODlXRDdDdnZ4cUlVZDhPVVFJQkMwNGNnVWViV0hnT2VXOVR6ZnV5WnMyczdyUDc5eDlwc3lnYlZoYTh0UUtzOWdBdms2MU5MSEN6VFhlU0pCOTBQaWRQblNGTjl5RlVybHdPbHk3dVY2SEdqaDA3cVV4Q1h1alpXR3ZyaU9xVEhWTzBTUnRCaEFWbURyUEZQaGFzTGRkUGJkcjJRdUVpVlpUQXI3L2YzTzNZYXFsanFwM1d0blBod3VYS09WSDczVktmTE5BMmFOQ0JiSUU3WVN2TlFMQTJsU05wakJnNURyMC9HNEw2RGRxamVvMFdOS1BSV2IzRVdLRHQyNmRMckUvZm5wd1BtMU5vdkl3WjB5bnpvT2hzeWJVbjNMQmhxeXFuL1c3cUo1c1NHQnZFc05hWW5aZllyak82eEZydVNaTkdZZkNRMGRGbHRjbmpQWHQwVUROSmJGcTViTG1oMmRpUW9kK2hlWXR1TkpOOG43VEpqOVJnbUo4WlRhTUlnemRyRmcrK25PaDNzMGlaai9GZ2pDT0ZhQWZSeVpNbnc5ZGt4MzduemoyNk51dmloUmtMUVB3WGJpaGd1Vk95N3ZVbmlzK1JoSjZyMzVINC9PRXBGWDRPTmtSb0Z1cUtRaFNtN3p0eVVKeEtVVDlLaHdZWk5PRGRleUhiOWFQU0J0bXMrZ3NQcEQ3dk13eWRPdmRYWmtIc3dEcUd6UHI0ZmNQK050b1VGQlJNaXA2WlNqSEM3eWhXanFST25SS2xhREJ2TFAwOFpRNlp5SEYwbUhQS1orYUhIMzlXcHNKMTZsUXpsdDNvUGxQYlpyUndKRHZqWEtDdVhLazgyQ0dCN1NpMThRS1hMcDJsbXRPbVRUTmRzMWg5WDdWcU9kS1VPWk5Bc0ZubDVmaVRQSzNFMDlnOG5XMHNzV25JOHVYclVLbFNhV1dYYlN5UDdCTUNpWjBBbTJ1d3BveTFTVStlbkZmM3o2bFR1NVFneS9hSWJFN0ZpVFc0cTFiT0orMzFVdVcwV0sxYWVaT211UGtCR0RHeDVscjdNb3g0TEtydlhLWlY2MTRZTXVSNzVjWFBvY1l1WHo2SWJsMmpqbkFSVlowSmVjeGNMYlU1Mm1sdFA5bHVtS012Y094cVM2VVdGT2ZaaXlKZmFKM3BvcXFYVFlvNmQrbFAwVGNHS2Z2N2pPUm9GNXZFRVoxKytPRVgwb0pQaWxFMWh3NGZSOW15SldLa0pXZk4vdDI3OXlNTlp6ZGd3RWg4VDVwWkZwaWpTdVBHamlDTjltL0tQQ0dxZkxaNGpNUGNzdk1ybTJ6MTcvOTF0RjI0ZGZ1dThvZUlPTGpXTDhpRGxhRkR4eWl6S3c2ZHkwNW9iT09xZFZSbTIzSjJYT1RaclM4RzlsYURmZmFQNE9oZ0E4aEJsWjJlNHlvbGpmQjRlMmZrUkJTM3c4aGU0N3U2VUN6cVZzNHU2QlVVaHNkR3RNL2FVbHpqU3JLcGZreURrUm9hTXBiV1N3NHhPSjllTWF2ZnZIbnpEdGsvVXloQ3V1YzVzUUtHLy9STk1uaWd6dStjTkdsU210U2ZHemZ1cU5qMExJUnppaXpVY25TVlJXeGJkUGtqSG85emdicHQyeWJLZUh6cTFQbkt5WUFkRGZqdit2VmJaSXhlVkdkYldiNWNLUktlTXlrdmZHMGUvbHkyYkoxNjRmTjBkbVJweG93Rnl1aWROUnlTaElBOUVxaFpvN0thOVZteFlvUEJmYlpwMHc1bFJzWG1WSndhTnFpdHRFaHNLcFU3VHhuVXF0MWEyVnBIeDR3ZHE5aXBpRTFEdEltZC9qaE9MRDhjWTVyNDRja3hzbGxiM0lVRU16WXpZRHM0ZlR2dW1OYXBuNThqRlhDZCtscDNQcDZOTk8wc0xHanQ5L1RMbUx2TjJ0VDE2N2ZFYVBWRWJnTkhsakFsc2tkazdWcThlRFU1d25XSTdIQ005bk0wbEdIRCttSVVtUUxGSkhIZng0ejVtYlJMNW9meDQ0VlZybEVJT2RhRW14bzFRcitOZS9ZY0pJMnk2U1ovN0l6SUd2N0lFanRqVGlFTjJQUnBQMGFXQlh5L3BVMmJDdXMzYkk0MGo2MGVTSjBxSmYwdVp5amwxdWVmRDhVamNqalVUd1VMNUZYQ3JyNlN5NFZtdC9qNXdJNktVYVg1QzM1SG9jS1ZsWS9GYmdwM3hqUFlwMDlmVUVWNG5RcU8zcFdQUWdweWhDLytZMXR0MW1xM2JkdVVGQVlGb3FyYXJHTWN5Y09QaExtVWVyTnFYTkY5TWdGSlJXWnB5ZldFV2pZa1kzZnNaeEZzblRtL2Z2cUVuQlludURoaEl0bEY3NC9ndkppSjZodEh0dFA2UzV5elh0cWZ6czhPalBxSmg4b3NjTCtPWUM2aW44ZmF0L2szd3JPZy9KdlJKbGRYTnpWRDZ1dnJxM2J4NEphZDE3WENNTzlNU1U2c25QaTlFekZsSVNYck4rUTNGM0ZoR0g3V3MwOGRKeGFNdVU1V01Ha1RSM3JpeEpGbE9KblNOcFV4QnYvRnFVRE5Xckh5NVV2aDFxMTcrT2JiOFdxcW1hZWIrZStQUDlZcis4N0tGRTZJRTZ2cVdRbjJ2Lzh0TnNnM1llSTBKU3p6ZEhaazZlNjlCOHFCZ1RYWkRGR1NFTEEzQWh6Ym5VZmxreWZQTXJoLytIN2l4ektiVTNGaUp5TWUrUjg0Y0ZTblhXYlRpT2dTaHgvaVdTU09SNnROSExLTVRUbE9uanlyM1dYU1ovOStQV2sxckp2azhOWks1VjlEOW04Y0FTaHAwcVRnaDZVbEVtdlBPV1FmUi9qUXR3MWZ2WG9oaGRwYkF3LzNxTFdQTVcwRFI5em8zTGwxdE5wKzFpaFArWG1NY3ZycjNidWpVYk1EVTgvTndoemJJbG9pY1pTS2tXVFdZYzRpSkx3T0FBK1EyQTQ2cG9sNURCcjBPYTErT0MybVJYWDVlVERETnQ2bUpKNFY0SkNPMGExZHdPWXUvREp2UUE2MUVSTzMrZnZ2aDVIV2RHVEVRNG5pTzJ1bWl4UXBTUDRTTTNDUVF1WkZUT0dtR2YxSjI5eFBkNGpmODh6MmxKNlRwKzZna1EyMjFSOHg0Z3NsV0xGREo2ZitBMFlnZTQ0U0JuK1hMMTlYVS9tVkt6ZkI3MHRYRzZrcGRydjhxUGhEaXNDUlBZTFljSVppUnJQcVFOOE1veWFGc0x0TmcvVG5VV2ljMlc1NmtWTW9EcEIveUV6U1BFZlVhZlAzejBrcFVWL3p3YndqSTRYb3kwS0RrZXNjdUZvdmNhU1I1eVJvZTVOZ2I2c3BmZm8wNUdUNkJYcFNLRlp0cWx5NXJGSm9zTjA5cCswVXpZTjlhcHFSNDdzMmNlUU9GbzVaTUk2WStMNWtXMmwyaHRVcVJ0aVBncVBOc0xrSXB6Tm56cXRGWW1yWHJxYSs4My84ck5TdjA1UzI2UXFidU9Ga1lqNnpzbFdvVUVwcHh6WnMyUFpSZVg1Qjg5UXYyM2Z5aTRHRHVQUDB6L0hqWnd6eXNrbkgxYXUzMUhRMmE2KzB3QXd5MFpmWmMzNmpjRmh0YVlvZ2ZCUVM4Ymg4RndLSmxRQjdOdk5zejgyYmQ4R09kL3JwUHhKMk9mNDdtMU94UUh6Ly9rUDFvQmt4WXFBU3JzdVZLMG14T2F2UmxKdCtxWSszRnk5WnFjTGMvZmpqVnlwTUhXdWlCZ3pvUWM3R3Iya1EvTnZIQmFMWWMralFVVFZyeGNIOE9TWXZheFpxMXF4QzdYeU84K2N2UjFFeVpvY1dMZm9Edi93eWhtdzJmNlcvamNvUm1xT0FMQ2Q3VUJhNHMyZlBnbjE3L3lZN2EyK3lDMjZwUWkvRjdBd2Zjdk5EbnBjR1oyM01wSjltS2NHVUkySVVKZzkyanZkZGdzd004dVFKai9ITDJuUGw5RGx0UGowRFA3eFlQOVJtMmhhZms2ZEdhMVN2akQzL0hqQ3RrSkZjTVRIMU1GSmM3UnBGaXlld2JTeUgvb3RKbnlaTkdxMDAzT1lJOHRxMnNQa0xyOXpIQWgwemlTcTFidFdFWXJTSEMzQlI1ZU5qSTBhT3g0N3RxeFZqL1JDQzA2ZVBJL09VS2NxcE43bzZiTzA0TDhYT1lXMjFKakdmOWU2czZ3S0h6VnRQTnVzOEdObFBFVmFhTjYrUG1UUEdxNEhyb0VHOWxlSnJ5WkpWS2o4N25QR0tpMy85dFEwOWVnN1MxVkdMN25OKzVyUnMyVWl0blB6cnJ5dXdjOWMrM2ZINDNtQWppOU1rVUJjaVB3K1NYM1VDOEhXS3JyRTdLQUNUeVVUT0l6Z1FtVWlZN2tUbXFHTm94Y1BBOS9KdFJiSjVYa2hPaHdPQ3c3Q0hOTkZhdStrY2ppNllRUG5Ld2ZEZS9vL3ljSHpwdFZUdkNIcm1oUVg2NHlGOS80THFlRXJoOXJhOFgwQkd5K0FUYWhBdit2TFdoalhVUENEakdRaWViV0IvbW5CaHVLZDZKM0hvUEU0Y1RwS2RvSHYyYks5aW0zTmdpb3JrWDdkangxNmNQaE0rZTNIdTdGNGwyMVdvMEpDaTZUeFE2eXowNzk4ZFN4YlBvdnZ6RkprbDlWQ0tvamtrQjNMaTgvTENRUjA2TkZQUGQ1NUpyVjY5a2xJa2FWZmxOS1Z0cXJJWS9CZW5BalZyeFZqci9PKy9oejVxRWh1VGU1RWRIbzlzNjlXdEFVL1A3RGhDSWZYNFJSY3hiZCsraHp5L2k2cHB0c2dFYXJhNzRoZm8xMThQaUZoY3ZndUJSRTJnV3JWS2FyWm45ZXJ3QjVSK1p6bldLNGZQcTBzdk9EYXIyckoxRjVsVy9JOGVRTjFKS0JoT3RzdlhTQkRhcEtaVU0yZk9vRi9VWUpzMUJleUlObWZPUkZwTUtWd3p4ZUgyQmc3OEJ0ZklmQ3NtNlF5RjdPdlFvUTlwMDcvSDJMRmZLL3M1YlYzNmk3TEVwRTVqZWRta2hFTTJmZmxsYjVyQy8xNU5SLzlLc2JDMUsyY2xvZEJLTElTeHQ3Y21DcTJUc2JxTjdidDE2NjR5VzJGTkNEK1B1RzVtejVxWVNUL05OTkMyc0gxdWRNS2ZzWE5FM0xkdzBUSVZHY05jZ1ZwcjZsR0hWaWlMVFdLQmt4Y1RZZ2RGVTVkalo4Yy9acVNOenh5YjgrL1lzWS9DKzFXTE5yNTRseTV0U0luVDA2UlRzWkEvZlBnWUZXTzZmWWZQVlJrZWZQQ0FTTHRpb0VrVjJWQ21HbVRLd3FZYnZIYkV6Sm5qRFZwKzVzeEZKVkR6enA0OUI5TkFPanlXUE9mbjkvTGd3ZC9wbmdWdWJrbVV5UWhycy9WVFE0b3gvZGxubmRYQWZ0aXdIekJ2L2hMOXd3bXl2WlVXYlBtTkZteEpSWUl4TC92TmlRWHR6MGxIL1JQWlFzOG1HMjVmMGpqOFFzNkQ4L1dXSFU5S0FtOWFtaEZQU2t1TWMyS1RqUnFPVGlvazNqSmFianhpS2hnUWludWtpUjBHTjNnSCsyTTRDZWpKU1VEYVRvUHFYaUVVYVVSUEVlMU1oY3RSM3BYa3RCa2EzcVNJMWRuRWQ1NDE1V2Y5L1BsVDZGM1JVMm1pT2FwVTM3NWZxUWhNM0FsV0xyUnIveGwrWHpKTDVXSG5WZzdKMnEvZjE3bytzbThkV3g5d3REaE8zMzMvay9wOWRhSlpUbzRpOS9qeFUzenh4U2hzbzRXN09QRjUyN1g3bkdUQ2FlcjV6emJhSEJYa3M4K0dxdVBhUE5HMVRaZlp4QTJOcTF1MmFIUlRKdFprOWRuNFYya25YYlg2YXlFTkZBS0pqd0Nid0d6Y3VFeHBxbm5GUFVzSXpLWlEyckIrQ1FsOWkwaExmZENVN0FaNVZxNllEMTdPM0JSSFJJT0NScjZ3UnA3RDZ2RUNKOUhaUXJNZ3ZYUEhHdEp5ZHJmSUFqSWMxWVh0dUxXQ3I1SG1LZHQ1WHE2OFYrOGh4ZzVIdXU4bjBxTDcrUVhRUzM2WGl1ckJTNVRIUnFNZTZZbmtRSUlRU0VwblBlb1loTEZCb1ZqcndHSnh3cWNpWkllOXcwV0RNc0VhUE5CZktTYmhteGJ2TFdDVHZYUG45cW9GWWNxVXJSdnY1NC9KQ2ZYR1JERXBKbm1GZ0JBUUFrSkFuNENLdk9GWmdoejdKc2FiTU0zblp6dnhyVnRYWVBDZ1BtUlR5TG90MHhKclcrL1I5S2tsaEdrK1kwd2NGSWNON1UrT2dYOVlSSmptYzk4aHh5YU91UjVWWkk3ZVpMNFFsVE1pMTJNczhmTGtJMFlNd0o0OTYralRQRHR6WS9YS1B1c2d3QkU5cHBLV3VSK1pYbnh3dVU2NHRySHFyNTlETUpaUS9HcDdGNmI1S3ZES3ZjbVRlNURTWUdIQ1hSUVR6eXdDdFltZ0pKc1FFQUpDd0JvSjdObHpTSm1WY01peVBidi9SSlBHMFd0eDJOUmo0TUFlSmkvMWJtcS9UWEZReko4dmoxb1JsMk5jV3pKdEpYT215UHJPR25HMlk0L09HZEZZZSs3U0NvaHN0c01EQUhQS0c2dFQ5bGtYZ1JVYVZ6THJJT0dOVER3UzJzS2lXbGdneXBJTjl4UnFreVNvR2IvZXZZZCtGQXZkR3RtSXlZYzFYaFZwa3hBUUFrTEFEQUljZ1lJOTREbnVQNi82dDNIVGRxTzFMRnM2aDViWi9qVk9CRVFXMXFOeVVOeTVZNjJLa0hIMW1xRURyZEdHeG1Bbng4SmV1SENxV3BRbVlqRmVRcDJkblhqMVQwbEN3QmlCakdRUzJvOUMybjJ2aVVuRWFXTTF4VzdmRUdyRDlqQm5YQ1NoV3BKdEVSQU50VzFkTDJtdEVCQUNRaUJTQXJ3cytkaHhVOG54cnBlS0xySi8zMGJscktkZmdFMDkyR2t5cnJTdCtnNksrdWZsYlY0Wmt1TkdXMXFZNXJyRDdiYkpVWXdFK29pcFE0Y1dwT215ckVZODRqbmt1MjBUZUVLNjZlOFNXSmhtZ2xNcDNKNEkwN2I1V3hJTnRXMWVOMm0xRUJBQ1FpQmFBcXkxSFRhc3Z3b3J4K0dsT0c1ckZZcXV3VXVJeDZYVHBERUh4YXhaTTRHZElEbEVZVXhDNjBYYlNiME1QV2loRzQ0R3dISEJ0WWxOVERobUxhL3NLRWtJQ0FFaEVGY0VSS0NPSzdKU3J4QVFBa0xBU2dpd01IdjF5bUVWRXExcTFXWnhwcDNXNzI3Wk1pWFFwMDgzV3A3OEM3V2JoZW5wMCtmSDZiblpLWEh0bW9WcXdLQnR5NlNKbzFXRURrczVYMnJybFU4aElBU0VnRDRCTWZuUXB5SGJRa0FJQ0lGRVNPREJnOGZvM1hzWXJZWTRQazRGV24xMFdnZkZ2aVJVOC9MaVhsN1A0dnpjSE03T3g4Y1hQSURneE02SVpjdCthckZJSnZyOWsyMGhJQVNFZ0Q0QlJ5ZW5GR1AwZHlUZTdZVDIzVTI4WktWblFrQUlXRCtCOHhjdTQralJrL0hhVUY0ZzVKZGZma0FaMGxaM29NVlIvR21KOHJoT0lSUUNqYzFhRGg4K2dSYk5HNnBGSDQ0ZS9TK3VUeXYxQ3dFaFlPY0VSRU50NXo4QTZiNFFFQUpDSUs0SW5EdDNpUlpsdUlUeDQ2ZkgyMUxkVzdmdFJJTUdOVldYdW5kdkw4NkljWFZ4cFY0aElBUU1DSWdOdFFFTytTSUVoSUFRRUFLMlRtRGIxcFU0UzB2YzU2QVZGS05hUGRIVyt5bnRGd0pDd0hvSWZMemd2UFcwVFZvaUJJU0FFQkFDUWlER0JIZ1JsK3JWSzZKcDB5NHhMaXNGaElBUUVBTG1FQkFiYW5Pb1NSa2hJQVNFZ0JDd1dnSlB2WjRqSUNBUVAwK1pZN1Z0bElZSkFTR1F1QWlJeVVmaXVwN1NHeUVnQklTQUVDQUNIT0VqTG1OdEMyUWhJQVNFZ0Q0QmNVclVweUhiUWtBSUNBRWhrQ2dJaURDZEtDNmpkRUlJMkF3Qld0REtUbVJxQndxYkZ4cG1NeGRHR2lvRWhJQVFFQUpDUUFnSUFTR1E4QVJDUXNJUUZvME02UlFjRkpyd0xZMlhGbkFjYWhHbzR3VzFuRVFJQ0FFaElBU0VnQkFRQW5aRXdFN1UwM1owUmFXclFrQUlDQUVoSUFTRWdCQVFBdkZLUUFUcWVNVXRKeE1DUWtBSUNBRWhJQVNFZ0JCSWJBUkVvRTVzVjFUNkl3U0VnQkFRQWtKQUNBZ0JJUkN2QkVTZ2psZmNjakloSUFTRWdCQ3dOUUllSGg2MjFtUnByeEFRQXZGTVFCWjJpV2ZnY2pvaElBU0VnQkN3SFFKNThuamk2cFZEYUZDL0ZvS0RRNUEyVFdwa3k1YVpsalhQQ2lkbkp5UlA1b0dVS1pJamJkclVtUHJMRHdnS0RNTDFHN2R0cDRQU1VpRWdCQ3hDUUpZZXR3aEdxVVFJQ0FFaElBUVNJd0ZYRjFlNHVycENvOUdvdjdKbFM4TFIwVkYxTld2V2pMUWQvaG90V2JJWUNoWEtoN0psUzJEcnR0MkpFWVgwU1FnSWdTZ0lpRUFkQlJ3NUpBU0VnQkN3SndLME1BRVdMcGlDdTNjZllNd1BQOXRUMXlQdGE0TUd0VEI4K0krWU5YdFJwSG40QUd1cE8zZHVqWW9WeTZCc21SSTRkdnhVbFBubG9CQVFBb21MZ0N3OW5yaXVwL1JHQ0FnQklXQTJBVFp2dUhCK1AwSkNRckJqeHo0c1hMak1ycld0Yk42eGR1MGkxSzdUbHN3OWdremlXckpFTVhUdjNoNERCbzQwS2I5a0VnSkNJSEVRRUtmRXhIRWRwUmRDUUFnSWdWZ1RxRit2SnBZc1dZMDZkZHBnNEJjalVhRkNHZXpmOXpjR0R1aXBOTEN4UG9HTlZUQnExQkJNbkRqVFpHR2F1M2Z5MURrVUxwd2ZibTZ1TnRaYmFhNFFFQUt4SVNBQ2RXem9TVmtoSUFTRVFDSWhVTHhZSWJCNXc0Q0IzK0RRNFJONDhPQXhSbzJlaURwMTI4RFgxdzhiTml6QnRLbGprVDlmN2tUUzQ2aTdrVHUzcDNJODNMRnpiOVFaalJ6ZHVIRUhtalN1YStTSTdCSUNRaUN4RWhDVGo4UjZaYVZmUWtBSUNBRVRDWEJZdUUwYmw2SnpsLzVLa0k2c1dNVUtwVEZnUUM5NGVDUkZHaktIMkxwMU44YU5ueHBaZHB2ZXYzYk5Jb3daOHpNdVhyb2E0MzVrekpBZWMrZE9Sdk1XM1dKY1Znb0lBU0ZnbXdSRVEyMmIxMDFhTFFTRWdCQ3dHSUhwMDM3RXRHbnpveFNtK1dTc3VXN2Y0WE1zVzdZV0pVb1V4WWdSQTlHaWVRT0x0Y05hS3FwU3VUeGV2UEEyUzVqbVBqenhlcXE2a2pWckptdnBrclFqR2dJYU9wNDNOQ1NhWEhGL09CZTFJVHlHVE55ZlM4NWdXUUlpVUZ1V3A5UVdCd1NHRE82TFhqMDd4a0hOVXFVUUVBSnRXamVCajg4N2JOeTAzV1FZYTladVJOMjZiVkg4aytybzI3ZDdvaE9xZi9oaHVOSk9td3pFU01iRmkxZWljNmMyUm83SUxtc2swRFVzQUpNZGdzR0NkVUttWGc1QitCRUJDZDZPaEdSZ3ErZU9kNEg2OXlXejRlOTNENjFhTm82U1dhT0d0ZUgzN2k3V3IxdHNOTi9SSTl0VVBWeVg5dStwMTBYOFBQbDdKRStlekdnWjJabndCSW9WTFlSWDN0ZHg1dlFla3hzelpNam42TldyazhuNXJUMWo1a3dad0wvVm16ZU9JV25TSkFuYTNIKzJyZGJkUDlyNzZNWHpLNWo3djhscUFZc0ViWnpleWRsMmw5dlhxV05MdmIyeUdWc0NPYkpuUTU4KzNUQmk1TmdZVjdWdi94SGN2SG1IekJxNm8zZnZ6bUJ6a01TUU9uZHFqVDE3RHVxMHpPYjJhZXUyUGFoZnY0YTV4ZU8wWE5NbTlYRGkrSGIwK2J6clIrZkpueThQRGgvYW90Ni92ajYzOGMrMlZjaVJQZXRIK2JKbHpZSWxpMmZpMmROTDZzOHpSN2FQOG1oM1ZLMVNBYjQrZHo1NjFtaWZPY2J1NitMRkNzUDc1YlZvNjlhZUl6YWZlUkdDRVU2TytEclVDV0Y2RmJGd1hTYzBFSnNjQXBIVzRJaGVwZ2lialNuL0dSS0tmWnhEc1ovS1ZRNDFqQTdEZFhZTURjQmxFdDdmVXA0ZG1rQjhxcGRuQ2x6UnhNRVJOYWlleEphMmJsbWhmZ1BHZm5mY1Y1YmR6cC9icC9Ld0RHZ3NHWHRuYVg5SFZ5NGYwaFVwWGVvVG5ENjFXLzJPK1hjMGFlSm9PTkUxMWsrdFd6WEd0YXRIVkI2ZnQ1SC8xdlhMUkxVZHIzR29rOUdLVWxXcWxGWHRhZE9tQ2Y1Y3R5blN0alZ2M3ZCOUVQMFNTSjBxSlY1NnYvb29iMEJBSU9iTVdZeFhyMTZydk0yYTFjZkFnVDJSSVVNNmRPazY0S1A4c2lQaENkU29VVWw1ditmS2xRT2xTaGJIZnlmUEpueWo0cmtGbFN1WFV3OE9EdzkzbEM5WENydjNISWh4Qy9paFVySmtVWlF1WFJkMzd0NlBjWG45QWlFaG9aZzM3M2Q0ZVQyajNSclNQRmFqc0YvdGtEMTdGalJzRkx1WkFYN0puaml4SFNkUG5rZTkrbTMxVDJ2WDI0VUw1Y2ZWYTdkaUZEM0Mwc0JVek9tRlUwbkQvQlg4L1FQTXJ0N0h4d2V0Mi9UR3loWHpNR25TREdVV1luWmxDVnlRSTNQMDdkc05OV3EyaUhWTE9NemU4ZU9uYWFCUmhwZ2NqM1Y5bHFpQXpYTkdqdndTUllzV05Gb2REL0JYclpvUFQ4OXNtRHAxSHRuS2U2Qm56dzVZc09BWDFLMzM0ZjdsZ2RpZVBldVFNV002L1BQUHZ6aHc0Qmk4NlQwY1dicCs0eFlHRFJxbDN0UDZlYnAyYmF2YWNvM3VoWWlKMjVra2lSdmV2dldKZU1paTMxbkFIYTBKeHViZ1VGeHpDRmR3L0wrOXE0Q1A2bmpDa3hDay9aZmlUb0dXNGhSM2R5ZTRlNUVpUllKTGdGQzBRQXN0N2g3Y0N5a09vVmh4ZHlndXhRc3RFdm5QTjhtNzNGM3VMbmVYeStWQ2RuNkVlN0s3YjkvM2JIYjJteGxZR2l1elFqdUlOYVRDbkEzelpUQ3IyVUVSSC9hYm9BQmFFRDhPcmY4UVFNTUNncW0xZXpBdGorZE9SYmp0K3hSaXZ5ekZ5dk8wK0hGcHdZZjN0Qy9BblRxempyY2lyaHNWWmJZSnRKeG4vQTZleVdFclIzcTQwUjk4VFB1ZnpJajc2OHdTbFNxV1lmMnZtTVZEdG03Vm1MSmsrZEppbVNsVDV0SzZkYjhabEVtWExnMzE2ZE9aenAyN0pOdlRwazNONFM3bnlmMHpZY0owS2xXcUtOOS9IZW5WcTM5b3pOakpVcVpjMlJJMGI5NGtldno0S1EwZVBJWWo4MlNuNXMzcjA5S2wwNmw4aFhxU0ZkWGdJRmFzT0ZXaExsNnNvQ2k3ejU2OW9PTEZDM0VZcGtUMDRtWDRoeEFQZGJseXhRbmxraVpOVEZCQU5tNzZQZHpwdkgvL25oLzB4VHFGQWpGVER4N2NRclZyVnlGOHNPeHhKZ2wzRUxYQm9RaGcwSU9iK24vLys1UXE4Z01XR3hYcUprM3Ewci8vL2llajVkb2NDY0FlaGRxUkZ3VXhoeGN1WEVGbnoxMlVacWRObjBkNzk2eW5zbVdMVTRuaWhlbmdvYU9PUEZ5c2JRc0tiTGFzWDRuQzFxRkRDNW84ZVk1ZGxtRkhBVGhxNUVCV250YXpZbjh0MGsxQ3FXN1d2SE9NVjZwNzlmeE9CcGVSR1dEb2d3bXVPUlIwVjFDb01iaWROV3VpZkZmWHJ0MUtEUnJVME8rcUxKY3RVNXl5WmZ1YUhTb1gwaER2c2JJdFU2YjAvRDB1U1FYeWYwTW5UcDZWYlNOSERoQmx1bWRQYjVvN2IxbTRkb3czM0wvL2tPYk1YV3F3R2QvL3dZTjcwcVZMVituUG95Y045bUVRVXFOR3hVZ045QXdhdExEeUZWdW5xM3A0VU1WM3JEUkR1MlpKSHhSRUsrTjdrQzhydmNjQzMxSHp1UEZDZGtUd2Z6dTJPdDhLakVQZDJjcjhsdlhuUDlpcWZZbzE4UWJCSDJpS1cwZ1l4VTV4Z3VnNEs5djlLQUd4UGszSGc0UG9CUDlXKy9DT1ZyaUhsRm5yRm8rR2NybVNnUjlvdDF2Y0NJN3ErcnRoR1I0K3ZLOG9xUjZNdFNsQnpIY3ZyKy9rbWxzS09ibGw2NDV3MWZ2MjZTclpTL0c4UVVCancyQ3ZYNzhSbkpCcEhxVk1rWnlPSGR2T00ya3RKRUVUQm1tOWUzZVdBVjZiTnQxMXoyZU9IRmtvYjk1Y2xEL2ZOM1QwMktsd3g0bG9nK2t6aTZpV25mczlQYXNUbEdCZjMzWFVyVnM3SGpVVW9kKzJoQWNISC9FMFBDMCtkZW9DSGgwM28vcjFhNWxVcUkyN0FTdjIzcjBIcVczYkp2VGxseG1VUW0wTVVEU3ZmLzMxbDJLTjJMSmxKeFhqd1ZXZE90WG94L0ZUd3ZVS0wzWEV2dzFtcThET25mc005dGV2VjR1eVovK2FuYUpXMFoyNzkyVWZScjdGMk5LN2V2VkdWZzZ1eTdhNjNEWkduRUZCd1hUeTVCbjZmZHNlWFR2Z1kzLysrZWZNR2YyZDZ0YXBUdkhpeGFQRGg0L1I3ajEvNk1wZ0FSK1FTcFhLeXY0blQ1N1JxbFViREdaS2tCbXRjZU02bERKbENuNEp2Q1UvVGpjYzBTQXVXZElra3ByNElEdDM0UjZ2VkttTUtOWUJBV0hPTU9DTXYzcjFTdmVoU3NYdGYvdHRjN3A4K1NxZE9IR1dXclJvS0JhaytQSGpjY1NGOW9LUmRuNWZmWldCNm5qV2tBSExjMzRlMXF6WlRJOGV3L0pzdmJ4NTh5K0hTUE9UYTRYblNGT29jZjNxOERNTXE1RXhIcGh0cU1ZeGpBK3lKYTRRVDdYZHUvZUFuYnFlQ1g3b0p5eGVRd1o3MGJKbGEzUURZUDFyZEpRL3FEdDMrVnZkeWF4Wk1ndjJPM2JzbGJhelpQbUtYcjU4eGUydk5iaEdlRW5qR2lWbDNOKzllOGZXdE4yNmdZUFZCN095SUJ6UWNJNmJtWXQ4L3Z4bGVURkRPY25ENGVqd2NvZGN2bnhkUGlwd2VQUDByRUpUcDgyTjBCSFF5c1BiVkt4cWxYS0V0Tm4yVUQzTUhVaFRxcmR2VzhrZk1wOFlaNmxHWkk2S0ZVdFQ5UnJOeloyaXpkdFBuem5QQ21wbW1aVnpsSkp1Y3lkQ0s3eDQ4WXFWK3dHMFllTldhc3FEZWxNS2RUNVdKTnpkMlRMNnh4SGRZZkMrcmxxMVBDR01JQlRxTktsVGNwenljdkl1c2thWjFqVmt0RkMrZkVreHNFMmFOTnRvRDlHd1lYM283NytmMHZQbkx6bDBZYnB3K3gyNW9VWndBTjBMZEdmcmRKamkrc0xkbmZKOENLTGJyUFIyRFg1cjFlRllKNlpDWE84a094VytwWkMybnJPR2ZqWXdnSXF3cFJxTUVhakxlYm5NWmpaaUJJUzIrb0F0MTFjQzMxTmg5eUJhRWJydEVkYzd4dCtFUm01QnREdTByZEJkTWZJSDN3MDRNWU5LVmJseVdaUG4wTGx6RzBxUklobnQyM2ZRYkJtVEZYbGowNmIxNk1HRHg3Um43d0VwQWlNc0dBejc5eCtXOWNkL1B5Ri8vOE1FZ3g2TXJZZVBIS2N2dmtndjM3RWpmeDdYTlh2NjlIbktuejgzZ1UxaGp6aE5vY1lJcFZLbDBuVDE2bDgwZjc2dktNcWdkWmhTcUd2VnFpSWZuWlVyMTdPaVZFQm9JampCcUo3NnNRZEFWY2Q2QkVweFNsN01QcXhidDVVSFZoLzRoVjR6M0V6Q2Q1MWE4MVRqQ0g2cHUvTTlFRUFEQm54dk1FMEl4V1RZc041MCsvWmRXc3JLR2FSUG55NmlwSzVaczBtVTB5V0xwMUU5bnRxRVlnaGxMazZjT0RScTFHUWFQV2FTbEFjZk95dGJDdnYzNzhxSzUvK2tEbWdQTFZwMDBRM2NvSFJQbWpSU1BpNW9COXl1cmwzYlNzSUxlUENEQi8zNzd5dWxIVmpjUWQrQXRhVlJvdzRXTGM2WWVzS3NDeFRkTDcvTUtOTlVSUW9YMENtdDZDQTQ0NGdCckgyc1VxWk16dE8wUFdqanh0LzVwZkUzODhsYlVPTEVuM08vUGFoSmt6cGk3WVpDWFkwL2VrdVdUSk8rdkg3OVJsNEt3Szk2OVdZUkt2b0NqSVgvd0xsY3VQQlhIbHpFcGYvK2V5dkg2TktsTlpVdlgxOFVXQ2pSM3Q2OW1INzFTdnEyZCs4aG51NCtJZjFEUDFPbFNpNzl4Z3NWRkpYcDAzN2tRVUt6VUV1OWg1ekxoQW5UYUxqUGVBdTlDTnVGNjRmamZmdHRVMVpXVThyQUNlOFlXUC9MbGE4cjd3L1FpblpzWDAzcDBxWFd6WXJnR3NFaVlZc0RYdGhSTFM5VnFWeGVxREtlbmxWREJsZm5yN0JpZlltV3IxZ1hUbW51NWVVdDZhbkhqdkdXVUhXV1czYnNYaWlPdzRmMzQvalNZVlA0ampvQ2xPcjZ6S2xldDI1QmpGT3F2YjI5T0luTEwzenZmSEFVSE5MT3VuVmJxRkZEVDFxeU5NUjY1dERHYldnTXM4R1dhSlpvQ2dOeXZBc3hPNndKQm44UWhFbUU1TTZkZ3hJbFNpaDBsaTZkMjhwMnZJOVhydG9vZzFZcFpNVi83ZmtkaTNlcnNjVVIzTm1TSlF2emUzNjhESWF0YUNwU1JTb3c1ZUljVzRuMUdjdXZ1TVZYb1JRTmF4dUhEVHNKSzhKM1dISG1IeEVzd3B5UlByUXRFRW9TdWJuVFBVUVRnUWJPQXNYNktSdCt2dEFxOFRycUhXWXJlVU4rcDhYam92cDk0MTB4U2pBYmpRUkpvUFZzMnJUTnBMSU15Z2Ercnp0Myt0T3RXM2RObGpGMzBxWDVtd29qRzJaWjhTMkc0THNPNHkyK1I1cWM0eG5ZaGcxclVmTGtJZmR4L2dJVnRGMjZYL1FEOVRDWXMwZENMNms5VlcyclU2SjRFUjRScEJYcnpZV0xWK2ppeFdzRVdvZXhVeFkraWxXcWxLVWJOMjVKeHFrTkczNlhVU3pvSWhFSnVOYmx5cFdRRC83Tm03Y2pLcTcyT3htQnhvM3J5ZzIrZi84aDJyQmhxMWh0eWpLUFNSTU1tcUFBNGlWYnBrd2RTdmg1WmhveVpLd29XMW9aakRoaERjYWdDNEk2dVhObmwvdnAwdVZyckZSV1lNdDNkVnE3ZGd1bFNwMkxzbVV2S1I4SHpGcm9DKzY3SlV2V1VwS2tXYWhWcTI2eXEyUEhsdktMVWJLUFR6OStxSjZ3bGJzTXBVeVZpeFhhTWNMdHdrY0FNbVJJYjRMRnRsZXZZYksvUW9VR292aERVYkVralhncUNncnA0Y1BIUTYzdmJtS2x0bFJIZjkraHcwZnB5NjhLMFpFakp3V24wcVU5YWRqd0gwWGhueng1dEF4RUVIMGhSY3FjUEwzVm01THdNekZ6cG5WS3FuWWN2QURyMWFzdUF4bzhSM2dtUjQ4ZUpCL0x2UGtxVVBJVU9aaDd0bHltaHN1Vks2VlZrMTlZcHBGbHIwdlh2dEl2OUEvWEUvMUZ2OUgvL1BseTgrQ2xBVnV6ajFHYXRIa29SODVTYk5HK1Q1MDZ0YUpVUEhpd1JkelplYWRRb1NxVU5sMGVhUzhmdDEyc2FDRnBBc29xL0NtNmRCa28xNmhnd2NweURzT0c5YlhsRUZhWHZjejNIKzVQVDg5VzFJR3huelI1cHFUdHh1RElsQnpoQVFlczVzNXk1b05scG1pUi9KeE8vR2YyTlJuRWtUMWVtK3BXcExkaHdBbWxldXhZN3hpVEJBYU9lTGhYakdlcElnMEdON0I4K1hxbktJYU82R3VDQkFuQ05ZTjdWRjlnMUhCemMrUDNaaVA2NlNjZkNaMDRlL1pFV3JRdy9HeWpmajM5WlNRSEtsNjhJTDhIVDlDMWF6ZDF1L0N1d2FBWHo4ejgrY3QxMjZOcUFXZWJtWVBVWFdDRk5ySUNaU29CNDJJczc4Qy9EaFc0UEliWndiV3R4QmJ0c0RMYTFxdkJicFNlMzI5SlRlelR5c1NFM3hiTkc0amhDVnptLy83N3oyU1h2WHA5eDdyZ3B6S2dOVm5Bd3NibTNENWs1Y29OdWxKdjNyeGgvU0lCeng2SGZVOCtNSy9ka21UT25JbG54Z3Z6alBZNXUyY3huYVpRWTRvSTl4VXNWSkF0VFBYQWxEZm9IZm9DYXgyY29iWnUzU21iL2YwUGlyVUpkQkZqMGFhOHZWbTVHVHRtQ0IwNDhKdE0vMklVRk5IVXUzRmJhajFxRWNBMElhWjhqck1UNHRObnoxbjVPU3FLTHF6VW11VDVKb2ZRSi9idE82VGpMMDJmRWVKMHFwVUJ6eGV6SElVSzVSVkZEN1FNV0h5M2h2S3E3dDE3eU1yd2hGQkxVNkJRRCs3Y3VjOEs1MmRpVmRiYWdRVjMrb3o1Y205dFphb0dLQllZblVMQW4wcVdMQW45OXRzT0hUMWgvZm90TW5JR3h3cFNvVUpKZG1iNG14WXZXU25ybUVLNmVQR3F2RGhBTXpBbFVQNWhlY0ZnRXNvL1VoU0RXNGdCUUdRRkhzMFpNcVRsUHU4ay85QnByaVZMMXdqZXNDaEJtVEluc09CRG1jVnpOUEtIZ1hUZ2o5K0U3Z0g2Rk9nZUdPM1BuZXZMZzUxUnVvL2ZvVU4vU25OSmt5WXlhUGFYWCtiSThXL2VOTzhvR1M5ZWZGSDhBM2txRkFJbEhBT1RvVVBIeWZVd2FEQ0NsWTBiL1FnRGRGZ204RTdCQnhtS0VhUklrUkRxeVlLRnZySU96UDM5anpCbEpUN0JhY1hSZ3BtUHZuMUh5SFcxdG0xdjczRXllQU8vT3FyRjMzOGpUNmR1bEhjdzdyMm9GQ2pWamRsUmNlclVzVFJxNUNDWFY2ekhqZk5tSzlxNEtJSGtDVk9mOEw2eEZBVWpTZzRjUlkzaWZRQUI3U3RuenRKTUhjb3IxbXI0TGxWbWlwdzFVcmR1RFRHbUxlVjNsTDQwYlZLUFFEdUJmNEVwL3lyOXNvNVkvcFNWMWFSTWNYbkp5cXVyeVdPMldIL0NuVXJzQXJHeDdjVUdQUG0rZmJ1S3MrQ3ExV0VLcjM1N09iSm5GWm91a2tUWnlsdUdFUlZjKzZ0WGI3S3g1cGl1V1JnMjRzYjFZRXQzT2RtR2NuQ0FOU2Y0Ymt5YzRDUGZodkhqcDVvckZ1RjJwMUUrd0JmRWgvUHdrWkNUaG1JOWNHQVBzVFRxY3lmQjFjSjAvNDRkSWR4Wk9LMzk5ZGR0b1l2Z3BQVzVwdUMrUWhHQWdHOEw1V1RFaUovbzUwa3pJenh4VmNDNUNKVG1SQW1nS1lEcUFBSGYvZWpSVTZ4Z0ZoRytPeXloc0tiaUdwdXo2R2s5eG1BTHRJaUNCZkl5MWFPZ0ROU2doRU5PbmpyTG84c0xWSTlmMkhENGc3SUlTZ0R1S2R3dm11QitDUTYxU3NCQkVGeHJjSU1oS1ZNbUV3dk1oUXRYdE9LaVdHZlBVVkxXMFVkUVFJSjRTZzU4WjAzQTA0WGxHd05GZkVTTkJaWklLSHV6WmkyUlhUZ3VlRjJOR3RVMmNQZ3hybWZOdW5hT2g0d2NDTUhaTFZ3NFAwOXpKVFBiVEp3NDdycVhEWEI1L1BnSmdYNHhZZUowcVFOdTh1UmZadEUzckpoNzllb3MvT3c4ZVhMSVBtTUhreUFyWHY3SFQ1eWl2Y3gxQTVmdXdubC90cGd1WTRWOXFVbk16SFk2ZEFldW15YXdoRU9nTUVONUFRM24rdlZiMm03NWJkeWtnOEc2bzFaQW80RGxEcHhaV3dTSzUvYnQrNmdkejZBWU8yM1owazVFWldGOUFhY2RVU2ZncE9NTTBjNE56a2l0V2pYa2E3eU1CejA3bVljYnRjcTh0ZWNtVVU3WXNwbzRjU0w1TmpuQ09kUGNzZUVzQll2dXlGRWZUMWJKbjMrZW9UTTQvUHJySEltT0FBNzZEaU8vRjFPWWdLb0dLc24yN1h0MHUvRk9IVENndTN6dmZaZXYxVzJQeWdWWUZQRUhXb2FyeWIraEZKRDRNZGhDM2Jseld4NXdwV0ZkYjZTQjdxYVBOWkpENFRzeU1mUjdvNzh2b3VYeTVVdUpGUnJmVkgzZEVQUWpSSHdiTUtDYkdHaGh5QUwxRDk4My9YSmErNzE2ZGhZL2djV0xWNUVmKzluWUswNVJxR0U5eTVRcGcvQXZFZXRQWDBEdjBGZVVNWlVQNWNmUHozQzZCNUVJUUJ2eFo3cUFKdUJVT3lKc21OYWUrbzA2QktBMFFtYk9uQ0IvK2tjcVhhb1kyVUxSMmJWclA0OTZ1N0FGTXI4NEVla1AxT0ROdTM3OVFnNHBsNGQ1MXZmRW9vcjd5NUdTUGwxYXVaZERCblF0RFpvR1RRVGNiMU5TcTFaVnViZDlmUHF5VmRLUWRnRG5SODJEM2xUZGlMYVptR21VS2xEYUl4THcyVXVXckdWeG1xdGYzMjdpcFEyNnloVjIvTVJnd2w3QkM2MGhjODNiczZNbG5KT0JCVUlld1NONzRhS1Y5allicmZYYXRXc21rUkhzNmNTa3liTnA5NjQxN0ZTN2lhMXlyK3hwd21JZGhENWJ1T0FYSG1DMmRraEVENHNITTlxNWptZDI4Q0ZidjM2ckRHNWJ0MjRzTklGTGw2NEovYytmdzYxRkZmWEVxQ3ZoVmhNekQ3aFpzM3BNdTNuUDlLVXc2bG00Z2c3WXNKME5SRkFjWEYyaE52VytNSTY0d0RxSkNLaDNtc0FJZ3VkYW0rWFR0cHY2aGRONVZxWjhyRnExeWNDQldBdVpCb2ZJSHQwN1NsVVlDclNaYUVTa2lhcW9VSjg2d0VDTk4rSi9ZZU43M2FsL292ZHkvc0JLc2ltRy9pZTgvVDhqeGRuZGFGM1hZQXhaZ0dHcFM1YzJNanVUaDJPSzU4eVpuUjIwUXd3eDFhcFZFQ1g2Q00vc0lqZ0JPTXMxYWxTU3Y4S0Y4OGtad3BrY2cxM05WOHJVYVNPa0k1eDk0VitrTHc4ZVBHTGEyYmM4MHpHU25lVXJFQXhOcDArZlp6cGVOVEVzNkplRmI5ZWdRZDNaaW42UjZVYWo5WGZadk93VWhScG1kNWpmNTg5ZklhTlByWmRWcTVZVFp6TE5LYXRnZ1R6TVU4M0VmTXNUWXNuUXlvRUNBZ2VtS2xYS0dTalUybjcxNjlvSVlMb0ZZUkp2M0xndGpnTmFieE1tVEVnOWVud3JqZ0tMT1dvSEZEdU1JUEVDdFNUSGpwK2lodzhmczdOZFJlWTRaNU00cU5xb0U0b05sT2tmZnZoWkYyOFNTWUF5Wjg1b3FVbURmWm8zUGl6cStwSWpleFo2Kys0dEsvOTM1Q044Ky9aOUtsaW9rbjRSczh1d1hGZXVYSWFkQ2greDRyWElvRnovL3QwazFPUDRDZlpQTldsOWhwVmNYMkFSQjZZZlBwaDZqZXVYTkwrTVNCLzkrMy9QMDJvMytCd2FpU1VaaVJpMEY1LzVtdWIzZ0pjSk9nLytHdk5nNjlkZng3QlZmRGo5Y2VCUEhhM0VmTzJJOThBWkJZUHd1SEVOcVJSZnBFOHJzd3V3Um1yM1RNU3RXUzRCaFFQVGpwcEYzM0xwOEh2aEJEZHExQ1QrRzBUZk03ZlprUUlyN0pMRlUzblFNdEhweWpUT0E0bGZlbmtOMVoyU3hsRUdCUWtmdCs3ZE8vQzlHVUFYTGx5V0dMVVlWQ0c5dVRPa2Z2MmFiRlZkeTQ1U3YwYzZpVXRFL2NVMWhzOEFsRWtreEhGVndmWENqSlhtdUlWK2F1OFV6SEJBbmo0TmNkaEtuVHFWck9NL3ZOOFFIY1NVUXE0ckZMclFyRmw5bVFGY3ZueWR3UzdRNlRBN0JtVWJmNUJFSEVsSmM3NCtlL2Fpd3hYcXQxQmsrZjJZR0tPRVNDclY3N20vVHpoRVhrYVl2RU1WYXpTSnVjRUhvVUdzWWQ1NHdzWUlLY1BMRUNoaG9KM0FDVkZmOFBWQk15OWphQ0x5VEJremlPRUYzeWJvYnhBNHRVTktsQ2drOTlqRGg0K0Vyb2R2ZnFkT0ljWXAzRXNRUk1DS3krRUt6U25VOEhzb1dyU0FjSjdQWDdna2RmVC93MnhoK1FyMWRadU9IOXZCTktXblFyZlVOaUs0d0t4WlA0bnUwYTVkVDRNQm5sYkdsbDljeXlnWGVMM2pBemQwNkZqaHoyb0hoTmNuU09DZ2VZQ3JpYmpFc1BwTm1UTFB3QnNaUEJ5RU93RnR4SnZiVUJLekVFQmtDM0NTWjg5ZVFzWktZN1ZxNWNYU0RFZEFXS2xoQVVYRUNHM1dBbHhYWXdVYkwrMzkrLytVK3dIM0M4S1VhUUlIUlZoUEVRWVBnbmFNTFN4YVdYTy84REtHY285QmdDYkk4QWdPS3FoSWpScDM0Q25paCtJUmp3eGl0OWpESFlKcC8wOCtUV0RTMmw2b1lENlorc0lIM0JnRHZEZ0tGODVMT1hOa0ZUNHdqZzM2QUY0c09GY294YUN1R0F0bWNqU0ZFZnh0WUlmUi92Z0pVMFJaaEhOaHZueWNiWXpwTmZyMEZlTjJJbHJQd09HRjBCZFlGVFVxUytMRWlTT3FackJmZTVGaVk3ZXU3Wm5qUHBpdDB3TTQ4c0VhV3JWNnMvREl3YXRNeDlkYjMwbkpvQkViVnNDL3ZILy9rVmhITVd1QnNFbVFsU3ZuOEd4WmVyYVdsSEVZUjdOZTNWb1N1U1l5MFNHMjc5Z3I4WXFoYURyUy8yUGMyQ0hpanhMZHNjNk5MeDNPRVg5ak9SRU1mQTVtekJqUFBoWjVhQ1R6clIyUlZNWDRlTWJyZVRtVUlTSUIxZlpzemMrSy9ZTk40M1l0clNQVVo3OSszVnhhb1Q3RmxEbThQMkVFV3h1YVBBUGNhRmp4b1d4RFRyR2xENXh3T0ZpRENvYUJhY21TUldYMkRRN25sZ1RHRldTUFJGUVE0OWpjM2I0ZlNQalRGODBZQXVmbXlDYXcwbTlYVzRhQ2U0OGpmR1NBRWh4SmdUcDhuTEdyR3NlRFBnMGtBZ0VOMlJXLzRmVUpjSWhqN1JwSzk1bGdubTNIdTVzcjRNNUx4M0d3czNLWktSeWJXb3Y4d1pzcGpWc3dQV0ZGL3prN0pzWkUwUnpvOWZzT1E4emN1Wk1rZ3N2TVdTR0dwVFZyZjlNdlFzaUtDOHQycDA1OVRFYUIwd3BESjhRM3puaGdwdTNYLyszRW1Wd3hZRnU0Y0pVdVdoeDBnOG1UUjNGWXh2VGlwTzJJOTY0RGJpUDlib2RmenNWbWZzVGh4T2dTem1qNmNvVDUxSzlldmRaRmJJRGlqUWYxK0luVCtzWGt3M2ZxMURtaGpZQStvaVJtSVFCRkNWWlNPQW9ZQytJSXd3cFJ1bFJ4UWphdFBYc095TFRRaXVXenFYOC9EbSsyY2JISm1KQWJOdmdKNXhtMEgvMllxU2M1VGlvVXpSRWordE9BL3QxNUtuMmRoTlF4UHE2bGRUaEdIRHAwVEViSVNNSGRyZXUzUWxPQnBXUmVhQklEY0g3aG5MT1IrOWV6UnljQ0pRSUs5eHJPemhRL2Z2eHd6V1BnRUVKbDJoMXVIMklqZi9MSkoyeWhLeTc3d0MzSFZPY2N6azRHSjBHRXE0UFZTRjlBYzRHU0MrdDJGZjc0NFdVQVo5eThlWFBTeWhWenBjOXIxOHhucFQ4amM1U1hSa3A1dkhyMXVyeUV3SThjTTNvSVRaMHlsaFdmQWZyZE1ic01SUmJjNXR5NXM5R2dnVDA1aGZFWDdEeDhXQ3ptWTlpUkdBSDVzUjJEYWRCbDhKNXdsSUN6aS9CZXlKajFmYmYyTkd2bVJCNWc1QmJIVFNqY21QbTZlZU1ZblRpK1ErNUJlNC9icVZNTFdyQWd4UEhSM2paUXJ5L0hiaDQzTHN5YUc1bTJVUGZiZHMxbE1CbVYzT3pJOWhIMU1VaERSQnBFQnNIVUxLYitvMUpBZ1lHelpNZE92WjJtVE9OODhJemk0NDNqdTZwZ2hnZ0Q1K2JONjRxai8yUU9IUXFlS3B6SU5Vb2FCcnkrdnV2bFhiTnd3UlFhelRNclhsNmRDTTdmOEFlQUlJVG5zNmVYYWY2OHlRYW5XcVZLZWVHOHJ1WkJ0RFhXYklQS1ViRENlaStkWklVNko0ZXlnelhaRmluSkdROHZjQ0tYQ25wcHd4ZHo2dkswYkcyZTd2YU9hbkdteFJtaEFlL1c2aVZubWNlSlgvS3dBdjB6eC9aQW12Slpib0gwaEVNVitya2JmamZ5c1VKOWlXZlovckdsVXg5cDJUT245OUs5dTZmNSs1RmV6aERLTUdKUHcxQnJUUGZRSU1EN0hkOWxmQWNuVGZwQlpzaEhqZnBKMjgyMG9rNHlNd3cvSXhpbW9IUnJmelZyVk5hVnMyWEI4Q3R0UzAwcnk4TDZCbWN2TGJxSGZyVUhQRzEva1QzMFFmUEFTeFRUOTVoT044V25oUWNvckZ3WU9TdUpPUWpBMFFTaERCSFhGT0ZvakFYT2FWQzJtelR4bEYwSTU3VnQyMTZ4WWd3YjVpWGV1M2hSRzh1QmcwY2trY2NKamxhZ1AxQ2J4Wmt6a1RnSWlpV2NvVERkQk1jL0tKL3BlYnJmV2tHc1lrVDVhTkdpdm5BK3dRZjcvdnRCdWdReFVGSVEwZytXOXg5LzlPWXA5YjdTbng0OWhrZ29OUDNqNE9HSGJ3QVV5OU5ud21Od2dEOWlvR1EwYUZCTHFpSFp4dkhqWjFqQnFFazllM2FRQVlORzZkRGFoVU1RYUM4dFd6YVVEeDYyZCs4eG1LZXZGalBleGFYUFVCNUhqLzVGUjMzUjZ0cjZlNTlwS2oxN0RwSCt3eGtVVnZCRmkxYkxkY01Na3lYQlJ4TWUrNWdsQUljVWZGcFl1SnB6VmozY0UxRE1odzcxWWtmVSs4eG41VzFzVFhlVWdFNENxZ05TMlU2Y09KeWpUbmpLZ0FpS0srUVREcXVFZm1GZzVHYno1MVNha0ZqU3AwOWZjQWozR1JiQU16eE5pU3hma1JWUUMyQ0I3ZVUxTExKTk9hVSt1T09JdGdPT3NjUlo1MEYyVk1tTTZUOEt4U1lpNStlb09ENUM2Q0VtdGFzS250ZW1UYitqVTZjdThEUGZrUWM2TGVYOUEydWh2bUNtZU5teWRUSkxpSXh6dUhjeElOSm1naElrK0VTKzEzai82MHZyMW8za1hRZWFqYXZJMWlCM3lzc3pnRWswbm9hVkhmdVVGZDdrY2R3SWtVSTBPZXZ1UWEzZkJZcUN2b0l6TGFaazVicnArN0MwNHloM2dCUElkSHIzZ2NxdzVkbVh5MEFKYThJRzdKZGFJL3dMWWtReE5nejVzY1VibHUvWUx0RDlZRlI2K1RKa2VJRk1tbml2K3pOOVNydm5qREg2TWxORzBRSGdrTGhvMFNxT3U5K1k4QzNUcEVxVmNrSTl5cFVySzFNT1J4djhnWXBtajdqRlQvQkYyTjFnVHdzeHBnN0duN0hrVkdQTU5WRWRWUWpFYkFTVys4NWlwWDJDdy9qSnNGNXUzYkpNWHY3R2d5aHJrY3FjT1JQUGJ2ek1DazViaHlqNjFoN1hVZVVxc0VVVURrbWR1L1J6VkpPNmRycHpabEZFdkxFMmdaQ3Vvb01Xa0YxMStmSlpuSTB4aEZQcW9HWlZNNUZBNEZPdWV6ak9CeHJKbVJGWEcxbUpJOUZzcEtybURncWc3ZkhjcUVpQUc5M1Y1NEZFcXRXWVdSbVV2VE5uOWtxUWdTSkZxN3IwU1VTNWhkcWx6MTUxVGlHZ0VGQUkySWtBd2tIQnd1M0ljR3VJZURGejVtS213blN6cTFkUXlPZHk0cFl1WGZySFNHVWFKdzNIeGM4KysxU3MvM2FCWUtZU25ONUJPUmpKRHFEUkpiREVJMzd6MTE5bmlxNHVxT01hSVFDdTg4OEJRZFRWdzQwc3U4TWJWWXlpVlpqK3VqS1ZaQ0hQV3NaMlpSb1FJNzQvOGtoTW1USW5paEIzWExOS29YWWNscW9saFlCQ0lCWWgwUG03dHNKUGQvUXBJd1p2MmJMRmhXOXVTOXRoRVQwY1p6RzM1ZmlPTElzRU9VaTI0cWlFTjdBTVQySStNTGphem5KQ05JY0hISnVuVHh2UHlXNitObGRFYlhjeUFyNXU4ZWtOVDJCM0NINW5KL25MY1IwdUYveWVpaklkWkNMM1NRbHhSdVBWL056MkVRZDJWOGRES2RTdWZvVlUveFFDQ2dHWFF3Q1dhVGlSYnZYYkdTVjlReUlFS0pUV0NDSld0R3ZibENhejQ4M216ZHRkT29xRU5lZURNa2dLczJyVlprNGsxTW5hS2hiTHpaZ3hnUjJWSjBaNWVEeUxuUWpkaVdnbVpjb1VrNmd1MXBSWFphSWVBVVRmNkJBY2wxSzdBR001UC9laGRZQTdQWXQyMVQ3cWNiZm1DSGZ1M3FObHZtdXRLUnJ0WlJTSE90b3ZnZXFBUWtBaEVOTVE2TWpUa0xDZXpwaTVJTXE2dm1UeE5IR3FSWXpxTjIvZVVDS09pNDZ3Z29nQWc4ZzRxVGhNSTBJcU5tNWNXOWFuVHAwdmtVS2lyRU5PYmhqNCttMzE1U25mM2h5YThvN2RSd2R2R2draVhDV3BDaXpUY1BaRGVOakluSmZkZ0tpS0NnR0ZRSlFnb0JUcUtJRlZOYW9RVUFoOHpBanMyYjFPWWhoSFpaYS8xYXZtU2xnbnhPcy9mLzR5ZTdpLzVHZ29EeVZsTTVKclBIejROejE2OURmemdzdHlQUDhpRWt0Vml4UCtzV0FQM25OZkRuM1ZyUGwzZHAwUzZ2djQ5S2Q2SElFaXVxa2VkcDJBcXFRUVVBakVHQVE4RGkxYUVRQUFJbFZKUkVGVVlreFBWVWNWQWdvQmhZQUxJRkNoZkdrSmF4aVZ5alJPRTlGRFRwdzRTMU9tenJPWW5odE9rU2p6TWNweERvdUpRWU5uN2FxMFNTK0JVMFRuT21oZ0Q4bTJoNGdualJ0M1ZNcDBSSUNwL1FvQmhVQ2tFVkFXNmtoRHFCcFFDQ2dFWWhNQ0t6anMyUkR2c2JyTWNiSHAzS1BqWE9GUXVHblRFcXBSczRYRmdZWFd0ektsbWR2T1ZCSEVmNi9KZFZ3dFM2VFdUL1dyRUZBSWZGd0lLQXYxeDNVOTFka29CQlFDVVlnQUxKNUlBNitsWVk3Q1E2bW1ReEZBcUxtcGJJRWZPS0E3SWFHSU9ZRnpKdWdkVDU4K2w4UkJDQ0dvbEdsemFLbnRDZ0dGZ0tNUlVBcTFveEZWN1NrRUZBSWZMUUpkT3JmbE9OR0xQdHJ6YzlVVFc3VjZFN1ZxMVloeTVjd21LYnoxK3dsRmVpQ25yMGNtVW1UQlZJTWRmWFRVc2tKQUllQXNCQlRsdzFsSXErTW9CQlFDTVJvQldEdzNiMXBNNVN2VWo5SG5FVk03ajltQnFWUEdVaVBtUklPL2p2VnhZME5DQzNwN2ozTm9ncDJZaXBIcXQwSkFJUkI5Q0NnTGRmUmhyNDZzRUZBSXhBQUVFSE42d25nZlFtYkVKVXZXeElBZWY1eGRoT1Vadk9pSEQ4NlNuOTh1ZGpRTUpJUVVQSDNtL01kNXd1cXNGQUlLZ1JpRmdGS29ZOVRsVXAxVkNDZ0VuSTFBM2p5NUtIdjJ6SlNUNlFiMmhtOXpkcDgvMXVNOWVmS2MzRGczODV3NVMybjdqcjBmNjJtcTgxSUlLQVJpSUFLSzhoRURMNXJxc2tKQUllQThCSkJncEdPSEZoUVlHRWl6NXl4eDNvSFZrVXdpZ0tnZmNGUlVvaEJRQ0NnRVhBa0J0d1NmWnVBTTlyRkIyS3hCc2VSVVk4UGxWT2VvRUZBSUtBUVVBZ29CaFlCQ3dCa0lCQWNULzdNb0h1NXhMTzVYT3hVQ0NnR0ZnRUpBSWFBUVVBZ29CQlFDc1JhQm9JQ0lqYkllZ1I4aVVMay9LdmhpMDdsK1ZCZE9uWXhDUUNHZ0VGQUlLQVFVQWdvQmwwWEEzV1Y3cGpxbUVGQUlLQVFVQWdvQmhZQkNRQ0dnRUlnQkNDaUZPZ1pjSk5WRmhZQkNRQ0dnRUZBSUtBUVVBZ29CMTBWQUtkU3VlMjFVenhRQ0NnR0ZnRUxBRGdRUW1RV0plSlFvQkJRQ0NnRm5JYUFVYW1jaHJZNmpFRkFJeEZnRUtwUXZKWm41SEhFQ1JZc1VvRlVyNTFMSkVvVWQwVnlzYWlOZHVqUlVwWEpaVHZBU045eDVaOHlRbnBDR3ZFenBZblRpK0hhNmQvZWt3NjVadUlPcERRb0JoWUJDd0FnQmxkakZDQkMxcWhCUUNDZ0U5QkVvV0NBditmajBaK1VzSTJYTVZJZ3o5SDNRMzIzenNxZG5WZkwwckVKZmY1MkpTcFNzU1cvZnZyTzVqZGhZQVVyMGN0K1pWS1JJZnZMM1B5d1F1Q0hMQzRkRFJUaXJlL2NlMHRPbnorakZpMWVNNlh2QmRjSDhYMmppeE9tMGFmTzIyQWlaT21lRmdFTEFpUWlveEM1T0JGc2RTaUdnRUloNUNJQTZzSHJWSEVsN3ZYMzdQcG93Y1Zxa1RtTHFsTEdpOUQxNjlEZGx5NWFadnU4K0tGTHRSVWRscEdHZlBlc25TUUUrWmVxOEtPMUM4bVJKcVYyN1pqd0lxVXJYcnYwbEE1dnUzUWRIbUhJY0tlT2hoRStjTUp5VjY3YzBjTkFvTlhpSjBpdWxHbGNJeEc0RWxFSWR1NisvT251RmdFTEFTZ1NnblBsdDlhVjIzL2FndTNjZldGbkxzRmd1VGwvdTQ5T1BHalh1SUR1Z1hQdjdINkpWcXpjWkZuVHh0VUVEZTlMdzRYM1lJdnljcmx5NXpsYjdBQmtrM0xwMWwyN2R1c04vZCtuNjliOVlvZlZnWmJncExWKytubzc4ZWNLbXN5cFlJQTkxN3R5V29MelBtYk5Nck16MnpnNDBidVJKSFR1MnBGNjlodEw1QzVkdDZrZW1qRi9Ra1NOK1loWFhycHRORGFqQ0NnR0ZRS3hBUUNuVXNlSXlxNU5VQ0NnRUhJRUErTS9mZjkrZVdyWHVabGR6bXpjdHBWNWUzcUpzb2dGWVVUZHRYRXBldk0xV1JjK3VEa1N5RXRKK1Q1em9JNVNLM2J2OTZmejVLM1Q1eWpWcEZmc3lzdktaTVdONnRpSi95Yi9wcUVTSklwUW5UdzU2OU9nSks5N1haQ0J5L2ZxdFVLVTdSUEcrZGZzdWdmOWNvMFlsV3I5K0s1VXBVNHc2ZEdoRk4yNzhSVE5tTEl6UUVtM3RLV1hNOEFYTm5EbWUxcTNiUW5QbUxvMndHaXpqelpyVjQ3LzZWS0RBTjFLK2FOSHFEdXRQaEIxUUJSUUNDb0VZaFlCU3FHUFU1VktkVlFnb0JLSWJnWmt6SnRDcVZSdHA5NTQvYk9vS3JLUjU4K2FpSWQ1akRlcEIwVnU0OEJlcTdkbWFYcjkrYmJEUGxWYktsQzVPbzBZTnBISGpmcVd0ZnJ1czZscnFWQ2xsQUxKa3lXcFJ2S0U0UStuT2xPa0x5c0RMbVRObm9uVHBVdXQrd1lPZU9YTVJMVml3bko0d0g5clJnbG1HRVQ1OTVkamRtV3J6NHVVcmcwTmdmNFh5SmNXcS90bG4vMlBMK2daYXQvNDNTcHdvRVNWTGxzUmdkc0dnb2xwUkNDZ0VZajBDU3FHTzliZUFBa0Fob0JDd0JRRllMdGV2WDBEbEt6UzAya0VSbHVqZHU5WlJsYXBOVENyTm5yWGhxRmlWT25Uc2JVdFhuRklXSFBKUkl3ZFE2dFFwbVlMUkw1d1M2b2hPbEMxVFhPZ2RvMGI5N0JSTGZjVUtwV25JRUMvYXpNNktvS2djUDM2R3Z2MjJHVlhnN2J0My95RUsvVis4M1ZqbXp2bVpGaTllVGY3N0R4bnZVdXNLQVlWQUxFZEFLZFN4L0FaUXA2OFFVQWpZamtESERpMHBjZUpFVmpzbytnenZMMXhqMytWcnpSNXM0Z1FmT25QbUFpMWVzc3BzR1dmdkFNVmw3Rmh2bWpwMXZsaHFuWDM4cUR3ZStPekhqKy9nUVZFZ0s5YmJSWW5ldmVlQXhVRVNaaE9tVGgzTHN3a3RvN0pycW0yRmdFSWdCaUtnRk9vWWVORlVseFVDQ29Ib1JjQVdCMFdOdTF1OVJqT0xuVWFiVzdmNFJqdWZldERBRUtmTGJObSs1aWdrWDVOWGIyKzduVEF0bnJBTDdCdzFjakM5ZlBuUzZvRVJ1b3lCejZaTjI1U1YyZ1d1bnlPN2tKckRMM1lPZmtjajNCTHdVdlNKVjlCYjJrNXg2Yng3bk9qcmhEcXlYUWhFaTBMZG9YMExTcElrTWMyY3RZaisrY2VRTTFpb1lGNnFWcTJpd2NtOGV2V0tyU05iK2FWK1g3ZTlaWXVHek1QTG9Gc1A1a0NrOSs4L29MWHNjUExxMVQrNjdXRUxJZkZLdzliVmtrSkFJV0FOQXVDUGR1clVpcDQ4ZVViekYvaUdxMkx0czRqblBuWHFWTHI2d2NGQmRKc2QwbGF0M2t6djNyM1RiVGRlNk8zVmhkNi9mMDlUcDBVdVBGdXRtcFZwelpwNUV1a0I3NTdJaXJVT2lrdVhUS2RKazJiUzhSTm5JanhrZFBPcGMrWE16bGJiN1h3OTNoTkMwN21TdFR4QzhKeFVBTHp3MWF2blV1a3luazQ2WXZRY0puNzgrTlNrY1IwNmZQZzRYYmw2M1dRbmNtVFBRbFdxbEtmNDhlUFI3TmxMbUE3MDBtUTVVeHUvNjlTR2tpZFBTc3VXclNGOWVvMVhyODcwdi85OWFsRGx4WXVYa1g3K0RSbzBXb25INit2ZDN0R2VvR0Q2U1UraC9pWW9nS3E3QmRDcllEZGE2eDZQL2lib0VkYko1MXdzYjlBSDJ1OGVsb1FvVTFBZ05YY3pIY2YrTld2eE05d1RVTVdnOXpUT3c0MHFCSG5RTXh1T1oxMnZIRnZLd3lNT05haGZpMlBxZjBsQmpOM0prMmZvOTIxN0RBNkNNazBhMTZVdnY4ekFkTGMzdEdMRkJucjQ2TEZCR1cwRmRMcEc3R3VDcUVEVzNrczVzbWVsQmcxcTBWOS8zYWFsZkM4Wmk2WDcySmErR2JkcmF0M3BDblhhTktub3hJbGQ5UG5ubnpGbnNEWHQzT1Z2MEsvTzM3V2h5Wk5IMG9jUEFSeXNQNWdRdHo5dTNMaHNSWGhGZGVxMG9jTkhqa3Y1My8xV1VybHl4ZmxERzNKenVydTdTNXpZaXhldlV2WHF6VXhjTUtWUUd3Q3RWaFFDVmlKUW8zcEZWa1RuMC9Qbkx6aGlRemw2K3V5NVFVMXJuOFhEaC93b1g3NWN1bWMyVGh4M2loTW5EaDA5ZW9wcTEyNWw5Z1Y2OTg0cGVSRm56MUhTNExqYWlxYnczNy8vME9RTFZTdm5hSVVhN1Via29JZ01pNDFaS2VuY3BaL1dqUWgvd2FldVY2K21oT2VMc0xDREMyVEwralYvekdieU8zaTJVcVl0WUR0NjFDQU9wWGZpbzB3WUF3V2tkYXRHMUs5Zk4zYmVURWNORzdhbjM3YnNDSWVHei9CKzFLZFBGLzQrcytMSDc0VGl4V3NTSXJaWUkrWExsV1NhelJMK3ZydHpkSmZtdE0vL29GUkx4SkZpTGw4NklIUXEvWGIrK3VzT21Ydis5Y3ZadS93dFc2YmJ4bkdqeWtIeFNCdmF0K1Z0VStMRnBadUJRWlRZUFVTUnJ2RSttTTY1ZTFnOERCVHByc0Z2cVR2ajhodUhrL3lPRXVqS0YySUZlM1NjOFBidkxLeS8vTU4yOFNLQmNlazlsMTdNeXYwRFZsRDdzM0x2cW9KQno4b1ZjNmhTcGRMMDc3Ly95WDJBTUprVEo4NmdvY1BHU2JlaHNDSXJiSTBhRlVXbncvcURCNCtwWXFVR2RQUG1iZDJwUVpIdTJiTVQrMUcwNFczQlZMaHdWWU5CbHE2Z2lRWHQrN04zN3lHcVZyMkpya1JFOTdHMWZkTTFhTVdDMDFPUGx5cFZqQitXendrS2NKMDYxYzEyc1F0L2dENVBsSmtTZnA2Wit2Zi9nUkltVEVnalJ2UTNLQTlsdW1USldsSXVXZkxzUE5KZFJ6bHlaS0UyYmNKQU5haWdWaFFDQ2dHYkVhalBGZ2gzL3FBa1RacVlRNW9WTjFuZjJtY1JNMUpReXZGc3AwbWJoN1p2MzhzdnozeFV0MjQxaysxYXN4SHZrMzc5dWxMTGxvMnNLZTdRTXQ0Y3NXUEVpSDZTUU1TNFlWQTRoZzd0VFNoaml5Q3JIMmJiT25Wc1pVczFoNVJGU0x4bXpUb3JaVG9DTkNkTW1NWVcvUFlSbElwNXV6R2dPbmQySDAyWk1rYWltcGc3Zy9iZk51ZnY4dmQwNnRRNVVhVFRwc3RydFRLTk5vY1A3eXN4eW8zYlQ1VXlCY1dMRjArc21Bayt5VURhWDFRcTA3Q0Y5L0p3cHlrQndUcGxPakZ2RzhiSzM1UVA3OW5LN0VFNUErTFFIYll1ZThjSnRHZ3pyc3ZXNVlzZUFkU0JGVXQzeWVKcGVJYkgyRnBkTlRpZXdWOHRYci9IczNXYldYR0hNZzkxZTNxZ083Vm1aVDQ5QlJrMjRFSnJiZHMwRTJWNjBhS1ZsREpWVHNxWnN6Uy90eDVSdDI3dENQNEpFRml2cTFldndMclpXa3FTTkF1L3AzL2dXY29VOU9PNG9ib3pxY25oTWkveElLcFBuODVpRk5YdHNHS2hXdFVLVktwVWtYQWxyYm1QcmVsYnVJWWoyT0IwaGJwUm85cWNBT0NseEMrdFdMR1VWUUF1V3J5S2FSeXZKTFNTdWZQQmxQR0tGZXZGcWwyUWFTTktGQUlLZ2NnajhPbW5uMURac3NYNHczbWVyY1QveXRSYVJLMWEreXlDbXJWb1VZZ0RYaEYyZm91Smd0QnVpUHJnMWF0VHVPNTM2ZHhhWWg3YkUvNXR1TTlFaVlHTTFObWdnVGhERU5idnpKbnp1cmpTempobVREMEd3dTBoL1htcmFCakVSU1ZtVUhhUXdiTng0NDV5WDVzNkZpeDczYnExbHpUdlRacDJvcE9uenBvcVpuWmIzVHJWWkJCOTgyYjRLQ3B3OUlWQy9mZmZUODNXZC9TT1VzSHZLUmxieW5jeHBVT1Rvcnd0T1J2OUZnVEZGUVVYeE5URnJQQVdqK05CaWJSQ0puNVR1Z1dSOTRkQXloZm9RWGU0dkRVQ1dra2VibmRWVUJobitpUXIzZys0ZmdQdWg2dEtuVHBWSlFQcGxDbnp4TEgzRGxOeXQvQk1CcjRab0lCQUdqYXNMWmJwR1RNV1NwbVpzeFpLdHROU3BZcFNrc1FZdGhDbFlkYkN6cDM3cVhScFQ3cDgyVFMxU0FvYS9ZZjdjTml3M3ZUdzRXTTVodjV1YSs1amEvcW0zNlkxeTA1VnFKTXliN3BFaWNKTStUaEhHemY2eVhSUzBTSUZJK3huQXVabndhS045TEdXQkFCRDNyeDVZNm1ZMnFjUVVBaFlpVUR4WW9VNFRuQWFVUXpQbjcvRU0wS0ZtYTZWTU1MYTFqNkxXam5UZmc4UkhvWW0vVHhTckJzSkUzNUdvSUM5ZWYwWGxTMVRRaXJDOG5IbDhpRjYrOTl0ZXZUd1BEVnZYai9pQnUwb3NXRGhTdWFSbHBPTWZscDFUR0dDNmpGajVtSnRrMDIveUFqNDRzVXJVYXBoZlk5cVFXZzhKS3daTzI1S1ZCL3FvMmwveXBTNWtuMFJNeEVmaSt6anJKMmxTdGUyU0dYSmx6YzNLMHlaYU5ldVA5Z2krZENtVTRleWhYQ0ZTQ0Yvd29SUEFXYWJRQVc3ZXZXR1RlMUdwbkJOOXlBNkhSaEl6L1ZzejVtWmJ2cU0veDdyT1FaZUNZNUR5ZG5xbklvdDFlWmtObE0wRnJqRjExbTZ6WlhUMzk3TVBZRE9CQWJRQlQwcUNUU2RJM3ljNnF6M09GVkowKzlZQk11d092djQvRVJRcERWNS9QaUpMQ0p5RGlSOStyU2lqMTNtYktvUWJFY2tJM3hEc21YTExOdm16bHRHVFp0MXNzckhSQ3FFL3RlNFVWMk82NStiVnE3Y0tJWlUvWDNXM01mVzlFMi9UV3VXblhxdE1DckJ0UEdtVGIvemlNUmYrb2NQa1NXQkVqNXNXRis1QUw2KzY4MFd6Wm9sc3p5b0h6NThZS3ZYU3JQbDFBNkZnRUxBZWdUd2ZPSWx1SWVUbUd6WTRFZXBVcVdnRXNVTFdXekEybWN4YjU1Y05KQWpTcng1ODY4a1NySFlxSm1kYTlaczR1bmpDVExZdm5qeEdqc2NldFBWYXpmRUFXWU94d3hPa1NJWlQxL1BvM256ZkhsNnNveVpWaUszR2NvdmFCMWp4M2pyR2hvMWFoRDNhenhqRitMam9kdGh3OExBZ2FONGluU0VSTnFBd2h1Vk1uQkFkdzRITjg5a2pPeW9QRzVNYmh0VzZ0V2NNcjVaMDdveCtUUnM3anVTOHNSak9nSVMzZHk3ZTFvR3JCaTRWcW9ZOGZQVnRFazl5cFVyRzRFeUV4UVUzb0lMM3lvM1ZscDc5KzdNZytPYjlQcWZHN1JtOVR5Q0hoQVZBaE5jZnJaT1gyREtoVDZ6T1lWYk1IMWdoVnIvNmRYU0RDVndJQTBEZkd0UFdLZlpHaDFnZElJbnVFUFpXS0dPMmlmZjZLQTJyQzVhdkpJbS96SkwvTnUwYW5qSHZuejVENTA2ZlU3YkpOY1RCbEZOTVB1QWF3eU9zNzBDL3ZiQWdkM1ptSEpOOUVsNzIwRS9ITm0zc0xPMHQwYzIxR3ZRb0xaOCtQeDVGUHpuMFJNU2lxbFdyU29tVzVnN2Q1SThxUGZ2bjZIMjdadlRnUU4vMHZnSmh0WVRQTlJIajI2VGNtZk83S0ZDaGZKeXF0ckZ0SGZmUVpOdHFvMEtBWVdBOVFqQWVseVRJMlBBZS9yb3NWTTh4WDFJcHRacTFhb2FyaEZybjBWWWtzR1hnOVg0eUJFL3lwNzlheG96NWhjNmNmSnN1RGF0MlhEZzRGRzJVR3lRZm1HcUdpbWxZVFdyenBHQ01IaWZPSEU2OWVzL2dnWVBHVTJEQm8yMnBrbTd5aHo1ODRRTURFQUJLTW16Y0hqaDI1cEowZmpBU09rOWhaVmNlTHkzYXh0MWZpSGdHK2JObTVPanJXd3k3b0phandBQjNHOWR1clNWRlBJUkZOWHR6cFkxTXlmS0dXU1J3cWdyN0lJTGNCeUVWS2hRU3FiNDRjQ0thQjBMRi81S2FkT21OdHRqT0E5anR1WGN1Y3UwWXFWcDQ5am5uNGUwamFnK0V5Wk1wK3ZYLzZKYXRTclRUeitOTU50dVpIYUFQNTJlRmVyYjRYWDd5RFJyZGQwS3pMbE94djRwRzl6QzZDWmE1YnZCN3BTQ0ZkSEVKZ1llV2hsWCtxM051bHloUXZua25yaDM3NEYwRFpIWllBekk4MDBPWFZjUjdTT3kwcTV0TTVrbEdUTm1zamhFMnROZVZQVE5zcnVxUGIwMFV3Y2YwdEtsaXpCSDVnWmR1SGhGU3UzYmQwaW1OQkVxNzlqeDB3WTExNjdkUXFkUG41ZHRlSERMbFN0QlE3MzcwSENmOGJweWdUeXFRNXBhZkVneDBtamR1aEcvM0ZwenBpdC8yc2JPVGtvVUFnb0IreEVvWENnL3A0bE9UOU9uTDVCR29QVENNN3RLbGJMQ2s0Tm50eWJXUG9zSXh6WnQyZ0x4bzRCSGVQdjJ6V2p3NEo2MGYvOWhIbVNmMUpxTDlHLysvTGtsakJNaU1XaUM5MFJVeXZidCs4alhkN29vMWdVS1ZIYllvWkFNWnZ1MlZhSmNPNnhSdlliZ2lOaTNyNC9lRnJWb0xRSnYzNzZqSlV2V0VCTDlZUEJqamZqNDlPY29MdFZGQ2UvYno4ZWFLaTVWQmxHM0lQUG4rMUwzSG9ObEdUakFZbGlYQXcxTW54SHl2cEFkZXY5MTZOQkMzaWN0VzNhVldTKzlYYnJGeFV0VzBvMGJmd2t0NEJsSEZjSzc1L0RoclJ3bG9oS2w0VXlkRDVndjYwaUp6M2JwQkt3N3ZPQS9ad3VPMk1vam1QeVo3bkdYd2x0ci8yVUtDc29rb1VDNjdiTEVqeERVRUwwTjBka1FqYzFueEFRZGxLdFdiWklCMGNDQlBlbEdwOTZzb3pXSjlFd2g2SFM5ZW5Xa3MyY3Ywc1pOZm9Td2VmWklWUFROYVFwMThXSUZKWFV0T0RiZVEzckwrWU5IQThzVzByMGFLOVIrZmpzNUJGWklWckZwMCtmVFNRNjExNkZEYy9yMTF6bTZzRjJCekh0YXVIQUZuVDEzVWRyYnMyYy9VMG5XOGlqNGU2VlEyM09IcVRvS0FUMEVLbGN1SzZHUXdEWFRubGxRcXRLbCs1SUtGY3hua05qQzJtY1JscWZac3hmclFpTDl5WmJkVFpzV3MwTFhsUm8zNmFoMzlNZ3RKa2pBeVJrd1pjdmhONTBsdDI3ZEZtVjZ3WUlWSFBIZ2pzTU9DMlVGRG5BMXFsZWlyZnhlZEtRb1I4VElvd2tyOVk3dEsyVjJCTmZLbkpRcFhadzVwLzNvSU0rcUlQUGtuRGxMelJXTkVkdVBoSWF3UldmLytPTUlEMkMvSnd4a1RVbktGTWtsS2dxaWdpQ0tqVGtCdlV4L2h2bngzMDhJaGpmNEkyUmx5NzZqRldxdEgvK0M3K0ZrblJvUlBNckVpVXRkMzMwZ05rYUhreGZodHJqbUJzeGtnbDZYaXVPemQrblNuM01MM05OMWRQMkdMVXdWck1FRHlCbzgyL0FuL2ZmZlc3cHc0VExQVEdhUlFCTzZnallzZk1laGxURVRBaU9BeHRXMm9icXVhRlQweldrS3RhZG5OZUdxNU9Sd0t2alRCQis5dW5Xck01MWpxcllwM0M4NGxyQ01GV2Z1Sm9BMGpvT3JWWUFGRFdHNTBxZFBvMjFTdndvQmhZQ2RDTlJoYjN6d0hHdlhyaUovV2pPSUhZMVFTUDc3RDJtYnd2MWEreXhlWjJzVUxOMFpNcVFQMTBaTTI0REVMUWpmbVNCQmVHdFRaTThGL09ZWk04WTdWS0hXSEJGcjFHd1IyZTdGNnZyZ3lXTVExYXZuZHpUdXgxL0RZU0VVRCtiVVAzMzZuQjFqTzV2SWtSQ3Vpa3R2MEpJd3VlczU3Q0ZoQjk0VkdNaWFFbEE3NFgrQnY5Zi8zRFFvc20zYkN1YWliNlpXcmJzWmJOZFc0SnlMc0oyUjRkeHFiUm4vQnJBV2pTRjNDcU1kRDNnOUxsdXRRMnp4SVR1VGhiS3MzenJJV2x5ZkkzajhGeHpYSUxxSWZqZVNoQjd2ZzdNMWZmMU9XTEU4Y0VBUHFsaXhOTThtTEtRbFMxY2IxSURDMjR6dmVUaUlRM2ZEd0d2V3JJbmlxM0ZETHc2MVFhVUlWa0FCQnU5NXhZclpCaVhobFA3cTVYVUpwYXdaV1EwS0dLMUVSZCtjb2xCakJBT3krcTFiZHlsWDd0SUdvNHJmTmkrVnlBRTVjMlRWVVVHTXpsdFdRUm5CQXd0TG1EbEprVHlaSklGeHBsWEtYRi9VZG9WQVRFYWdRUDV2SlBUUnBrM2J4UU5iT3hjOGg0aFRXN05tSlJvMGVMUzJPZHl2dGM5aVF1YlhnZnJoNkdjV1VRUVFMU0FaVHc4Nld5eFpLZTN0Q3pLTFFXbEJmTmZ6Yk9GeGhDaEhSRWVnR05LR0wvUGMvZmR0WUFyaVFrNVE5RW8ySXFZeTRwQWpTZzZjVmgxMTNSelhhL3RhZ25FTDMrS3laVXZvNHBVakF5cWVOemlKbVJKWXMzdjBHR0t3cXhVbmowR0kyMTkvblVzN2R1eVZmUWNQYktFdnZrakxla0laWGNianI3N0tLTzhISkk5eHRDQ2F4Z3RPb0pLSW5SRDE1U3FGUlBSSXk1RTJYb1lPSExKd1NMd25iQUI4cERlUTBLOWp5eklVOVNhTWx4OFB4cDdwSlg3UmJ5TUpyNkIvengxd1BQMTJIYmtNUjlUKy9idEpjaTR0bVl1cDlyZHNEWmxaeTUwck8rWE9uVjE4NGtBUHNVZmc3UDNKSjJFRHQ5Uk1CVUpNOUt0WGJ6S2RjSjdOa1djYzJUY1RFdzMybktMbE9naTloV25qUTRlT0d5alRxTFYxNnk0RzV4UG1TSmMwMjBnYjV0MTh3NlQyR3pkdW0wMkJpdEZyMzc3ZEpBTWpIQmlWS0FRVUF2WWpVSzVjS1VrbmpQQ1crb0lab09QSHowZ1VEYVRlTmlYV1BvdHczT3ZaczZOWWRIY1paVXcxMWE2NWJhQ1I0QU9mT25WeVhWejdnd2YvNU1GM2tFd3pJMElBNkdWdGpSejdNTkJIOGhSRUhvZ0pBaXMxSE9BY0ljb1IwUkVvaHJVQksvWGt5Yk5rNnJ0Z2dUd0VxOTNTcGRNbDNHUzkrbTAvR21VYVp3eGZCd3hZUFQyclVONDhPU2t4T3lsNmVYMG54cTc5b2JOV1NNL2UyNnVMT09paURnWVRzK2NzTWZoRDlrUE1VUHY1N2FKZHUvZWptQ3pEd2JGcjZIMWV0a3h4OXIwcUtqUFUrcEVqcExBRC9vUENlcDA1eWpsRE15RnFUWjUwaTB1UCtaM1NpZE9FUTBsQ3BJMjJyQUFmWXI3enk5QkNpZmkzWmRBN2kzR3BRNHVHKzhuSEdSTVJlOXBYTC9hMGNhR3ZXWUZITWhtT2lXRzh5eVhXWVhHR3RmbjU4MWZVdXMzM1FuZXoxTEVTeFF1enY4RTBlVWYvOU5NTVMwWEQ3Y043R2pOQWNJaUZGVnovWGxxL2ZxdTgvK0VqZ3hCODVoZ000UnJWMnhDWnZ1azFRMDZ4VUZmbGJEYjRlSUVYYlN3WXVTTExXdjM2TlF5Y0dXYk1tTUJUQ09PbE9IalcrSkI3ZVhrYktPVFlmdURBYjFJR1RvbElnWHJ0MmswYU0zYXk4V0hVdWtKQUlXQURBbkNhQXQ4Tk1VT05CV0V2a1VvV3MwNkliZ0d4OWxtRWhmdk1tYjFTQjlOMmVDOGdhWXptK0NnN1RQd0g1MGhNNStrTFBzaDU4cGFqK3c4ZTBjV0xWNmtZKzJrOCtmc1NaMkJ0UXp0Mjd1UFV4dHNsQStPZE95ZjV3MDJTSGhrZmNFMEtGc2dyMFFNUTMvN1FvYU0yWlhyVDJuRG1MN0FlTjg1YkZCak5DbXJ2OFpVam9yM0ltYThIQ2czb1VXWEtGSk9NY05VNXBYWmt3aWFhUDFMMDdnRkZxMmZQSWJSbXpUem1nMitSYnpLZS8xbXpsakFON0xCMERrNkVZOFlNb3BNbk9aTmlpUnBXZDNqYXRQbE1KNnNvWEhPRXp2dnNzLy9KZThqTGE2akJ0OS9xQnEwb3VDY3dtSlhsT0JTUFh3M3ZROHVEdit6RGRJVXBuR1NtWXVBSCtwemZWY1JXNjNaY1FPTTcxK0hVNURQaXg2V0VuRlJ1aHJ0dE5LL203b0YwZ3lPTC9Na0pYRXdKVk9paW5BcjlFTS9JdnpjZ25wZ3FIVDNiaG5NNDQzVHBVc3ZNMmI2OUd3dzZjZTdjSmFwUnM3bHNnKy9IeXBXemhEMkFid3F5SmVyejVBMHFtbG5CdllBd2pSczJiRFVJMDJlbXVOV2JIZEUzL1lNNVJhRytlZk1XL2ZERFQ4S2YwVDg0bHNFN0hEWnN2RXdYSWVqN01RN1BOV3FVb1VMOCt2VnI4ZWJVejZ5MGxFY3A0T09FU2JCa3pGbXpack51eWkxc24xcFNDQ2dFckVVQTF0eE5tN1pKakYxVDA5UzdkdTNuNS9sbkRudDVYNXEwOWxtY3k4NWJtQnJXQk1ydG5UdjNhTzI2M3l4YU4zNytlWlpFRmRIcWFiL0l1S3BKeTFiZHFIbXoraEx0NXhySG9ZYTBiTldGbWpTdUs5WjBUQzhlUG55Y0k1U1VsM2NNOW9Obk41aHBLM2pKMzdwOUY1dGNYcEJ4ckYyNzVqUnA4a3k3KzZvY0VlMkd6bUxGclR5dERTZDU4SUUxaTZ2RkNpNitjOXUyM2NMN3ZuSWw1SG5TNys2ZXZRZDRWcm1lS0w4d1pDSHAwNGFOdit1SzdOeTFqNVhpaVR4WU5oOE9jLzM2TFVJUnVYVXJ6SUVYa1QycVZXOUtqVGpEWHBvMHFlWFpSQ1FIR01xaVNyYXdOWG9JQjZUT0doQkE1L1NTcXl6bUJDMS92Z3VnR200QjlHK0FPNjNsVElwLzYxbXkvVGpVM1JCV3B0ZVpVS1paVjZZNXJKQS9oSDNiaUFmQWg2SkxYR0FQVTAzK005cW5uU1A0MDRXNUwyMTVsczFGRGRTRSsrUE9uWkJ2Z05adjdmZmh3MGZhb2x5N2Nad3c2dG16RjN5UCtORUROb0NZRTN3amtpWk5Ja210OU11QUZ2alBQMjkwenV6Nit4RG9ZdXpZWCtWYm9yOWRXN1owSCtPK3NyWnZXbnVXZnQzaUovZ2l6R1JqcVdTTTM0Y3hYeXc1MVJoL3JkUUpLQVFVQXFZUVFGWStjSFhMbEsxcnMvVVQ4YkhoRk5hcjEzZHNQV3Foa3JpWUFsaHRpM1VJUUROWTVQYU9IdkFBZjRBWlByT3pRV25POGFtN3NybXpZbEE4bTdJdU9ydWZ6amdlTXQ5dTJiSk1rbjk5Mjc2WE13NXA5ekhNakkvc2JrOVZWQWdvQkJRQ0NvRW9RZ0FVQWxCWlBHdFh0ZWtJVU1TM2NTeHJYOStaS2lPaVRjaXB3aDg3QWpDei9SRHNRWjVzRWM3Q2ZPcm9sb1RjQVM4UE54cks0VWZlUlhkblhPRDRTRHFGV1F6OStOWXUwQzJUWFZBV2FwT3dxSTBLQVlXQVFzQTFFWUREMTRJRnYxRDFHczJzN2lDczAvQkx1WExsT2pWczFON3FlcXFnUWlDMklOQ0dPZEhWMmNUWVBEaStBNU9MMjQ3ZUtJN3RnWlF1M3B6c1JjMnAyNDVmZE5ad0NvYzZPazlRSFZzaG9CQlFDSHhNQ0NDRUhrS1E1czJUaTA2ZkNja21hK244b0V3UEg5NmZTcFNzcFdnZWxvQlMrMkkxQXVCTUgyUW53S0JvbnJkZkdCU1hibktvUEtWTXg3emJNWnB2blpnSG1PcXhRa0Fob0JDSWJnVGduQWd1ZEVTQ3BDSmp4M3B6eXQ5dVNwbU9DQ3kxUDFZakFBWDJxZ3ZFZkw3R2ZZaCs0a21zdmhYc1BubWxVTnNObmFxb0VGQUlLQVNpQndGWXBsT25Ua0dnZjVnVEtOTklDZHk0Y2NjWW41M1AzRG1xN1FvQmhZQkN3RlVRaU9QaGtjakhWVG9UdGYxd3plRG9VWHZPcW5XRmdFTGdZMFhnbjFldkpReWdZZmpRa0xPRm9vMGtDaDA3OXVHUWdHRmh5VDVXTE5SNUtRUVVBZ3FCNkVaQVdhaWord3FvNHlzRUZBSUtBVHNRMk9xM1d4THNKRWhnbUZRQ3l2VHExWE5FbWI1OHhYUXFhRHNPcDZvb0JCUUNDZ0dGZ0FVRWxJWGFBamhxbDBKQUlhQVFjRlVFa0c0OWNhSkU5RVg2OUhTT2s5UkFrSzF2MmJMcG5DenJSenA1NnB5cmRsMzFTeUdnRUZBSWZIUUlLQXYxUjNkSjFRa3BCQlFDc1FXQkJRdDhxVk9uRm5LNlVLYlhyMXZBbWI5K3BRTUhqOFlXQ05SNUtnUVVBZ29CbDBCQXhhRjJpY3VnT3FFUVVBZ29CT3hEWVBXcXVmVDI3VHRLa0NBQkxWKytsdGF0MzJwZlE2cVdRa0Fob0JCUUNOaU5nSXBEYlRkMHFxSkNRQ0dnRUloK0JESm56a1E1YzJhbHJsMEhLbVU2K2krSDZvRkNRQ0VRU3hGUUZ1cFlldUhWYVNzRUZBSWZCd0pGaXhTZ0FnWHkwSUtGeThWUy9YR2NsVG9MaFlCQ1FDRVFzeEJRQ25YTXVsNnF0d29CaFlCQ1FDR2dFRkFJS0FRVUFpNkdnRWVjdUxFbFBuTnNPVThYdThOVWR4UUNDZ0dGZ0VKQUlhQVFVQWpFWUFTQ0FvaUNneTBuaFBjSVVqa3VZL0FsVmwxWENDZ0VGQUlLQVlXQVFrQWhvQkNJV2dRc0s5TTR0a2R3VU1TRm9yYVR6bXc5TnAyck0zRlZ4MUlJS0FRVUFnb0JoWUJDUUNFUWV4RlFjYWhqNzdWWFo2NFFVQWdvQkJRQ0NnR0ZnRUpBSWVBQUJKUkM3UUFRVlJNS0FZV0FRa0Fob0JCUUNDZ0VGQUt4RjRIL0F3b3V4OWlXTS9DWkFBQUFBRWxGVGtTdVFtQ0NcIlxuXHR9LFxuXHRcImNhbGVuZGFyXCI6IHtcblx0XHR0eXBlOiBcImltYWdlL3BuZ1wiLFxuXHRcdGRhdGE6IFwiaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUFvQUFBQUtDQVlBQUFDTk1zKzlBQUFBYzBsRVFWUjRuSVhRd1FrQ01SU0U0VTlaTE1DVDlYamFxMkFmTmhmWVU1b1FMTUFPdG9ONDhFV2VpNWlCSVJQZS95WVEzcXJoZjFsRkc3aUtjRWFKeFNmdWtVdk1XZ2RIYXZ0MHVXSHRnMlF3eFhuQW5KWjJ1T0x5Vlp0eWJ6emhnV05tZm9GbDAvWUI4N05ielIxY2pQOXhlUUhTREM2bWNMMXhGUUFBQUFCSlJVNUVya0pnZ2c9PVwiXG5cdH0sXG5cdFwiY2hlY2tlZFwiOiB7XG5cdFx0dHlwZTogXCJpbWFnZS9wbmdcIixcblx0XHRkYXRhOiBcImlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBMEFBQUFQQ0FZQUFBQS9JMFYzQUFBQUJHZEJUVUVBQUxHUEMveGhCUUFBQUFsd1NGbHpBQUFPd2dBQURzSUJGU2hLZ0FBQUFCaDBSVmgwVTI5bWRIZGhjbVVBY0dGcGJuUXVibVYwSURRdU1DNDFaWVV5WlFBQUFZSkpSRUZVT0UrTmtzdExnbEVReGYwZmFoRzBpRnJVeG0yRWxGRFlMb2hDcUNEYUNBa1dQYXhJUmJGRkVKRWFHRUtMRENvTUVUUkZVQU1MeWFJSEJVRzZzU0tJTXRLRnFFaExUODE4WlVnbURoenUzRFBuOXowdVYxUnJtVXdteUdReXFOVnFmRnZWaXdCeHU1UkZQWnVMU3lHTUtoei9xbEVzUlYxOUs4eG02eSt3N2JwQlBGbkFmZXJqajNiZFFYNkRwSGNBVXdhdkFIVU4yUkdJWnhCSlpISDJtQy9UVWV5ZHd3VFp2QmVnTEVOTmd3N3NYNldoMUZzd05tUEVtalBDRHlHUlJ3Q3RXOUUzdE1nZEF0UXc3R1pqWWNOWCtnemEyd0ozWlhzU1pVdVEwdldDT1Y4U0hmSkovdWx1aGJIVWoxdjhQS05Nc3pJb1FOUk1IQ1NoRDZXaDh6eWhyYk9Qd3o4dytTVEtsQ0NKN29STlV6UUg2M2tCczV0aEJnaGVQWHhsajJhVW9TeERQY3VYUE5pTEFjNUVFWjZISWtibVYyRFlpWEJQSHMwbzA3OStLMERUVmovczExbUUwMEEwTCtnNFZjRHAxMHFLWk1Benl0QmhNYVRSYVBtWWc4ODVEbGNTelNpajBlb0VpSW91b1VxbHFxcWFMMnJsRW9rK0FkNHZsZnpQb1ZEc0FBQUFBRWxGVGtTdVFtQ0NcIlxuXHR9LFxuXHRcImRpYWxvZ1wiOiB7XG5cdFx0dHlwZTogXCJpbWFnZS9wbmdcIixcblx0XHRkYXRhOiBcImlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFINEFBQUFVQ0FNQUFBQjhrbm1HQUFBQVhWQk1WRVhuNHRmbTRkZm40dGpuNDlubzVOcnA1ZHpwNU52bTRkYmkzTkRnMnMzbzVOdmw0TlRoMjg3azM5UHA1ZHZoM00vajNkSGszOVRsNE5YZzI4N2szdFBpM2RIaDNORG00dGZqM3RMaDI4L280OXJvNDluZzJzN2w0ZGJsNE5iNlZiRXlBQUFDMUVsRVFWUjRBWFZWMFlLREtBd0U0QUFWSzZTd0M5YnQvMy9tbllKMnRGN2V3TUVKeVdSZ2pITXVoRlQvbkVNYjI2MWh4YnJxaDIzaFJvbVloeExyWWZYQVRUbTZEVHYwNjBxMHZ4aDkrYitTWWozTXVqM2M1SU9SQUZNQkV0RDByS2dvQUhJSkxXTGxmcElHOHFBQUlrM3drOXRKS3oyRTg0R3JIVXZiVmhMYnl2dzBpQTIvNm90YS9RYmJ2ditZYlVla2JVVjZSL0RnM1lXTitaeXpUL2E4WDZLcEJMcFczY3RhMkZDT0xGTWtMdVplOTdQZ0ZKTTdqb2FHOWJVSGxWeVpXTTYzdEdsbFpwK3l6SXdpcEdGSlF3SjVycWdYMmU3L3c5S3J3dVlNQXRCa2dUYlM3M3owcjlKRDlJSnl5MkdKRWpTUUQ5a0p3aUllVFNOeHlDOUR6MlZjR2lLVDZJSHBscjdWeW5iQStVcFZBK2J4UVlpL2tOUGtuSnRTRG45Q2ZlYkJOUFNyWmRLMHIrNkltRThwNVJ6RG00c3pnRnRJUU5xbWUzWmtjQnNQMXJSdkpaQmJmcjZjNE84UWMwNHBnZkpyWTVyczRkSjVoaFowejl6Nit4MHZ5czhPeWo1bktFTVRQOG9MQncrN09BaDlUa0NkSjgvNU5ubzRkdDZkNTA2ZHliVVliaFREbUZqdHh3eGpUdmpWRGhJVGlKVk5vZTVMeW9HSVFrNEZ0ZCtRRWNubFlQRitLWStEV2MxV2dQU3FKZVhqWHhQcFQ5dVhvQnFHeDZtN2p5bHl2UnZtOGhHQXB1TkF5V2lzOThyWFl2ZXZaVlNndXpnZnc4a0dmM2FSNGdkMkROVWNRWDFxWEhhdnZMRnJwdjZML250L2QrOVJYVjhPRkRDRkVBaEhCdCtxU3I2L0ZOKzM3SlZTN0JDOXp3T1hqNi9KVzA0SkxCN205ODR2L0hJaVg3N203aUg1a0wxMTk4b3Y4T0kwemlYMDFiMzJGbzljM1ZIemNlOXhkY3MrTEMwVGVIUEtSZm11bE9MY1pmVHlXMklDejZEcjVGbDRGNDFvMXExblllQXRzNmJ1aGllU3kzZStrcXpNN1BQODg1QXRmQjBGSk9Db1VablVRU3lsbEFVM2ttazRja0F1UnFDMk9YQWgxYjN5bGFCajlLYTNQaWRRUXhKY0JFdEdyV1JuY3YyZWpyRWpWQ25TWDl0WU91QmswN1lJNEo2TVlwcGNCVTBwRWdPdkR0dit4Q0NUcnR3TDVsODd3Vk8zTy9nNUdRQUFBQUJKUlU1RXJrSmdnZz09XCJcblx0fSxcblx0XCJkb3duLXJlY3RhbmdsZVwiOiB7XG5cdFx0dHlwZTogXCJpbWFnZS9wbmdcIixcblx0XHRkYXRhOiBcImlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBa0FBQUFFQ0FZQUFBQmNEeFhPQUFBQUFYTlNSMElBcnM0YzZRQUFBQVJuUVUxQkFBQ3hqd3Y4WVFVQUFBQUpjRWhaY3dBQURzTUFBQTdEQWNkdnFHUUFBQUFhZEVWWWRGTnZablIzWVhKbEFGQmhhVzUwTGs1RlZDQjJNeTQxTGpFeFIvTkNOd0FBQUJwSlJFRlVHRmRqZ0lML2VEQUtJS2dBQmdncWdBRTBCUXdNQVBUbEQvRnBpMEpmQUFBQUFFbEZUa1N1UW1DQ1wiXG5cdH0sXG5cdFwiZmlsdGVyLW9mZlwiOiB7XG5cdFx0dHlwZTogXCJpbWFnZS9wbmdcIixcblx0XHRkYXRhOiBcImlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBNEFBQUFNQ0FZQUFBQlNnSXphQUFBQUFYTlNSMElBcnM0YzZRQUFBQVJuUVUxQkFBQ3hqd3Y4WVFVQUFBQUpjRWhaY3dBQURzTUFBQTdEQWNkdnFHUUFBQUFZZEVWWWRGTnZablIzWVhKbEFIQmhhVzUwTG01bGRDQTBMakF1TldXRk1tVUFBQUNoU1VSQlZDaFR6WkhCQ29VZ0ZFVDlUcUVpc2tneVdvdXRRdlJMUklyK2NSN1hRQWppSlcvMUJnWm1NVWV2WHNZNXh5OU9vREVHTWNZaVV6ZUI2N3FpYlZ1d1FqVk5BNjMxMVYrV0JlTTR2c0xETUVBcGRlLzFmWTlwbXRJNDUzbmVIRUtBbEJKZDF6MGZYdGMxNlBiak9ESzA3enZtZVVaVlZkOG5vb2M3NXpKSU9YM0dtNmkwYlZzR0tmOHhLSVJJdXlKVExnSkozbnZRenNqVzJnZUlzUS9wcjloTVZyU25jQUFBQUFCSlJVNUVya0pnZ2c9PVwiXG5cdH0sXG5cdFwiZmlsdGVyLW9uXCI6IHtcblx0XHR0eXBlOiBcImltYWdlL3BuZ1wiLFxuXHRcdGRhdGE6IFwiaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUE0QUFBQU1DQVlBQUFCU2dJemFBQUFBQVhOU1IwSUFyczRjNlFBQUFBUm5RVTFCQUFDeGp3djhZUVVBQUFBSmNFaFpjd0FBRHNNQUFBN0RBY2R2cUdRQUFBQVlkRVZZZEZOdlpuUjNZWEpsQUhCaGFXNTBMbTVsZENBMExqQXVOV1dGTW1VQUFBQ29TVVJCVkNoVFkzQnFmUDJmSEF6V21EYmo3ZjhwMjk0UmhWT0Jhc0VhMDJlKy9lL1ZCbVFRQ1R4YVgvOVBudllHb2o1eXdwdi9RZDJFTmZ0M3Z2NGYxZ2ZWQkFQK25XLytoL2ErQVR0bjFxNzNLSGp5dHZkZ2czMDcwRFRCZ0h2TDYvOGcyMmZzUUdpYURtU0hBMjF4YXliZ0lwREhpeGE4aFdzc25BOE5ERUlBcENoM0xrSWppRDJJTllKQ0wyWDZXM0I4Z2RoRWFRUUJVT0NBNGd5RTgrZTl4YUtKZ1FFQS83NEJORTNjRWxrQUFBQUFTVVZPUks1Q1lJST1cIlxuXHR9LFxuXHRcInVuY2hlY2tlZFwiOiB7XG5cdFx0dHlwZTogXCJpbWFnZS9wbmdcIixcblx0XHRkYXRhOiBcImlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBMEFBQUFQQ0FZQUFBQS9JMFYzQUFBQUJHZEJUVUVBQUxHUEMveGhCUUFBQUFsd1NGbHpBQUFPd2dBQURzSUJGU2hLZ0FBQUFCaDBSVmgwVTI5bWRIZGhjbVVBY0dGcGJuUXVibVYwSURRdU1DNDFaWVV5WlFBQUFSQkpSRUZVT0UrOWtydHVnMUFRUlBsZFNpbzdGUTF0WkltT2tvS09Cb21HVDBFVVJDNWlubzU0eVR3OTBXeXdRaFRrSWtWV0dvRjJ6dXhkcmxEK3QwelRoS1pwVDBWbXhiOENRUkNnNnpyMGZiOHJlcjd2ZndjUHh4ZGNyeCtZcGduelBHTlpsaDlpYnh4SGxHVUpzaExTZFYwYXQ5dE5wZzdESUJyWDUrT2tQTTlCVmtLR1lTQkpFdFIxamJackJkaXFiVnRVVllVMFRVRldRcStuRStJNHh2dmxJbUdhVzdGSGp3eFpDVm1XaGJmekdWbVdvU2dLV1hVcjl1aVJJU3NoeDNGa0VsZG9tdWJYYXV6UkkwTldRcDdueVVSK05HL3Jmci9qVVh4bmp4NXZtS3lFYk51V294OVh2aWQ2Wk1oSzZIQTR3blZkaEdHSUtJcDJSWThNV1FteCtKdW9xdnBVWkZiOEw2VW9ueVlMM3VPdHJGSCtBQUFBQUVsRlRrU3VRbUNDXCJcblx0fSxcblx0XCJ1cC1kb3duLXNwaW5cIjoge1xuXHRcdHR5cGU6IFwiaW1hZ2UvcG5nXCIsXG5cdFx0ZGF0YTogXCJpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQTRBQUFBUENBWUFBQURVRlA1MEFBQUFCR2RCVFVFQUFMR1BDL3hoQlFBQUFBbHdTRmx6QUFBT3dRQUFEc0VCdUpGcjdRQUFBQmgwUlZoMFUyOW1kSGRoY21VQWNHRnBiblF1Ym1WMElEUXVNQzQxWllVeVpRQUFBR0pKUkVGVU9FK2xrd0VLQUNFSUJIMlpiL1BuSHNvR2VhVkpEVWpHT2dSUnBLcGtpSWoreTRNTUUzZURSN2thS09WTnNKeU1OaklIekd5OVluVzZKN3FJY3JyaVFpbWVDcU9STkFCZDBmcFJUa3Q4dVZVajdFc3hDNnZzL3EzZS9RNmlEMmJ3bkJ5alBYSE5BQUFBQUVsRlRrU3VRbUNDXCJcblx0fSxcblx0XCJ1cC1kb3duXCI6IHtcblx0XHR0eXBlOiBcImltYWdlL3BuZ1wiLFxuXHRcdGRhdGE6IFwiaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUE0QUFBQVBDQVlBQUFEVUZQNTBBQUFBQkdkQlRVRUFBTEdQQy94aEJRQUFBQWx3U0ZsekFBQU93UUFBRHNFQnVKRnI3UUFBQUJoMFJWaDBVMjltZEhkaGNtVUFjR0ZwYm5RdWJtVjBJRFF1TUM0MVpZVXlaUUFBQUdGSlJFRlVPRStsa2tFS1FDRUlSRDJaSjNQaDNpTjRXRDlHZmxwWWhqMFlZb3dwR2dKbWJpa2QzZ2pNREZva3didVQxaUFpdXJHNW5vbWdxbzVRYVBvOUVSUVJJNkpmN3NmR2p1ZHkyamUyMytpMFdsMm9RODVUT2RsZnJKUU9hekY4YnIrcnFUWFFLbjBBQUFBQVNVVk9SSzVDWUlJPVwiXG5cdH0sXG59O1xuIiwiLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF8gPSByZXF1aXJlKCdvYmplY3QtaXRlcmF0b3JzJyk7XG5cbnZhciBpbWFnZXMgPSByZXF1aXJlKCcuL2ltYWdlcycpOyAvLyB0aGlzIGlzIHRoZSBmaWxlIGdlbmVyYXRlZCBieSBndWxwZmlsZS5qcyAoYW5kIGlnbm9yZWQgYnkgZ2l0KVxuXG5fKGltYWdlcykuZWFjaChmdW5jdGlvbihpbWFnZSwga2V5KSB7XG4gICAgdmFyIGVsZW1lbnQgPSBuZXcgSW1hZ2UoKTtcbiAgICBlbGVtZW50LnNyYyA9ICdkYXRhOicgKyBpbWFnZS50eXBlICsgJztiYXNlNjQsJyArIGltYWdlLmRhdGE7XG4gICAgaW1hZ2VzW2tleV0gPSBlbGVtZW50O1xufSk7XG5cbmltYWdlcy5jaGVja2JveCA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgcmV0dXJuIGltYWdlc1tzdGF0ZSA/ICdjaGVja2VkJyA6ICd1bmNoZWNrZWQnXTtcbn07XG5cbmltYWdlcy5maWx0ZXIgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHJldHVybiBpbWFnZXNbc3RhdGUgPyAnZmlsdGVyLW9uJyA6ICdmaWx0ZXItb2ZmJ107XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGltYWdlcztcbiIsIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKiBAbW9kdWxlIGF1dG9tYXQgKi9cblxudmFyIEVOQ09ERVJTID0gLyVcXHsoXFxkKylcXH0vZzsgLy8gZG91YmxlICQkIHRvIGVuY29kZVxuXG52YXIgUkVQTEFDRVJTID0gL1xcJFxceyguKj8pXFx9L2c7IC8vIHNpbmdsZSAkIHRvIHJlcGxhY2VcblxuXG4vKipcbiAqIEBzdW1tYXJ5IFN0cmluZyBmb3JtYXR0ZXIuXG4gKlxuICogQGRlc2MgU3RyaW5nIHN1YnN0aXR1dGlvbiBpcyBwZXJmb3JtZWQgb24gbnVtYmVyZWQgX3JlcGxhY2VyXyBwYXR0ZXJucyBsaWtlIGAke259YCBvciBfZW5jb2Rlcl8gcGF0dGVybnMgbGlrZSBgJXtufWAgd2hlcmUgbiBpcyB0aGUgemVyby1iYXNlZCBgYXJndW1lbnRzYCBpbmRleC4gU28gYCR7MH1gIHdvdWxkIGJlIHJlcGxhY2VkIHdpdGggdGhlIGZpcnN0IGFyZ3VtZW50IGZvbGxvd2luZyBgdGV4dGAuXG4gKlxuICogRW5jb2RlcnMgYXJlIGp1c3QgbGlrZSByZXBsYWNlcnMgZXhjZXB0IHRoZSBhcmd1bWVudCBpcyBIVE1MLWVuY29kZWQgYmVmb3JlIGJlaW5nIHVzZWQuXG4gKlxuICogVG8gY2hhbmdlIHRoZSBmb3JtYXQgcGF0dGVybnMsIGFzc2lnbiBuZXcgYFJlZ0V4cGAgcGF0dGVybnMgdG8gYGF1dG9tYXQuZW5jb2RlcnNgIGFuZCBgYXV0b21hdC5yZXBsYWNlcnNgLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfGZ1bmN0aW9ufSB0ZW1wbGF0ZSAtIEEgdGVtcGxhdGUgdG8gYmUgZm9ybWF0dGVkIGFzIGRlc2NyaWJlZCBhYm92ZS4gT3ZlcmxvYWRzOlxuICogKiBBIHN0cmluZyBwcmltaXRpdmUgY29udGFpbmluZyB0aGUgdGVtcGxhdGUuXG4gKiAqIEEgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdpdGggYHRoaXNgIGFzIHRoZSBjYWxsaW5nIGNvbnRleHQuIFRoZSB0ZW1wbGF0ZSBpcyB0aGUgdmFsdWUgcmV0dXJuZWQgZnJvbSB0aGlzIGNhbGwuXG4gKlxuICogQHBhcmFtIHsuLi4qfSBbcmVwbGFjZW1lbnRzXSAtIFJlcGxhY2VtZW50IHZhbHVlcyBmb3IgbnVtYmVyZWQgZm9ybWF0IHBhdHRlcm5zLlxuICpcbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGZvcm1hdHRlZCB0ZXh0LlxuICpcbiAqIEBtZW1iZXJPZiBtb2R1bGU6YXV0b21hdFxuICovXG5mdW5jdGlvbiBhdXRvbWF0KHRlbXBsYXRlLCByZXBsYWNlbWVudHMvKi4uLiovKSB7XG4gICAgdmFyIGhhc1JlcGxhY2VtZW50cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxO1xuXG4gICAgLy8gaWYgYHRlbXBsYXRlYCBpcyBhIGZ1bmN0aW9uLCBjb252ZXJ0IGl0IHRvIHRleHRcbiAgICBpZiAodHlwZW9mIHRlbXBsYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRlbXBsYXRlID0gdGVtcGxhdGUuY2FsbCh0aGlzKTsgLy8gbm9uLXRlbXBsYXRlIGZ1bmN0aW9uOiBjYWxsIGl0IHdpdGggY29udGV4dCBhbmQgdXNlIHJldHVybiB2YWx1ZVxuICAgIH1cblxuICAgIGlmIChoYXNSZXBsYWNlbWVudHMpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIHRlbXBsYXRlID0gdGVtcGxhdGUucmVwbGFjZShhdXRvbWF0LnJlcGxhY2Vyc1JlZ2V4LCBmdW5jdGlvbihtYXRjaCwga2V5KSB7XG4gICAgICAgICAgICBrZXkgLT0gLTE7IC8vIGNvbnZlcnQgdG8gbnVtYmVyIGFuZCBpbmNyZW1lbnRcbiAgICAgICAgICAgIHJldHVybiBhcmdzLmxlbmd0aCA+IGtleSA/IGFyZ3Nba2V5XSA6ICcnO1xuICAgICAgICB9KTtcblxuICAgICAgICB0ZW1wbGF0ZSA9IHRlbXBsYXRlLnJlcGxhY2UoYXV0b21hdC5lbmNvZGVyc1JlZ2V4LCBmdW5jdGlvbihtYXRjaCwga2V5KSB7XG4gICAgICAgICAgICBrZXkgLT0gLTE7IC8vIGNvbnZlcnQgdG8gbnVtYmVyIGFuZCBpbmNyZW1lbnRcbiAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA+IGtleSkge1xuICAgICAgICAgICAgICAgIHZhciBodG1sRW5jb2Rlck5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdESVYnKTtcbiAgICAgICAgICAgICAgICBodG1sRW5jb2Rlck5vZGUudGV4dENvbnRlbnQgPSBhcmdzW2tleV07XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0bWxFbmNvZGVyTm9kZS5pbm5lckhUTUw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRlbXBsYXRlO1xufVxuXG4vKipcbiAqIEBzdW1tYXJ5IFJlcGxhY2UgY29udGVudHMgb2YgYGVsYCB3aXRoIGBOb2Rlc2AgZ2VuZXJhdGVkIGZyb20gZm9ybWF0dGVkIHRlbXBsYXRlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfGZ1bmN0aW9ufSB0ZW1wbGF0ZSAtIFNlZSBgdGVtcGxhdGVgIHBhcmFtZXRlciBvZiB7QGxpbmsgYXV0b21hdH0uXG4gKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gW2VsXSAtIE5vZGUgaW4gd2hpY2ggdG8gcmV0dXJuIG1hcmt1cCBnZW5lcmF0ZWQgZnJvbSB0ZW1wbGF0ZS4gSWYgb21pdHRlZCwgYSBuZXcgYDxkaXY+Li4uPC9kaXY+YCBlbGVtZW50IHdpbGwgYmUgY3JlYXRlZCBhbmQgcmV0dXJuZWQuXG4gKlxuICogQHBhcmFtIHsuLi4qfSBbcmVwbGFjZW1lbnRzXSAtIFJlcGxhY2VtZW50IHZhbHVlcyBmb3IgbnVtYmVyZWQgZm9ybWF0IHBhdHRlcm5zLlxuICpcbiAqIEByZXR1cm4ge0hUTUxFbGVtZW50fSBUaGUgYGVsYCBwcm92aWRlZCBvciBhIG5ldyBgPGRpdj4uLi48L2Rpdj5gIGVsZW1lbnQsIGl0cyBgaW5uZXJIVE1MYCBzZXQgdG8gdGhlIGZvcm1hdHRlZCB0ZXh0LlxuICpcbiAqIEBtZW1iZXJPZiBtb2R1bGU6YXV0b21hdFxuICovXG5mdW5jdGlvbiByZXBsYWNlKHRlbXBsYXRlLCBlbCwgcmVwbGFjZW1lbnRzLyouLi4qLykge1xuICAgIHZhciBlbE9taXR0ZWQgPSB0eXBlb2YgZWwgIT09ICdvYmplY3QnLFxuICAgICAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICAgIGlmIChlbE9taXR0ZWQpIHtcbiAgICAgICAgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdESVYnKTtcbiAgICAgICAgYXJncy51bnNoaWZ0KHRlbXBsYXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBhcmdzWzBdID0gdGVtcGxhdGU7XG4gICAgfVxuXG4gICAgZWwuaW5uZXJIVE1MID0gYXV0b21hdC5hcHBseShudWxsLCBhcmdzKTtcblxuICAgIHJldHVybiBlbDtcbn1cblxuLyoqXG4gKiBAc3VtbWFyeSBBcHBlbmQgb3IgaW5zZXJ0IGBOb2RlYHMgZ2VuZXJhdGVkIGZyb20gZm9ybWF0dGVkIHRlbXBsYXRlIGludG8gZ2l2ZW4gYGVsYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xmdW5jdGlvbn0gdGVtcGxhdGUgLSBTZWUgYHRlbXBsYXRlYCBwYXJhbWV0ZXIgb2Yge0BsaW5rIGF1dG9tYXR9LlxuICpcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsXG4gKlxuICogQHBhcmFtIHtOb2RlfSBbcmVmZXJlbmNlTm9kZT1udWxsXSBJbnNlcnRzIGJlZm9yZSB0aGlzIGVsZW1lbnQgd2l0aGluIGBlbGAgb3IgYXQgZW5kIG9mIGBlbGAgaWYgYG51bGxgLlxuICpcbiAqIEBwYXJhbSB7Li4uKn0gW3JlcGxhY2VtZW50c10gLSBSZXBsYWNlbWVudCB2YWx1ZXMgZm9yIG51bWJlcmVkIGZvcm1hdCBwYXR0ZXJucy5cbiAqXG4gKiBAcmV0dXJucyB7Tm9kZVtdfSBBcnJheSBvZiB0aGUgZ2VuZXJhdGVkIG5vZGVzICh0aGlzIGlzIGFuIGFjdHVhbCBBcnJheSBpbnN0YW5jZTsgbm90IGFuIEFycmF5LWxpa2Ugb2JqZWN0KS5cbiAqXG4gKiBAbWVtYmVyT2YgbW9kdWxlOmF1dG9tYXRcbiAqL1xuZnVuY3Rpb24gYXBwZW5kKHRlbXBsYXRlLCBlbCwgcmVmZXJlbmNlTm9kZSwgcmVwbGFjZW1lbnRzLyouLi4qLykge1xuICAgIHZhciByZXBsYWNlbWVudHNTdGFydEF0ID0gMyxcbiAgICAgICAgcmVmZXJlbmNlTm9kZU9taXR0ZWQgPSB0eXBlb2YgcmVmZXJlbmNlTm9kZSAhPT0gJ29iamVjdCc7ICAvLyByZXBsYWNlbWVudHMgYXJlIG5ldmVyIG9iamVjdHNcblxuICAgIGlmIChyZWZlcmVuY2VOb2RlT21pdHRlZCkge1xuICAgICAgICByZWZlcmVuY2VOb2RlID0gbnVsbDtcbiAgICAgICAgcmVwbGFjZW1lbnRzU3RhcnRBdCA9IDI7XG4gICAgfVxuXG4gICAgcmVwbGFjZW1lbnRzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCByZXBsYWNlbWVudHNTdGFydEF0KTtcbiAgICB2YXIgcmVzdWx0ID0gW10sXG4gICAgICAgIGRpdiA9IHJlcGxhY2UuYXBwbHkobnVsbCwgW3RlbXBsYXRlXS5jb25jYXQocmVwbGFjZW1lbnRzKSk7XG5cbiAgICB3aGlsZSAoZGl2LmNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGRpdi5maXJzdENoaWxkKTtcbiAgICAgICAgZWwuaW5zZXJ0QmVmb3JlKGRpdi5maXJzdENoaWxkLCByZWZlcmVuY2VOb2RlKTsgLy8gcmVtb3ZlcyBjaGlsZCBmcm9tIGRpdlxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogVXNlIHRoaXMgY29udmVuaWVuY2Ugd3JhcHBlciB0byByZXR1cm4gdGhlIGZpcnN0IGNoaWxkIG5vZGUgZGVzY3JpYmVkIGluIGB0ZW1wbGF0ZWAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8ZnVuY3Rpb259IHRlbXBsYXRlIC0gSWYgYSBmdW5jdGlvbiwgZXh0cmFjdCB0ZW1wbGF0ZSBmcm9tIGNvbW1lbnQgd2l0aGluLlxuICpcbiAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH0gVGhlIGZpcnN0IGBOb2RlYCBpbiB5b3VyIHRlbXBsYXRlLlxuICpcbiAqIEBtZW1iZXJPZiBtb2R1bGU6YXV0b21hdFxuICovXG5mdW5jdGlvbiBmaXJzdENoaWxkKHRlbXBsYXRlLCByZXBsYWNlbWVudHMvKi4uLiovKSB7XG4gICAgcmV0dXJuIHJlcGxhY2UuYXBwbHkobnVsbCwgYXJndW1lbnRzKS5maXJzdENoaWxkO1xufVxuXG4vKipcbiAqIFVzZSB0aGlzIGNvbnZlbmllbmNlIHdyYXBwZXIgdG8gcmV0dXJuIHRoZSBmaXJzdCBjaGlsZCBlbGVtZW50IGRlc2NyaWJlZCBpbiBgdGVtcGxhdGVgLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfGZ1bmN0aW9ufSB0ZW1wbGF0ZSAtIElmIGEgZnVuY3Rpb24sIGV4dHJhY3QgdGVtcGxhdGUgZnJvbSBjb21tZW50IHdpdGhpbi5cbiAqXG4gKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9IFRoZSBmaXJzdCBgSFRNTEVsZW1lbnRgIGluIHlvdXIgdGVtcGxhdGUuXG4gKlxuICogQG1lbWJlck9mIG1vZHVsZTphdXRvbWF0XG4gKi9cbmZ1bmN0aW9uIGZpcnN0RWxlbWVudCh0ZW1wbGF0ZSwgcmVwbGFjZW1lbnRzLyouLi4qLykge1xuICAgIHJldHVybiByZXBsYWNlLmFwcGx5KG51bGwsIGFyZ3VtZW50cykuZmlyc3RFbGVtZW50Q2hpbGQ7XG59XG5cbi8qKlxuICogQHN1bW1hcnkgRmluZHMgc3RyaW5nIHN1YnN0aXR1dGlvbiBsZXhlbWVzIHRoYXQgcmVxdWlyZSBIVE1MIGVuY29kaW5nLlxuICogQGRlc2MgTW9kaWZ5IHRvIHN1aXQuXG4gKiBAZGVmYXVsdCAle259XG4gKiBAdHlwZSB7UmVnRXhwfVxuICogQG1lbWJlck9mIG1vZHVsZTphdXRvbWF0XG4gKi9cbmF1dG9tYXQuZW5jb2RlcnNSZWdleCA9IEVOQ09ERVJTO1xuXG4vKipcbiAqIEBzdW1tYXJ5IEZpbmRzIHN0cmluZyBzdWJzdGl0dXRpb24gbGV4ZW1lcy5cbiAqIEBkZXNjIE1vZGlmeSB0byBzdWl0LlxuICogQGRlZmF1bHQgJHtufVxuICogQHR5cGUge1JlZ0V4cH1cbiAqIEBtZW1iZXJPZiBtb2R1bGU6YXV0b21hdFxuICovXG5hdXRvbWF0LnJlcGxhY2Vyc1JlZ2V4ID0gUkVQTEFDRVJTO1xuXG5hdXRvbWF0LmZvcm1hdCA9IGF1dG9tYXQ7IC8vIGlmIHlvdSBmaW5kIHVzaW5nIGp1c3QgYGF1dG9tYXQoKWAgY29uZnVzaW5nXG5hdXRvbWF0LnJlcGxhY2UgPSByZXBsYWNlO1xuYXV0b21hdC5hcHBlbmQgPSBhcHBlbmQ7XG5hdXRvbWF0LmZpcnN0Q2hpbGQgPSBmaXJzdENoaWxkO1xuYXV0b21hdC5maXJzdEVsZW1lbnQgPSBmaXJzdEVsZW1lbnQ7XG5cbm1vZHVsZS5leHBvcnRzID0gYXV0b21hdDtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbi8qKiBAbmFtZXNwYWNlIGNzc0luamVjdG9yICovXG5cbi8qKlxuICogQHN1bW1hcnkgSW5zZXJ0IGJhc2Ugc3R5bGVzaGVldCBpbnRvIERPTVxuICpcbiAqIEBkZXNjIENyZWF0ZXMgYSBuZXcgYDxzdHlsZT4uLi48L3N0eWxlPmAgZWxlbWVudCBmcm9tIHRoZSBuYW1lZCB0ZXh0IHN0cmluZyhzKSBhbmQgaW5zZXJ0cyBpdCBidXQgb25seSBpZiBpdCBkb2VzIG5vdCBhbHJlYWR5IGV4aXN0IGluIHRoZSBzcGVjaWZpZWQgY29udGFpbmVyIGFzIHBlciBgcmVmZXJlbmNlRWxlbWVudGAuXG4gKlxuICogPiBDYXZlYXQ6IElmIHN0eWxlc2hlZXQgaXMgZm9yIHVzZSBpbiBhIHNoYWRvdyBET00sIHlvdSBtdXN0IHNwZWNpZnkgYSBsb2NhbCBgcmVmZXJlbmNlRWxlbWVudGAuXG4gKlxuICogQHJldHVybnMgQSByZWZlcmVuY2UgdG8gdGhlIG5ld2x5IGNyZWF0ZWQgYDxzdHlsZT4uLi48L3N0eWxlPmAgZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gY3NzUnVsZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbSURdXG4gKiBAcGFyYW0ge3VuZGVmaW5lZHxudWxsfEVsZW1lbnR8c3RyaW5nfSBbcmVmZXJlbmNlRWxlbWVudF0gLSBDb250YWluZXIgZm9yIGluc2VydGlvbi4gT3ZlcmxvYWRzOlxuICogKiBgdW5kZWZpbmVkYCB0eXBlIChvciBvbWl0dGVkKTogaW5qZWN0cyBzdHlsZXNoZWV0IGF0IHRvcCBvZiBgPGhlYWQ+Li4uPC9oZWFkPmAgZWxlbWVudFxuICogKiBgbnVsbGAgdmFsdWU6IGluamVjdHMgc3R5bGVzaGVldCBhdCBib3R0b20gb2YgYDxoZWFkPi4uLjwvaGVhZD5gIGVsZW1lbnRcbiAqICogYEVsZW1lbnRgIHR5cGU6IGluamVjdHMgc3R5bGVzaGVldCBpbW1lZGlhdGVseSBiZWZvcmUgZ2l2ZW4gZWxlbWVudCwgd2hlcmV2ZXIgaXQgaXMgZm91bmQuXG4gKiAqIGBzdHJpbmdgIHR5cGU6IGluamVjdHMgc3R5bGVzaGVldCBpbW1lZGlhdGVseSBiZWZvcmUgZ2l2ZW4gZmlyc3QgZWxlbWVudCBmb3VuZCB0aGF0IG1hdGNoZXMgdGhlIGdpdmVuIGNzcyBzZWxlY3Rvci5cbiAqXG4gKiBAbWVtYmVyT2YgY3NzSW5qZWN0b3JcbiAqL1xuZnVuY3Rpb24gY3NzSW5qZWN0b3IoY3NzUnVsZXMsIElELCByZWZlcmVuY2VFbGVtZW50KSB7XG4gICAgaWYgKHR5cGVvZiByZWZlcmVuY2VFbGVtZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICByZWZlcmVuY2VFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihyZWZlcmVuY2VFbGVtZW50KTtcbiAgICAgICAgaWYgKCFyZWZlcmVuY2VFbGVtZW50KSB7XG4gICAgICAgICAgICB0aHJvdyAnQ2Fubm90IGZpbmQgcmVmZXJlbmNlIGVsZW1lbnQgZm9yIENTUyBpbmplY3Rpb24uJztcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAocmVmZXJlbmNlRWxlbWVudCAmJiAhKHJlZmVyZW5jZUVsZW1lbnQgaW5zdGFuY2VvZiBFbGVtZW50KSkge1xuICAgICAgICB0aHJvdyAnR2l2ZW4gdmFsdWUgbm90IGEgcmVmZXJlbmNlIGVsZW1lbnQuJztcbiAgICB9XG5cbiAgICB2YXIgY29udGFpbmVyID0gcmVmZXJlbmNlRWxlbWVudCAmJiByZWZlcmVuY2VFbGVtZW50LnBhcmVudE5vZGUgfHwgZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdO1xuXG4gICAgaWYgKElEKSB7XG4gICAgICAgIElEID0gY3NzSW5qZWN0b3IuaWRQcmVmaXggKyBJRDtcblxuICAgICAgICBpZiAoY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJyMnICsgSUQpKSB7XG4gICAgICAgICAgICByZXR1cm47IC8vIHN0eWxlc2hlZXQgYWxyZWFkeSBpbiBET01cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgc3R5bGUudHlwZSA9ICd0ZXh0L2Nzcyc7XG4gICAgaWYgKElEKSB7XG4gICAgICAgIHN0eWxlLmlkID0gSUQ7XG4gICAgfVxuICAgIGlmIChjc3NSdWxlcyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIGNzc1J1bGVzID0gY3NzUnVsZXMuam9pbignXFxuJyk7XG4gICAgfVxuICAgIGNzc1J1bGVzID0gJ1xcbicgKyBjc3NSdWxlcyArICdcXG4nO1xuICAgIGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG4gICAgICAgIHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzc1J1bGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHN0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzc1J1bGVzKSk7XG4gICAgfVxuXG4gICAgaWYgKHJlZmVyZW5jZUVsZW1lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZWZlcmVuY2VFbGVtZW50ID0gY29udGFpbmVyLmZpcnN0Q2hpbGQ7XG4gICAgfVxuXG4gICAgY29udGFpbmVyLmluc2VydEJlZm9yZShzdHlsZSwgcmVmZXJlbmNlRWxlbWVudCk7XG5cbiAgICByZXR1cm4gc3R5bGU7XG59XG5cbi8qKlxuICogQHN1bW1hcnkgT3B0aW9uYWwgcHJlZml4IGZvciBgPHN0eWxlPmAgdGFnIElEcy5cbiAqIEBkZXNjIERlZmF1bHRzIHRvIGAnaW5qZWN0ZWQtc3R5bGVzaGVldC0nYC5cbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAbWVtYmVyT2YgY3NzSW5qZWN0b3JcbiAqL1xuY3NzSW5qZWN0b3IuaWRQcmVmaXggPSAnaW5qZWN0ZWQtc3R5bGVzaGVldC0nO1xuXG4vLyBJbnRlcmZhY2Vcbm1vZHVsZS5leHBvcnRzID0gY3NzSW5qZWN0b3I7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKiBAbmFtZXNwYWNlIGV4dGVuZC1tZSAqKi9cblxuLyoqIEBzdW1tYXJ5IEV4dGVuZHMgYW4gZXhpc3RpbmcgY29uc3RydWN0b3IgaW50byBhIG5ldyBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcmV0dXJucyB7Q2hpbGRDb25zdHJ1Y3Rvcn0gQSBuZXcgY29uc3RydWN0b3IsIGV4dGVuZGVkIGZyb20gdGhlIGdpdmVuIGNvbnRleHQsIHBvc3NpYmx5IHdpdGggc29tZSBwcm90b3R5cGUgYWRkaXRpb25zLlxuICpcbiAqIEBkZXNjIEV4dGVuZHMgXCJvYmplY3RzXCIgKGNvbnN0cnVjdG9ycyksIHdpdGggb3B0aW9uYWwgYWRkaXRpb25hbCBjb2RlLCBvcHRpb25hbCBwcm90b3R5cGUgYWRkaXRpb25zLCBhbmQgb3B0aW9uYWwgcHJvdG90eXBlIG1lbWJlciBhbGlhc2VzLlxuICpcbiAqID4gQ0FWRUFUOiBOb3QgdG8gYmUgY29uZnVzZWQgd2l0aCBVbmRlcnNjb3JlLXN0eWxlIC5leHRlbmQoKSB3aGljaCBpcyBzb21ldGhpbmcgZWxzZSBlbnRpcmVseS4gSSd2ZSB1c2VkIHRoZSBuYW1lIFwiZXh0ZW5kXCIgaGVyZSBiZWNhdXNlIG90aGVyIHBhY2thZ2VzIChsaWtlIEJhY2tib25lLmpzKSB1c2UgaXQgdGhpcyB3YXkuIFlvdSBhcmUgZnJlZSB0byBjYWxsIGl0IHdoYXRldmVyIHlvdSB3YW50IHdoZW4geW91IFwicmVxdWlyZVwiIGl0LCBzdWNoIGFzIGB2YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdleHRlbmQnKWAuXG4gKlxuICogUHJvdmlkZSBhIGNvbnN0cnVjdG9yIGFzIHRoZSBjb250ZXh0IGFuZCBhbnkgcHJvdG90eXBlIGFkZGl0aW9ucyB5b3UgcmVxdWlyZSBpbiB0aGUgZmlyc3QgYXJndW1lbnQuXG4gKlxuICogRm9yIGV4YW1wbGUsIGlmIHlvdSB3aXNoIHRvIGJlIGFibGUgdG8gZXh0ZW5kIGBCYXNlQ29uc3RydWN0b3JgIHRvIGEgbmV3IGNvbnN0cnVjdG9yIHdpdGggcHJvdG90eXBlIG92ZXJyaWRlcyBhbmQvb3IgYWRkaXRpb25zLCBiYXNpYyB1c2FnZSBpczpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgQmFzZSA9IHJlcXVpcmUoJ2V4dGVuZC1tZScpLkJhc2U7XG4gKiB2YXIgQmFzZUNvbnN0cnVjdG9yID0gQmFzZS5leHRlbmQoYmFzZVByb3RvdHlwZSk7IC8vIG1peGVzIGluIC5leHRlbmRcbiAqIHZhciBDaGlsZENvbnN0cnVjdG9yID0gQmFzZUNvbnN0cnVjdG9yLmV4dGVuZChjaGlsZFByb3RvdHlwZU92ZXJyaWRlc0FuZEFkZGl0aW9ucyk7XG4gKiB2YXIgR3JhbmRjaGlsZENvbnN0cnVjdG9yID0gQ2hpbGRDb25zdHJ1Y3Rvci5leHRlbmQoZ3JhbmRjaGlsZFByb3RvdHlwZU92ZXJyaWRlc0FuZEFkZGl0aW9ucyk7XG4gKiBgYGBcbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIChgZXh0ZW5kKClgKSBpcyBhZGRlZCB0byB0aGUgbmV3IGV4dGVuZGVkIG9iamVjdCBjb25zdHJ1Y3RvciBhcyBhIHByb3BlcnR5IGAuZXh0ZW5kYCwgZXNzZW50aWFsbHkgbWFraW5nIHRoZSBvYmplY3QgY29uc3RydWN0b3IgaXRzZWxmIGVhc2lseSBcImV4dGVuZGFibGUuXCIgKE5vdGU6IFRoaXMgaXMgYSBwcm9wZXJ0eSBvZiBlYWNoIGNvbnN0cnVjdG9yIGFuZCBub3QgYSBtZXRob2Qgb2YgaXRzIHByb3RvdHlwZSEpXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtleHRlbmRlZENsYXNzTmFtZV0gLSBUaGlzIGlzIHNpbXBseSBhZGRlZCB0byB0aGUgcHJvdG90eXBlIGFzICQkQ0xBU1NfTkFNRS4gVXNlZnVsIGZvciBkZWJ1Z2dpbmcgYmVjYXVzZSBhbGwgZGVyaXZlZCBjb25zdHJ1Y3RvcnMgYXBwZWFyIHRvIGhhdmUgdGhlIHNhbWUgbmFtZSAoXCJDb25zdHJ1Y3RvclwiKSBpbiB0aGUgZGVidWdnZXIuXG4gKlxuICogQHBhcmFtIHtleHRlbmRlZFByb3RvdHlwZUFkZGl0aW9uc09iamVjdH0gW3Byb3RvdHlwZUFkZGl0aW9uc10gLSBPYmplY3Qgd2l0aCBtZW1iZXJzIHRvIGNvcHkgdG8gbmV3IGNvbnN0cnVjdG9yJ3MgcHJvdG90eXBlLiBNb3N0IG1lbWJlcnMgd2lsbCBiZSBjb3BpZWQgdG8gdGhlIHByb3RvdHlwZS4gU29tZSBtZW1iZXJzLCBob3dldmVyLCBoYXZlIHNwZWNpYWwgbWVhbmluZ3MgYXMgZXhwbGFpbmVkIGluIHRoZSB7QGxpbmsgZXh0ZW5kZWRQcm90b3R5cGVBZGRpdGlvbnNPYmplY3R8dHlwZSBkZWZpbml0aW9ufSAoYW5kIG1heSBvciBtYXkgbm90IGJlIGNvcGllZCB0byB0aGUgcHJvdG90eXBlKS5cbiAqXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtkZWJ1Z10gLSBTZWUgcGFyYW1ldGVyIGBleHRlbmRlZENsYXNzTmFtZWAgXyhhYm92ZSlfLlxuICpcbiAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBCYXNlIC0gQSBjb252ZW5pZW50IGJhc2UgY2xhc3MgZnJvbSB3aGljaCBhbGwgb3RoZXIgY2xhc3NlcyBjYW4gYmUgZXh0ZW5kZWQuXG4gKlxuICogQG1lbWJlck9mIGV4dGVuZC1tZVxuICovXG5mdW5jdGlvbiBleHRlbmQoZXh0ZW5kZWRDbGFzc05hbWUsIHByb3RvdHlwZUFkZGl0aW9ucykge1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBwcm90b3R5cGVBZGRpdGlvbnMgPSB7fTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBleHRlbmRlZENsYXNzTmFtZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIHByb3RvdHlwZUFkZGl0aW9ucyA9IGV4dGVuZGVkQ2xhc3NOYW1lO1xuICAgICAgICAgICAgICAgICAgICBleHRlbmRlZENsYXNzTmFtZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICAgICAgcHJvdG90eXBlQWRkaXRpb25zID0ge307XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgJ1NpbmdsZS1wYXJhbWV0ZXIgb3ZlcmxvYWQgbXVzdCBiZSBlaXRoZXIgc3RyaW5nIG9yIG9iamVjdC4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXh0ZW5kZWRDbGFzc05hbWUgIT09ICdzdHJpbmcnIHx8IHR5cGVvZiBwcm90b3R5cGVBZGRpdGlvbnMgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ1R3by1wYXJhbWV0ZXIgb3ZlcmxvYWQgbXVzdCBiZSBzdHJpbmcsIG9iamVjdC4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyAnVG9vIG1hbnkgcGFyYW1ldGVycyc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gQ29uc3RydWN0b3IoKSB7XG4gICAgICAgIGlmIChwcm90b3R5cGVBZGRpdGlvbnMucHJlSW5pdGlhbGl6ZSkge1xuICAgICAgICAgICAgcHJvdG90eXBlQWRkaXRpb25zLnByZUluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGluaXRpYWxpemVQcm90b3R5cGVDaGFpbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgICAgIGlmIChwcm90b3R5cGVBZGRpdGlvbnMucG9zdEluaXRpYWxpemUpIHtcbiAgICAgICAgICAgIHByb3RvdHlwZUFkZGl0aW9ucy5wb3N0SW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgQ29uc3RydWN0b3IuZXh0ZW5kID0gZXh0ZW5kO1xuXG4gICAgdmFyIHByb3RvdHlwZSA9IENvbnN0cnVjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodGhpcy5wcm90b3R5cGUpO1xuICAgIHByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENvbnN0cnVjdG9yO1xuXG4gICAgaWYgKGV4dGVuZGVkQ2xhc3NOYW1lKSB7XG4gICAgICAgIHByb3RvdHlwZS4kJENMQVNTX05BTUUgPSBleHRlbmRlZENsYXNzTmFtZTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvdG90eXBlQWRkaXRpb25zKSB7XG4gICAgICAgIGlmIChwcm90b3R5cGVBZGRpdGlvbnMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gcHJvdG90eXBlQWRkaXRpb25zW2tleV07XG4gICAgICAgICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2luaXRpYWxpemVPd24nOlxuICAgICAgICAgICAgICAgICAgICAvLyBhbHJlYWR5IGNhbGxlZCBhYm92ZTsgbm90IG5lZWRlZCBpbiBwcm90b3R5cGVcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnYWxpYXNlcyc6XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGFsaWFzIGluIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUuaGFzT3duUHJvcGVydHkoYWxpYXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFrZUFsaWFzKHZhbHVlW2FsaWFzXSwgYWxpYXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlWzBdID09PSAnIycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ha2VBbGlhcyh2YWx1ZSwga2V5LnN1YnN0cigxKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNEZXNjcmlwdG9yKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvdHlwZSwga2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm90b3R5cGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG5cbiAgICBmdW5jdGlvbiBtYWtlQWxpYXModmFsdWUsIGtleSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNoYWRvd1xuICAgICAgICBwcm90b3R5cGVba2V5XSA9IHByb3RvdHlwZUFkZGl0aW9uc1t2YWx1ZV07XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpc0Rlc2NyaXB0b3IodmFsdWUpIHtcbiAgICB2YXIgcmVzdWx0O1xuICAgIGlmKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUpIHtcbiAgICAgICAgdmFyIGxlbiA9IE9iamVjdC5rZXlzKHZhbHVlKS5sZW5ndGgsXG4gICAgICAgICAgICBoYXNTZXR0ZXIgPSB0eXBlb2YgdmFsdWUuc2V0ID09PSAnZnVuY3Rpb24nICYmIHZhbHVlLnNldC5sZW5ndGggPT09IDEsXG4gICAgICAgICAgICBoYXNHZXR0ZXIgPSB0eXBlb2YgdmFsdWUuZ2V0ID09PSAnZnVuY3Rpb24nICYmIHZhbHVlLmdldC5sZW5ndGggPT09IDA7XG5cbiAgICAgICAgcmVzdWx0ID0gdHlwZW9mIHZhbHVlLmNvbmZpZ3VyYWJsZSA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUuZW51bWVyYWJsZSA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICAgICBsZW4gPT09IDEgJiYgKGhhc1NldHRlciB8fCBoYXNHZXR0ZXIpIHx8XG4gICAgICAgICAgICBsZW4gPT09IDIgJiYgaGFzU2V0dGVyICYmIGhhc0dldHRlcjtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gQmFzZSgpIHt9XG5CYXNlLnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogQmFzZS5wcm90b3R5cGUuY29uc3RydWN0b3IsXG4gICAgZ2V0IHN1cGVyKCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmdldFByb3RvdHlwZU9mKE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKSk7XG4gICAgfVxufTtcbkJhc2UuZXh0ZW5kID0gZXh0ZW5kO1xuZXh0ZW5kLkJhc2UgPSBCYXNlO1xuXG4vKiogQHR5cGVkZWYge2Z1bmN0aW9ufSBleHRlbmRlZENvbnN0cnVjdG9yXG4gKiBAcHJvcGVydHkgcHJvdG90eXBlLnN1cGVyIC0gQSByZWZlcmVuY2UgdG8gdGhlIHByb3RvdHlwZSB0aGlzIGNvbnN0cnVjdG9yIHdhcyBleHRlbmRlZCBmcm9tLlxuICogQHByb3BlcnR5IFtleHRlbmRdIC0gSWYgYHByb3RvdHlwZUFkZGl0aW9ucy5leHRlbmRhYmxlYCB3YXMgdHJ1dGh5LCB0aGlzIHdpbGwgYmUgYSByZWZlcmVuY2UgdG8ge0BsaW5rIGV4dGVuZC5leHRlbmR8ZXh0ZW5kfS5cbiAqL1xuXG4vKiogQHR5cGVkZWYge29iamVjdH0gZXh0ZW5kZWRQcm90b3R5cGVBZGRpdGlvbnNPYmplY3RcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFtpbml0aWFsaXplXSAtIEFkZGl0aW9uYWwgY29uc3RydWN0b3IgY29kZSBmb3IgbmV3IG9iamVjdC4gVGhpcyBtZXRob2QgaXMgYWRkZWQgdG8gdGhlIG5ldyBjb25zdHJ1Y3RvcidzIHByb3RvdHlwZS4gR2V0cyBwYXNzZWQgbmV3IG9iamVjdCBhcyBjb250ZXh0ICsgc2FtZSBhcmdzIGFzIGNvbnN0cnVjdG9yIGl0c2VsZi4gQ2FsbGVkIG9uIGluc3RhbnRpYXRpb24gYWZ0ZXIgc2ltaWxhciBmdW5jdGlvbiBpbiBhbGwgYW5jZXN0b3JzIGNhbGxlZCB3aXRoIHNhbWUgc2lnbmF0dXJlLlxuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW2luaXRpYWxpemVPd25dIC0gQWRkaXRpb25hbCBjb25zdHJ1Y3RvciBjb2RlIGZvciBuZXcgb2JqZWN0LiBUaGlzIG1ldGhvZCBpcyBhZGRlZCB0byB0aGUgbmV3IGNvbnN0cnVjdG9yJ3MgcHJvdG90eXBlLiBHZXRzIHBhc3NlZCBuZXcgb2JqZWN0IGFzIGNvbnRleHQgKyBzYW1lIGFyZ3MgYXMgY29uc3RydWN0b3IgaXRzZWxmLiBDYWxsZWQgb24gaW5zdGFudGlhdGlvbiBhZnRlciAoYWxsKSB0aGUgYGluaXRpYWxpemVgIGZ1bmN0aW9uKHMpLlxuICogQHByb3BlcnR5IHtvYmplY3R9IFthbGlhc2VzXSAtIEhhc2ggb2YgYWxpYXNlcyBmb3IgcHJvdG90eXBlIG1lbWJlcnMgaW4gZm9ybSBgeyBrZXk6ICdtZW1iZXInLCAuLi4gfWAgd2hlcmUgYGtleWAgaXMgdGhlIG5hbWUgb2YgYW4gYWxpZWFzIGFuZCBgJ21lbWJlcidgIGlzIHRoZSBuYW1lIG9mIGFuIGV4aXN0aW5nIG1lbWJlciBpbiB0aGUgcHJvdG90eXBlLiBFYWNoIHN1Y2gga2V5IGlzIGFkZGVkIHRvIHRoZSBwcm90b3R5cGUgYXMgYSByZWZlcmVuY2UgdG8gdGhlIG5hbWVkIG1lbWJlci4gKFRoZSBgYWxpYXNlc2Agb2JqZWN0IGl0c2VsZiBpcyAqbm90KiBhZGRlZCB0byBwcm90b3R5cGUuKSBBbHRlcm5hdGl2ZWx5OlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtrZXlzXSAtIEFyYml0cmFyeSBwcm9wZXJ0eSBuYW1lcyBkZWZpbmVkIGhlcmUgd2l0aCBzdHJpbmcgdmFsdWVzIHN0YXJ0aW5nIHdpdGggYSBgI2AgY2hhcmFjdGVyIHdpbGwgYWxpYXMgdGhlIGFjdHVhbCBwcm9wZXJ0aWVzIG5hbWVkIGluIHRoZSBzdHJpbmdzIChmb2xsb3dpbmcgdGhlIGAjYCkuIFRoaXMgaXMgYW4gYWx0ZXJuYXRpdmUgdG8gcHJvdmlkaW5nIGFuIGBhbGlhc2VzYCBoYXNoLCBwZXJoYXBzIHNpbXBsZXIgKHRob3VnaCBzdWJ0bGVyKS4gKFVzZSB5b3VyIG93biBpZGVudGlmaWVycyBoZXJlOyBkb24ndCB1c2UgdGhlIG5hbWUgYGtleXNgISlcbiAqIEBwcm9wZXJ0eSB7ZGVzY3JpcHRvck9iamVjdH0gW2Rlc2NyaXB0b3JzXSAtIFdpbGwgYmUgcnVuIHRocm91Z2ggYE9iamVjdC5kZWZpbmVQcm9wZXJ0eSgpYC4gVXNlIHlvdXIgb3duIGlkZW50aWZpZXJzIGhlcmU7IGRvbid0IHVzZSB0aGUgbmFtZSBgZGVzY3JpcHRvcnNgISlcbiAqIERldGVjdGVkIGJ5IGR1Y2stdHlwaW5nOlxuICogKiBJdCBoYXMgYSBgY29uZmlndXJhYmxlYCBwcm9wZXJ0eS5cbiAqICogSXQgaGFzIGFuIGBlbnVtZXJhYmxlYCBwcm9wZXJ0eS5cbiAqICogSXQgaGFzIG9ubHk6IGEgYHNldGAgZnVuY3Rpb24gdGhhdCB0YWtlcyBleGFjdGx5IG9uZSBwYXJhbWV0ZXIgYW5kL29yIG9ubHkgYSBgZ2V0YCBmdW5jdGlvbiB0aGF0IHRha2VzIG5vIHBhcmFtZXRlcnMuXG4gKiBAcHJvcGVydHkgeyp9IFthcmJpdHJhcnlQcm9wZXJ0aWVzXSAtIEFueSBhZGRpdGlvbmFsIGFyYml0cmFyeSBwcm9wZXJ0aWVzIGRlZmluZWQgaGVyZSB3aWxsIGJlIGFkZGVkIHRvIHRoZSBuZXcgY29uc3RydWN0b3IncyBwcm90b3R5cGUuIChVc2UgeW91ciBvd24gaWRlbnRpZmllcnMgaGVyZTsgZG9uJ3QgdXNlIHRoZSBuYW1lIGBhcmliaXRyYXJ5UHJvcGVydGllc2AhKVxuICovXG5cbi8qKiBAc3VtbWFyeSBDYWxsIGFsbCBgaW5pdGlhbGl6ZWAgbWV0aG9kcyBmb3VuZCBpbiBwcm90b3R5cGUgY2hhaW4uXG4gKiBAZGVzYyBUaGlzIHJlY3Vyc2l2ZSByb3V0aW5lIGlzIGNhbGxlZCBieSB0aGUgY29uc3RydWN0b3IuXG4gKiAxLiBXYWxrcyBiYWNrIHRoZSBwcm90b3R5cGUgY2hhaW4gdG8gYE9iamVjdGAncyBwcm90b3R5cGVcbiAqIDIuIFdhbGtzIGZvcndhcmQgdG8gbmV3IG9iamVjdCwgY2FsbGluZyBhbnkgYGluaXRpYWxpemVgIG1ldGhvZHMgaXQgZmluZHMgYWxvbmcgdGhlIHdheSB3aXRoIHRoZSBzYW1lIGNvbnRleHQgYW5kIGFyZ3VtZW50cyB3aXRoIHdoaWNoIHRoZSBjb25zdHJ1Y3RvciB3YXMgY2FsbGVkLlxuICogQHByaXZhdGVcbiAqIEBtZW1iZXJPZiBleHRlbmQtbWVcbiAqL1xuZnVuY3Rpb24gaW5pdGlhbGl6ZVByb3RvdHlwZUNoYWluKCkge1xuICAgIHZhciB0ZXJtID0gdGhpcyxcbiAgICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICByZWN1cih0ZXJtKTtcblxuICAgIGZ1bmN0aW9uIHJlY3VyKG9iaikge1xuICAgICAgICB2YXIgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKTtcbiAgICAgICAgaWYgKHByb3RvLmNvbnN0cnVjdG9yICE9PSBPYmplY3QpIHtcbiAgICAgICAgICAgIHJlY3VyKHByb3RvKTtcbiAgICAgICAgICAgIGlmIChwcm90by5oYXNPd25Qcm9wZXJ0eSgnaW5pdGlhbGl6ZScpKSB7XG4gICAgICAgICAgICAgICAgcHJvdG8uaW5pdGlhbGl6ZS5hcHBseSh0ZXJtLCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHRlbmQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHNbJ2NvbHVtbi1DUUwtc3ludGF4J10gPSBbXG4nPGxpPicsXG4nXHQ8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImNvcHlcIj48L2J1dHRvbj4nLFxuJ1x0PGRpdiBjbGFzcz1cImZpbHRlci10cmVlLXJlbW92ZS1idXR0b25cIiB0aXRsZT1cImRlbGV0ZSBjb25kaXRpb25hbFwiPjwvZGl2PicsXG4nXHR7MX06JyxcbidcdDxpbnB1dCBuYW1lPVwiezJ9XCIgY2xhc3M9XCJ7NH1cIiB2YWx1ZT1cInszOmVuY29kZX1cIj4nLFxuJzwvbGk+J1xuXS5qb2luKCdcXG4nKTtcblxuZXhwb3J0c1snY29sdW1uLVNRTC1zeW50YXgnXSA9IFtcbic8bGk+JyxcbidcdDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiY29weVwiPjwvYnV0dG9uPicsXG4nXHQ8ZGl2IGNsYXNzPVwiZmlsdGVyLXRyZWUtcmVtb3ZlLWJ1dHRvblwiIHRpdGxlPVwiZGVsZXRlIGNvbmRpdGlvbmFsXCI+PC9kaXY+JyxcbidcdHsxfTonLFxuJ1x0PHRleHRhcmVhIG5hbWU9XCJ7Mn1cIiByb3dzPVwiMVwiIGNsYXNzPVwiezR9XCI+ezM6ZW5jb2RlfTwvdGV4dGFyZWE+Jyxcbic8L2xpPidcbl0uam9pbignXFxuJyk7XG5cbmV4cG9ydHMuY29sdW1uRmlsdGVyID0gW1xuJzxzcGFuIGNsYXNzPVwiZmlsdGVyLXRyZWVcIj4nLFxuJ1x0IDxzdHJvbmc+PHNwYW4+ezJ9IDwvc3Bhbj5jb2x1bW4gZmlsdGVyIHN1YmV4cHJlc3Npb246PC9zdHJvbmc+PGJyPicsXG4nXHQgTWF0Y2gnLFxuJ1x0IDxsYWJlbD48aW5wdXQgdHlwZT1cInJhZGlvXCIgY2xhc3M9XCJmaWx0ZXItdHJlZS1vcC1jaG9pY2VcIiBuYW1lPVwidHJlZU9wezF9XCIgdmFsdWU9XCJvcC1vclwiPmFueTwvbGFiZWw+JyxcbidcdCA8bGFiZWw+PGlucHV0IHR5cGU9XCJyYWRpb1wiIGNsYXNzPVwiZmlsdGVyLXRyZWUtb3AtY2hvaWNlXCIgbmFtZT1cInRyZWVPcHsxfVwiIHZhbHVlPVwib3AtYW5kXCI+YWxsPC9sYWJlbD4nLFxuJ1x0IDxsYWJlbD48aW5wdXQgdHlwZT1cInJhZGlvXCIgY2xhc3M9XCJmaWx0ZXItdHJlZS1vcC1jaG9pY2VcIiBuYW1lPVwidHJlZU9wezF9XCIgdmFsdWU9XCJvcC1ub3JcIj5ub25lPC9sYWJlbD4nLFxuJ1x0IG9mIHRoZSBmb2xsb3dpbmc6JyxcbidcdCA8c2VsZWN0PicsXG4nXHRcdCA8b3B0aW9uIHZhbHVlPVwiXCI+TmV3IGV4cHJlc3Npb24maGVsbGlwOzwvb3B0aW9uPicsXG4nXHQgPC9zZWxlY3Q+JyxcbidcdCA8b2w+PC9vbD4nLFxuJyA8L3NwYW4+J1xuXS5qb2luKCdcXG4nKTtcblxuZXhwb3J0cy5jb2x1bW5GaWx0ZXJzID0gW1xuJzxzcGFuIGNsYXNzPVwiZmlsdGVyLXRyZWUgZmlsdGVyLXRyZWUtdHlwZS1jb2x1bW4tZmlsdGVyc1wiPicsXG4nXHQgTWF0Y2ggPHN0cm9uZz5hbGw8L3N0cm9uZz4gb2YgdGhlIGZvbGxvd2luZyBjb2x1bW4gZmlsdGVyczonLFxuJ1x0IDxvbD48L29sPicsXG4nIDwvc3Bhbj4nXG5dLmpvaW4oJ1xcbicpO1xuXG5leHBvcnRzLmxvY2tlZENvbHVtbiA9IFtcbic8c3Bhbj4nLFxuJ1x0IHsxOmVuY29kZX0nLFxuJ1x0IDxpbnB1dCB0eXBlPVwiaGlkZGVuXCIgdmFsdWU9XCJ7Mn1cIj4nLFxuJyA8L3NwYW4+J1xuXS5qb2luKCdcXG4nKTtcblxuZXhwb3J0cy5ub3RlID0gW1xuJzxkaXYgY2xhc3M9XCJmb290bm90ZXNcIj4nLFxuJ1x0PGRpdiBjbGFzcz1cImZvb3Rub3RlXCI+PC9kaXY+JyxcbidcdDxwPlNlbGVjdCBhIG5ldyB2YWx1ZSBvciBkZWxldGUgdGhlIGV4cHJlc3Npb24gYWx0b2dldGhlci48L3A+Jyxcbic8L2Rpdj4nXG5dLmpvaW4oJ1xcbicpO1xuXG5leHBvcnRzLm5vdGVzID0gW1xuJzxkaXYgY2xhc3M9XCJmb290bm90ZXNcIj4nLFxuJ1x0PHA+Tm90ZSB0aGUgZm9sbG93aW5nIGVycm9yIGNvbmRpdGlvbnM6PC9wPicsXG4nXHQ8dWwgY2xhc3M9XCJmb290bm90ZVwiPjwvdWw+JyxcbidcdDxwPlNlbGVjdCBuZXcgdmFsdWVzIG9yIGRlbGV0ZSB0aGUgZXhwcmVzc2lvbiBhbHRvZ2V0aGVyLjwvcD4nLFxuJzwvZGl2Pidcbl0uam9pbignXFxuJyk7XG5cbmV4cG9ydHMub3B0aW9uTWlzc2luZyA9IFtcbidUaGUgcmVxdWVzdGVkIHZhbHVlIG9mIDxzcGFuIGNsYXNzPVwiZmllbGQtbmFtZVwiPnsxOmVuY29kZX08L3NwYW4+JyxcbicoPHNwYW4gY2xhc3M9XCJmaWVsZC12YWx1ZVwiPnsyOmVuY29kZX08L3NwYW4+KSBpcyBub3QgdmFsaWQuJ1xuXS5qb2luKCdcXG4nKTtcblxuZXhwb3J0cy5yZW1vdmVCdXR0b24gPSBbXG4nPGRpdiBjbGFzcz1cImZpbHRlci10cmVlLXJlbW92ZS1idXR0b25cIiB0aXRsZT1cImRlbGV0ZSBjb25kaXRpb25hbFwiPjwvZGl2Pidcbl0uam9pbignXFxuJyk7XG5cbmV4cG9ydHMuc3VidHJlZSA9IFtcbic8c3BhbiBjbGFzcz1cImZpbHRlci10cmVlXCI+JyxcbidcdCBNYXRjaCcsXG4nXHQgPGxhYmVsPjxpbnB1dCB0eXBlPVwicmFkaW9cIiBjbGFzcz1cImZpbHRlci10cmVlLW9wLWNob2ljZVwiIG5hbWU9XCJ0cmVlT3B7MX1cIiB2YWx1ZT1cIm9wLW9yXCI+YW55PC9sYWJlbD4nLFxuJ1x0IDxsYWJlbD48aW5wdXQgdHlwZT1cInJhZGlvXCIgY2xhc3M9XCJmaWx0ZXItdHJlZS1vcC1jaG9pY2VcIiBuYW1lPVwidHJlZU9wezF9XCIgdmFsdWU9XCJvcC1hbmRcIj5hbGw8L2xhYmVsPicsXG4nXHQgPGxhYmVsPjxpbnB1dCB0eXBlPVwicmFkaW9cIiBjbGFzcz1cImZpbHRlci10cmVlLW9wLWNob2ljZVwiIG5hbWU9XCJ0cmVlT3B7MX1cIiB2YWx1ZT1cIm9wLW5vclwiPm5vbmU8L2xhYmVsPicsXG4nXHQgb2YgdGhlIGZvbGxvd2luZzonLFxuJ1x0IDxzZWxlY3Q+JyxcbidcdFx0IDxvcHRpb24gdmFsdWU9XCJcIj5OZXcgZXhwcmVzc2lvbiZoZWxsaXA7PC9vcHRpb24+JyxcbidcdFx0IDxvcHRpb24gdmFsdWU9XCJzdWJleHBcIiBzdHlsZT1cImJvcmRlci1ib3R0b206MXB4IHNvbGlkIGJsYWNrXCI+U3ViZXhwcmVzc2lvbjwvb3B0aW9uPicsXG4nXHQgPC9zZWxlY3Q+JyxcbidcdCA8b2w+PC9vbD4nLFxuJyA8L3NwYW4+J1xuXS5qb2luKCdcXG4nKTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIF8gPSByZXF1aXJlKCdvYmplY3QtaXRlcmF0b3JzJyk7XG52YXIgcG9wTWVudSA9IHJlcXVpcmUoJ3BvcC1tZW51Jyk7XG5cbnZhciBGaWx0ZXJUcmVlID0gcmVxdWlyZSgnLi9qcy9GaWx0ZXJUcmVlJyk7XG5GaWx0ZXJUcmVlLk5vZGUgPSByZXF1aXJlKCcuL2pzL0ZpbHRlck5vZGUnKTsgLy8gYWthOiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoRmlsdGVyVHJlZS5wcm90b3R5cGUpLmNvbnN0cnVjdG9yXG5GaWx0ZXJUcmVlLkxlYWYgPSByZXF1aXJlKCcuL2pzL0ZpbHRlckxlYWYnKTsgLy8gYWthOiBGaWx0ZXJUcmVlLnByb3RvdHlwZS5lZGl0b3JzLkRlZmF1bHRcblxuLy8gZXhwb3NlIHNvbWUgb2JqZWN0cyBmb3IgcGx1Zy1pbiBhY2Nlc3NcblxuRmlsdGVyVHJlZS5Db25kaXRpb25hbHMgPSByZXF1aXJlKCcuL2pzL0NvbmRpdGlvbmFscycpO1xuXG4vLyBGT0xMT1dJTkcgUFJPUEVSVElFUyBBUkUgKioqIFRFTVBPUkFSWSAqKiosXG4vLyBGT1IgVEhFIERFTU8gVE8gQUNDRVNTIFRIRVNFIE5PREUgTU9EVUxFUy5cblxuRmlsdGVyVHJlZS5fID0gXztcbkZpbHRlclRyZWUucG9wTWVudSA9IHBvcE1lbnU7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBGaWx0ZXJUcmVlO1xuIiwiLyoqIEBtb2R1bGUgY29uZGl0aW9uYWxzICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEJhc2UgPSByZXF1aXJlKCdleHRlbmQtbWUnKS5CYXNlO1xudmFyIF8gPSByZXF1aXJlKCdvYmplY3QtaXRlcmF0b3JzJyk7XG52YXIgcmVnRXhwTElLRSA9IHJlcXVpcmUoJ3JlZ2V4cC1saWtlJyk7XG5cbnZhciBJTiA9ICdJTicsXG4gICAgTk9UX0lOID0gJ05PVCAnICsgSU4sXG4gICAgTElLRSA9ICdMSUtFJyxcbiAgICBOT1RfTElLRSA9ICdOT1QgJyArIExJS0UsXG4gICAgTElLRV9XSUxEX0NBUkQgPSAnJScsXG4gICAgTklMID0gJyc7XG5cbnZhciB0b1N0cmluZztcblxudmFyIGRlZmF1bHRJZFF0cyA9IHtcbiAgICBiZWc6ICdcIicsXG4gICAgZW5kOiAnXCInXG59O1xuXG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBDb25kaXRpb25hbHMgPSBCYXNlLmV4dGVuZCh7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzcWxJZFF0c09iamVjdH0gW29wdGlvbnMuc3FsSWRRdHM9e2JlZzonXCInLGVuZDonXCInfV1cbiAgICAgKiBAbWVtYmVyT2YgQ29uZGl0aW9uYWxzLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGlkUXRzID0gb3B0aW9ucyAmJiBvcHRpb25zLnNxbElkUXRzO1xuICAgICAgICBpZiAoaWRRdHMpIHtcbiAgICAgICAgICAgIHRoaXMuc3FsSWRRdHMgPSBpZFF0czsgLy8gb25seSBvdmVycmlkZSBpZiBkZWZpbmVkXG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgc3FsSWRRdHM6IGRlZmF1bHRJZFF0cyxcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gaWRcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqIEBtZW1iZXJPZiBDb25kaXRpb25hbHMucHJvdG90eXBlXG4gICAgICovXG4gICAgbWFrZVNxbElkZW50aWZpZXI6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNxbElkUXRzLmJlZyArIGlkICsgdGhpcy5zcWxJZFF0cy5lbmQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBzdHJpbmdcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqIEBtZW1iZXJPZiBDb25kaXRpb25hbHMucHJvdG90eXBlXG4gICAgICovXG4gICAgbWFrZVNxbFN0cmluZzogZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiAnXFwnJyArIHNxRXNjKHN0cmluZykgKyAnXFwnJztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbmRpdGlvbmFscy5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBtYWtlTElLRTogZnVuY3Rpb24oYmVnLCBlbmQsIG9wLCBvcmlnaW5hbE9wLCBjKSB7XG4gICAgICAgIHZhciBlc2NhcGVkID0gYy5vcGVyYW5kLnJlcGxhY2UoLyhbX1xcW1xcXSVdKS9nLCAnWyQxXScpOyAvLyBlc2NhcGUgYWxsIExJS0UgcmVzZXJ2ZWQgY2hhcnNcbiAgICAgICAgcmV0dXJuIHRoaXMubWFrZVNxbElkZW50aWZpZXIoYy5jb2x1bW4pICtcbiAgICAgICAgICAgICcgJyArIG9wICtcbiAgICAgICAgICAgICcgJyArIHRoaXMubWFrZVNxbFN0cmluZyhiZWcgKyBlc2NhcGVkICsgZW5kKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbmRpdGlvbmFscy5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBtYWtlSU46IGZ1bmN0aW9uKG9wLCBjKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1ha2VTcWxJZGVudGlmaWVyKGMuY29sdW1uKSArXG4gICAgICAgICAgICAnICcgKyBvcCArXG4gICAgICAgICAgICAnICcgKyAnKFxcJycgKyBzcUVzYyhjLm9wZXJhbmQpLnJlcGxhY2UoL1xccyosXFxzKi9nLCAnXFwnLCBcXCcnKSArICdcXCcpJztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbmRpdGlvbmFscy5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBtYWtlOiBmdW5jdGlvbihvcCwgYykge1xuICAgICAgICByZXR1cm4gdGhpcy5tYWtlU3FsSWRlbnRpZmllcihjLmNvbHVtbikgK1xuICAgICAgICAgICAgJyAnICsgb3AgK1xuICAgICAgICAgICAgJyAnICsgYy5tYWtlU3FsT3BlcmFuZCgpO1xuICAgIH1cbn0pO1xuXG52YXIgb3BzID0gQ29uZGl0aW9uYWxzLnByb3RvdHlwZS5vcHMgPSB7XG4gICAgdW5kZWZpbmVkOiB7XG4gICAgICAgIHRlc3Q6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdHJ1ZTsgfSxcbiAgICAgICAgbWFrZTogZnVuY3Rpb24oKSB7IHJldHVybiAnJzsgfVxuICAgIH0sXG5cbiAgICAvKiogQHR5cGUge3JlbGF0aW9uYWxPcGVyYXRvcn1cbiAgICAgKiBAbWVtYmVyT2YgQ29uZGl0aW9uYWxzLnByb3RvdHlwZVxuICAgICAqL1xuICAgICc8Jzoge1xuICAgICAgICB0ZXN0OiBmdW5jdGlvbihhLCBiKSB7IHJldHVybiBhIDwgYjsgfSxcbiAgICAgICAgbWFrZTogZnVuY3Rpb24oYykgeyByZXR1cm4gdGhpcy5tYWtlKCc8JywgYyk7IH1cbiAgICB9LFxuICAgIC8qKiBAdHlwZSB7cmVsYXRpb25hbE9wZXJhdG9yfVxuICAgICAqIEBtZW1iZXJPZiBDb25kaXRpb25hbHMucHJvdG90eXBlXG4gICAgICovXG4gICAgJzw9Jzoge1xuICAgICAgICB0ZXN0OiBmdW5jdGlvbihhLCBiKSB7IHJldHVybiBhIDw9IGI7IH0sXG4gICAgICAgIG1ha2U6IGZ1bmN0aW9uKGMpIHsgcmV0dXJuIHRoaXMubWFrZSgnPD0nLCBjKTsgfVxuICAgIH0sXG5cbiAgICAvKiogQHR5cGUge3JlbGF0aW9uYWxPcGVyYXRvcn1cbiAgICAgKiBAbWVtYmVyT2YgQ29uZGl0aW9uYWxzLnByb3RvdHlwZVxuICAgICAqL1xuICAgICc9Jzoge1xuICAgICAgICB0ZXN0OiBmdW5jdGlvbihhLCBiKSB7IHJldHVybiBhID09PSBiOyB9LFxuICAgICAgICBtYWtlOiBmdW5jdGlvbihjKSB7IHJldHVybiB0aGlzLm1ha2UoJz0nLCBjKTsgfVxuICAgIH0sXG5cbiAgICAvKiogQHR5cGUge3JlbGF0aW9uYWxPcGVyYXRvcn1cbiAgICAgKiBAbWVtYmVyT2YgQ29uZGl0aW9uYWxzLnByb3RvdHlwZVxuICAgICAqL1xuICAgICc+PSc6IHtcbiAgICAgICAgdGVzdDogZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gYSA+PSBiOyB9LFxuICAgICAgICBtYWtlOiBmdW5jdGlvbihjKSB7IHJldHVybiB0aGlzLm1ha2UoJz49JywgYyk7IH1cbiAgICB9LFxuXG4gICAgLyoqIEB0eXBlIHtyZWxhdGlvbmFsT3BlcmF0b3J9XG4gICAgICogQG1lbWJlck9mIENvbmRpdGlvbmFscy5wcm90b3R5cGVcbiAgICAgKi9cbiAgICAnPic6IHtcbiAgICAgICAgdGVzdDogZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gYSA+IGI7IH0sXG4gICAgICAgIG1ha2U6IGZ1bmN0aW9uKGMpIHsgcmV0dXJuIHRoaXMubWFrZSgnPicsIGMpOyB9XG4gICAgfSxcblxuICAgIC8qKiBAdHlwZSB7cmVsYXRpb25hbE9wZXJhdG9yfVxuICAgICAqIEBtZW1iZXJPZiBDb25kaXRpb25hbHMucHJvdG90eXBlXG4gICAgICovXG4gICAgJzw+Jzoge1xuICAgICAgICB0ZXN0OiBmdW5jdGlvbihhLCBiKSB7IHJldHVybiBhICE9PSBiOyB9LFxuICAgICAgICBtYWtlOiBmdW5jdGlvbihjKSB7IHJldHVybiB0aGlzLm1ha2UoJzw+JywgYyk7IH1cbiAgICB9LFxuXG4gICAgLyoqIEB0eXBlIHtyZWxhdGlvbmFsT3BlcmF0b3J9XG4gICAgICogQG1lbWJlck9mIENvbmRpdGlvbmFscy5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBMSUtFOiB7XG4gICAgICAgIHRlc3Q6IGZ1bmN0aW9uKGEsIGIpIHsgcmV0dXJuIHJlZ0V4cExJS0UuY2FjaGVkKGIsIHRydWUpLnRlc3QoYSk7IH0sXG4gICAgICAgIG1ha2U6IGZ1bmN0aW9uKGMpIHsgcmV0dXJuIHRoaXMubWFrZShMSUtFLCBjKTsgfSxcbiAgICAgICAgdHlwZTogJ3N0cmluZydcbiAgICB9LFxuXG4gICAgLyoqIEB0eXBlIHtyZWxhdGlvbmFsT3BlcmF0b3J9XG4gICAgICogQG1lbWJlck9mIENvbmRpdGlvbmFscy5wcm90b3R5cGVcbiAgICAgKi9cbiAgICAnTk9UIExJS0UnOiB7XG4gICAgICAgIHRlc3Q6IGZ1bmN0aW9uKGEsIGIpIHsgcmV0dXJuICFyZWdFeHBMSUtFLmNhY2hlZChiLCB0cnVlKS50ZXN0KGEpOyB9LFxuICAgICAgICBtYWtlOiBmdW5jdGlvbihjKSB7IHJldHVybiB0aGlzLm1ha2UoTk9UX0xJS0UsIGMpOyB9LFxuICAgICAgICB0eXBlOiAnc3RyaW5nJ1xuICAgIH0sXG5cbiAgICAvKiogQHR5cGUge3JlbGF0aW9uYWxPcGVyYXRvcn1cbiAgICAgKiBAbWVtYmVyT2YgQ29uZGl0aW9uYWxzLnByb3RvdHlwZVxuICAgICAqL1xuICAgIElOOiB7IC8vIFRPRE86IGN1cnJlbnRseSBmb3JjaW5nIHN0cmluZyB0eXBpbmc7IHJld29yayBjYWxsaW5nIGNvZGUgdG8gcmVzcGVjdCBjb2x1bW4gdHlwZVxuICAgICAgICB0ZXN0OiBmdW5jdGlvbihhLCBiKSB7IHJldHVybiBpbk9wKGEsIGIpID49IDA7IH0sXG4gICAgICAgIG1ha2U6IGZ1bmN0aW9uKGMpIHsgcmV0dXJuIHRoaXMubWFrZUlOKElOLCBjKTsgfSxcbiAgICAgICAgb3BlcmFuZExpc3Q6IHRydWUsXG4gICAgICAgIHR5cGU6ICdzdHJpbmcnXG4gICAgfSxcblxuICAgIC8qKiBAdHlwZSB7cmVsYXRpb25hbE9wZXJhdG9yfVxuICAgICAqIEBtZW1iZXJPZiBDb25kaXRpb25hbHMucHJvdG90eXBlXG4gICAgICovXG4gICAgJ05PVCBJTic6IHsgLy8gVE9ETzogY3VycmVudGx5IGZvcmNpbmcgc3RyaW5nIHR5cGluZzsgcmV3b3JrIGNhbGxpbmcgY29kZSB0byByZXNwZWN0IGNvbHVtbiB0eXBlXG4gICAgICAgIHRlc3Q6IGZ1bmN0aW9uKGEsIGIpIHsgcmV0dXJuIGluT3AoYSwgYikgPCAwOyB9LFxuICAgICAgICBtYWtlOiBmdW5jdGlvbihjKSB7IHJldHVybiB0aGlzLm1ha2VJTihOT1RfSU4sIGMpOyB9LFxuICAgICAgICBvcGVyYW5kTGlzdDogdHJ1ZSxcbiAgICAgICAgdHlwZTogJ3N0cmluZydcbiAgICB9LFxuXG4gICAgLyoqIEB0eXBlIHtyZWxhdGlvbmFsT3BlcmF0b3J9XG4gICAgICogQG1lbWJlck9mIENvbmRpdGlvbmFscy5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBDT05UQUlOUzoge1xuICAgICAgICB0ZXN0OiBmdW5jdGlvbihhLCBiKSB7IHJldHVybiBjb250YWluc09wKGEsIGIpID49IDA7IH0sXG4gICAgICAgIG1ha2U6IGZ1bmN0aW9uKGMpIHsgcmV0dXJuIHRoaXMubWFrZUxJS0UoTElLRV9XSUxEX0NBUkQsIExJS0VfV0lMRF9DQVJELCBMSUtFLCAnQ09OVEFJTlMnLCBjKTsgfSxcbiAgICAgICAgdHlwZTogJ3N0cmluZydcbiAgICB9LFxuXG4gICAgLyoqIEB0eXBlIHtyZWxhdGlvbmFsT3BlcmF0b3J9XG4gICAgICogQG1lbWJlck9mIENvbmRpdGlvbmFscy5wcm90b3R5cGVcbiAgICAgKi9cbiAgICAnTk9UIENPTlRBSU5TJzoge1xuICAgICAgICB0ZXN0OiBmdW5jdGlvbihhLCBiKSB7IHJldHVybiBjb250YWluc09wKGEsIGIpIDwgMDsgfSxcbiAgICAgICAgbWFrZTogZnVuY3Rpb24oYykgeyByZXR1cm4gdGhpcy5tYWtlTElLRShMSUtFX1dJTERfQ0FSRCwgTElLRV9XSUxEX0NBUkQsIE5PVF9MSUtFLCAnTk9UIENPTlRBSU5TJywgYyk7IH0sXG4gICAgICAgIHR5cGU6ICdzdHJpbmcnXG4gICAgfSxcblxuICAgIC8qKiBAdHlwZSB7cmVsYXRpb25hbE9wZXJhdG9yfVxuICAgICAqIEBtZW1iZXJPZiBDb25kaXRpb25hbHMucHJvdG90eXBlXG4gICAgICovXG4gICAgQkVHSU5TOiB7XG4gICAgICAgIHRlc3Q6IGZ1bmN0aW9uKGEsIGIpIHsgYiA9IHRvU3RyaW5nKGIpOyByZXR1cm4gYmVnaW5zT3AoYSwgYi5sZW5ndGgpID09PSBiOyB9LFxuICAgICAgICBtYWtlOiBmdW5jdGlvbihjKSB7IHJldHVybiB0aGlzLm1ha2VMSUtFKE5JTCwgTElLRV9XSUxEX0NBUkQsIExJS0UsICdCRUdJTlMnLCBjKTsgfSxcbiAgICAgICAgdHlwZTogJ3N0cmluZydcbiAgICB9LFxuXG4gICAgLyoqIEB0eXBlIHtyZWxhdGlvbmFsT3BlcmF0b3J9XG4gICAgICogQG1lbWJlck9mIENvbmRpdGlvbmFscy5wcm90b3R5cGVcbiAgICAgKi9cbiAgICAnTk9UIEJFR0lOUyc6IHtcbiAgICAgICAgdGVzdDogZnVuY3Rpb24oYSwgYikgeyBiID0gdG9TdHJpbmcoYik7IHJldHVybiBiZWdpbnNPcChhLCBiLmxlbmd0aCkgIT09IGI7IH0sXG4gICAgICAgIG1ha2U6IGZ1bmN0aW9uKGMpIHsgcmV0dXJuIHRoaXMubWFrZUxJS0UoTklMLCBMSUtFX1dJTERfQ0FSRCwgTk9UX0xJS0UsICdOT1QgQkVHSU5TJywgYyk7IH0sXG4gICAgICAgIHR5cGU6ICdzdHJpbmcnXG4gICAgfSxcblxuICAgIC8qKiBAdHlwZSB7cmVsYXRpb25hbE9wZXJhdG9yfVxuICAgICAqIEBtZW1iZXJPZiBDb25kaXRpb25hbHMucHJvdG90eXBlXG4gICAgICovXG4gICAgRU5EUzoge1xuICAgICAgICB0ZXN0OiBmdW5jdGlvbihhLCBiKSB7IGIgPSB0b1N0cmluZyhiKTsgcmV0dXJuIGVuZHNPcChhLCBiLmxlbmd0aCkgPT09IGI7IH0sXG4gICAgICAgIG1ha2U6IGZ1bmN0aW9uKGMpIHsgcmV0dXJuIHRoaXMubWFrZUxJS0UoTElLRV9XSUxEX0NBUkQsIE5JTCwgTElLRSwgJ0VORFMnLCBjKTsgfSxcbiAgICAgICAgdHlwZTogJ3N0cmluZydcbiAgICB9LFxuXG4gICAgLyoqIEB0eXBlIHtyZWxhdGlvbmFsT3BlcmF0b3J9XG4gICAgICogQG1lbWJlck9mIENvbmRpdGlvbmFscy5wcm90b3R5cGVcbiAgICAgKi9cbiAgICAnTk9UIEVORFMnOiB7XG4gICAgICAgIHRlc3Q6IGZ1bmN0aW9uKGEsIGIpIHsgYiA9IHRvU3RyaW5nKGIpOyByZXR1cm4gZW5kc09wKGEsIGIubGVuZ3RoKSAhPT0gYjsgfSxcbiAgICAgICAgbWFrZTogZnVuY3Rpb24oYykgeyByZXR1cm4gdGhpcy5tYWtlTElLRShMSUtFX1dJTERfQ0FSRCwgTklMLCBOT1RfTElLRSwgJ05PVCBFTkRTJywgYyk7IH0sXG4gICAgICAgIHR5cGU6ICdzdHJpbmcnXG4gICAgfVxufTtcblxuLy8gc29tZSBzeW5vbnltc1xub3BzWydcXHUyMjY0J10gPSBvcHNbJzw9J107ICAvLyBVTklDT0RFICdMRVNTLVRIQU4gT1IgRVFVQUwgVE8nXG5vcHNbJ1xcdTIyNjUnXSA9IG9wc1snPj0nXTsgIC8vIFVOSUNPREUgJ0dSRUFURVItVEhBTiBPUiBFUVVBTCBUTydcbm9wc1snXFx1MjI2MCddID0gb3BzWyc8PiddOyAgLy8gVU5JQ09ERSAnTk9UIEVRVUFMIFRPJ1xuXG5mdW5jdGlvbiBpbk9wKGEsIGIpIHtcbiAgICByZXR1cm4gYlxuICAgICAgICAudHJpbSgpIC8vIHJlbW92ZSBsZWFkaW5nIGFuZCB0cmFpbGluZyBzcGFjZSBjaGFyc1xuICAgICAgICAucmVwbGFjZSgvXFxzKixcXHMqL2csICcsJykgLy8gcmVtb3ZlIGFueSB3aGl0ZS1zcGFjZSBjaGFycyBmcm9tIGFyb3VuZCBjb21tYXNcbiAgICAgICAgLnNwbGl0KCcsJykgLy8gcHV0IGluIGFuIGFycmF5XG4gICAgICAgIC5pbmRleE9mKChhICsgJycpKTsgLy8gc2VhcmNoIGFycmF5IHdob2xlIG1hdGNoZXNcbn1cblxuZnVuY3Rpb24gY29udGFpbnNPcChhLCBiKSB7XG4gICAgcmV0dXJuIHRvU3RyaW5nKGEpLmluZGV4T2YodG9TdHJpbmcoYikpO1xufVxuXG5mdW5jdGlvbiBiZWdpbnNPcChhLCBsZW5ndGgpIHtcbiAgICByZXR1cm4gdG9TdHJpbmcoYSkuc3Vic3RyKDAsIGxlbmd0aCk7XG59XG5cbmZ1bmN0aW9uIGVuZHNPcChhLCBsZW5ndGgpIHtcbiAgICByZXR1cm4gdG9TdHJpbmcoYSkuc3Vic3RyKC1sZW5ndGgsIGxlbmd0aCk7XG59XG5cbmZ1bmN0aW9uIHNxRXNjKHN0cmluZykge1xuICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvJy9nLCAnXFwnXFwnJyk7XG59XG5cbnZhciBncm91cHMgPSB7XG4gICAgZXF1YWxpdHk6IHtcbiAgICAgICAgbGFiZWw6ICdFcXVhbGl0eScsXG4gICAgICAgIHN1Ym1lbnU6IFsnPSddXG4gICAgfSxcbiAgICBpbmVxdWFsaXRpZXM6IHtcbiAgICAgICAgbGFiZWw6ICdJbmVxdWFsaXRpZXMnLFxuICAgICAgICBzdWJtZW51OiBbXG4gICAgICAgICAgICAnPCcsXG4gICAgICAgICAgICAnXFx1MjI2NCcsIC8vIFVOSUNPREUgJ0xFU1MtVEhBTiBPUiBFUVVBTCBUTyc7IG9uIGEgTWFjLCB0eXBlIG9wdGlvbi1jb21tYSAo4omkKVxuICAgICAgICAgICAgJ1xcdTIyNjAnLCAvLyBVTklDT0RFICdOT1QgRVFVQUxTJzsgb24gYSBNYWMsIHR5cGUgb3B0aW9uLWVxdWFscyAo4omgKVxuICAgICAgICAgICAgJ1xcdTIyNjUnLCAvLyBVTklDT0RFICdHUkVBVEVSLVRIQU4gT1IgRVFVQUwgVE8nOyBvbiBhIE1hYywgdHlwZSBvcHRpb24tcGVyaW9kICjiiaUpXG4gICAgICAgICAgICAnPidcbiAgICAgICAgXVxuICAgIH0sXG4gICAgc2V0czoge1xuICAgICAgICBsYWJlbDogJ1NldCBzY2FucycsXG4gICAgICAgIHN1Ym1lbnU6IFsnSU4nLCAnTk9UIElOJ11cbiAgICB9LFxuICAgIHN0cmluZ3M6IHtcbiAgICAgICAgbGFiZWw6ICdTdHJpbmcgc2NhbnMnLFxuICAgICAgICBzdWJtZW51OiBbXG4gICAgICAgICAgICAnQ09OVEFJTlMnLCAnTk9UIENPTlRBSU5TJyxcbiAgICAgICAgICAgICdCRUdJTlMnLCAnTk9UIEJFR0lOUycsXG4gICAgICAgICAgICAnRU5EUycsICdOT1QgRU5EUydcbiAgICAgICAgXVxuICAgIH0sXG4gICAgcGF0dGVybnM6IHtcbiAgICAgICAgbGFiZWw6ICdQYXR0ZXJuIHNjYW5zJyxcbiAgICAgICAgc3VibWVudTogWydMSUtFJywgJ05PVCBMSUtFJ11cbiAgICB9XG59O1xuXG4vLyBhZGQgYSBgbmFtZWAgcHJvcCB0byBlYWNoIGdyb3VwXG5fKGdyb3VwcykuZWFjaChmdW5jdGlvbihncm91cCwga2V5KSB7IGdyb3VwLm5hbWUgPSBrZXk7IH0pO1xuXG4vKipcbiAqIEBtZW1iZXJPZiBDb25kaXRpb25hbHNcbiAqL1xuQ29uZGl0aW9uYWxzLmdyb3VwcyA9IGdyb3VwcztcblxuLyoqIERlZmF1bHQgb3BlcmF0b3IgbWVudSB3aGVuIGNvbnNpc3Rpbmcgb2YgYWxsIG9mIHRoZSBncm91cHMgaW4ge0BsaW5rIG1vZHVsZTpjb25kaXRpb25hbHMuZ3JvdXBzfGdyb3Vwc30uIFRoaXMgbWVudSBpcyB1c2VkIHdoZW4gbm9uZSBvZiB0aGUgZm9sbG93aW5nIGlzIG90aGVyd2lzZSBkZWZpbmVkOlxuICogKiBUaGUgYG9wTWVudWAgcHJvcGVydHkgb2YgdGhlIGNvbHVtbiBzY2hlbWEuXG4gKiAqIFRoZSBlbnRyeSBpbiB0aGUgbm9kZSdzIGB0eXBlT3BNYXBgIGhhc2ggY29ycmVzcG9uZGluZyB0byB0aGUgYHR5cGVgIHByb3BlcnR5IG9mIHRoZSBjb2x1bW4gc2NoZW1hLlxuICogKiBUaGUgbm9kZSdzIGB0cmVlT3BNZW51YCBvYmplY3QuXG4gKiBAdHlwZSB7bWVudUl0ZW1bXX1cbiAqIEBtZW1iZXJPZiBDb25kaXRpb25hbHNcbiAqL1xuQ29uZGl0aW9uYWxzLmRlZmF1bHRPcE1lbnUgPSBbIC8vIGhpZXJhcmNoaWNhbCBtZW51IG9mIHJlbGF0aW9uYWwgb3BlcmF0b3JzXG4gICAgZ3JvdXBzLmVxdWFsaXR5LFxuICAgIGdyb3Vwcy5pbmVxdWFsaXRpZXMsXG4gICAgZ3JvdXBzLnNldHMsXG4gICAgZ3JvdXBzLnN0cmluZ3MsXG4gICAgZ3JvdXBzLnBhdHRlcm5zXG5dO1xuXG5cbi8vIE1lYW50IHRvIGJlIGNhbGxlZCBieSBGaWx0ZXJUcmVlLnByb3RvdHlwZS5zZXRTZW5zaXRpdml0eSBvbmx5XG5Db25kaXRpb25hbHMuc2V0VG9TdHJpbmcgPSBmdW5jdGlvbihmbikge1xuICAgIHJldHVybiAodG9TdHJpbmcgPSBmbik7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbmRpdGlvbmFscztcbiIsIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuLyogZXNsaW50LWRpc2FibGUga2V5LXNwYWNpbmcgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcG9wTWVudSA9IHJlcXVpcmUoJ3BvcC1tZW51Jyk7XG5cbnZhciBGaWx0ZXJOb2RlID0gcmVxdWlyZSgnLi9GaWx0ZXJOb2RlJyk7XG52YXIgQ29uZGl0aW9uYWxzID0gcmVxdWlyZSgnLi9Db25kaXRpb25hbHMnKTtcblxuXG52YXIgdG9TdHJpbmc7IC8vIHNldCBieSBGaWx0ZXJMZWFmLnNldFRvU3RyaW5nKCkgY2FsbGVkIGZyb20gLi4vaW5kZXguanNcblxuXG4vKiogQHR5cGVkZWYge29iamVjdH0gY29udmVydGVyXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9ufSB0b1R5cGUgLSBSZXR1cm5zIGlucHV0IHZhbHVlIGNvbnZlcnRlZCB0byB0eXBlLiBGYWlscyBzaWxlbnRseS5cbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IGZhaWxlZCAtIFRlc3RzIGlucHV0IHZhbHVlIGFnYWluc3QgdHlwZSwgcmV0dXJuaW5nIGBmYWxzZSBpZiB0eXBlIG9yIGB0cnVlYCBpZiBub3QgdHlwZS5cbiAqL1xuXG4vKiogQHR5cGUge2NvbnZlcnRlcn0gKi9cbnZhciBudW1iZXJDb252ZXJ0ZXIgPSB7XG4gICAgdG9UeXBlOiBOdW1iZXIsXG4gICAgZmFpbGVkOiBpc05hTlxufTtcblxuLyoqIEB0eXBlIHtjb252ZXJ0ZXJ9ICovXG52YXIgZGF0ZUNvbnZlcnRlciA9IHtcbiAgICB0b1R5cGU6IGZ1bmN0aW9uKHMpIHsgcmV0dXJuIG5ldyBEYXRlKHMpOyB9LFxuICAgIGZhaWxlZDogaXNOYU5cbn07XG5cbi8qKlxuICogQHR5cGVkZWYge29iamVjdH0gZmlsdGVyTGVhZlZpZXdPYmplY3RcbiAqXG4gKiBAcHJvcGVydHkge0hUTUxFbGVtZW50fSBjb2x1bW4gLSBBIGRyb3AtZG93biB3aXRoIG9wdGlvbnMgZnJvbSB0aGUgYEZpbHRlckxlYWZgIGluc3RhbmNlJ3Mgc2NoZW1hLiBWYWx1ZSBpcyB0aGUgbmFtZSBvZiB0aGUgY29sdW1uIGJlaW5nIHRlc3RlZCAoaS5lLiwgdGhlIGNvbHVtbiB0byB3aGljaCB0aGlzIGNvbmRpdGlvbmFsIGV4cHJlc3Npb24gYXBwbGllcykuXG4gKlxuICogQHByb3BlcnR5IG9wZXJhdG9yIC0gQSBkcm9wLWRvd24gd2l0aCBvcHRpb25zIGZyb20ge0BsaW5rIGNvbHVtbk9wTWVudX0sIHtAbGluayB0eXBlT3BNYXB9LCBvciB7QGxpbmsgdHJlZU9wTWVudX0uIFZhbHVlIGlzIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG9wZXJhdG9yLlxuICpcbiAqIEBwcm9wZXJ0eSBvcGVyYW5kIC0gQW4gaW5wdXQgZWxlbWVudCwgc3VjaCBhcyBhIGRyb3AtZG93biBvciBhIHRleHQgYm94LlxuICovXG5cbi8qKiBAY29uc3RydWN0b3JcbiAqIEBzdW1tYXJ5IEFuIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgYSBjb25kaXRpb25hbCBleHByZXNzaW9uIG5vZGUgaW4gYSBmaWx0ZXIgdHJlZS5cbiAqIEBkZXNjIFRoaXMgb2JqZWN0IHJlcHJlc2VudHMgYSBjb25kaXRpb25hbCBleHByZXNzaW9uLiBJdCBpcyBhbHdheXMgYSB0ZXJtaW5hbCBub2RlIGluIHRoZSBmaWx0ZXIgdHJlZTsgaXQgaGFzIG5vIGNoaWxkIG5vZGVzIG9mIGl0cyBvd24uXG4gKlxuICogQSBjb25kaXRpb25hbCBleHByZXNzaW9uIGlzIGEgc2ltcGxlIGR5YWRpYyBleHByZXNzaW9uIHdpdGggdGhlIGZvbGxvd2luZyBzeW50YXggaW4gdGhlIFVJOlxuICpcbiAqID4gX2NvbHVtbiBvcGVyYXRvciBvcGVyYW5kX1xuICpcbiAqIHdoZXJlOlxuICogKiBfY29sdW1uXyBpcyB0aGUgbmFtZSBvZiBhIGNvbHVtbiBmcm9tIHRoZSBkYXRhIHJvdyBvYmplY3RcbiAqICogX29wZXJhdG9yXyBpcyB0aGUgbmFtZSBvZiBhbiBvcGVyYXRvciBmcm9tIHRoZSBub2RlJ3Mgb3BlcmF0b3IgbGlzdFxuICogKiBfb3BlcmFuZF8gaXMgYSBsaXRlcmFsIHZhbHVlIHRvIGNvbXBhcmUgYWdhaW5zdCB0aGUgdmFsdWUgaW4gdGhlIG5hbWVkIGNvbHVtblxuICpcbiAqICoqTk9URToqKiBUaGUge0BsaW5rIENvbHVtbkxlYWZ9IGV4dGVuc2lvbiBvZiB0aGlzIG9iamVjdCBoYXMgYSBkaWZmZXJlbnQgaW1wbGVtZW50YXRpb24gb2YgX29wZXJhbmRfIHdoaWNoIGlzOiBUaGUgbmFtZSBvZiBhIGNvbHVtbiBmcm9tIHdoaWNoIHRvIGZldGNoIHRoZSBjb21wYXJlIHZhbHVlIChmcm9tIHRoZSBzYW1lIGRhdGEgcm93IG9iamVjdCkgdG8gY29tcGFyZSBhZ2FpbnN0IHRoZSB2YWx1ZSBpbiB0aGUgbmFtZWQgY29sdW1uLiBTZWUgKkV4dGVuZGluZyB0aGUgY29uZGl0aW9uYWwgZXhwcmVzc2lvbiBvYmplY3QqIGluIHRoZSB7QGxpbmsgaHR0cDovL2pvbmVpdC5naXRodWIuaW8vZmlsdGVyLXRyZWUvaW5kZXguaHRtbHxyZWFkbWV9LlxuICpcbiAqIFRoZSB2YWx1ZXMgb2YgdGhlIHRlcm1zIG9mIHRoZSBleHByZXNzaW9uIGFib3ZlIGFyZSBzdG9yZWQgaW4gdGhlIGZpcnN0IHRocmVlIHByb3BlcnRpZXMgYmVsb3cuIEVhY2ggb2YgdGhlc2UgdGhyZWUgcHJvcGVydGllcyBpcyBzZXQgZWl0aGVyIGJ5IGBzZXRTdGF0ZSgpYCBvciBieSB0aGUgdXNlciB2aWEgYSBjb250cm9sIGluIGBlbGAuIE5vdGUgdGhhdCB0aGVzZSBwcm9wZXJ0aWVzIGFyZSBub3QgZHluYW1pY2FsbHkgYm91bmQgdG8gdGhlIFVJIGNvbnRyb2xzOyB0aGV5IGFyZSB1cGRhdGVkIGJ5IHRoZSB2YWxpZGF0aW9uIGZ1bmN0aW9uLCBgaW52YWxpZCgpYC5cbiAqXG4gKiAqKlNlZSBhbHNvIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBzdXBlcmNsYXNzOioqIHtAbGluayBGaWx0ZXJOb2RlfVxuICpcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBjb2x1bW4gLSBOYW1lIG9mIHRoZSBtZW1iZXIgaW4gdGhlIGRhdGEgcm93IG9iamVjdHMgYWdhaW5zdCB3aGljaCBgb3BlcmFuZGAgd2lsbCBiZSBjb21wYXJlZC4gUmVmbGVjdHMgdGhlIHZhbHVlIG9mIHRoZSBgdmlldy5jb2x1bW5gIGNvbnRyb2wgYWZ0ZXIgdmFsaWRhdGlvbi5cbiAqXG4gKiBAcHJvcGVydHkge3N0cmluZ30gb3BlcmF0b3IgLSBPcGVyYXRvciBzeW1ib2wuIFRoaXMgbXVzdCBtYXRjaCBhIGtleSBpbiB0aGUgYHRoaXMucm9vdC5jb25kaXRpb25hbHMub3BzYCBoYXNoLiBSZWZsZWN0cyB0aGUgdmFsdWUgb2YgdGhlIGB2aWV3Lm9wZXJhdG9yYCBjb250cm9sIGFmdGVyIHZhbGlkYXRpb24uXG4gKlxuICogQHByb3BlcnR5IHtzdHJpbmd9IG9wZXJhbmQgLSBWYWx1ZSB0byBjb21wYXJlIGFnYWluc3QgdGhlIHRoZSBtZW1iZXIgb2YgZGF0YSByb3cgbmFtZWQgYnkgYGNvbHVtbmAuIFJlZmxlY3RzIHRoZSB2YWx1ZSBvZiB0aGUgYHZpZXcub3BlcmFuZGAgY29udHJvbCwgYWZ0ZXIgdmFsaWRhdGlvbi5cbiAqXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZSAtIFVzZWQgdG8gZGVzY3JpYmUgdGhlIG9iamVjdCBpbiB0aGUgVUkgc28gdXNlciBjYW4gc2VsZWN0IGFuIGV4cHJlc3Npb24gZWRpdG9yLlxuICpcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbdHlwZT0nc3RyaW5nJ10gLSBUaGUgZGF0YSB0eXBlIG9mIHRoZSBzdWJleHByZXNzaW9uIGlmIG5laXRoZXIgdGhlIG9wZXJhdG9yIG5vciB0aGUgY29sdW1uIHNjaGVtYSBkZWZpbmVzIGEgdHlwZS5cbiAqXG4gKiBAcHJvcGVydHkge0hUTUxFbGVtZW50fSBlbCAtIEEgYDxzcGFuPi4uLjwvc3Bhbj5gIGVsZW1lbnQgdGhhdCBjb250YWlucyB0aGUgVUkgY29udHJvbHMuIFRoaXMgZWxlbWVudCBpcyBhdXRvbWF0aWNhbGx5IGFwcGVuZWRlZCB0byB0aGUgcGFyZW50IGBGaWx0ZXJUcmVlYCdzIGBlbGAuIEdlbmVyYXRlZCBieSB7QGxpbmsgRmlsdGVyTGVhZiNjcmVhdGVWaWV3fGNyZWF0ZVZpZXd9LlxuICpcbiAqIEBwcm9wZXJ0eSB7ZmlsdGVyTGVhZlZpZXdPYmplY3R9IHZpZXcgLSBBIGhhc2ggY29udGFpbmluZyBkaXJlY3QgcmVmZXJlbmNlcyB0byB0aGUgY29udHJvbHMgaW4gYGVsYC4gQWRkZWQgYnkge0BsaW5rIEZpbHRlckxlYWYjY3JlYXRlVmlld3xjcmVhdGVWaWV3fS5cbiAqL1xudmFyIEZpbHRlckxlYWYgPSBGaWx0ZXJOb2RlLmV4dGVuZCgnRmlsdGVyTGVhZicsIHtcblxuICAgIG5hbWU6ICdjb2x1bW4gPSB2YWx1ZScsIC8vIGRpc3BsYXkgc3RyaW5nIGZvciBkcm9wLWRvd25cblxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy52aWV3KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy52aWV3KSB7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3W2tleV0ucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdGhpcy5vbkNoYW5nZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqIEBzdW1tYXJ5IENyZWF0ZSBhIG5ldyB2aWV3LlxuICAgICAqIEBkZXNjIFRoaXMgbmV3IFwidmlld1wiIGlzIGEgZ3JvdXAgb2YgSFRNTCBgRWxlbWVudGAgY29udHJvbHMgdGhhdCBjb21wbGV0ZWx5IGRlc2NyaWJlIHRoZSBjb25kaXRpb25hbCBleHByZXNzaW9uIHRoaXMgb2JqZWN0IHJlcHJlc2VudHMuIFRoaXMgbWV0aG9kIGNyZWF0ZXMgdGhlIHZpZXcsIHNldHRpbmcgYHRoaXMuZWxgIHRvIHBvaW50IHRvIGl0LCBhbmQgdGhlIG1lbWJlcnMgb2YgYHRoaXMudmlld2AgdG8gcG9pbnQgdG8gdGhlIGluZGl2aWR1YWwgY29udHJvbHMgdGhlcmVpbi5cbiAgICAgKiBAbWVtYmVyT2YgRmlsdGVyTGVhZi5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBjcmVhdGVWaWV3OiBmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgICB2YXIgZWwgPSB0aGlzLmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuXG4gICAgICAgIGVsLmNsYXNzTmFtZSA9ICdmaWx0ZXItdHJlZS1lZGl0b3IgZmlsdGVyLXRyZWUtZGVmYXVsdCc7XG5cbiAgICAgICAgaWYgKHN0YXRlICYmIHN0YXRlLmNvbHVtbikge1xuICAgICAgICAgICAgLy8gU3RhdGUgaW5jbHVkZXMgY29sdW1uOlxuICAgICAgICAgICAgLy8gT3BlcmF0b3IgbWVudSBpcyBidWlsdCBsYXRlciBpbiBsb2FkU3RhdGU7IHdlIGRvbid0IG5lZWQgdG8gYnVpbGQgaXQgbm93LiBUaGUgY2FsbCB0b1xuICAgICAgICAgICAgLy8gZ2V0T3BNZW51IGJlbG93IHdpdGggdW5kZWZpbmVkIGNvbHVtbk5hbWUgcmV0dXJucyBbXSByZXN1bHRpbmcgaW4gYW4gZW1wdHkgZHJvcC1kb3duLlxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gV2hlbiBzdGF0ZSBkb2VzIE5PVCBpbmNsdWRlIGNvbHVtbiwgaXQncyBiZWNhdXNlIGVpdGhlcjpcbiAgICAgICAgICAgIC8vIGEuIGNvbHVtbiBpcyB1bmtub3duIGFuZCBvcCBtZW51IHdpbGwgYmUgZW1wdHkgdW50aWwgdXNlciBjaG9vc2VzIGEgY29sdW1uOyBvclxuICAgICAgICAgICAgLy8gYi4gY29sdW1uIGlzIGhhcmQtY29kZWQgd2hlbiB0aGVyZSdzIG9ubHkgb25lIHBvc3NpYmxlIGNvbHVtbiBhcyBpbmZlcmFibGUgZnJvbSBzY2hlbWE6XG4gICAgICAgICAgICB2YXIgc2NoZW1hID0gdGhpcy5zY2hlbWEgJiYgdGhpcy5zY2hlbWEubGVuZ3RoID09PSAxICYmIHRoaXMuc2NoZW1hWzBdLFxuICAgICAgICAgICAgICAgIGNvbHVtbk5hbWUgPSBzY2hlbWEgJiYgc2NoZW1hLm5hbWUgfHwgc2NoZW1hO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy52aWV3ID0ge1xuICAgICAgICAgICAgY29sdW1uOiB0aGlzLm1ha2VFbGVtZW50KHRoaXMuc2NoZW1hLCAnY29sdW1uJywgdGhpcy5zb3J0Q29sdW1uTWVudSksXG4gICAgICAgICAgICBvcGVyYXRvcjogdGhpcy5tYWtlRWxlbWVudChnZXRPcE1lbnUuY2FsbCh0aGlzLCBjb2x1bW5OYW1lKSwgJ29wZXJhdG9yJyksXG4gICAgICAgICAgICBvcGVyYW5kOiB0aGlzLm1ha2VFbGVtZW50KClcbiAgICAgICAgfTtcblxuICAgICAgICBlbC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdicicpKTtcbiAgICB9LFxuXG4gICAgbG9hZFN0YXRlOiBmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgICBpZiAoc3RhdGUpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSwgZWwsIGksIGIsIHNlbGVjdGVkLCBub3RlcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFGaWx0ZXJOb2RlLm9wdGlvbnNTY2hlbWFba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXNba2V5XSA9IHN0YXRlW2tleV07XG4gICAgICAgICAgICAgICAgICAgIGVsID0gdGhpcy52aWV3W2tleV07XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoZWwudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnY2hlY2tib3gnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncmFkaW8nOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnaW5wdXRbbmFtZT1cXCcnICsgZWwubmFtZSArICdcXCddJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGVsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsW2ldLmNoZWNrZWQgPSB2YWx1ZS5pbmRleE9mKGVsW2ldLnZhbHVlKSA+PSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3NlbGVjdC1tdWx0aXBsZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWwgPSBlbC5vcHRpb25zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGIgPSBmYWxzZTsgaSA8IGVsLmxlbmd0aDsgaSsrLCBiID0gYiB8fCBzZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZCA9IHZhbHVlLmluZGV4T2YoZWxbaV0udmFsdWUpID49IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsW2ldLnNlbGVjdGVkID0gc2VsZWN0ZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEZpbHRlck5vZGUuc2V0V2FybmluZ0NsYXNzKGVsLCBiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWwudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoRmlsdGVyTm9kZS5zZXRXYXJuaW5nQ2xhc3MoZWwpICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3Rlcy5wdXNoKHsga2V5OiBrZXksIHZhbHVlOiB2YWx1ZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ2NvbHVtbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFrZU9wTWVudS5jYWxsKHRoaXMsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm90ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIG11bHRpcGxlID0gbm90ZXMubGVuZ3RoID4gMSxcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVzID0gdGhpcy50ZW1wbGF0ZXMsXG4gICAgICAgICAgICAgICAgICAgIGZvb3Rub3RlcyA9IHRlbXBsYXRlcy5nZXQobXVsdGlwbGUgPyAnbm90ZXMnIDogJ25vdGUnKSxcbiAgICAgICAgICAgICAgICAgICAgaW5uZXIgPSBmb290bm90ZXMucXVlcnlTZWxlY3RvcignLmZvb3Rub3RlJyk7XG4gICAgICAgICAgICAgICAgbm90ZXMuZm9yRWFjaChmdW5jdGlvbihub3RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmb290bm90ZSA9IG11bHRpcGxlID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKSA6IGlubmVyO1xuICAgICAgICAgICAgICAgICAgICBub3RlID0gdGVtcGxhdGVzLmdldCgnb3B0aW9uTWlzc2luZycsIG5vdGUua2V5LCBub3RlLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKG5vdGUubGVuZ3RoKSB7IGZvb3Rub3RlLmFwcGVuZENoaWxkKG5vdGVbMF0pOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChtdWx0aXBsZSkgeyBpbm5lci5hcHBlbmRDaGlsZChmb290bm90ZSk7IH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubm90ZXNFbCA9IGZvb3Rub3RlcztcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge2NvbnZlcnRlcn0gbnVtYmVyXG4gICAgICogQHByb3BlcnR5IHtjb252ZXJ0ZXJ9IGludCAtIHN5bm9ueW0gb2YgYG51bWJlcmBcbiAgICAgKiBAcHJvcGVydHkge2NvbnZlcnRlcn0gZmxvYXQgLSBzeW5vbnltIG9mIGBudW1iZXJgXG4gICAgICogQHByb3BlcnR5IHtjb252ZXJ0ZXJ9IGRhdGVcbiAgICAgKiBAcHJvcGVydHkge2NvbnZlcnRlcn0gc3RyaW5nXG4gICAgICovXG4gICAgY29udmVydGVyczoge1xuICAgICAgICBudW1iZXI6IG51bWJlckNvbnZlcnRlcixcbiAgICAgICAgaW50OiBudW1iZXJDb252ZXJ0ZXIsXG4gICAgICAgIGZsb2F0OiBudW1iZXJDb252ZXJ0ZXIsXG4gICAgICAgIGRhdGU6IGRhdGVDb252ZXJ0ZXJcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIGJ5IHRoZSBwYXJlbnQgbm9kZSdzIHtAbGluayBGaWx0ZXJUcmVlI2ludmFsaWR8aW52YWxpZCgpfSBtZXRob2QsIHdoaWNoIGNhdGNoZXMgdGhlIGVycm9yIHRocm93biB3aGVuIGludmFsaWQuXG4gICAgICpcbiAgICAgKiBBbHNvIHBlcmZvcm1zIHRoZSBmb2xsb3dpbmcgY29tcGlsYXRpb24gYWN0aW9uczpcbiAgICAgKiAqIENvcGllcyBhbGwgYHRoaXMudmlld2AnIHZhbHVlcyBmcm9tIHRoZSBET00gdG8gc2ltaWxhcmx5IG5hbWVkIHByb3BlcnRpZXMgb2YgYHRoaXNgLlxuICAgICAqICogUHJlLXNldHMgYHRoaXMub3BgIGFuZCBgdGhpcy5jb252ZXJ0ZXJgIGZvciB1c2UgaW4gYHRlc3RgJ3MgdHJlZSB3YWxrLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50aHJvdz1mYWxzZV0gLSBUaHJvdyBhbiBlcnJvciBpZiBtaXNzaW5nIG9yIGludmFsaWQgdmFsdWUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5mb2N1cz1mYWxzZV0gLSBNb3ZlIGZvY3VzIHRvIG9mZmVuZGluZyBjb250cm9sLlxuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR9IFRoaXMgaXMgdGhlIG5vcm1hbCByZXR1cm4gd2hlbiB2YWxpZDsgb3RoZXJ3aXNlIHRocm93cyBlcnJvciB3aGVuIGludmFsaWQuXG4gICAgICogQG1lbWJlck9mIEZpbHRlckxlYWYucHJvdG90eXBlXG4gICAgICovXG4gICAgaW52YWxpZDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICB2YXIgZWxlbWVudE5hbWUsIHR5cGUsIGZvY3VzZWQ7XG5cbiAgICAgICAgZm9yIChlbGVtZW50TmFtZSBpbiB0aGlzLnZpZXcpIHtcbiAgICAgICAgICAgIHZhciBlbCA9IHRoaXMudmlld1tlbGVtZW50TmFtZV0sXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBjb250cm9sVmFsdWUoZWwpLnRyaW0oKTtcblxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSAnJykge1xuICAgICAgICAgICAgICAgIGlmICghZm9jdXNlZCAmJiBvcHRpb25zICYmIG9wdGlvbnMuZm9jdXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xpY2tJbihlbCk7XG4gICAgICAgICAgICAgICAgICAgIGZvY3VzZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnRocm93KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyB0aGlzLkVycm9yKCdNaXNzaW5nIG9yIGludmFsaWQgJyArIGVsZW1lbnROYW1lICsgJyBpbiBjb25kaXRpb25hbCBleHByZXNzaW9uLiBDb21wbGV0ZSB0aGUgZXhwcmVzc2lvbiBvciByZW1vdmUgaXQuJywgdGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBDb3B5IGVhY2ggY29udHJvbHMncyB2YWx1ZSBhcyBhIG5ldyBzaW1pbGFybHkgbmFtZWQgcHJvcGVydHkgb2YgdGhpcyBvYmplY3QuXG4gICAgICAgICAgICAgICAgdGhpc1tlbGVtZW50TmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMub3AgPSB0aGlzLnJvb3QuY29uZGl0aW9uYWxzLm9wc1t0aGlzLm9wZXJhdG9yXTtcblxuICAgICAgICB0eXBlID0gdGhpcy5nZXRUeXBlKCk7XG5cbiAgICAgICAgdGhpcy5jb252ZXJ0ZXIgPSB0eXBlICYmIHR5cGUgIT09ICdzdHJpbmcnICYmIHRoaXMuY29udmVydGVyc1t0eXBlXTtcbiAgICB9LFxuXG4gICAgZ2V0VHlwZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0aGlzLm9wLnR5cGUgLy8gdGhlIGV4cHJlc3Npb24ncyBvcGVyYXRvcidzIHR5cGUgKGJlY2F1c2Ugc29tZSBvcGVyYXRvcnMgb25seSB3b3JrIHdpdGggc3RyaW5ncylcbiAgICAgICAgICAgIHx8XG4gICAgICAgICAgICAodGhpcy5zY2hlbWEubG9va3VwKHRoaXMuY29sdW1uKSB8fCB7fSkudHlwZSAvLyB0aGUgZXhwcmVzc2lvbidzIGNvbHVtbiBzY2hlbWEgdHlwZVxuICAgICAgICAgICAgfHxcbiAgICAgICAgICAgIHRoaXMudHlwZSAvLyB0aGUgZXhwcmVzc2lvbiBub2RlJ3MgdHlwZVxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICB2YWxPckZ1bmM6IGZ1bmN0aW9uKGRhdGFSb3csIGNvbHVtbk5hbWUpIHtcbiAgICAgICAgdmFyIHZmID0gZGF0YVJvd1tjb2x1bW5OYW1lXTtcbiAgICAgICAgdmFyIHJlc3VsdCA9ICh0eXBlb2YgdmYpWzBdID09PSAnZicgPyB2ZihkYXRhUm93LCBjb2x1bW5OYW1lKSA6IHZmO1xuICAgICAgICByZXR1cm4gcmVzdWx0IHx8IHJlc3VsdCA9PT0gMCA/IHJlc3VsdCA6ICcnO1xuICAgIH0sXG5cbiAgICBwOiBmdW5jdGlvbihkYXRhUm93KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbE9yRnVuYyhkYXRhUm93LCB0aGlzLmNvbHVtbik7XG4gICAgfSxcblxuICAgIC8vIFRvIGJlIG92ZXJyaWRkZW4gd2hlbiBvcGVyYW5kIGlzIGEgY29sdW1uIG5hbWUgKHNlZSBjb2x1bW5zLmpzKS5cbiAgICBxOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3BlcmFuZDtcbiAgICB9LFxuXG4gICAgdGVzdDogZnVuY3Rpb24oZGF0YVJvdykge1xuICAgICAgICB2YXIgcCwgcSwgLy8gdW50eXBlZCB2ZXJzaW9ucyBvZiBhcmdzXG4gICAgICAgICAgICBQLCBRLCAvLyB0eXBlZCB2ZXJzaW9ucyBvZiBwIGFuZCBxXG4gICAgICAgICAgICBjb252ZXJ0ZXI7XG5cbiAgICAgICAgLy8gVE9ETzogSWYgYSBsaXRlcmFsIChpLmUuLCB3aGVuIHRoaXMucSBpcyBub3Qgb3ZlcnJpZGRlbiksIHEgb25seSBuZWVkcyB0byBiZSBmZXRjaGVkIE9OQ0UgZm9yIGFsbCByb3dzXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAocCA9IHRoaXMucChkYXRhUm93KSkgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgKHEgPSB0aGlzLnEoZGF0YVJvdykpID09PSB1bmRlZmluZWRcbiAgICAgICAgKVxuICAgICAgICAgICAgPyBmYWxzZSAvLyBkYXRhIGluYWNjZXNzaWJsZSBzbyBleGNsdWRlIHJvd1xuICAgICAgICAgICAgOiAoXG4gICAgICAgICAgICAgICAgKGNvbnZlcnRlciA9IHRoaXMuY29udmVydGVyKSAmJlxuICAgICAgICAgICAgICAgICFjb252ZXJ0ZXIuZmFpbGVkKFAgPSBjb252ZXJ0ZXIudG9UeXBlKHApKSAmJiAvLyBhdHRlbXB0IHRvIGNvbnZlcnQgZGF0YSB0byB0eXBlXG4gICAgICAgICAgICAgICAgIWNvbnZlcnRlci5mYWlsZWQoUSA9IGNvbnZlcnRlci50b1R5cGUocSkpXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgPyB0aGlzLm9wLnRlc3QoUCwgUSkgLy8gYm90aCBjb252ZXJzaW9ucyBzdWNjZXNzZnVsOiBjb21wYXJlIGFzIHR5cGVzXG4gICAgICAgICAgICAgICAgOiB0aGlzLm9wLnRlc3QodG9TdHJpbmcocCksIHRvU3RyaW5nKHEpKTsgLy8gb25lIG9yIGJvdGggY29udmVyc2lvbnMgZmFpbGVkOiBjb21wYXJlIGFzIHN0cmluZ3NcbiAgICB9LFxuXG4gICAgdG9KU09OOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHN0YXRlID0ge307XG4gICAgICAgIGlmICh0aGlzLmVkaXRvcikge1xuICAgICAgICAgICAgc3RhdGUuZWRpdG9yID0gdGhpcy5lZGl0b3I7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMudmlldykge1xuICAgICAgICAgICAgc3RhdGVba2V5XSA9IHRoaXNba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zY2hlbWEgIT09IHRoaXMucGFyZW50LnNjaGVtYSkge1xuICAgICAgICAgICAgc3RhdGUuc2NoZW1hID0gdGhpcy5zY2hlbWE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGb3IgYCdvYmplY3QnYCBhbmQgYCdKU09OJ2Agbm90ZSB0aGF0IHRoZSBzdWJ0cmVlJ3MgdmVyc2lvbiBvZiBgZ2V0U3RhdGVgIHdpbGwgbm90IGNhbGwgdGhpcyBsZWFmIHZlcnNpb24gb2YgYGdldFN0YXRlYCBiZWNhdXNlIHRoZSBmb3JtZXIgdXNlcyBgdW5zdHJ1bmdpZnkoKWAgYW5kIGBKU09OLnN0cmluZ2lmeSgpYCwgcmVzcGVjdGl2ZWx5LCBib3RoIG9mIHdoaWNoIHJlY3Vyc2UgYW5kIGNhbGwgYHRvSlNPTigpYCBvbiB0aGVpciBvd24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnM9J29iamVjdCddIC0gU2VlIHRoZSBzdWJ0cmVlIHZlcnNpb24gb2Yge0BsaW5rIEZpbHRlclRyZWUjZ2V0U3RhdGV8Z2V0U3RhdGV9IGZvciBtb3JlIGluZm8uXG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgRmlsdGVyTGVhZi5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBnZXRTdGF0ZTogZnVuY3Rpb24gZ2V0U3RhdGUob3B0aW9ucykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gJycsXG4gICAgICAgICAgICBzeW50YXggPSBvcHRpb25zICYmIG9wdGlvbnMuc3ludGF4IHx8ICdvYmplY3QnO1xuXG4gICAgICAgIHN3aXRjaCAoc3ludGF4KSB7XG4gICAgICAgICAgICBjYXNlICdvYmplY3QnOiAvLyBzZWUgbm90ZSBhYm92ZVxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMudG9KU09OKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdKU09OJzogLy8gc2VlIG5vdGUgYWJvdmVcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBKU09OLnN0cmluZ2lmeSh0aGlzLCBudWxsLCBvcHRpb25zICYmIG9wdGlvbnMuc3BhY2UpIHx8ICcnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnU1FMJzpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLmdldFN5bnRheCh0aGlzLnJvb3QuY29uZGl0aW9uYWxzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIG1ha2VTcWxPcGVyYW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdC5jb25kaXRpb25hbHMubWFrZVNxbFN0cmluZyh0aGlzLm9wZXJhbmQpOyAvLyB0b2RvOiB0aGlzIHNob3VsZCBiZSBhIG51bWJlciBpZiB0eXBlIGlzIG51bWJlciBpbnN0ZWFkIG9mIGEgc3RyaW5nIC0tIGJ1dCB3ZSB3aWxsIGhhdmUgdG8gZW5zdXJlIGl0IGlzIG51bWVyaWMhXG4gICAgfSxcblxuICAgIGdldFN5bnRheDogZnVuY3Rpb24oY29uZGl0aW9uYWxzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvb3QuY29uZGl0aW9uYWxzLm9wc1t0aGlzLm9wZXJhdG9yXS5tYWtlLmNhbGwoY29uZGl0aW9uYWxzLCB0aGlzKTtcbiAgICB9LFxuXG4gICAgLyoqIEBzdW1tYXJ5IEhUTUwgZm9ybSBjb250cm9scyBmYWN0b3J5LlxuICAgICAqIEBkZXNjIENyZWF0ZXMgYW5kIGFwcGVuZHMgYSB0ZXh0IGJveCBvciBhIGRyb3AtZG93bi5cbiAgICAgKiA+IERlZmluZWQgb24gdGhlIEZpbHRlclRyZWUgcHJvdG90eXBlIGZvciBhY2Nlc3MgYnkgZGVyaXZlZCB0eXBlcyAoYWx0ZXJuYXRlIGZpbHRlciBlZGl0b3JzKS5cbiAgICAgKiBAcmV0dXJucyBUaGUgbmV3IGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHttZW51SXRlbVtdfSBbbWVudV0gLSBPdmVybG9hZHM6XG4gICAgICogKiBJZiBvbWl0dGVkLCB3aWxsIGNyZWF0ZSBhbiBgPGlucHV0Lz5gICh0ZXh0IGJveCkgZWxlbWVudC5cbiAgICAgKiAqIElmIGNvbnRhaW5zIG9ubHkgYSBzaW5nbGUgb3B0aW9uLCB3aWxsIGNyZWF0ZSBhIGA8c3Bhbj4uLi48L3NwYW4+YCBlbGVtZW50IGNvbnRhaW5pbmcgdGhlIHN0cmluZyBhbmQgYSBgPGlucHV0IHR5cGU9aGlkZGVuPmAgY29udGFpbmluZyB0aGUgdmFsdWUuXG4gICAgICogKiBPdGhlcndpc2UsIGNyZWF0ZXMgYSBgPHNlbGVjdD4uLi48L3NlbGVjdD5gIGVsZW1lbnQgd2l0aCB0aGVzZSBtZW51IGl0ZW1zLlxuICAgICAqIEBwYXJhbSB7bnVsbHxzdHJpbmd9IFtwcm9tcHQ9JyddIC0gQWRkcyBhbiBpbml0aWFsIGA8b3B0aW9uPi4uLjwvb3B0aW9uPmAgZWxlbWVudCB0byB0aGUgZHJvcC1kb3duIHdpdGggdGhpcyB2YWx1ZSwgcGFyZW50aGVzaXplZCwgYXMgaXRzIGB0ZXh0YDsgYW5kIGVtcHR5IHN0cmluZyBhcyBpdHMgYHZhbHVlYC4gT21pdHRpbmcgY3JlYXRlcyBhIGJsYW5rIHByb21wdDsgYG51bGxgIHN1cHByZXNzZXMuXG4gICAgICogQHBhcmFtIFtzb3J0XVxuICAgICAqIEBtZW1iZXJPZiBGaWx0ZXJMZWFmLnByb3RvdHlwZVxuICAgICAqL1xuICAgIG1ha2VFbGVtZW50OiBmdW5jdGlvbihtZW51LCBwcm9tcHQsIHNvcnQpIHtcbiAgICAgICAgdmFyIGVsLCByZXN1bHQsIG9wdGlvbnMsXG4gICAgICAgICAgICBvcHRpb24gPSBtZW51LFxuICAgICAgICAgICAgdGFnTmFtZSA9IG1lbnUgPyAnU0VMRUNUJyA6ICdJTlBVVCc7XG5cbiAgICAgICAgLy8gZGV0ZXJtaW5lIGlmIHRoZXJlIHdvdWxkIGJlIG9ubHkgYSBzaW5nbGUgaXRlbSBpbiB0aGUgZHJvcGRvd25cbiAgICAgICAgd2hpbGUgKG9wdGlvbiBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICBpZiAob3B0aW9uLmxlbmd0aCA9PT0gMSAmJiAhcG9wTWVudS5pc0dyb3VwUHJveHkob3B0aW9uWzBdKSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbiA9IG9wdGlvblswXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3B0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbikge1xuICAgICAgICAgICAgLy8gaGFyZCB0ZXh0IHdoZW4gc2luZ2xlIGl0ZW1cbiAgICAgICAgICAgIGVsID0gdGhpcy50ZW1wbGF0ZXMuZ2V0KFxuICAgICAgICAgICAgICAgICdsb2NrZWRDb2x1bW4nLFxuICAgICAgICAgICAgICAgIG9wdGlvbi5hbGlhcyB8fCBvcHRpb24ubmFtZSB8fCBvcHRpb24sXG4gICAgICAgICAgICAgICAgb3B0aW9uLm5hbWUgfHwgb3B0aW9uLmFsaWFzIHx8IG9wdGlvblxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IGVsLnF1ZXJ5U2VsZWN0b3IoJ2lucHV0Jyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIHByb21wdDogcHJvbXB0LFxuICAgICAgICAgICAgICAgIHNvcnQ6IHNvcnQsXG4gICAgICAgICAgICAgICAgZ3JvdXA6IGZ1bmN0aW9uKGdyb3VwTmFtZSkgeyByZXR1cm4gQ29uZGl0aW9uYWxzLmdyb3Vwc1tncm91cE5hbWVdOyB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBtYWtlIGFuIGVsZW1lbnRcbiAgICAgICAgICAgIGVsID0gcG9wTWVudS5idWlsZCh0YWdOYW1lLCBtZW51LCBvcHRpb25zKTtcblxuICAgICAgICAgICAgLy8gaWYgaXQncyBhIHRleHRib3gsIGxpc3RlbiBmb3Iga2V5dXAgZXZlbnRzXG4gICAgICAgICAgICBpZiAoZWwudHlwZSA9PT0gJ3RleHQnICYmIHRoaXMuZXZlbnRIYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIHRoaXMuZXZlbnRIYW5kbGVyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaGFuZGxlIG9uY2hhbmdlIGV2ZW50c1xuICAgICAgICAgICAgdGhpcy5vbkNoYW5nZSA9IHRoaXMub25DaGFuZ2UgfHwgY2xlYW5VcEFuZE1vdmVPbi5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLm9uQ2hhbmdlKTtcblxuICAgICAgICAgICAgRmlsdGVyTm9kZS5zZXRXYXJuaW5nQ2xhc3MoZWwpO1xuICAgICAgICAgICAgcmVzdWx0ID0gZWw7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmVsLmFwcGVuZENoaWxkKGVsKTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn0pO1xuXG4vKiogYGNoYW5nZWAgZXZlbnQgaGFuZGxlciBmb3IgYWxsIGZvcm0gY29udHJvbHMuXG4gKiBSZWJ1aWxkcyB0aGUgb3BlcmF0b3IgZHJvcC1kb3duIGFzIG5lZWRlZC5cbiAqIFJlbW92ZXMgZXJyb3IgQ1NTIGNsYXNzIGZyb20gY29udHJvbC5cbiAqIEFkZHMgd2FybmluZyBDU1MgY2xhc3MgZnJvbSBjb250cm9sIGlmIGJsYW5rOyByZW1vdmVzIGlmIG5vdCBibGFuay5cbiAqIEFkZHMgd2FybmluZyBDU1MgY2xhc3MgZnJvbSBjb250cm9sIGlmIGJsYW5rOyByZW1vdmVzIGlmIG5vdCBibGFuay5cbiAqIE1vdmVzIGZvY3VzIHRvIG5leHQgbm9uLWJsYW5rIHNpYmxpbmcgY29udHJvbC5cbiAqIEB0aGlzIEJvdW5kIHRvIHRoaXMgbm9kZS5cbiAqL1xuZnVuY3Rpb24gY2xlYW5VcEFuZE1vdmVPbihldnQpIHtcbiAgICB2YXIgZWwgPSBldnQudGFyZ2V0O1xuXG4gICAgLy8gcmVtb3ZlIGBlcnJvcmAgQ1NTIGNsYXNzLCB3aGljaCBtYXkgaGF2ZSBiZWVuIGFkZGVkIGJ5IGBGaWx0ZXJMZWFmLnByb3RvdHlwZS5pbnZhbGlkYFxuICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoJ2ZpbHRlci10cmVlLWVycm9yJyk7XG5cbiAgICAvLyBzZXQgb3IgcmVtb3ZlICd3YXJuaW5nJyBDU1MgY2xhc3MsIGFzIHBlciBlbC52YWx1ZVxuICAgIEZpbHRlck5vZGUuc2V0V2FybmluZ0NsYXNzKGVsKTtcblxuICAgIGlmIChlbCA9PT0gdGhpcy52aWV3LmNvbHVtbikge1xuICAgICAgICAvLyByZWJ1aWxkIG9wZXJhdG9yIGxpc3QgYWNjb3JkaW5nIHRvIHNlbGVjdGVkIGNvbHVtbiBuYW1lIG9yIHR5cGUsIHJlc3RvcmluZyBzZWxlY3RlZCBpdGVtXG4gICAgICAgIG1ha2VPcE1lbnUuY2FsbCh0aGlzLCBlbC52YWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKGVsLnZhbHVlKSB7XG4gICAgICAgIC8vIGZpbmQgbmV4dCBzaWJsaW5nIGNvbnRyb2wsIGlmIGFueVxuICAgICAgICBpZiAoIWVsLm11bHRpcGxlKSB7XG4gICAgICAgICAgICB3aGlsZSAoKGVsID0gZWwubmV4dEVsZW1lbnRTaWJsaW5nKSAmJiAoISgnbmFtZScgaW4gZWwpIHx8IGVsLnZhbHVlLnRyaW0oKSAhPT0gJycpKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjdXJseVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gYW5kIGNsaWNrIGluIGl0IChvcGVucyBzZWxlY3QgbGlzdClcbiAgICAgICAgaWYgKGVsICYmIGVsLnZhbHVlLnRyaW0oKSA9PT0gJycpIHtcbiAgICAgICAgICAgIGVsLnZhbHVlID0gJyc7IC8vIHJpZCBvZiBhbnkgd2hpdGUgc3BhY2VcbiAgICAgICAgICAgIEZpbHRlck5vZGUuY2xpY2tJbihlbCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBmb3J3YXJkIHRoZSBldmVudCB0byB0aGUgYXBwbGljYXRpb24ncyBldmVudCBoYW5kbGVyXG4gICAgaWYgKHRoaXMuZXZlbnRIYW5kbGVyKSB7XG4gICAgICAgIHRoaXMuZXZlbnRIYW5kbGVyKGV2dCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnZXRPcE1lbnUoY29sdW1uTmFtZSkge1xuICAgIHZhciBjb2x1bW4gPSB0aGlzLnNjaGVtYS5sb29rdXAoY29sdW1uTmFtZSkgfHwge307XG4gICAgcmV0dXJuIChcbiAgICAgICAgY29sdW1uLm9wTWVudVxuICAgICAgICAgICAgfHxcbiAgICAgICAgdGhpcy50eXBlT3BNYXAgJiYgdGhpcy50eXBlT3BNYXBbY29sdW1uLnR5cGUgfHwgdGhpcy50eXBlXVxuICAgICAgICAgICAgfHxcbiAgICAgICAgdGhpcy5vcE1lbnVcbiAgICApO1xufVxuXG5mdW5jdGlvbiBtYWtlT3BNZW51KGNvbHVtbk5hbWUpIHtcbiAgICB2YXIgb3BNZW51ID0gZ2V0T3BNZW51LmNhbGwodGhpcywgY29sdW1uTmFtZSk7XG5cbiAgICBpZiAob3BNZW51ICE9PSB0aGlzLnJlbmRlcmVkT3BNZW51KSB7XG4gICAgICAgIHZhciBuZXdPcERyb3AgPSB0aGlzLm1ha2VFbGVtZW50KG9wTWVudSwgJ29wZXJhdG9yJyk7XG5cbiAgICAgICAgbmV3T3BEcm9wLnZhbHVlID0gdGhpcy52aWV3Lm9wZXJhdG9yLnZhbHVlO1xuICAgICAgICB0aGlzLmVsLnJlcGxhY2VDaGlsZChuZXdPcERyb3AsIHRoaXMudmlldy5vcGVyYXRvcik7XG4gICAgICAgIHRoaXMudmlldy5vcGVyYXRvciA9IG5ld09wRHJvcDtcblxuICAgICAgICBGaWx0ZXJOb2RlLnNldFdhcm5pbmdDbGFzcyhuZXdPcERyb3ApO1xuXG4gICAgICAgIHRoaXMucmVuZGVyZWRPcE1lbnUgPSBvcE1lbnU7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjbGlja0luKGVsKSB7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgZWwuY2xhc3NMaXN0LmFkZCgnZmlsdGVyLXRyZWUtZXJyb3InKTtcbiAgICAgICAgRmlsdGVyTm9kZS5jbGlja0luKGVsKTtcbiAgICB9LCAwKTtcbn1cblxuZnVuY3Rpb24gY29udHJvbFZhbHVlKGVsKSB7XG4gICAgdmFyIHZhbHVlLCBpO1xuXG4gICAgc3dpdGNoIChlbC50eXBlKSB7XG4gICAgICAgIGNhc2UgJ2NoZWNrYm94JzpcbiAgICAgICAgY2FzZSAncmFkaW8nOlxuICAgICAgICAgICAgZWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFtuYW1lPVxcJycgKyBlbC5uYW1lICsgJ1xcJ106ZW5hYmxlZDpjaGVja2VkJyk7XG4gICAgICAgICAgICBmb3IgKHZhbHVlID0gW10sIGkgPSAwOyBpIDwgZWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YWx1ZS5wdXNoKGVsW2ldLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3NlbGVjdC1tdWx0aXBsZSc6XG4gICAgICAgICAgICBlbCA9IGVsLm9wdGlvbnM7XG4gICAgICAgICAgICBmb3IgKHZhbHVlID0gW10sIGkgPSAwOyBpIDwgZWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoIWVsLmRpc2FibGVkICYmIGVsLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLnB1c2goZWxbaV0udmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB2YWx1ZSA9IGVsLnZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbn1cblxuLy8gTWVhbnQgdG8gYmUgY2FsbGVkIGJ5IEZpbHRlclRyZWUucHJvdG90eXBlLnNldFNlbnNpdGl2aXR5IG9ubHlcbkZpbHRlckxlYWYuc2V0VG9TdHJpbmcgPSBmdW5jdGlvbihmbikge1xuICAgIHRvU3RyaW5nID0gZm47XG4gICAgcmV0dXJuIENvbmRpdGlvbmFscy5zZXRUb1N0cmluZyhmbik7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gRmlsdGVyTGVhZjtcbiIsIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfID0gcmVxdWlyZSgnb2JqZWN0LWl0ZXJhdG9ycycpO1xudmFyIGV4dGVuZCA9IHJlcXVpcmUoJ2V4dGVuZC1tZScpLCBCYXNlID0gZXh0ZW5kLkJhc2U7IGV4dGVuZC5kZWJ1ZyA9IHRydWU7XG52YXIgcG9wTWVudSA9IHJlcXVpcmUoJ3BvcC1tZW51Jyk7XG5cbnZhciBjc3NJbmplY3RvciA9IHJlcXVpcmUoJy4vc3R5bGVzaGVldCcpO1xudmFyIFRlbXBsYXRlcyA9IHJlcXVpcmUoJy4vVGVtcGxhdGVzJyk7XG52YXIgQ29uZGl0aW9uYWxzID0gcmVxdWlyZSgnLi9Db25kaXRpb25hbHMnKTtcbnZhciBQYXJzZXJTUUwgPSByZXF1aXJlKCcuL3BhcnNlci1TUUwnKTtcblxuXG52YXIgQ0hJTERSRU5fVEFHID0gJ09MJyxcbiAgICBDSElMRF9UQUcgPSAnTEknO1xuXG4vLyBKU09OLWRldGVjdG9yOiBiZWdpbnMgX2FuZF8gZW5kcyB3aXRoIGVpdGhlciBbIGFuZCBdIF9vcl8geyBhbmQgfVxudmFyIHJlSlNPTiA9IC9eXFxzKigoXFxbW15dKlxcXSl8KFxce1teXSpcXH0pKVxccyokLztcblxuZnVuY3Rpb24gRmlsdGVyVHJlZUVycm9yKG1lc3NhZ2UsIG5vZGUpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIHRoaXMubm9kZSA9IG5vZGU7XG59XG5GaWx0ZXJUcmVlRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuRmlsdGVyVHJlZUVycm9yLnByb3RvdHlwZS5uYW1lID0gJ0ZpbHRlclRyZWVFcnJvcic7XG5cbi8qKiBAdHlwZWRlZiB7b2JqZWN0fSBGaWx0ZXJUcmVlU2V0U3RhdGVPcHRpb25zT2JqZWN0XG4gKlxuICogQHByb3BlcnR5IHtib29sZWFufSBbc3ludGF4PSdhdXRvJ10gLSBTcGVjaWZ5IHBhcnNlciB0byB1c2Ugb24gYHN0YXRlYC4gT25lIG9mOlxuICogKiBgJ2F1dG8nYCAtIEF1dG8tZGV0ZWN0OyBzZWUge0BsaW5rIEZpbHRlck5vZGUjcGFyc2VTdGF0ZVN0cmluZ30gZm9yIGFsZ29yaXRobS5cbiAqICogYCdvYmplY3QnYCAtIEEgcmF3IHN0YXRlIG9iamVjdCBzdWNoIGFzIHRoYXQgcHJvZHVjZWQgYnkgdGhlIFtnZXRTdGF0ZSgpXXtAbGluayBGaWx0ZXJUcmVlI2dldFN0YXRlfSBtZXRob2QuXG4gKiAqIGAnSlNPTidgIC0gQSBKU09OIHN0cmluZyB2ZXJzaW9uIG9mIGEgc3RhdGUgb2JqZWN0IHN1Y2ggYXMgdGhhdCBwcm9kdWNlZCBieSB0aGUgW2dldFN0YXRlKClde0BsaW5rIEZpbHRlclRyZWUjZ2V0U3RhdGV9IG1ldGhvZC5cbiAqICogYCdTUUwnYCAtIEEgU1FMIFtzZWFyY2ggY29uZGl0aW9uIGV4cHJlc3Npb25de0BsaW5rIGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvbXMxNzM1NDUuYXNweH0gc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gW2NvbnRleHRdIElmIGRlZmluZWQsIHRoZSBwcm92aWRlZCBpbnB1dCBzdHJpbmcgaXMgdXNlZCBhcyBhIHNlbGVjdG9yIHRvIGFuIGBIVE1MRWxlbWVudGAgY29udGFpbmVkIGluIGBjb250ZXh0YC4gVGhlIGB2YWx1ZWAgcHJvcGVydHkgb2YgdGhpcyBlbGVtZW50IGlzIGZldGNoZWQgZnJvbSB0aGUgRE9NIGFuZCBpcyB1c2VkIGFzIHRoZSBpbnB1dCBzdGF0ZSBzdHJpbmc7IHByb2NlZWQgYXMgYWJvdmUuXG4gKi9cblxuLyoqIEB0eXBlZGVmIHtvYmplY3R9IEZpbHRlclRyZWVPcHRpb25zT2JqZWN0XG4gKlxuICogQHByb3BlcnR5IHttZW51SXRlbVtdfSBbc2NoZW1hXSAtIEEgZGVmYXVsdCBsaXN0IG9mIGNvbHVtbiBuYW1lcyBmb3IgZmllbGQgZHJvcC1kb3ducyBvZiBhbGwgZGVzY2VuZGFudCB0ZXJtaW5hbCBub2Rlcy4gT3ZlcnJpZGVzIGBvcHRpb25zLnN0YXRlLnNjaGVtYWAgKHNlZSkuIE1heSBiZSBkZWZpbmVkIGZvciBhbnkgbm9kZSBhbmQgcGVydGFpbnMgdG8gYWxsIGRlc2NlbmRhbnRzIG9mIHRoYXQgbm9kZSAoaW5jbHVkaW5nIHRlcm1pbmFsIG5vZGVzKS4gSWYgb21pdHRlZCAoYW5kIG5vIGBvd25TY2hlbWFgKSwgd2lsbCB1c2UgdGhlIG5lYXJlc3QgYW5jZXN0b3IgYHNjaGVtYWAgZGVmaW5pdGlvbi4gSG93ZXZlciwgZGVzY2VuZGFudHMgd2l0aCB0aGVpciBvd24gZGVmaW5pdGlvbiBvZiBgdHlwZXNgIHdpbGwgb3ZlcnJpZGUgYW55IGFuY2VzdG9yIGRlZmluaXRpb24uXG4gKlxuICogPiBUeXBpY2FsbHkgb25seSB1c2VkIGJ5IHRoZSBjYWxsZXIgZm9yIHRoZSB0b3AtbGV2ZWwgKHJvb3QpIHRyZWUuXG4gKlxuICogQHByb3BlcnR5IHttZW51SXRlbVtdfSBbb3duU2NoZW1hXSAtIEEgZGVmYXVsdCBsaXN0IG9mIGNvbHVtbiBuYW1lcyBmb3IgZmllbGQgZHJvcC1kb3ducyBvZiBpbW1lZGlhdGUgZGVzY2VuZGFudCB0ZXJtaW5hbCBub2RlcyBfb25seV8uIE92ZXJyaWRlcyBgb3B0aW9ucy5zdGF0ZS5vd25TY2hlbWFgIChzZWUpLlxuICpcbiAqIEFsdGhvdWdoIGJvdGggYG9wdGlvbnMuc2NoZW1hYCBhbmQgYG9wdGlvbnMub3duU2NoZW1hYCBhcmUgbm90YXRlZCBhcyBvcHRpb25hbCBoZXJlaW4sIGJ5IHRoZSB0aW1lIGEgdGVybWluYWwgbm9kZSB0cmllcyB0byByZW5kZXIgYSBzY2hlbWEgZHJvcC1kb3duLCBhIGBzY2hlbWFgIGxpc3Qgc2hvdWxkIGJlIGRlZmluZWQgdGhyb3VnaCAoaW4gb3JkZXIgb2YgcHJpb3JpdHkpOlxuICpcbiAqICogVGVybWluYWwgbm9kZSdzIG93biBgb3B0aW9ucy5zY2hlbWFgIChvciBgb3B0aW9ucy5zdGF0ZS5zY2hlbWFgKSBkZWZpbml0aW9uLlxuICogKiBUZXJtaW5hbCBub2RlJ3MgcGFyZW50IG5vZGUncyBgb3B0aW9uLm93blNjaGVtYWAgKG9yIGBvcHRpb24uc3RhdGUubm9kZXNGaWVsZHNgKSBkZWZpbml0aW9uLlxuICogKiBUZXJtaW5hbCBub2RlJ3MgcGFyZW50IChvciBhbnkgYW5jZXN0b3IpIG5vZGUncyBgb3B0aW9ucy5zY2hlbWFgIChvciBgb3B0aW9ucy5zdGF0ZS5zY2hlbWFgKSBkZWZpbml0aW9uLlxuICpcbiAqIEBwcm9wZXJ0eSB7RmlsdGVyVHJlZVN0YXRlT2JqZWN0fSBbc3RhdGVdIC0gQSBkYXRhIHN0cnVjdHVyZSB0aGF0IGRlc2NyaWJlcyBhIHRyZWUsIHN1YnRyZWUsIG9yIGxlYWYgKHRlcm1pbmFsIG5vZGUpLiBJZiB1bmRlZmluZWQsIGxvYWRzIGFuIGVtcHR5IGZpbHRlciwgd2hpY2ggaXMgYSBgRmlsdGVyVHJlZWAgbm9kZSBjb25zaXN0aW5nIHRoZSBkZWZhdWx0IGBvcGVyYXRvcmAgdmFsdWUgKGAnb3AtYW5kJ2ApLlxuICpcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFtlZGl0b3I9J0RlZmF1bHQnXSAtIFRoZSBuYW1lIG9mIHRoZSBjb25kaXRpb25hbCBleHByZXNzaW9uJ3MgVUkgXCJlZGl0b3IuXCIgVGhpcyBuYW1lIG11c3QgYmUgcmVnaXN0ZXJlZCBpbiB0aGUgcGFyZW50IG5vZGUncyB7QGxpbmsgRmlsdGVyVHJlZSNlZGl0b3JzfGVkaXRvcnN9IGhhc2gsIHdoZXJlIGl0IG1hcHMgdG8gYSBsZWFmIGNvbnN0cnVjdG9yIChgRmlsdGVyTGVhZmAgb3IgYSBkZXNjZW5kYW50IHRoZXJlb2YpLiAoVXNlIHtAbGluayBGaWx0ZXJUcmVlI2FkZEVkaXRvcn0gdG8gcmVnaXN0ZXIgbmV3IGVkaXRvcnMuKVxuICpcbiAqIEBwcm9wZXJ0eSB7RmlsdGVyVHJlZX0gW3BhcmVudF0gLSBVc2VkIGludGVybmFsbHkgdG8gaW5zZXJ0IGVsZW1lbnQgd2hlbiBjcmVhdGluZyBuZXN0ZWQgc3VidHJlZXMuIFRoZSBvbmx5IHRpbWUgaXQgbWF5IGJlIChhbmQgbXVzdCBiZSkgb21pdHRlZCBpcyB3aGVuIGNyZWF0aW5nIHRoZSByb290IG5vZGUuXG4gKlxuICogQHByb3BlcnR5IHtzdHJpbmd8SFRNTEVsZW1lbnR9IFtjc3NTdHlsZXNoZWV0UmVmZXJlbmNlRWxlbWVudF0gLSBwYXNzZWQgdG8gY3NzSW5zZXJ0XG4gKi9cblxuLyoqIEB0eXBlZGVmIHtvYmplY3R8c3RyaW5nfSBGaWx0ZXJUcmVlU3RhdGVPYmplY3RcbiAqXG4gKiBAc3VtbWFyeSBTdGF0ZSB3aXRoIHdoaWNoIHRvIGNyZWF0ZSBhIG5ldyBub2RlIG9yIHJlcGxhY2UgYW4gZXhpc3Rpbmcgbm9kZS5cbiAqXG4gKiBAZGVzYyBBIHN0cmluZyBvciBwbGFpbiBvYmplY3QgdGhhdCBkZXNjcmliZXMgYSBmaWx0ZXItdHJlZSBub2RlLiBJZiBhIHN0cmluZywgaXQgaXMgcGFyc2VkIGludG8gYW4gb2JqZWN0IGJ5IHtAbGluayBGaWx0ZXJOb2RlfnBhcnNlU3RhdGVTdHJpbmd9LiAoU2VlLCBmb3IgYXZhaWxhYmxlIG92ZXJsb2Fkcy4pXG4gKlxuICogVGhlIHJlc3VsdGluZyBvYmplY3QgbWF5IGJlIGEgZmxhdCBvYmplY3QgdGhhdCBkZXNjcmliZXMgYSB0ZXJtaW5hbCBub2RlIG9yIGEgY2hpbGRsZXNzIHJvb3Qgb3IgYnJhbmNoIG5vZGU7IG9yIG1heSBiZSBhIGhpZXJhcmNoaWNhbCBvYmplY3QgdG8gZGVmaW5lIGFuIGVudGlyZSB0cmVlIG9yIHN1YnRyZWUuXG4gKlxuICogSW4gYW55IGNhc2UsIHRoZSByZXN1bHRpbmcgb2JqZWN0IG1heSBoYXZlIGFueSBvZiB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogQHByb3BlcnR5IHttZW51SXRlbVtdfSBbc2NoZW1hXSAtIFNlZSBgc2NoZW1hYCBwcm9wZXJ0eSBvZiB7QGxpbmsgRmlsdGVyVHJlZU9wdGlvbnNPYmplY3R9LlxuICpcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbZWRpdG9yPSdEZWZhdWx0J10gLSBTZWUgYGVkaXRvcmAgcHJvcGVydHkgb2Yge0BsaW5rIEZpbHRlclRyZWVPcHRpb25zT2JqZWN0fS5cbiAqXG4gKiBAcHJvcGVydHkgbWlzYyAtIE90aGVyIG1pc2NlbGxhbmVvdXMgcHJvcGVydGllcyB3aWxsIGJlIGNvcGllZCBkaXJlY3RseSB0byB0aGUgbmV3IGBGaXRsZXJOb2RlYCBvYmplY3QuIChUaGUgbmFtZSBcIm1pc2NcIiBoZXJlIGlzIGp1c3QgYSBzdGFuZC1pbjsgdGhlcmUgaXMgbm8gc3BlY2lmaWMgcHJvcGVydHkgY2FsbGVkIFwibWlzY1wiLilcbiAqXG4gKiAqIE1heSBkZXNjcmliZSBhIG5vbi10ZXJtaW5hbCBub2RlIHdpdGggcHJvcGVydGllczpcbiAqICAgKiBgc2NoZW1hYCAtIE92ZXJyaWRkZW4gb24gaW5zdGFudGlhdGlvbiBieSBgb3B0aW9ucy5zY2hlbWFgLiBJZiBib3RoIHVuc3BlY2lmaWVkLCB1c2VzIHBhcmVudCdzIGRlZmluaXRpb24uXG4gKiAgICogYG9wZXJhdG9yYCAtIE9uZSBvZiB7QGxpbmsgdHJlZU9wZXJhdG9yc30uXG4gKiAgICogYGNoaWxkcmVuYCAtICBBcnJheSBjb250YWluaW5nIGFkZGl0aW9uYWwgdGVybWluYWwgYW5kIG5vbi10ZXJtaW5hbCBub2Rlcy5cbiAqXG4gKiBUaGUgY29uc3RydWN0b3IgYXV0by1kZXRlY3RzIGBzdGF0ZWAncyB0eXBlOlxuICogICogSlNPTiBzdHJpbmcgdG8gYmUgcGFyc2VkIGJ5IGBKU09OLnBhcnNlKClgIGludG8gYSBwbGFpbiBvYmplY3RcbiAqICAqIFNRTCBXSEVSRSBjbGF1c2Ugc3RyaW5nIHRvIGJlIHBhcnNlZCBpbnRvIGEgcGxhaW4gb2JqZWN0XG4gKiAgKiBDU1Mgc2VsZWN0b3Igb2YgYW4gRWxlbWVudCB3aG9zZSBgdmFsdWVgIGNvbnRhaW5zIG9uZSBvZiB0aGUgYWJvdmVcbiAqICAqIHBsYWluIG9iamVjdFxuICovXG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKlxuICogQHN1bW1hcnkgQSBub2RlIGluIGEgZmlsdGVyIHRyZWUuXG4gKlxuICogQGRlc2NyaXB0aW9uIEEgZmlsdGVyIHRyZWUgcmVwcmVzZW50cyBhIF9jb21wbGV4IGNvbmRpdGlvbmFsIGV4cHJlc3Npb25fIGFuZCBjb25zaXN0cyBvZiBhIHNpbmdsZSBpbnN0YW5jZSBvZiBhIHtAbGluayBGaWx0ZXJUcmVlfSBvYmplY3QgYXMgdGhlIF9yb290XyBvZiBhbiBfbl8tYXJ5IHRyZWUuXG4gKlxuICogRmlsdGVyIHRyZWVzIGFyZSBjb21wcmlzZWQgb2YgaW5zdGFuY2VzIG9mIGBGaWx0ZXJOb2RlYCBvYmplY3RzLiBIb3dldmVyLCB0aGUgYEZpbHRlck5vZGVgIGNvbnN0cnVjdG9yIGlzIGFuIFwiYWJzdHJhY3QgY2xhc3NcIjsgZmlsdGVyIG5vZGUgb2JqZWN0cyBhcmUgbmV2ZXIgaW5zdGFudGlhdGVkIGRpcmVjdGx5IGZyb20gdGhpcyBjb25zdHJ1Y3Rvci4gQSBmaWx0ZXIgdHJlZSBpcyBhY3R1YWxseSBjb21wcmlzZWQgb2YgaW5zdGFuY2VzIG9mIHR3byBcInN1YmNsYXNzZXNcIiBvZiBgRmlsdGVyTm9kZWAgb2JqZWN0czpcbiAqICoge0BsaW5rIEZpbHRlclRyZWV9IChvciBzdWJjbGFzcyB0aGVyZW9mKSBvYmplY3RzLCBpbnN0YW5jZXMgb2Ygd2hpY2ggcmVwcmVzZW50IHRoZSByb290IG5vZGUgYW5kIGFsbCB0aGUgYnJhbmNoIG5vZGVzOlxuICogICAqIFRoZXJlIGlzIGFsd2F5cyBleGFjdGx5IG9uZSByb290IG5vZGUsIGNvbnRhaW5pbmcgdGhlIHdob2xlIGZpbHRlciB0cmVlLCB3aGljaCByZXByZXNlbnRzIHRoZSBmaWx0ZXIgZXhwcmVzc2lvbiBpbiBpdHMgZW50aXJldHkuIFRoZSByb290IG5vZGUgaXMgZGlzdGluZ3Vpc2hlZCBieSBoYXZpbmcgbm8gcGFyZW50IG5vZGUuXG4gKiAgICogVGhlcmUgYXJlIHplcm8gb3IgbW9yZSBicmFuY2ggbm9kZXMsIG9yIHN1YnRyZWVzLCB3aGljaCBhcmUgY2hpbGQgbm9kZXMgb2YgdGhlIHJvb3Qgb3Igb3RoZXIgYnJhbmNoZXMgaGlnaGVyIHVwIGluIHRoZSB0cmVlLCByZXByZXNlbnRpbmcgc3ViZXhwcmVzc2lvbnMgd2l0aGluIHRoZSBsYXJnZXIgZmlsdGVyIGV4cHJlc3Npb24uIEVhY2ggYnJhbmNoIG5vZGUgaGFzIGV4YWN0bHkgb25lIHBhcmVudCBub2RlLlxuICogICAqIFRoZXNlIG5vZGVzIHBvaW50IHRvIHplcm8gb3IgbW9yZSBjaGlsZCBub2RlcyB3aGljaCBhcmUgZWl0aGVyIG5lc3RlZCBzdWJ0cmVlcywgb3I6XG4gKiAqIHtAbGluayBGaWx0ZXJMZWFmfSAob3Igc3ViY2xhc3MgdGhlcmVvZikgb2JqZWN0cywgZWFjaCBpbnN0YW5jZSBvZiB3aGljaCByZXByZXNlbnRzIGEgc2luZ2xlIHNpbXBsZSBjb25kaXRpb25hbCBleHByZXNzaW9uLiBUaGVzZSBhcmUgdGVybWluYWwgbm9kZXMsIGhhdmluZyBleGFjdGx5IG9uZSBwYXJlbnQgbm9kZSwgYW5kIG5vIGNoaWxkIG5vZGVzLlxuICpcbiAqIFRoZSBwcm9ncmFtbWVyIG1heSBleHRlbmQgdGhlIHNlbWFudGljcyBvZiBmaWx0ZXIgdHJlZXMgYnkgZXh0ZW5kaW5nIHRoZSBhYm92ZSBvYmplY3RzLlxuICpcbiAqIEBwcm9wZXJ0eSB7RmlsdGVyTm9kZX0gW3BhcmVudF0gLSBVbmRlZmluZWQgbWVhbnMgdGhpcyBpcyB0aGUgcm9vdCBub2RlLlxuICpcbiAqIEBwcm9wZXJ0eSB7RmlsdGVyTm9kZX0gcm9vdCAtIENvbnZlbmllbmNlIHJlZmVyZW5jZSB0byB0aGUgcm9vdCBub2RlLlxuICpcbiAqIEBwcm9wZXJ0eSB7bWVudUl0ZW1bXX0gc2NoZW1hIC0gQ29sdW1uIHNjaGVtYSB1c2VkIGJ5IGRlc2NlbmRhbnQgbGVhZiBub2RlcyAoaW5jbHVkaW5nIHRoaXMgbm9kZSBpZiBpdCBpcyBhIGxlYWYgbm9kZSkgdG8gcmVuZGVyIGEgY29sdW1uIGNob2ljZSBkcm9wLWRvd24uXG4gKlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtlZGl0b3JdIC0gTmFtZSBvZiBmaWx0ZXIgZWRpdG9yIHVzZWQgYnkgZGVzY2VuZGFudCBsZWFmIG5vZGVzIChpbmNsdWRpbmcgdGhpcyBub2RlIGlmIGl0IGlzIGEgbGVhZiBub2RlKS5cbiAqXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbZXZlbnRIYW5kbGVyXSAtIEV2ZW50IGhhbmRsZXIgZm9yIFVJIGV2ZW50cy4gU2VlICpFdmVudHMqIGluIHRoZSB7QGxpbmsgaHR0cDovL2pvbmVpdC5naXRodWIuaW8vZmlsdGVyLXRyZWUvaW5kZXguaHRtbHxyZWFkbWV9IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICpcbiAqIEBwcm9wZXJ0eSB7bWVudUl0ZW1bXX0gW3RyZWVPcE1lbnU9Q29uZGl0aW9uYWxzLmRlZmF1bHRPcE1lbnVdIC0gRGVmYXVsdCBvcGVyYXRvciBtZW51IGZvciBhbGwgZGVzY2VuZGFudCBsZWFmIG5vZGVzLiBPbmx5IHVzZWQgaWYgdGhlIGxlYWYgbm9kZSBoYXMgbm8gZGVmaW5lZCBgb3BNZW51YCBwcm9wZXJ0eSBfYW5kXyB0aGVyZSBpcyBubyBtZW51IGRlZmluZWQgaW4gYHR5cGVPcE1lbnVzYCBrZXllZCB0byB0aGUgY29sdW1uJ3MgYHR5cGVgLlxuICpcbiAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBbdHlwZU9wTWFwXSAtIEEgaGFzaCBvZiB0eXBlIG5hbWVzLiBFYWNoIG1lbWJlciB0aHVzIGRlZmluZWQgY29udGFpbnMgYSBzcGVjaWZpYyBvcGVyYXRvciBtZW51IGZvciBhbGwgZGVzY2VuZGFudCBsZWFmIG5vZGVzIHRoYXQ6XG4gKiAxLiBkbyBub3QgaGF2ZSB0aGVpciBvd24gb3BlcmF0b3IgbWVudSAoYG9wTWVudWAgcHJvcGVydHkpIG9mIHRoZWlyIG93bjsgYW5kXG4gKiAyLiB3aG9zZSBjb2x1bW5zIHJlc29sdmUgdG8gdGhhdCB0eXBlLlxuICpcbiAqIFRoZSB0eXBlIGlzIGRldGVybWluZWQgYnkgKGluIHByaW9yaXR5IG9yZGVyKTpcbiAqIDEuIHRoZSBgdHlwZWAgcHJvcGVydHkgb2YgdGhlIHtAbGluayBGaWx0ZXJMZWFmfTsgb3JcbiAqIDIuIHRoZSBgdHlwZWAgcHJvcGVydHkgb2YgdGhlIGVsZW1lbnQgaW4gdGhlIG5lYXJlc3Qgbm9kZSAoaW5jbHVkaW5nIHRoZSBsZWFmIG5vZGUgaXRzZWxmKSB0aGF0IGhhcyBhIGRlZmluZWQgYG93blNjaGVtYWAgb3IgYHNjaGVtYWAgYXJyYXkgcHJvcGVydHkgd2l0aCBhbiBlbGVtZW50IGhhdmluZyBhIG1hdGNoaW5nIGNvbHVtbiBuYW1lLlxuICpcbiAqIEBwcm9wZXJ0eSB7c3FsSWRRdHNPYmplY3R9IFtzcWxJZFF0cz17YmVnOidcIicsZW5kOidcIid9XSAtIFF1b3RlIGNoYXJhY3RlcnMgZm9yIFNRTCBpZGVudGlmaWVycy4gVXNlZCBmb3IgYm90aCBwYXJzaW5nIGFuZCBnZW5lcmF0aW5nIFNRTC4gU2hvdWxkIGJlIHBsYWNlZCBvbiB0aGUgcm9vdCBub2RlLlxuICpcbiAqIEBwcm9wZXJ0eSB7SFRNTEVsZW1lbnR9IGVsIC0gVGhlIERPTSBlbGVtZW50IGNyZWF0ZWQgYnkgdGhlIGByZW5kZXJgIG1ldGhvZCB0byByZXByZXNlbnQgdGhpcyBub2RlLiBDb250YWlucyB0aGUgYGVsYHMgZm9yIGFsbCBjaGlsZCBub2RlcyAod2hpY2ggYXJlIHRoZW1zZWx2ZXMgcG9pbnRlZCB0byBieSB0aG9zZSBub2RlcykuIFRoaXMgaXMgYWx3YXlzIGdlbmVyYXRlZCBidXQgaXMgb25seSBpbiB0aGUgcGFnZSBET00gaWYgeW91IHB1dCBpdCB0aGVyZS5cbiAqL1xuXG52YXIgRmlsdGVyTm9kZSA9IEJhc2UuZXh0ZW5kKCdGaWx0ZXJOb2RlJywge1xuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgQ3JlYXRlIGEgbmV3IG5vZGUgb3Igc3VidHJlZS5cbiAgICAgKiBAZGVzYyBUeXBpY2FsbHkgdXNlZCBieSB0aGUgYXBwbGljYXRpb24gbGF5ZXIgdG8gY3JlYXRlIHRoZSBlbnRpcmUgZmlsdGVyIHRyZWU7IGFuZCBpbnRlcm5hbGx5LCByZWN1cnNpdmVseSwgdG8gY3JlYXRlIGVhY2ggbm9kZSBpbmNsdWRpbmcgYm90aCBzdWJ0cmVlcyBhbmQgbGVhdmVzLlxuICAgICAqXG4gICAgICogKipOb2RlIHByb3BlcnRpZXMgYW5kIG9wdGlvbnM6KiogTm9kZXMgYXJlIGluc3RhbnRpYXRlZCB3aXRoOlxuICAgICAqIDEuIENlcnRhaW4gKipyZXF1aXJlZCBwcm9wZXJ0aWVzKiogd2hpY2ggZGlmZmVyIGZvciBzdWJ0cmVlcyBhbmQgbGVhdmVzLlxuICAgICAqIDIuIEFyYml0cmFyeSAqKm5vbi1zdGFuZGFyZCBvcHRpb24gcHJvcGVydGllcyoqIGFyZSBkZWZpbmVkIG9uIHRoZSBgb3B0aW9uc2Agb2JqZWN0IChzbyBsb25nIGFzIHRoZWlyIG5hbWVzIGRvIG5vdCBjb25mbGljdCB3aXRoIGFueSBzdGFuZGFyZCBvcHRpb25zKSBhbmQgbmV2ZXIgcGVyc2lzdC5cbiAgICAgKiAzLiBDZXJ0YWluICoqc3RhbmRhcmQgb3B0aW9ucyBwcm9wZXJ0aWVzKiogYXMgZGVmaW5lZCBpbiB0aGUge0BsaW5rIEZpbHRlck5vZGV+b3B0aW9uc1NjaGVtYXxvcHRpb25zU2NoZW1hfSBoYXNoLCBjb21lIGZyb20gdmFyaW91cyBzb3VyY2VzLCBhcyBwcmlvcml0aXplZCBhcyBmb2xsb3dzOlxuICAgICAqICAgIDEuIGBvcHRpb25zYCBvYmplY3Q7IGRvZXMgbm90IHBlcnNpc3RcbiAgICAgKiAgICAyLiBgc3RhdGVgOyBvYmplY3Q7IHBlcnNpc3RzXG4gICAgICogICAgMy4gYHBhcmVudGAgb2JqZWN0OyBwZXJzaXN0c1xuICAgICAqICAgIDQuIGBkZWZhdWx0YCBvYmplY3Q7IGRvZXMgbm90IHBlcnNpc3RcbiAgICAgKlxuICAgICAqIE5vdGVzOlxuICAgICAqIDEuIFwiUGVyc2lzdHNcIiBtZWFucyBvdXRwdXQgYnkge0BsaW5rIEZpbHRlclRyZWUjZ2V0U3RhdGV8Z2V0U3RhdGUoKX0uXG4gICAgICogMi4gVGhlIGBwYXJlbnRgIG9iamVjdCBpcyBnZW5lcmF0ZWQgaW50ZXJuYWxseSBmb3Igc3VidHJlZXMuIEl0IGFsbG93cyBzdGFuZGFyZCBvcHRpb25zIHRvIGluaGVyaXQgZnJvbSB0aGUgcGFyZW50IG5vZGUuXG4gICAgICogMy4gVGhlIGBkZWZhdWx0YCBvYmplY3QgY29tZXMgZnJvbSB0aGUgYGRlZmF1bHRgIHByb3BlcnR5LCBpZiBhbnksIG9mIHRoZSB7QGxpbmsgRmlsdGVyTm9kZX5vcHRpb25zU2NoZW1hfHNjaGVtYSBvYmplY3R9IGZvciB0aGUgc3RhbmRhcmQgb3B0aW9uIGluIHF1ZXN0aW9uLiBOb3RlIHRoYXQgb25jZSBkZWZpbmVkLCBzdWJ0cmVlcyB3aWxsIHRoZW4gaW5oZXJpdCB0aGlzIHZhbHVlLlxuICAgICAqIDQuIElmIG5vdCBkZWZpbmVkIGJ5IGFueSBvZiB0aGUgYWJvdmUsIHRoZSBzdGFuZGFyZCBvcHRpb24gcmVtYWlucyB1bmRlZmluZWQgb24gdGhlIG5vZGUuXG4gICAgICpcbiAgICAgKiAqKlF1ZXJ5IEJ1aWxkZXIgVUkgc3VwcG9ydDoqKiBJZiB5b3VyIGFwcCB3YW50cyB0byBtYWtlIHVzZSBvZiB0aGUgZ2VuZXJhdGVkIFVJLCB5b3UgYXJlIHJlc3BvbnNpYmxlIGZvciBpbnNlcnRpbmcgdGhlIHRvcC1sZXZlbCBgLmVsYCBpbnRvIHRoZSBET00uIChPdGhlcndpc2UganVzdCBpZ25vcmUgaXQuKVxuICAgICAqXG4gICAgICogQHBhcmFtIHtGaWx0ZXJUcmVlT3B0aW9uc09iamVjdH0gW29wdGlvbnNdIC0gVGhlIG5vZGUgc3RhdGU7IG9yIGFuIG9wdGlvbnMgb2JqZWN0IHBvc3NpYmx5IGNvbnRhaW5pbmcgYHN0YXRlYCBhbW9uZyBvdGhlciBvcHRpb25zLiBBbHRob3VnaCB5b3UgY2FuIGluc3RhbnRpYXRlIGEgZmlsdGVyIHdpdGhvdXQgYW55IG9wdGlvbnMsIHRoaXMgaXMgZ2VuZXJhbGx5IG5vdCB1c2VmdWwuIFNlZSAqSW5zdGFudGlhdGluZyBhIGZpbHRlciogaW4gdGhlIHtAbGluayBodHRwOi8vam9uZWl0LmdpdGh1Yi5pby9maWx0ZXItdHJlZS9pbmRleC5odG1sfHJlYWRtZX0gZm9yIGEgcHJhY3RpY2FsIGRpc2N1c3Npb24gb2YgbWluaW11bSBvcHRpb25zLlxuICAgICAqXG4gICAgICogKiBAbWVtYmVyT2YgRmlsdGVyTm9kZS5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudCA9IHRoaXMucGFyZW50IHx8IG9wdGlvbnMucGFyZW50LFxuICAgICAgICAgICAgcm9vdCA9IHBhcmVudCAmJiBwYXJlbnQucm9vdDtcblxuICAgICAgICBpZiAoIXJvb3QpIHtcbiAgICAgICAgICAgIHJvb3QgPSB0aGlzO1xuXG4gICAgICAgICAgICB0aGlzLnN0eWxlc2hlZXQgPSB0aGlzLnN0eWxlc2hlZXQgfHxcbiAgICAgICAgICAgICAgICBjc3NJbmplY3RvcihvcHRpb25zLmNzc1N0eWxlc2hlZXRSZWZlcmVuY2VFbGVtZW50KTtcblxuICAgICAgICAgICAgdGhpcy5jb25kaXRpb25hbHMgPSBuZXcgQ29uZGl0aW9uYWxzKG9wdGlvbnMpOyAvLyAuc3FsSWRRdHNcblxuICAgICAgICAgICAgdGhpcy5QYXJzZXJTUUwgPSBuZXcgUGFyc2VyU1FMKG9wdGlvbnMpOyAvLyAuc2NoZW1hLCAuY2FzZVNlbnNpdGl2ZUNvbHVtbk5hbWVzLCAucmVzb2x2ZUFsaWFzZXNcblxuICAgICAgICAgICAgdmFyIGtleXMgPSBbJ25hbWUnXTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnJlc29sdmVBbGlhc2VzKSB7XG4gICAgICAgICAgICAgICAga2V5cy5wdXNoKCdhbGlhcycpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmZpbmRPcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIGNhc2VTZW5zaXRpdmU6IG9wdGlvbnMuY2FzZVNlbnNpdGl2ZUNvbHVtbk5hbWVzLFxuICAgICAgICAgICAgICAgIGtleXM6IGtleXNcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJvb3QgPSByb290O1xuXG4gICAgICAgIHRoaXMuZG9udFBlcnNpc3QgPSB7fTsgLy8gaGFzaCBvZiB0cnV0aHkgdmFsdWVzXG5cbiAgICAgICAgdGhpcy5zZXRTdGF0ZShvcHRpb25zLnN0YXRlLCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLyoqIEluc2VydCBlYWNoIHN1YnRyZWUgaW50byBpdHMgcGFyZW50IG5vZGUgYWxvbmcgd2l0aCBhIFwiZGVsZXRlXCIgYnV0dG9uLlxuICAgICAqID4gVGhlIHJvb3QgdHJlZSAod2hpY2ggaGFzIG5vIHBhcmVudCkgaXMgaW5zZXJ0ZWQgaW50byB0aGUgRE9NIGJ5IHRoZSBpbnN0YW50aWF0aW5nIGNvZGUgKHdpdGhvdXQgYSBkZWxldGUgYnV0dG9uKS5cbiAgICAgKiBAbWVtYmVyT2YgRmlsdGVyTm9kZS5wcm90b3R5cGVcbiAgICAgKi9cbiAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgIHZhciBuZXdMaXN0SXRlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoQ0hJTERfVEFHKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMubm90ZXNFbCkge1xuICAgICAgICAgICAgICAgIG5ld0xpc3RJdGVtLmFwcGVuZENoaWxkKHRoaXMubm90ZXNFbCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5rZWVwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsID0gdGhpcy50ZW1wbGF0ZXMuZ2V0KCdyZW1vdmVCdXR0b24nKTtcbiAgICAgICAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMucmVtb3ZlLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgICAgIG5ld0xpc3RJdGVtLmFwcGVuZENoaWxkKGVsKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbmV3TGlzdEl0ZW0uYXBwZW5kQ2hpbGQodGhpcy5lbCk7XG5cbiAgICAgICAgICAgIHRoaXMucGFyZW50LmVsLnF1ZXJ5U2VsZWN0b3IoQ0hJTERSRU5fVEFHKS5hcHBlbmRDaGlsZChuZXdMaXN0SXRlbSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0ZpbHRlclRyZWVTdGF0ZU9iamVjdH0gc3RhdGVcbiAgICAgKiBAcGFyYW0ge0ZpbHRlclRyZWVTZXRTdGF0ZU9wdGlvbnNPYmplY3R9IFtvcHRpb25zXVxuICAgICAqIEBtZW1iZXJPZiBGaWx0ZXJOb2RlLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHNldFN0YXRlOiBmdW5jdGlvbihzdGF0ZSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgb2xkRWwgPSB0aGlzLmVsO1xuXG4gICAgICAgIHN0YXRlID0gdGhpcy5wYXJzZVN0YXRlU3RyaW5nKHN0YXRlLCBvcHRpb25zKTtcblxuICAgICAgICB0aGlzLm1peEluU3RhbmRhcmRPcHRpb25zKHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5taXhJbk5vbnN0YW5kYXJkT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgdGhpcy5jcmVhdGVWaWV3KHN0YXRlKTtcbiAgICAgICAgdGhpcy5sb2FkU3RhdGUoc3RhdGUpO1xuICAgICAgICB0aGlzLnJlbmRlcigpO1xuXG4gICAgICAgIGlmIChvbGRFbCkge1xuICAgICAgICAgICAgdmFyIG5ld0VsID0gdGhpcy5lbDtcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudCAmJiBvbGRFbC5wYXJlbnRFbGVtZW50LnRhZ05hbWUgPT09ICdMSScpIHtcbiAgICAgICAgICAgICAgICBvbGRFbCA9IG9sZEVsLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgbmV3RWwgPSBuZXdFbC5wYXJlbnROb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2xkRWwucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQobmV3RWwsIG9sZEVsKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBDb252ZXJ0IGEgc3RyaW5nIHRvIGEgc3RhdGUgb2JqZWN0LlxuICAgICAqXG4gICAgICogQGRlc2MgVGhleSBzdHJpbmcncyBzeW50YXggaXMgaW5mZXJyZWQgYXMgZm9sbG93czpcbiAgICAgKiAxLiBJZiBzdGF0ZSBpcyB1bmRlZmluZWQgb3IgYWxyZWFkeSBhbiBvYmplY3QsIHJldHVybiBhcyBpcy5cbiAgICAgKiAyLiBJZiBgb3B0aW9ucy5jb250ZXh0YCBpcyBkZWZpbmVkLCBgc3RhdGVgIGlzIGFzc3VtZWQgdG8gYmUgYSBDU1Mgc2VsZWN0b3Igc3RyaW5nIChhdXRvLWRldGVjdGVkKSBwb2ludGluZyB0byBhbiBIVE1MIGZvcm0gY29udHJvbCB3aXRoIGEgYHZhbHVlYCBwcm9wZXJ0eSwgc3VjaCBhcyBhIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSFRNTElucHV0RWxlbWVudCBIVE1MSW5wdXRFbGVtZW50fSBvciBhIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSFRNTFRleHRBcmVhRWxlbWVudCBIVE1MVGV4dEFyZWFFbGVtZW50fS4gVGhlIGVsZW1lbnQgaXMgc2VsZWN0ZWQgYW5kIGlmIGZvdW5kLCBpdHMgdmFsdWUgaXMgZmV0Y2hlZCBmcm9tIHRoZSBET00gYW5kIGFzc2lnbmVkIHRvIGBzdGF0ZWAuXG4gICAgICogMy4gSWYgYG9wdGlvbnMuc3ludGF4YCBpcyBgJ2F1dG8nYCwgSlNPTiBzeW50YXggaXMgZGV0ZWN0ZWQgaWYgYHN0YXRlYCBiZWdpbnMgX2FuZF8gZW5kcyB3aXRoIGVpdGhlciBgW2AgYW5kIGBdYCBfb3JfIGB7YCBhbmQgYH1gIChpZ25vcmluZyBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZSBzcGFjZSkuXG4gICAgICogNC4gSWYgSlNPTiBzeW50YXgsIHBhcnNlIHRoZSBzdHJpbmcgaW50byBhbiBhY3R1YWwgYEZpbHRlclRyZWVTdGF0ZU9iamVjdGAgdXNpbmcge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0pTT04vcGFyc2V8SlNPTi5wYXJzZX0gYW5kIHRocm93IGFuIGVycm9yIGlmIHVucGFyc2FibGUuXG4gICAgICogNS4gSWYgbm90IEpTT04sIHBhcnNlIHRoZSBzdHJpbmcgYXMgU1FMIGludG8gYW4gYWN0dWFsIGBGaWx0ZXJUcmVlU3RhdGVPYmplY3RgIHVzaW5nIHBhcnNlci1TUUwncyB7QGxpbmsgUGFyc2VyU1FMI3BhcnNlcnxwYXJzZXJ9IGFuZCB0aHJvdyBhbiBlcnJvciBpZiB1bnBhcnNhYmxlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtGaWx0ZXJUcmVlU3RhdGVPYmplY3R9IFtzdGF0ZV1cbiAgICAgKiBAcGFyYW0ge0ZpbHRlclRyZWVTZXRTdGF0ZU9wdGlvbnNPYmplY3R9IFtvcHRpb25zXVxuICAgICAqXG4gICAgICogQHJldHVybnMge0ZpbHRlclRyZWVTdGF0ZU9iamVjdH0gVGhlIHVubW9sZXN0ZWQgYHN0YXRlYCBwYXJhbWV0ZXIuIFRocm93cyBhbiBlcnJvciBpZiBgc3RhdGVgIGlzIHVua25vd24gb3IgaW52YWxpZCBzeW50YXguXG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgRmlsdGVyTm9kZVxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIHBhcnNlU3RhdGVTdHJpbmc6IGZ1bmN0aW9uKHN0YXRlLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29udGV4dCA9IG9wdGlvbnMgJiYgb3B0aW9ucy5jb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICBzeW50YXggPSBvcHRpb25zICYmIG9wdGlvbnMuc3ludGF4IHx8ICdhdXRvJzsgLy8gZGVmYXVsdCBpcyAnYXV0bydcblxuICAgICAgICAgICAgICAgIGlmIChjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlID0gY29udGV4dC5xdWVyeVNlbGVjdG9yKHN0YXRlKS52YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoc3ludGF4ID09PSAnYXV0bycpIHtcbiAgICAgICAgICAgICAgICAgICAgc3ludGF4ID0gcmVKU09OLnRlc3Qoc3RhdGUpID8gJ0pTT04nIDogJ1NRTCc7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc3dpdGNoIChzeW50YXgpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnSlNPTic6XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gSlNPTi5wYXJzZShzdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGaWx0ZXJUcmVlRXJyb3IoJ0pTT04gcGFyc2VyOiAnICsgZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1NRTCc6XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gdGhpcy5yb290LlBhcnNlclNRTC5wYXJzZShzdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGaWx0ZXJUcmVlRXJyb3IoJ1NRTCBXSEVSRSBjbGF1c2UgcGFyc2VyOiAnICsgZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHN0YXRlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGaWx0ZXJUcmVlRXJyb3IoJ1VuZXhwZWN0ZWQgaW5wdXQgc3RhdGUuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBlYWNoIHN0YW5kYXJkIG9wdGlvbiBmcm9tIHdoZW4gZm91bmQgb24gdGhlIGBvcHRpb25zYCBvciBgc3RhdGVgIG9iamVjdHMsIHJlc3BlY3RpdmVseTsgb3IgaWYgbm90IGFuIFwib3duXCIgb3B0aW9uLCBvbiB0aGUgYHBhcmVudGAgb2JqZWN0IG9yIGZyb20gdGhlIG9wdGlvbnMgc2NoZW1hIGRlZmF1bHQgKGlmIGFueSlcbiAgICAgKiBAcGFyYW0gc3RhdGVcbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqL1xuICAgIG1peEluU3RhbmRhcmRPcHRpb25zOiBmdW5jdGlvbihzdGF0ZSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXM7XG5cbiAgICAgICAgXyhGaWx0ZXJOb2RlLm9wdGlvbnNTY2hlbWEpLmVhY2goZnVuY3Rpb24ob3B0aW9uU2NoZW1hLCBrZXkpIHtcbiAgICAgICAgICAgIGlmICghb3B0aW9uU2NoZW1hLmlnbm9yZSAmJiAodGhpcyAhPT0gdGhpcy5yb290IHx8IG9wdGlvblNjaGVtYS5yb290Qm91bmQpKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9wdGlvbjtcblxuICAgICAgICAgICAgICAgIG5vZGUuZG9udFBlcnNpc3Rba2V5XSA9IC8vIHRydXRoeSBpZiBmcm9tIGBvcHRpb25zYCBvciBgZGVmYXVsdGBcbiAgICAgICAgICAgICAgICAgICAgKG9wdGlvbiA9IG9wdGlvbnMgJiYgb3B0aW9uc1trZXldKSAhPT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgICAgICAgIChvcHRpb24gPSBzdGF0ZSAmJiBzdGF0ZVtrZXldKSA9PT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgICAgICEob3B0aW9uU2NoZW1hLm93biB8fCBub2RlLmhhc093blByb3BlcnR5KGtleSkgJiYgb3B0aW9uICE9PSBudWxsKSAmJlxuICAgICAgICAgICAgICAgICAgICAhKG9wdGlvbiA9IG5vZGUucGFyZW50ICYmIG5vZGUucGFyZW50W2tleV0pICYmXG4gICAgICAgICAgICAgICAgICAgIChvcHRpb24gPSBvcHRpb25TY2hlbWEuZGVmYXVsdCk7XG5cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9uID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBub2RlW2tleV07XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuZG9udFBlcnNpc3Rba2V5XSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAob3B0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkgPT09ICdzY2hlbWEnICYmICFvcHRpb24ud2Fsaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXR0YWNoIHRoZSBgd2Fsa2AgYW5kIGBmaW5kYCBjb252ZW5pZW5jZSBtZXRob2RzIHRvIHRoZSBgc2NoZW1hYCBhcnJheVxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uLndhbGsgPSBwb3BNZW51LndhbGsuYmluZChvcHRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uLmxvb2t1cCA9IHBvcE1lbnUubG9va3VwLmJpbmQob3B0aW9uLCBub2RlLnJvb3QuZmluZE9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG5vZGVba2V5XSA9IG9wdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqL1xuICAgIG1peEluTm9uc3RhbmRhcmRPcHRpb25zOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHZhciBub2RlID0gdGhpcztcblxuICAgICAgICAvLyBjb3B5IGFsbCByZW1haW5pbmcgb3B0aW9ucyBkaXJlY3RseSB0byB0aGUgbmV3IGluc3RhbmNlLCBvdmVycmlkaW5nIHByb3RvdHlwZSBtZW1iZXJzIG9mIHRoZSBzYW1lIG5hbWVcbiAgICAgICAgXyhvcHRpb25zKS5lYWNoKGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICAgIGlmICghRmlsdGVyTm9kZS5vcHRpb25zU2NoZW1hW2tleV0pIHtcbiAgICAgICAgICAgICAgICBub2RlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKiBSZW1vdmUgYm90aDpcbiAgICAgKiAqIGB0aGlzYCBmaWx0ZXIgbm9kZSBmcm9tIGl0J3MgYHBhcmVudGAncyBgY2hpbGRyZW5gIGNvbGxlY3Rpb247IGFuZFxuICAgICAqICogYHRoaXNgIGZpbHRlciBub2RlJ3MgYGVsYCdzIGNvbnRhaW5lciAoYWx3YXlzIGEgYDxsaT5gIGVsZW1lbnQpIGZyb20gaXRzIHBhcmVudCBlbGVtZW50LlxuICAgICAqIEBtZW1iZXJPZiBGaWx0ZXJOb2RlLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHJlbW92ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhdmVydCxcbiAgICAgICAgICAgIHBhcmVudCA9IHRoaXMucGFyZW50O1xuXG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmV2ZW50SGFuZGxlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRIYW5kbGVyLmNhbGwocGFyZW50LCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdkZWxldGUnLFxuICAgICAgICAgICAgICAgICAgICBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24oKSB7IGF2ZXJ0ID0gdHJ1ZTsgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFhdmVydCkge1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50LmtlZXAgfHwgLy8gbmV2ZXIgXCJwcnVuZVwiIChyZW1vdmUgaWYgZW1wdHkpIHRoaXMgcGFydGljdWxhciBzdWJleHByZXNzaW9uXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudC5jaGlsZHJlbi5sZW5ndGggPiAxIC8vIHRoaXMgbm9kZSBoYXMgc2libGluZ3Mgc28gd2lsbCBub3QgYmUgZW1wdHkgYWZ0ZXIgdGhpcyByZW1vdmVcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcHJvY2VlZCB3aXRoIHJlbW92ZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVsLnBhcmVudE5vZGUucmVtb3ZlKCk7IC8vIHRoZSBwYXJlbnQgaXMgYWx3YXlzIHRoZSBjb250YWluaW5nIDxsaT4gdGFnXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudC5jaGlsZHJlbi5zcGxpY2UocGFyZW50LmNoaWxkcmVuLmluZGV4T2YodGhpcyksIDEpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlY3Vyc2UgdG8gcHJ1bmUgZW50aXJlIHN1YmV4cHJlc3Npb24gYmVjYXVzZSBpdCdzIHBydW5lLWFibGUgYW5kIHdvdWxkIGVuZCB1cCBlbXB0eSAoY2hpbGRsZXNzKVxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIEVycm9yOiBGaWx0ZXJUcmVlRXJyb3IsXG5cbiAgICB0ZW1wbGF0ZXM6IG5ldyBUZW1wbGF0ZXMoKVxufSk7XG5cbi8qKiBAdHlwZWRlZiBvcHRpb25zU2NoZW1hT2JqZWN0XG4gKiBAc3VtbWFyeSBTdGFuZGFyZCBvcHRpb24gc2NoZW1hXG4gKiBAZGVzYyBTdGFuZGFyZCBvcHRpb25zIGFyZSBhdXRvbWF0aWNhbGx5IGFkZGVkIHRvIG5vZGVzLiBEYXRhIHNvdXJjZXMgZm9yIHN0YW5kYXJkIG9wdGlvbnMgaW5jbHVkZSBgb3B0aW9uc2AsIGBzdGF0ZWAsIGBwYXJlbnRgIGFuZCBgZGVmYXVsdGAgKGluIHRoYXQgb3JkZXIpLiBEZXNjcmliZXMgc3RhbmRhcmQgb3B0aW9ucyB0aHJvdWdoIHZhcmlvdXMgcHJvcGVydGllczpcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2lnbm9yZV0gLSBEbyBub3QgYXV0b21hdGljYWxseSBhZGQgdG8gbm9kZXMgKHByb2Nlc3NlZCBlbHNld2hlcmUpLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbb3duXSAtIERvIG5vdCBhdXRvbWF0aWNhbGx5IGFkZCBmcm9tIGBwYXJlbnRgIG9yIGBkZWZhdWx0YC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3Jvb3RCb3VuZF0gLSBBdXRvbWF0aWNhbGx5IGFkZCB0byByb290IG5vZGUgb25seS5cbiAqIEBwcm9wZXJ0eSB7Kn0gW2RlZmF1bHRdIC0gVGhpcyBpcyB0aGUgZGVmYXVsdCBkYXRhIHNvdXJjZSB3aGVuIGFsbCBvdGhlciBzdHJhdGVnaWVzIGZhaWwuXG4gKi9cblxuLyoqXG4gKiBAc3VtbWFyeSBEZWZpbmVzIHRoZSBzdGFuZGFyZCBvcHRpb25zIGF2YWlsYWJsZSB0byBhIG5vZGUuXG4gKiBAZGVzYyBUaGUgZm9sbG93aW5nIHByb3BlcnRpZXMgYmVhciB0aGUgc2FtZSBuYW1lcyBhcyB0aGUgbm9kZSBvcHRpb25zIHRoZXkgZGVmaW5lLlxuICogQHR5cGUge3BiamVjdH1cbiAqIEBtZW1iZXJPZiBGaWx0ZXJOb2RlXG4gKi9cbkZpbHRlck5vZGUub3B0aW9uc1NjaGVtYSA9IHtcblxuICAgIHN0YXRlOiB7IGlnbm9yZTogdHJ1ZSB9LFxuXG4gICAgY3NzU3R5bGVzaGVldFJlZmVyZW5jZUVsZW1lbnQ6IHsgaWdub3JlOiB0cnVlIH0sXG5cbiAgICAvKiogQHN1bW1hcnkgRGVmYXVsdCBjb2x1bW4gc2NoZW1hIGZvciBjb2x1bW4gZHJvcC1kb3ducyBvZiBkaXJlY3QgZGVzY2VuZGFudCBsZWFmIG5vZGVzIG9ubHkuXG4gICAgICogQGRlc2MgPiBUaGlzIGRvY3MgZW50cnkgZGVzY3JpYmVzIGEgcHJvcGVydHkgaW4gdGhlIEZpbHRlck5vZGUgcHJvdG90eXBlLiBJdCBkb2VzIG5vdCBkZXNjcmliZSB0aGUgb3B0aW9uc1NjaGVtYSBwcm9wZXJ0eSAoZGVzcGl0ZSBpdCdzIHBvc2l0aW9uIGluIHRoZSBzb3VyY2UgY29kZSkuXG4gICAgICogQHR5cGUge3N0cmluZ1tdfVxuICAgICAqIEBtZW1iZXJPZiBGaWx0ZXJOb2RlLm9wdGlvbnNTY2hlbWFcbiAgICAgKi9cbiAgICBvd25TY2hlbWE6IHsgb3duOiB0cnVlIH0sXG5cbiAgICAvKiogQHN1bW1hcnkgRGVmYXVsdCBjb2x1bW4gc2NoZW1hIGZvciBjb2x1bW4gZHJvcC1kb3ducyBvZiBhbGwgZGVzY2VuZGFudCBsZWFmIG5vZGVzLlxuICAgICAqIEBkZXNjID4gVGhpcyBkb2NzIGVudHJ5IGRlc2NyaWJlcyBhIHByb3BlcnR5IGluIHRoZSBGaWx0ZXJOb2RlIHByb3RvdHlwZS4gSXQgZG9lcyBub3QgZGVzY3JpYmUgdGhlIG9wdGlvbnNTY2hlbWEgcHJvcGVydHkgKGRlc3BpdGUgaXQncyBwb3NpdGlvbiBpbiB0aGUgc291cmNlIGNvZGUpLlxuICAgICAqIEB0eXBlIHttZW51SXRlbVtdfVxuICAgICAqIEBtZW1iZXJPZiBGaWx0ZXJOb2RlLm9wdGlvbnNTY2hlbWFcbiAgICAgKi9cbiAgICBzY2hlbWE6IHt9LFxuXG4gICAgLyoqIEBzdW1tYXJ5IFR5cGUgb2YgZmlsdGVyIGVkaXRvci5cbiAgICAgKiBAZGVzYyA+IFRoaXMgZG9jcyBlbnRyeSBkZXNjcmliZXMgYSBwcm9wZXJ0eSBpbiB0aGUgRmlsdGVyTm9kZSBwcm90b3R5cGUuIEl0IGRvZXMgbm90IGRlc2NyaWJlIHRoZSBvcHRpb25zU2NoZW1hIHByb3BlcnR5IChkZXNwaXRlIGl0J3MgcG9zaXRpb24gaW4gdGhlIHNvdXJjZSBjb2RlKS5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBtZW1iZXJPZiBGaWx0ZXJOb2RlLm9wdGlvbnNTY2hlbWFcbiAgICAgKi9cbiAgICBlZGl0b3I6IHt9LFxuXG4gICAgLyoqIEBzdW1tYXJ5IEV2ZW50IGhhbmRsZXIgZm9yIFVJIGV2ZW50cy5cbiAgICAgKiBAZGVzYyA+IFRoaXMgZG9jcyBlbnRyeSBkZXNjcmliZXMgYSBwcm9wZXJ0eSBpbiB0aGUgRmlsdGVyTm9kZSBwcm90b3R5cGUuIEl0IGRvZXMgbm90IGRlc2NyaWJlIHRoZSBvcHRpb25zU2NoZW1hIHByb3BlcnR5IChkZXNwaXRlIGl0J3MgcG9zaXRpb24gaW4gdGhlIHNvdXJjZSBjb2RlKS5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBtZW1iZXJPZiBGaWx0ZXJOb2RlLm9wdGlvbnNTY2hlbWFcbiAgICAgKi9cbiAgICBldmVudEhhbmRsZXI6IHt9LFxuXG4gICAgdHlwZTogeyBvd246IHRydWUgfSxcblxuICAgIGtlZXA6IHsgb3duOiB0cnVlIH0sXG5cbiAgICAvKiogQHN1bW1hcnkgT3ZlcnJpZGUgb3BlcmF0b3IgbGlzdCBhdCBhbnkgbm9kZS5cbiAgICAgKiBAZGVzYyA+IFRoaXMgZG9jcyBlbnRyeSBkZXNjcmliZXMgYSBwcm9wZXJ0eSBpbiB0aGUgRmlsdGVyTm9kZSBwcm90b3R5cGUuIEl0IGRvZXMgbm90IGRlc2NyaWJlIHRoZSBvcHRpb25zU2NoZW1hIHByb3BlcnR5IChkZXNwaXRlIGl0J3MgcG9zaXRpb24gaW4gdGhlIHNvdXJjZSBjb2RlKS5cbiAgICAgKiBAdHlwZSB7c3RyaW5nW119XG4gICAgICogQG1lbWJlck9mIEZpbHRlck5vZGUub3B0aW9uc1NjaGVtYVxuICAgICAqL1xuICAgIG9wTWVudTogeyBkZWZhdWx0OiBDb25kaXRpb25hbHMuZGVmYXVsdE9wTWVudSB9LFxuXG4gICAgdHlwZU9wTWFwOiB7IHJvb3RCb3VuZDogdHJ1ZSB9LFxuXG4gICAgLyoqIEBzdW1tYXJ5IFRydXRoeSB3aWxsIHNvcnQgdGhlIGNvbHVtbiBtZW51cy5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAbWVtYmVyT2YgRmlsdGVyTm9kZS5vcHRpb25zU2NoZW1hXG4gICAgICovXG4gICAgc29ydENvbHVtbk1lbnU6IHt9XG59O1xuXG5GaWx0ZXJOb2RlLnNldFdhcm5pbmdDbGFzcyA9IGZ1bmN0aW9uKGVsLCB2YWx1ZSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgICB2YWx1ZSA9IGVsLnZhbHVlO1xuICAgIH1cbiAgICBlbC5jbGFzc0xpc3RbdmFsdWUgPyAncmVtb3ZlJyA6ICdhZGQnXSgnZmlsdGVyLXRyZWUtd2FybmluZycpO1xuICAgIHJldHVybiB2YWx1ZTtcbn07XG5cbkZpbHRlck5vZGUuY2xpY2tJbiA9IGZ1bmN0aW9uKGVsKSB7XG4gICAgaWYgKGVsKSB7XG4gICAgICAgIGlmIChlbC50YWdOYW1lID09PSAnU0VMRUNUJykge1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsgZWwuZGlzcGF0Y2hFdmVudChuZXcgTW91c2VFdmVudCgnbW91c2Vkb3duJykpOyB9LCAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVsLmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZpbHRlck5vZGU7XG4iLCIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuLy8gVGhpcyBpcyB0aGUgbWFpbiBmaWxlLCB1c2FibGUgYXMgaXMsIHN1Y2ggYXMgYnkgL3Rlc3QvaW5kZXguanMuXG5cbi8vIEZvciBucG06IHJlcXVpcmUgdGhpcyBmaWxlXG4vLyBGb3IgQ0ROOiBndWxwZmlsZS5qcyBicm93c2VyaWZpZXMgdGhpcyBmaWxlIHdpdGggc291cmNlbWFwIHRvIC9idWlsZC9maWx0ZXItdHJlZS5qcyBhbmQgdWdsaWZpZWQgd2l0aG91dCBzb3VyY2VtYXAgdG8gL2J1aWxkL2ZpbHRlci10cmVlLm1pbi5qcy4gVGhlIENETiBpcyBodHRwczovL2pvbmVpdC5naXRodWIuaW8vZmlsdGVyLXRyZWUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHBvcE1lbnUgPSByZXF1aXJlKCdwb3AtbWVudScpO1xudmFyIHVuc3RydW5naWZ5ID0gcmVxdWlyZSgndW5zdHJ1bmdpZnknKTtcblxudmFyIF8gPSByZXF1aXJlKCdvYmplY3QtaXRlcmF0b3JzJyk7XG52YXIgRmlsdGVyTm9kZSA9IHJlcXVpcmUoJy4vRmlsdGVyTm9kZScpO1xudmFyIEZpbHRlckxlYWYgPSByZXF1aXJlKCcuL0ZpbHRlckxlYWYnKTtcbnZhciBvcGVyYXRvcnMgPSByZXF1aXJlKCcuL3RyZWUtb3BlcmF0b3JzJyk7XG5cblxudmFyIG9yZGluYWwgPSAwO1xuXG4vKiogQGNvbnN0cnVjdG9yXG4gKiBAc3VtbWFyeSBBbiBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSByb290IG5vZGUgb3IgYSBicmFuY2ggbm9kZSBpbiBhIGZpbHRlciB0cmVlLlxuICogQGRlc2MgQSBub2RlIHJlcHJlc2VudGluZyBhIHN1YmV4cHJlc3Npb24gaW4gdGhlIGZpbHRlciBleHByZXNzaW9uLiBNYXkgYmUgdGhvdWdodCBvZiBhcyBhIHBhcmVudGhlc2l6ZWQgc3ViZXhwcmVzc2lvbiBpbiBhbGdlYnJhaWMgZXhwcmVzc2lvbiBzeW50YXguIEFzIGRpc2N1c3NlZCB1bmRlciB7QGxpbmsgRmlsdGVyTm9kZX0sIGEgYEZpbHRlclRyZWVgIGluc3RhbmNlJ3MgY2hpbGQgbm9kZXMgbWF5IGJlIGVpdGhlcjpcbiAqICogT3RoZXIgKG5lc3RlZCkgYEZpbHRlclRyZWVgIChvciBzdWJjbGFzcyB0aGVyZW9mKSBub2RlcyByZXByZXNlbnRpbmcgc3ViZXhwcmVzc2lvbnMuXG4gKiAqIHtAbGluayBGaWx0ZXJMZWFmfSAob3Igc3ViY2xhc3MgdGhlcmVvZikgdGVybWluYWwgbm9kZXMgcmVwcmVzZW50aW5nIGNvbmRpdGlvbmFsIGV4cHJlc3Npb25zLlxuICpcbiAqIFRoZSBgRmlsdGVyVHJlZWAgb2JqZWN0IGFsc28gaGFzIG1ldGhvZHMsIHNvbWUgb2Ygd2hpY2ggb3BlcmF0ZSBvbiBhIHNwZWNpZmljIHN1YnRyZWUgaW5zdGFuY2UsIGFuZCBzb21lIG9mIHdoaWNoIHJlY3Vyc2UgdGhyb3VnaCBhbGwgdGhlIHN1YnRyZWUncyBjaGlsZCBub2RlcyBhbmQgYWxsIHRoZWlyIGRlc2NlbmRhbnRzLCBfZXRjLl9cbiAqXG4gKiBUaGUgcmVjdXJzaXZlIG1ldGhvZHMgYXJlIGludGVyZXN0aW5nLiBUaGV5IGFsbCB3b3JrIHNpbWlsYXJseSwgbG9vcGluZyB0aHJvdWdoIHRoZSBsaXN0IG9mIGNoaWxkIG5vZGVzLCByZWN1cnNpbmcgd2hlbiB0aGUgY2hpbGQgbm9kZSBpcyBhIG5lc3RlZCBzdWJ0cmVlICh3aGljaCB3aWxsIHJlY3Vyc2UgZnVydGhlciB3aGVuIGl0IGhhcyBpdHMgb3duIG5lc3RlZCBzdWJ0cmVlcyk7IGFuZCBjYWxsaW5nIHRoZSBwb2x5bW9ycGhpYyBtZXRob2Qgd2hlbiB0aGUgY2hpbGQgbm9kZSBpcyBhIGBGaWx0ZXJMZWFmYCBvYmplY3QsIHdoaWNoIGlzIGEgdGVybWluYWwgbm9kZS4gU3VjaCBwb2x5bW9ycGhpYyBtZXRob2RzIGluY2x1ZGUgYHNldFN0YXRlKClgLCBgZ2V0U3RhdGUoKWAsIGBpbnZhbGlkKClgLCBhbmQgYHRlc3QoKWAuXG4gKlxuICogRm9yIGV4YW1wbGUsIGNhbGxpbmcgYHRlc3QoZGF0YVJvdylgIG9uIHRoZSByb290IHRyZWUgcmVjdXJzZXMgdGhyb3VnaCBhbnkgc3VidHJlZXMgZXZlbnR1YWxseSBjYWxsaW5nIGB0ZXN0KGRhdGFSb3cpYCBvbiBlYWNoIG9mIGl0cyBsZWFmIG5vZGVzIGFuZCBjb25jYXRlbmF0aW5nIHRoZSByZXN1bHRzIHRvZ2V0aGVyIHVzaW5nIHRoZSBzdWJ0cmVlJ3MgYG9wZXJhdG9yYC4gVGhlIHN1YnRyZWUncyBgdGVzdChkYXRhUm93KWAgY2FsbCB0aGVuIHJldHVybnMgdGhlIHJlc3VsdCB0byBpdCdzIHBhcmVudCdzIGB0ZXN0KClgIGNhbGwsIF9ldGMuLF8gZXZlbnR1YWxseSBidWJibGluZyB1cCB0byB0aGUgcm9vdCBub2RlJ3MgYHRlc3QoZGF0YVJvdylgIGNhbGwsIHdoaWNoIHJldHVybnMgdGhlIGZpbmFsIHJlc3VsdCB0byB0aGUgb3JpZ2luYWwgY2FsbGVyLiBUaGlzIHJlc3VsdCBkZXRlcm1pbmVzIGlmIHRoZSBnaXZlbiBkYXRhIHJvdyBwYXNzZWQgdGhyb3VnaCB0aGUgZW50aXJlIGZpbHRlciBleHByZXNzaW9uIHN1Y2Nlc3NmdWxseSAoYHRydWVgKSBhbmQgc2hvdWxkIGJlIGRpc3BsYXllZCwgb3Igd2FzIGJsb2NrZWQgc29tZXdoZXJlIChgZmFsc2VgKSBhbmQgc2hvdWxkIG5vdCBiZSBkaXNwbGF5ZWQuXG4gKlxuICogTm90ZSB0aGF0IGluIHByYWN0aWNlOlxuICogMS4gYGNoaWxkcmVuYCBtYXkgYmUgZW1wdHkuIFRoaXMgcmVwcmVzZW50cyBhIGFuIGVtcHR5IHN1YmV4cHJlc3Npb24uIE5vcm1hbGx5IHBvaW50bGVzcywgZW1wdHkgc3ViZXhwcmVzc2lvbnMgY291bGQgYmUgcHJ1bmVkLiBGaWx0ZXItdHJlZSBhbGxvd3MgdGhlbSBob3dldmVyIGFzIGhhcm1sZXNzIHBsYWNlaG9sZGVycy5cbiAqIDEuIGBvcGVyYXRvcmAgbWF5IGJlIG9taXR0ZWQgaW4gd2hpY2ggY2FzZSBpdCBkZWZhdWx0cyB0byBBTkQuXG4gKiAxLiBBIGBmYWxzZWAgcmVzdWx0IGZyb20gYSBjaGlsZCBub2RlIHdpbGwgc2hvcnQtc3RvcCBhbiBBTkQgb3BlcmF0aW9uOyBhIGB0cnVlYCByZXN1bHQgd2lsbCBzaG9ydC1zdG9wIGFuIE9SIG9yIE5PUiBvcGVyYXRpb24uXG4gKlxuICogQWRkaXRpb25hbCBub3RlczpcbiAqIDEuIEEgYEZpbHRlclRyZWVgIG1heSBjb25zaXN0IG9mIGEgc2luZ2xlIGxlYWYsIGluIHdoaWNoIGNhc2UgdGhlIGNvbmNhdGVuYXRpb24gYG9wZXJhdG9yYCBpcyBub3QgbmVlZGVkIGFuZCBtYXkgYmUgbGVmdCB1bmRlZmluZWQuIEhvd2V2ZXIsIGlmIGEgc2Vjb25kIGNoaWxkIGlzIGFkZGVkIGFuZCB0aGUgb3BlcmF0b3IgaXMgc3RpbGwgdW5kZWZpbmVkLCBpdCB3aWxsIGJlIHNldCB0byB0aGUgZGVmYXVsdCAoYCdvcC1hbmQnYCkuXG4gKiAyLiBUaGUgb3JkZXIgb2YgdGhlIGNoaWxkcmVuIGlzIHVuZGVmaW5lZCBhcyBhbGwgb3BlcmF0b3JzIGFyZSBjb21tdXRhdGl2ZS4gRm9yIHRoZSAnYG9wLW9yYCcgb3BlcmF0b3IsIGV2YWx1YXRpb24gY2Vhc2VzIG9uIHRoZSBmaXJzdCBwb3NpdGl2ZSByZXN1bHQgYW5kIGZvciBlZmZpY2llbmN5LCBhbGwgc2ltcGxlIGNvbmRpdGlvbmFsIGV4cHJlc3Npb25zIHdpbGwgYmUgZXZhbHVhdGVkIGJlZm9yZSBhbnkgY29tcGxleCBzdWJleHByZXNzaW9ucy5cbiAqIDMuIEEgbmVzdGVkIGBGaWx0ZXJUcmVlYCBpcyBkaXN0aW5ndWlzaGVkIChkdWNrLXR5cGVkKSBmcm9tIGEgbGVhZiBub2RlIGJ5IHRoZSBwcmVzZW5jZSBvZiBhIGBjaGlsZHJlbmAgbWVtYmVyLlxuICogNC4gTmVzdGluZyBhIGBGaWx0ZXJUcmVlYCBjb250YWluaW5nIGEgc2luZ2xlIGNoaWxkIGlzIHZhbGlkIChhbGJlaXQgcG9pbnRsZXNzKS5cbiAqXG4gKiAqKlNlZSBhbHNvIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBzdXBlcmNsYXNzOioqIHtAbGluayBGaWx0ZXJOb2RlfVxuICpcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbb3BlcmF0b3I9J29wLWFuZCddIC0gVGhlIG9wZXJhdG9yIHRoYXQgY29uY2F0ZW50YXRlcyB0aGUgdGVzdCByZXN1bHRzIGZyb20gYWxsIHRoZSBub2RlJ3MgYGNoaWxkcmVuYCAoY2hpbGQgbm9kZXMpLiBNdXN0IGJlIG9uZSBvZjpcbiAqICogYCdvcC1hbmQnYFxuICogKiBgJ29wLW9yJ2BcbiAqICogYCdvcC1ub3InYFxuICpcbiAqIE5vdGUgdGhhdCB0aGVyZSBpcyBvbmx5IG9uZSBgb3BlcmF0b3JgIHBlciBzdWJleHByZXNzaW9uLiBJZiB5b3UgbmVlZCB0byBtaXggb3BlcmF0b3JzLCBjcmVhdGUgYSBzdWJvcmRpbmF0ZSBzdWJleHByZXNzaW9uIGFzIG9uZSBvZiB0aGUgY2hpbGQgbm9kZXMuXG4gKlxuICogQHByb3BlcnR5IHtGaWx0ZXJOb2RlW119IGNoaWxkcmVuIC0gQSBsaXN0IG9mIGRlc2NlbmRhbnRzIG9mIHRoaXMgbm9kZS4gQXMgbm90ZWQsIHRoZXNlIG1heSBiZSBvdGhlciBgRmlsdGVyVHJlZWAgKG9yIHN1YmNsYXNzIHRoZXJlb2YpIG5vZGVzOyBvciBtYXkgYmUgdGVybWluYWwgYEZpbHRlckxlYWZgIChvciBzdWJjbGFzcyB0aGVyZW9mKSBub2Rlcy4gTWF5IGJlIGFueSBsZW5ndGggaW5jbHVkaW5nIDAgKG5vbmU7IGVtcHR5KS5cbiAqXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtrZWVwPWZhbHNlXSAtIERvIG5vdCBhdXRvbWF0aWNhbGx5IHBydW5lIHdoZW4gbGFzdCBjaGlsZCByZW1vdmVkLlxuICpcbiAqIEBwcm9wZXJ0eSB7ZmllbGRJdGVtW119IFtvd25TY2hlbWFdIC0gQ29sdW1uIG1lbnUgdG8gYmUgdXNlZCBvbmx5IGJ5IGxlYWYgbm9kZXMgdGhhdCBhcmUgY2hpbGRyZW4gKGRpcmVjdCBkZXNjZW5kYW50cykgb2YgdGhpcyBub2RlLlxuICpcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbdHlwZT0nc3VidHJlZSddIC0gVHlwZSBvZiBub2RlLCBmb3IgcmVuZGVyaW5nIHB1cnBvc2VzOyBuYW1lcyB0aGUgcmVuZGVyaW5nIHRlbXBsYXRlIHRvIHVzZSB0byBnZW5lcmF0ZSB0aGUgbm9kZSdzIFVJIHJlcHJlc2VudGF0aW9uLlxuICovXG52YXIgRmlsdGVyVHJlZSA9IEZpbHRlck5vZGUuZXh0ZW5kKCdGaWx0ZXJUcmVlJywge1xuXG4gICAgLyoqXG4gICAgICogSGFzaCBvZiBjb25zdHJ1Y3RvcnMgZm9yIG9iamVjdHMgdGhhdCBleHRlbmQgZnJvbSB7QGxpbmsgRmlsdGVyTGVhZn0sIHdoaWNoIGlzIHRoZSBgRGVmYXVsdGAgbWVtYmVyIGhlcmUuXG4gICAgICpcbiAgICAgKiBBZGQgYWRkaXRpb25hbCBlZGl0b3JzIHRvIHRoaXMgb2JqZWN0IChpbiB0aGUgcHJvdG90eXBlKSBwcmlvciB0byBpbnN0YW50aWF0aW5nIGEgbGVhZiBub2RlIHRoYXQgcmVmZXJzIHRvIGl0LiBUaGlzIG9iamVjdCBleGlzdHMgaW4gdGhlIHByb3RvdHlwZSBhbmQgYWRkaXRpb25zIHRvIGl0IHdpbGwgYWZmZWN0IGFsbCBub2RlcyB0aGF0IGRvbid0IGhhdmUgdGhlaXIgYW4gXCJvd25cIiBoYXNoLlxuICAgICAqXG4gICAgICogSWYgeW91IGNyZWF0ZSBhbiBcIm93blwiIGhhc2ggaW4geW91ciBpbnN0YW5jZSBiZSBzdXJlIHRvIGluY2x1ZGUgdGhlIGRlZmF1bHQgZWRpdG9yLCBmb3IgZXhhbXBsZTogYHsgRGVmYXVsdDogRmlsdGVyVHJlZS5wcm90b3R5cGUuZWRpdG9ycy5EZWZhdWx0LCAuLi4gfWAuIChPbmUgd2F5IG9mIG92ZXJyaWRpbmcgd291bGQgYmUgdG8gaW5jbHVkZSBzdWNoIGFuIG9iamVjdCBpbiBhbiBgZWRpdG9yc2AgbWVtYmVyIG9mIHRoZSBvcHRpb25zIG9iamVjdCBwYXNzZWQgdG8gdGhlIGNvbnN0cnVjdG9yIG9uIGluc3RhbnRpYXRpb24uIFRoaXMgd29ya3MgYmVjYXVzZSBhbGwgbWlzY2VsbGFuZW91cyBtZW1iZXJzIGFyZSBzaW1wbHkgY29waWVkIHRvIHRoZSBuZXcgaW5zdGFuY2UuIE5vdCB0byBiZSBjb25mdXNlZCB3aXRoIHRoZSBzdGFuZGFyZCBvcHRpb24gYGVkaXRvcmAgd2hpY2ggaXMgYSBzdHJpbmcgY29udGFpbmluZyBhIGtleSBmcm9tIHRoaXMgaGFzaCBhbmQgdGVsbHMgdGhlIGxlYWYgbm9kZSB3aGF0IHR5cGUgdG8gdXNlLilcbiAgICAgKi9cbiAgICBlZGl0b3JzOiB7XG4gICAgICAgIERlZmF1bHQ6IEZpbHRlckxlYWZcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQW4gZXh0ZW5zaW9uIGlzIGEgaGFzaCBvZiBwcm90b3R5cGUgb3ZlcnJpZGVzIChtZXRob2RzLCBwcm9wZXJ0aWVzKSB1c2VkIHRvIGV4dGVuZCB0aGUgZGVmYXVsdCBlZGl0b3IuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtrZXk9J0RlZmF1bHQnXSAtIE5tZSBvZiB0aGUgbmV3IGV4dGVuc2lvbiBnaXZlbiBpbiBgZXh0YCBvciBuYW1lIG9mIGFuIGV4aXN0aW5nIGV4dGVuc2lvbiBpbiBgRmlsdGVyVHJlZS5leHRlbnNpb25zYC4gQXMgYSBjb25zdHJ1Y3Rvciwgc2hvdWxkIGhhdmUgYW4gaW5pdGlhbCBjYXBpdGFsLiBJZiBvbWl0dGVkLCByZXBsYWNlcyB0aGUgZGVmYXVsdCBlZGl0b3IgKEZpbHRlckxlYWYpLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbZXh0XSBBbiBleHRlbnNpb24gaGFzaFxuICAgICAqIEBwYXJhbSB7RmlsZXJMZWFmfSBbQmFzZUVkaXRvcj10aGlzLmVkaXRvcnMuRGVmYXVsdF0gLSBDb25zdHJ1Y3RvciB0byBleHRlbmQgZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7RmlsbHRlckxlYWZ9IEEgbmV3IGNsYXNzIGV4dGVuZGVkIGZyb20gYEJhc2VFZGl0b3JgIC0tIHdoaWNoIGlzIGluaXRpYWxseSBgRmlsdGVyTGVhZmAgYnV0IG1heSBpdHNlbGYgaGF2ZSBiZWVuIGV4dGVuZGVkIGJ5IGEgY2FsbCB0byBgLmFkZEVkaXRvcignRGVmYXVsdCcsIGV4dGVuc2lvbilgLlxuICAgICAqL1xuICAgIGFkZEVkaXRvcjogZnVuY3Rpb24oa2V5LCBleHQsIEJhc2VFZGl0b3IpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAvLyBga2V5YCAoc3RyaW5nKSB3YXMgb21pdHRlZFxuICAgICAgICAgICAgQmFzZUVkaXRvciA9IGV4dDtcbiAgICAgICAgICAgIGV4dCA9IGtleTtcbiAgICAgICAgICAgIGtleSA9ICdEZWZhdWx0JztcbiAgICAgICAgfVxuICAgICAgICBCYXNlRWRpdG9yID0gQmFzZUVkaXRvciB8fCB0aGlzLmVkaXRvcnMuRGVmYXVsdDtcbiAgICAgICAgZXh0ID0gZXh0IHx8IEZpbHRlclRyZWUuZXh0ZW5zaW9uc1trZXldO1xuICAgICAgICByZXR1cm4gKHRoaXMuZWRpdG9yc1trZXldID0gQmFzZUVkaXRvci5leHRlbmQoa2V5LCBleHQpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIFRoZSBuYW1lIG9mIHRoZSBleGlzdGluZyBlZGl0b3IgdG8gcmVtb3ZlLlxuICAgICAqIEBtZW1iZXJPZiBGaWx0ZXJUcmVlLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHJlbW92ZUVkaXRvcjogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIGlmIChrZXkgPT09ICdEZWZhdWx0Jykge1xuICAgICAgICAgICAgdGhyb3cgJ0Nhbm5vdCByZW1vdmUgZGVmYXVsdCBlZGl0b3IuJztcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgdGhpcy5lZGl0b3JzW2tleV07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQG1lbWJlck9mIEZpbHRlclRyZWUucHJvdG90eXBlXG4gICAgICovXG4gICAgY3JlYXRlVmlldzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZWwgPSB0aGlzLnRlbXBsYXRlcy5nZXQoXG4gICAgICAgICAgICB0aGlzLnR5cGUgfHwgJ3N1YnRyZWUnLFxuICAgICAgICAgICAgKytvcmRpbmFsLFxuICAgICAgICAgICAgdGhpcy5zY2hlbWFbMF0gJiYgcG9wTWVudS5mb3JtYXRJdGVtKHRoaXMuc2NoZW1hWzBdKVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIEFkZCB0aGUgZXhwcmVzc2lvbiBlZGl0b3JzIHRvIHRoZSBcImFkZCBuZXdcIiBkcm9wLWRvd25cbiAgICAgICAgdmFyIGFkZE5ld0N0cmwgPSB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoJzpzY29wZT5zZWxlY3QnKTtcbiAgICAgICAgaWYgKGFkZE5ld0N0cmwpIHtcbiAgICAgICAgICAgIHZhciBzdWJtZW51LCBvcHRncm91cCxcbiAgICAgICAgICAgICAgICBlZGl0b3JzID0gdGhpcy5lZGl0b3JzO1xuXG4gICAgICAgICAgICBpZiAoYWRkTmV3Q3RybC5sZW5ndGggPT09IDEgJiYgdGhpcy5lZGl0b3JzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgZWRpdG9yIGlzIHRoZSBvbmx5IG9wdGlvbiBiZXNpZGVzIHRoZSBudWxsIHByb21wdCBvcHRpb25cbiAgICAgICAgICAgICAgICAvLyBzbyBtYWtlIGl0IHRoIGVvbmx5IGl0ZW0gaSB0aGUgZHJvcC1kb3duXG4gICAgICAgICAgICAgICAgc3VibWVudSA9IGFkZE5ld0N0cmw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHRoZXJlIGFyZSBhbHJlYWR5IG9wdGlvbnMgYW5kL29yIG11bHRpcGxlIGVkaXRvcnNcbiAgICAgICAgICAgICAgICBzdWJtZW51ID0gb3B0Z3JvdXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdvcHRncm91cCcpO1xuICAgICAgICAgICAgICAgIG9wdGdyb3VwLmxhYmVsID0gJ0NvbmRpdGlvbmFsIEV4cHJlc3Npb25zJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGVkaXRvcnMpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBlZGl0b3JzW2tleV0ucHJvdG90eXBlLm5hbWUgfHwga2V5O1xuICAgICAgICAgICAgICAgIHN1Ym1lbnUuYXBwZW5kQ2hpbGQobmV3IE9wdGlvbihuYW1lLCBrZXkpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKG9wdGdyb3VwKSB7XG4gICAgICAgICAgICAgICAgYWRkTmV3Q3RybC5hZGQob3B0Z3JvdXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBvbmNoYW5nZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBvblRyZWVPcENsaWNrLmJpbmQodGhpcykpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBtZW1iZXJPZiBGaWx0ZXJUcmVlLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGxvYWRTdGF0ZTogZnVuY3Rpb24oc3RhdGUpIHtcbiAgICAgICAgdGhpcy5vcGVyYXRvciA9ICdvcC1hbmQnO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gW107XG5cbiAgICAgICAgaWYgKCFzdGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5hZGQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFZhbGlkYXRlIGBzdGF0ZS5jaGlsZHJlbmAgKHJlcXVpcmVkKVxuICAgICAgICAgICAgaWYgKCEoc3RhdGUuY2hpbGRyZW4gaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgdGhpcy5FcnJvcignRXhwZWN0ZWQgYGNoaWxkcmVuYCBwcm9wZXJ0eSB0byBiZSBhbiBhcnJheS4nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVmFsaWRhdGUgYHN0YXRlLm9wZXJhdG9yYCAoaWYgZ2l2ZW4pXG4gICAgICAgICAgICBpZiAoc3RhdGUub3BlcmF0b3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW9wZXJhdG9yc1tzdGF0ZS5vcGVyYXRvcl0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IHRoaXMuRXJyb3IoJ0V4cGVjdGVkIGBvcGVyYXRvcmAgcHJvcGVydHkgdG8gYmUgb25lIG9mOiAnICsgT2JqZWN0LmtleXMob3BlcmF0b3JzKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5vcGVyYXRvciA9IHN0YXRlLm9wZXJhdG9yO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzdGF0ZS5jaGlsZHJlbi5mb3JFYWNoKHRoaXMuYWRkLmJpbmQodGhpcykpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQG1lbWJlck9mIEZpbHRlclRyZWUucHJvdG90eXBlXG4gICAgICovXG4gICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJhZGlvQnV0dG9uID0gdGhpcy5lbC5xdWVyeVNlbGVjdG9yKCc6c2NvcGUgPiBsYWJlbCA+IGlucHV0W3ZhbHVlPScgKyB0aGlzLm9wZXJhdG9yICsgJ10nKSxcbiAgICAgICAgICAgIGFkZEZpbHRlckxpbmsgPSB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoJy5maWx0ZXItdHJlZS1hZGQtY29uZGl0aW9uYWwnKTtcblxuICAgICAgICBpZiAocmFkaW9CdXR0b24pIHtcbiAgICAgICAgICAgIHJhZGlvQnV0dG9uLmNoZWNrZWQgPSB0cnVlO1xuICAgICAgICAgICAgb25UcmVlT3BDbGljay5jYWxsKHRoaXMsIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IHJhZGlvQnV0dG9uXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHdoZW4gbXVsdGlwbGUgZmlsdGVyIGVkaXRvcnMgYXZhaWxhYmxlLCBzaW11bGF0ZSBjbGljayBvbiB0aGUgbmV3IFwiYWRkIGNvbmRpdGlvbmFsXCIgbGlua1xuICAgICAgICBpZiAoYWRkRmlsdGVyTGluayAmJiAhdGhpcy5jaGlsZHJlbi5sZW5ndGggJiYgT2JqZWN0LmtleXModGhpcy5lZGl0b3JzKS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB0aGlzWydmaWx0ZXItdHJlZS1hZGQtY29uZGl0aW9uYWwnXSh7XG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBhZGRGaWx0ZXJMaW5rXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHByb2NlZWQgd2l0aCByZW5kZXJcbiAgICAgICAgRmlsdGVyTm9kZS5wcm90b3R5cGUucmVuZGVyLmNhbGwodGhpcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IENyZWF0ZSBhIG5ldyBub2RlIGFzIHBlciBgc3RhdGVgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zPXtzdGF0ZTp7fX1dIC0gTWF5IGJlIG9uZSBvZjpcbiAgICAgKlxuICAgICAqICogYW4gYG9wdGlvbnNgIG9iamVjdCBjb250YWluaW5nIGEgYHN0YXRlYCBwcm9wZXJ0eVxuICAgICAqICogYSBgc3RhdGVgIG9iamVjdCAoaW4gd2hpY2ggY2FzZSB0aGVyZSBpcyBubyBgb3B0aW9uc2Agb2JqZWN0KVxuICAgICAqXG4gICAgICogSW4gYW55IGNhc2UsIHJlc3VsdGluZyBgc3RhdGVgIG9iamVjdCBtYXkgYmUgZWl0aGVyLi4uXG4gICAgICogKiBBIG5ldyBzdWJ0cmVlIChoYXMgYSBgY2hpbGRyZW5gIHByb3BlcnR5KTpcbiAgICAgKiAgIEFkZCBhIG5ldyBgRmlsdGVyVHJlZWAgbm9kZS5cbiAgICAgKiAqIEEgbmV3IGxlYWYgKG5vIGBjaGlsZHJlbmAgcHJvcGVydHkpOiBhZGQgYSBuZXcgYEZpbHRlckxlYWZgIG5vZGU6XG4gICAgICogICAqIElmIHRoZXJlIGlzIGFuIGBlZGl0b3JgIHByb3BlcnR5OlxuICAgICAqICAgICBBZGQgbGVhZiB1c2luZyBgdGhpcy5lZGl0b3JzW3N0YXRlLmVkaXRvcl1gLlxuICAgICAqICAgKiBPdGhlcndpc2UgKGluY2x1ZGluZyB0aGUgY2FzZSB3aGVyZSBgc3RhdGVgIGlzIHVuZGVmaW5lZCk6XG4gICAgICogICAgIEFkZCBsZWFmIHVzaW5nIGB0aGlzLmVkaXRvcnMuRGVmYXVsdGAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmZvY3VzPWZhbHNlXSBDYWxsIGludmFsaWQoKSBhZnRlciBpbnNlcnRpbmcgdG8gZm9jdXMgb24gZmlyc3QgYmxhbmsgY29udHJvbCAoaWYgYW55KS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtGaWx0ZXJOb2RlfSBUaGUgbmV3IG5vZGUuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgRmlsdGVyVHJlZS5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBhZGQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIENvbnN0cnVjdG9yLCBuZXdOb2RlO1xuXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIGlmICghb3B0aW9ucy5zdGF0ZSkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IHsgc3RhdGU6IG9wdGlvbnMgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLnN0YXRlLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBDb25zdHJ1Y3RvciA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBDb25zdHJ1Y3RvciA9IHRoaXMuZWRpdG9yc1tvcHRpb25zLnN0YXRlLmVkaXRvciB8fCAnRGVmYXVsdCddO1xuICAgICAgICB9XG5cbiAgICAgICAgb3B0aW9ucy5wYXJlbnQgPSB0aGlzO1xuICAgICAgICBuZXdOb2RlID0gbmV3IENvbnN0cnVjdG9yKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmNoaWxkcmVuLnB1c2gobmV3Tm9kZSk7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuZm9jdXMpIHtcbiAgICAgICAgICAgIC8vIGZvY3VzIG9uIGJsYW5rIGNvbnRyb2wgYSBiZWF0IGFmdGVyIGFkZGluZyBpdFxuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsgbmV3Tm9kZS5pbnZhbGlkKG9wdGlvbnMpOyB9LCA3NTApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ld05vZGU7XG4gICAgfSxcblxuICAgIC8qKiBAdHlwZWRlZiB7b2JqZWN0fSBGaWx0ZXJUcmVlVmFsaWRhdGlvbk9wdGlvbnNPYmplY3RcbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFt0aHJvdz1mYWxzZV0gLSBUaHJvdyAoZG8gbm90IGNhdGNoKSBgRmlsdGVyVHJlZUVycm9yYHMuXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbYWxlcnQ9ZmFsc2VdIC0gQW5ub3VuY2UgZXJyb3IgdmlhIHdpbmRvdy5hbGVydCgpIGJlZm9yZSByZXR1cm5pbmcuXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbZm9jdXM9ZmFsc2VdIC0gUGxhY2UgdGhlIGZvY3VzIG9uIHRoZSBvZmZlbmRpbmcgY29udHJvbCBhbmQgZ2l2ZSBpdCBlcnJvciBjb2xvci5cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7RmlsdGVyVHJlZVZhbGlkYXRpb25PcHRpb25zT2JqZWN0fSBbb3B0aW9uc11cbiAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfEZpbHRlclRyZWVFcnJvcn0gYHVuZGVmaW5lZGAgaWYgdmFsaWQ7IG9yIHRoZSBjYXVnaHQgYEZpbHRlclRyZWVFcnJvcmAgaWYgZXJyb3IuXG4gICAgICogQG1lbWJlck9mIEZpbHRlclRyZWUucHJvdG90eXBlXG4gICAgICovXG4gICAgaW52YWxpZDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSBpbnZhbGlkLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgcmVzdWx0ID0gZXJyO1xuXG4gICAgICAgICAgICAvLyBUaHJvdyB3aGVuIHVuZXhwZWN0ZWQgKG5vdCBhIGZpbHRlciB0cmVlIGVycm9yKVxuICAgICAgICAgICAgaWYgKCEoZXJyIGluc3RhbmNlb2YgdGhpcy5FcnJvcikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBbHRlciBhbmQvb3IgdGhyb3cgd2hlbiByZXF1ZXN0ZWRcbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuYWxlcnQpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cuYWxlcnQocmVzdWx0Lm1lc3NhZ2UgfHwgcmVzdWx0KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1hbGVydFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMudGhyb3cpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBkYXRhUm93XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICogQG1lbWJlck9mIEZpbHRlclRyZWUucHJvdG90eXBlXG4gICAgICovXG4gICAgdGVzdDogZnVuY3Rpb24gdGVzdChkYXRhUm93KSB7XG4gICAgICAgIHZhciBvcGVyYXRvciA9IG9wZXJhdG9yc1t0aGlzLm9wZXJhdG9yXSxcbiAgICAgICAgICAgIHJlc3VsdCA9IG9wZXJhdG9yLnNlZWQsXG4gICAgICAgICAgICBub0NoaWxkcmVuRGVmaW5lZCA9IHRydWU7XG5cbiAgICAgICAgdGhpcy5jaGlsZHJlbi5maW5kKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICBub0NoaWxkcmVuRGVmaW5lZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIEZpbHRlckxlYWYpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gb3BlcmF0b3IucmVkdWNlKHJlc3VsdCwgY2hpbGQudGVzdChkYXRhUm93KSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaGlsZC5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gb3BlcmF0b3IucmVkdWNlKHJlc3VsdCwgdGVzdC5jYWxsKGNoaWxkLCBkYXRhUm93KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgPT09IG9wZXJhdG9yLmFib3J0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBub0NoaWxkcmVuRGVmaW5lZCB8fCAob3BlcmF0b3IubmVnYXRlID8gIXJlc3VsdCA6IHJlc3VsdCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IE51bWJlciBvZiBmaWx0ZXJzICh0ZXJtaW5hbCBub2RlcykgZGVmaW5lZCBpbiB0aGlzIHN1YnRyZWUuXG4gICAgICovXG4gICAgZmlsdGVyQ291bnQ6IGZ1bmN0aW9uIGZpbHRlckNvdW50KCkge1xuICAgICAgICB2YXIgbiA9IDA7XG5cbiAgICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgICAgICBuICs9IGNoaWxkIGluc3RhbmNlb2YgRmlsdGVyTGVhZiA/IDEgOiBmaWx0ZXJDb3VudC5jYWxsKGNoaWxkKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIG47XG4gICAgfSxcblxuICAgIC8qKiBAdHlwZWRlZiB7b2JqZWN0fSBGaWx0ZXJUcmVlR2V0U3RhdGVPcHRpb25zT2JqZWN0XG4gICAgICpcbiAgICAgKiBAc3VtbWFyeSBPYmplY3QgY29udGFpbmluZyBvcHRpb25zIGZvciBwcm9kdWNpbmcgYSBzdGF0ZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAZGVzYyBTdGF0ZSBpcyBjb21tb25seSB1c2VkIGZvciB0d28gcHVycG9zZXM6XG4gICAgICogMS4gVG8gcGVyc2lzdCB0aGUgZmlsdGVyIHN0YXRlIHNvIHRoYXQgaXQgY2FuIGJlIHJlbG9hZGVkIGxhdGVyLlxuICAgICAqIDIuIFRvIHNlbmQgYSBxdWVyeSB0byBhIGRhdGFiYXNlIGVuZ2luZS5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3N5bnRheD0nb2JqZWN0J10gLSBBIGNhc2Utc2Vuc2l0aXZlIHN0cmluZyBpbmRpY2F0aW5nIHRoZSBleHBlY3RlZCB0eXBlIGFuZCBmb3JtYXQgb2YgYSBzdGF0ZSBvYmplY3QgdG8gYmUgZ2VuZXJhdGVkIGZyb20gYSBmaWx0ZXIgdHJlZS4gT25lIG9mOlxuICAgICAqICogYCdvYmplY3QnYCAoZGVmYXVsdCkgQSByYXcgc3RhdGUgb2JqZWN0IHByb2R1Y2VkIGJ5IHdhbGtpbmcgdGhlIHRyZWUgdXNpbmcgYHtAbGluayBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS91bnN0cnVuZ2lmeXx1bnN0cnVuZ2lmeSgpfWAsIHJlc3BlY3RpbmcgYEpTT04uc3RyaW5naWZ5KClgJ3MgXCJ7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvSlNPTi9zdHJpbmdpZnkjdG9KU09OKClfYmVoYXZpb3J8dG9KU09OKCkgYmVoYXZpb3J9LFwiIGFuZCByZXR1cm5pbmcgYSBwbGFpbiBvYmplY3Qgc3VpdGFibGUgZm9yIHJlc3VibWl0dGluZyB0byB7QGxpbmsgRmlsdGVyTm9kZSNzZXRTdGF0ZXxzZXRTdGF0ZX0uIFRoaXMgaXMgYW4gXCJlc3NlbnRpYWxcIiB2ZXJzaW9uIG9mIHRoZSBhY3R1YWwgbm9kZSBvYmplY3RzIGluIHRoZSB0cmVlLlxuICAgICAqICogYCdKU09OJ2AgLSBBIHN0cmluZ2lmaWVkIHN0YXRlIG9iamVjdCBwcm9kdWNlZCBieSB3YWxraW5nIHRoZSB0cmVlIHVzaW5nIGB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvSlNPTi9zdHJpbmdpZnkjdG9KU09OKClfYmVoYXZpb3J8SlNPTi5zdHJpbmdpZnkoKX1gLCByZXR1cm5pbmcgYSBKU09OIHN0cmluZyBieSBjYWxsaW5nIGB0b0pTT05gIGF0IGV2ZXJ5IG5vZGUuIFRoaXMgaXMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHNhbWUgXCJlc3NlbnRpYWxcIiBvYmplY3QgYXMgdGhhdCBwcm9kdWNlZCBieSB0aGUgYCdvYmplY3QnYCBvcHRpb24sIGJ1dCBcInN0cmluZ2lmaWVkXCIgYW5kIHRoZXJlZm9yZSBzdWl0YWJsZSBmb3IgdGV4dC1iYXNlZCBzdG9yYWdlIG1lZGlhLlxuICAgICAqICogYCdTUUwnYCAtIFRoZSBzdWJleHByZXNzaW9uIGluIFNRTCBjb25kaXRpb25hbCBzeW50YXggcHJvZHVjZWQgYnkgd2Fsa2luZyB0aGUgdHJlZSBhbmQgcmV0dXJuaW5nIGEgU1FMIFtzZWFyY2ggY29uZGl0aW9uIGV4cHJlc3Npb25de0BsaW5rIGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvbXMxNzM1NDUuYXNweH0uIFN1aXRhYmxlIGZvciB1c2UgaW4gdGhlIFdIRVJFIGNsYXVzZSBvZiBhIFNRTCBgU0VMRUNUYCBzdGF0ZW1lbnQgdXNlZCB0byBxdWVyeSBhIGRhdGFiYXNlIGZvciBhIGZpbHRlcmVkIHJlc3VsdCBzZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtzcGFjZV0gLSBXaGVuIGBvcHRpb25zLnN5bnRheCA9PT0gJ0pTT04nYCwgZm9yd2FyZGVkIHRvIGBKU09OLnN0cmluZ2lmeWAgYXMgdGhlIHRoaXJkIHBhcmFtZXRlciwgYHNwYWNlYCAoc2VlKS5cbiAgICAgKlxuICAgICAqIE5PVEU6IFRoZSBTUUwgc3ludGF4IHJlc3VsdCBjYW5ub3QgYWNjb21tb2RhdGUgbm9kZSBtZXRhLWRhdGEuIFdoaWxlIG1ldGEtZGF0YSBzdWNoIGFzIGB0eXBlYCB0eXBpY2FsbHkgY29tZXMgZnJvbSB0aGUgY29sdW1uIHNjaGVtYSwgbWV0YS1kYXRhIGNhbiBiZSBpbnN0YWxsZWQgZGlyZWN0bHkgb24gYSBub2RlLiBTdWNoIG1ldGEtZGF0YSB3aWxsIG5vdCBiZSBwYXJ0IG9mIHRoZSByZXN1bHRpbmcgU1FMIGV4cHJlc3Npb24uIEZvciB0aGlzIHJlYXNvbiwgU1FMIHNob3VsZCBub3QgYmUgdXNlZCB0byBwZXJzaXN0IGZpbHRlciBzdGF0ZSBidXQgcmF0aGVyIGl0cyB1c2Ugc2hvdWxkIGJlIGxpbWl0ZWQgdG8gZ2VuZXJhdGluZyBhIGZpbHRlciBxdWVyeSBmb3IgYSByZW1vdGUgZGF0YSBzZXJ2ZXIuXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBHZXQgYSByZXByZXNlbnRhdGlvbiBvZiBmaWx0ZXIgc3RhdGUuXG4gICAgICogQGRlc2MgQ2FsbGluZyB0aGlzIG9uIHRoZSByb290IHdpbGwgZ2V0IHRoZSBlbnRpcmUgdHJlZSdzIHN0YXRlOyBjYWxsaW5nIHRoaXMgb24gYW55IHN1YnRyZWUgd2lsbCBnZXQganVzdCB0aGF0IHN1YnRyZWUncyBzdGF0ZS5cbiAgICAgKlxuICAgICAqIE9ubHkgX2Vzc2VudGlhbF8gcHJvcGVydGllcyB3aWxsIGJlIG91dHB1dDpcbiAgICAgKlxuICAgICAqIDEuIGBGaWx0ZXJUcmVlYCBub2RlcyB3aWxsIG91dHB1dCBhdCBsZWFzdCAyIHByb3BlcnRpZXM6XG4gICAgICogICAgKiBgb3BlcmF0b3JgXG4gICAgICogICAgKiBgY2hpbGRyZW5gXG4gICAgICogMi4gYEZpbHRlckxlYWZgIG5vZGVzIHdpbGwgb3V0cHV0ICh2aWEge0BsaW5rIEZpbHRlckxlYWYjZ2V0U3RhdGV8Z2V0U3RhdGV9KSBhdCBsZWFzdCAzIHByb3BlcnRpZXMsIG9uZSBwcm9wZXJ0eSBmb3IgZWFjaCBpdGVtIGluIGl0J3MgYHZpZXdgOlxuICAgICAqICAgICogYGNvbHVtbmBcbiAgICAgKiAgICAqIGBvcGVyYXRvcmBcbiAgICAgKiAgICAqIGBvcGVyYW5kYFxuICAgICAqIDMuIEFkZGl0aW9uYWwgbm9kZSBwcm9wZXJ0aWVzIHdpbGwgYmUgb3V0cHV0IHdoZW46XG4gICAgICogICAgMS4gV2hlbiB0aGUgcHJvcGVydHkgd2FzICoqTk9UKiogZXh0ZXJuYWxseSBzb3VyY2VkOlxuICAgICAqICAgICAgIDEuIERpZCAqbm90KiBjb21lIGZyb20gdGhlIGBvcHRpb25zYCBvYmplY3Qgb24gbm9kZSBpbnN0YW50aWF0aW9uLlxuICAgICAqICAgICAgIDIuIERpZCAqbm90KiBjb21lIGZyb20gdGhlIG9wdGlvbnMgc2NoZW1hIGBkZWZhdWx0YCBvYmplY3QsIGlmIGFueS5cbiAgICAgKiAgICAyLiAqKkFORCoqIGF0IGxlYXN0IG9uZSBvZiB0aGUgZm9sbG93aW5nIGlzIHRydWU6XG4gICAgICogICAgICAgMS4gV2hlbiBpdCdzIGFuIFwib3duXCIgcHJvcGVydHkuXG4gICAgICogICAgICAgMi4gV2hlbiBpdHMgdmFsdWUgZGlmZmVycyBmcm9tIGl0J3MgcGFyZW50J3MuXG4gICAgICogICAgICAgMy4gV2hlbiB0aGlzIGlzIHRoZSByb290IG5vZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0ZpbHRlclRyZWVHZXRTdGF0ZU9wdGlvbnNPYmplY3R9IFtvcHRpb25zXVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucy5zcWxJZFF0c10gLSBXaGVuIGBvcHRpb25zLnN5bnRheCA9PT0gJ1NRTCdgLCBmb3J3YXJkZWQgdG8gYGNvbmRpdGlvbmFscy5wdXNoU3FsSWRRdHMoKWAuXG4gICAgICogQHJldHVybnMge29iamVjdHxzdHJpbmd9IFJldHVybnMgb2JqZWN0IHdoZW4gYG9wdGlvbnMuc3ludGF4ID09PSAnb2JqZWN0J2A7IG90aGVyd2lzZSByZXR1cm5zIHN0cmluZy5cbiAgICAgKiBAbWVtYmVyT2YgRmlsdGVyVHJlZS5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBnZXRTdGF0ZTogZnVuY3Rpb24gZ2V0U3RhdGUob3B0aW9ucykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gJycsXG4gICAgICAgICAgICBzeW50YXggPSBvcHRpb25zICYmIG9wdGlvbnMuc3ludGF4IHx8ICdvYmplY3QnO1xuXG4gICAgICAgIHN3aXRjaCAoc3ludGF4KSB7XG4gICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHVuc3RydW5naWZ5LmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ0pTT04nOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IEpTT04uc3RyaW5naWZ5KHRoaXMsIG51bGwsIG9wdGlvbnMgJiYgb3B0aW9ucy5zcGFjZSkgfHwgJyc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ1NRTCc6XG4gICAgICAgICAgICAgICAgdmFyIGxleGVtZSA9IG9wZXJhdG9yc1t0aGlzLm9wZXJhdG9yXS5TUUw7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24oY2hpbGQsIGlkeCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3AgPSBpZHggPyAnICcgKyBsZXhlbWUub3AgKyAnICcgOiAnJztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgRmlsdGVyTGVhZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IG9wICsgY2hpbGQuZ2V0U3RhdGUob3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hpbGQuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gb3AgKyBnZXRTdGF0ZS5jYWxsKGNoaWxkLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBsZXhlbWUuYmVnICsgcmVzdWx0ICsgbGV4ZW1lLmVuZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IHRoaXMuRXJyb3IoJ1Vua25vd24gc3ludGF4IG9wdGlvbiBcIicgKyBzeW50YXggKyAnXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIHRvSlNPTjogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICBzdGF0ZSA9IHtcbiAgICAgICAgICAgICAgICBvcGVyYXRvcjogdGhpcy5vcGVyYXRvcixcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogW11cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgICAgICBzdGF0ZS5jaGlsZHJlbi5wdXNoKGNoaWxkIGluc3RhbmNlb2YgRmlsdGVyTGVhZiA/IGNoaWxkIDogdG9KU09OLmNhbGwoY2hpbGQpKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgXyhGaWx0ZXJOb2RlLm9wdGlvbnNTY2hlbWEpLmVhY2goZnVuY3Rpb24ob3B0aW9uU2NoZW1hLCBrZXkpIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBzZWxmW2tleV0gJiYgLy8gdGhlcmUgaXMgYSBzdGFuZGFyZCBvcHRpb24gb24gdGhlIG5vZGUgd2hpY2ggbWF5IG5lZWQgdG8gYmUgb3V0cHV0XG4gICAgICAgICAgICAgICAgIXNlbGYuZG9udFBlcnNpc3Rba2V5XSAmJiAoXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvblNjaGVtYS5vd24gfHwgLy8gb3V0cHV0IGJlY2F1c2UgaXQncyBhbiBcIm93blwiIG9wdGlvbiAoYmVsb25ncyB0byB0aGUgbm9kZSlcbiAgICAgICAgICAgICAgICAgICAgIXNlbGYucGFyZW50IHx8IC8vIG91dHB1dCBiZWNhdXNlIGl0J3MgdGhlIHJvb3Qgbm9kZVxuICAgICAgICAgICAgICAgICAgICBzZWxmW2tleV0gIT09IHNlbGYucGFyZW50W2tleV0gLy8gb3V0cHV0IGJlY2F1c2UgaXQgZGlmZmVycyBmcm9tIGl0cyBwYXJlbnQncyB2ZXJzaW9uXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgc3RhdGVba2V5XSA9IHNlbGZba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBTZXQgdGhlIGNhc2Ugc2Vuc2l0aXZpdHkgb2YgZmlsdGVyIHRlc3RzIGFnYWluc3QgZGF0YS5cbiAgICAgKiBAZGVzYyBDYXNlIHNlbnNpdGl2aXR5IHBlcnRhaW5zIHRvIHN0cmluZyBjb21wYXJlcyBvbmx5LiBUaGlzIGluY2x1ZGVzIHVudHlwZWQgY29sdW1ucywgY29sdW1ucyB0eXBlZCBhcyBzdHJpbmdzLCB0eXBlZCBjb2x1bW5zIGNvbnRhaW5pbmcgZGF0YSB0aGF0IGNhbm5vdCBiZSBjb2VyY2VkIHRvIHR5cGUgb3Igd2hlbiB0aGUgZmlsdGVyIGV4cHJlc3Npb24gb3BlcmFuZCBjYW5ub3QgYmUgY29lcmNlZC5cbiAgICAgKlxuICAgICAqIE5PVEU6IFRoaXMgaXMgYSBzaGFyZWQgcHJvcGVydHkgYW5kIGFmZmVjdHMgYWxsIGZpbHRlci10cmVlIGluc3RhbmNlcyBjb25zdHJ1Y3RlZCBieSB0aGlzIGNvZGUgaW5zdGFuY2UuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc1NlbnNpdGl2ZVxuICAgICAqIEBtZW1iZXJPZiBGaWx0ZXJ0cmVlLnByb3RvdHlwZS5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBzZXRDYXNlU2Vuc2l0aXZpdHk6IGZ1bmN0aW9uKGlzU2Vuc2l0aXZlKSB7XG4gICAgICAgIHZhciB0b1N0cmluZyA9IGlzU2Vuc2l0aXZlID8gdG9TdHJpbmdDYXNlU2Vuc2l0aXZlIDogdG9TdHJpbmdDYXNlSW5zZW5zaXRpdmU7XG4gICAgICAgIEZpbHRlckxlYWYuc2V0VG9TdHJpbmcodG9TdHJpbmcpO1xuICAgIH1cblxufSk7XG5cbmZ1bmN0aW9uIHRvU3RyaW5nQ2FzZUluc2Vuc2l0aXZlKHMpIHsgcmV0dXJuIChzICsgJycpLnRvVXBwZXJDYXNlKCk7IH1cbmZ1bmN0aW9uIHRvU3RyaW5nQ2FzZVNlbnNpdGl2ZShzKSB7IHJldHVybiBzICsgJyc7IH1cblxuLy8gU29tZSBldmVudCBoYW5kbGVycyBib3VuZCB0byBGaWx0ZXJUcmVlIG9iamVjdFxuXG5mdW5jdGlvbiBvbmNoYW5nZShldnQpIHsgLy8gY2FsbGVkIGluIGNvbnRleHRcbiAgICB2YXIgY3RybCA9IGV2dC50YXJnZXQ7XG4gICAgaWYgKGN0cmwucGFyZW50RWxlbWVudCA9PT0gdGhpcy5lbCkge1xuICAgICAgICBpZiAoY3RybC52YWx1ZSA9PT0gJ3N1YmV4cCcpIHtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4ucHVzaChuZXcgRmlsdGVyVHJlZSh7XG4gICAgICAgICAgICAgICAgcGFyZW50OiB0aGlzXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmFkZCh7XG4gICAgICAgICAgICAgICAgc3RhdGU6IHsgZWRpdG9yOiBjdHJsLnZhbHVlIH0sXG4gICAgICAgICAgICAgICAgZm9jdXM6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGN0cmwuc2VsZWN0ZWRJbmRleCA9IDA7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBvblRyZWVPcENsaWNrKGV2dCkgeyAvLyBjYWxsZWQgaW4gY29udGV4dFxuICAgIHZhciBjdHJsID0gZXZ0LnRhcmdldDtcblxuICAgIGlmIChjdHJsLmNsYXNzTmFtZSA9PT0gJ2ZpbHRlci10cmVlLW9wLWNob2ljZScpIHtcbiAgICAgICAgdGhpcy5vcGVyYXRvciA9IGN0cmwudmFsdWU7XG5cbiAgICAgICAgLy8gZGlzcGxheSBzdHJpa2UtdGhyb3VnaFxuICAgICAgICB2YXIgcmFkaW9CdXR0b25zID0gdGhpcy5lbC5xdWVyeVNlbGVjdG9yQWxsKCdsYWJlbD5pbnB1dC5maWx0ZXItdHJlZS1vcC1jaG9pY2VbbmFtZT0nICsgY3RybC5uYW1lICsgJ10nKTtcbiAgICAgICAgQXJyYXkucHJvdG90eXBlLmZvckVhY2guY2FsbChyYWRpb0J1dHRvbnMsIGZ1bmN0aW9uKGN0cmwpIHtcbiAgICAgICAgICAgIGN0cmwucGFyZW50RWxlbWVudC5zdHlsZS50ZXh0RGVjb3JhdGlvbiA9IGN0cmwuY2hlY2tlZCA/ICdub25lJyA6ICdsaW5lLXRocm91Z2gnO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBkaXNwbGF5IG9wZXJhdG9yIGJldHdlZW4gZmlsdGVycyBieSBhZGRpbmcgb3BlcmF0b3Igc3RyaW5nIGFzIGEgQ1NTIGNsYXNzIG9mIHRoaXMgdHJlZVxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb3BlcmF0b3JzKSB7XG4gICAgICAgICAgICB0aGlzLmVsLmNsYXNzTGlzdC5yZW1vdmUoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVsLmNsYXNzTGlzdC5hZGQodGhpcy5vcGVyYXRvcik7XG4gICAgfVxufVxuXG4vKipcbiAqIFRocm93cyBlcnJvciBpZiBpbnZhbGlkIGV4cHJlc3Npb24gdHJlZS5cbiAqIENhdWdodCBieSB7QGxpbmsgRmlsdGVyVHJlZSNpbnZhbGlkfEZpbHRlclRyZWUucHJvdG90eXBlLmludmFsaWQoKX0uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmZvY3VzPWZhbHNlXSAtIE1vdmUgZm9jdXMgdG8gb2ZmZW5kaW5nIGNvbnRyb2wuXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfSBpZiB2YWxpZFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaW52YWxpZChvcHRpb25zKSB7IC8vIGNhbGxlZCBpbiBjb250ZXh0XG4gICAgLy9pZiAodGhpcyBpbnN0YW5jZW9mIEZpbHRlclRyZWUgJiYgIXRoaXMuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgLy8gICAgdGhyb3cgbmV3IHRoaXMuRXJyb3IoJ0VtcHR5IHN1YmV4cHJlc3Npb24gKG5vIGZpbHRlcnMpLicpO1xuICAgIC8vfVxuXG4gICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIEZpbHRlckxlYWYpIHtcbiAgICAgICAgICAgIGNoaWxkLmludmFsaWQob3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hpbGQuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICBpbnZhbGlkLmNhbGwoY2hpbGQsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cbkZpbHRlclRyZWUuZXh0ZW5zaW9ucyA9IHtcbiAgICBDb2x1bW5zOiByZXF1aXJlKCcuL2V4dGVuc2lvbnMvY29sdW1ucycpXG59O1xuXG4vLyBtb2R1bGUgaW5pdGlhbGl6YXRpb25cbkZpbHRlclRyZWUucHJvdG90eXBlLnNldENhc2VTZW5zaXRpdml0eSh0cnVlKTsgIC8vIGRlZmF1bHQgaXMgY2FzZS1zZW5zaXRpdmUgd2hpY2ggaXMgbW9yZSBlZmZpY2llbnQ7IG1heSBiZSByZXNldCBhdCB3aWxsXG5cblxubW9kdWxlLmV4cG9ydHMgPSBGaWx0ZXJUcmVlO1xuIiwiLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHRlbXBsZXggPSByZXF1aXJlKCd0ZW1wbGV4Jyk7XG5cbnZhciB0ZW1wbGF0ZXMgPSByZXF1aXJlKCcuLi9odG1sJyk7XG5cbnZhciBlbmNvZGVycyA9IC9cXHsoXFxkKylcXDplbmNvZGVcXH0vZztcblxuZnVuY3Rpb24gVGVtcGxhdGVzKCkge31cbnZhciBjb25zdHJ1Y3RvciA9IFRlbXBsYXRlcy5wcm90b3R5cGUuY29uc3RydWN0b3I7XG5UZW1wbGF0ZXMucHJvdG90eXBlID0gdGVtcGxhdGVzO1xuVGVtcGxhdGVzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGNvbnN0cnVjdG9yOyAvLyByZXN0b3JlIGl0XG5UZW1wbGF0ZXMucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKHRlbXBsYXRlTmFtZSkgeyAvLyBtaXggaXQgaW5cbiAgICB2YXIga2V5cyxcbiAgICAgICAgbWF0Y2hlcyA9IHt9LFxuICAgICAgICB0ZW1wID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksXG4gICAgICAgIHRleHQgPSB0aGlzW3RlbXBsYXRlTmFtZV0sXG4gICAgICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXG4gICAgZW5jb2RlcnMubGFzdEluZGV4ID0gMDtcblxuICAgIHdoaWxlICgoa2V5cyA9IGVuY29kZXJzLmV4ZWModGV4dCkpKSB7XG4gICAgICAgIG1hdGNoZXNba2V5c1sxXV0gPSB0cnVlO1xuICAgIH1cblxuICAgIGtleXMgPSBPYmplY3Qua2V5cyhtYXRjaGVzKTtcblxuICAgIGlmIChrZXlzLmxlbmd0aCkge1xuICAgICAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICB0ZW1wLnRleHRDb250ZW50ID0gYXJnc1trZXldO1xuICAgICAgICAgICAgYXJnc1trZXldID0gdGVtcC5pbm5lckhUTUw7XG4gICAgICAgIH0pO1xuICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKGVuY29kZXJzLCAneyQxfScpO1xuICAgIH1cblxuICAgIHRlbXAuaW5uZXJIVE1MID0gdGVtcGxleC5hcHBseSh0aGlzLCBbdGV4dF0uY29uY2F0KGFyZ3MpKTtcblxuICAgIC8vIGlmIG9ubHkgb25lIEhUTUxFbGVtZW50LCByZXR1cm4gaXQ7IG90aGVyd2lzZSBlbnRpcmUgbGlzdCBvZiBub2Rlc1xuICAgIHJldHVybiB0ZW1wLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiB0ZW1wLmNoaWxkTm9kZXMubGVuZ3RoID09PSAxXG4gICAgICAgID8gdGVtcC5maXJzdENoaWxkXG4gICAgICAgIDogdGVtcC5jaGlsZE5vZGVzO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBUZW1wbGF0ZXM7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBDb25kaXRpb25hbHMgPSByZXF1aXJlKCcuLi9Db25kaXRpb25hbHMnKTtcbnZhciBGaWx0ZXJMZWFmID0gcmVxdWlyZSgnLi4vRmlsdGVyTGVhZicpO1xuXG4vKipcbiAqIEBzdW1tYXJ5IFByb3RvdHlwZSBhZGRpdGlvbnMgb2JqZWN0IGZvciBleHRlbmRpbmcge0BsaW5rIEZpbHRlckxlYWZ9LlxuICogQGRlc2MgUmVzdWx0aW5nIG9iamVjdCBpcyBzaW1pbGFyIHRvIHtAbGluayBGaWx0ZXJMZWFmfSBleGNlcHQ6XG4gKiAxLiBUaGUgYG9wZXJhbmRgIHByb3BlcnR5IG5hbWVzIGFub3RoZXIgY29sdW1uIHJhdGhlciB0aGFuIGNvbnRhaW5zIGEgbGl0ZXJhbC5cbiAqIDIuIE9wZXJhdG9ycyBhcmUgbGltaXRlZCB0byBlcXVhbGl0eSwgaW5lcXVhbGl0aWVzLCBhbmQgc2V0cyAoSU4vTk9UIElOKS4gT21pdHRlZCBhcmUgdGhlIHN0cmluZyBhbmQgcGF0dGVybiBzY2FucyAoQkVHSU5TL05PVCBCRUdJTlMsIEVORFMvTk9UIEVORFMsIENPTlRBSU5TL05PVCBDT05UQUlOUywgYW5kIExJS0UvTk9UIExJS0UpLlxuICpcbiAqIEBleHRlbmRzIEZpbHRlckxlYWZcbiAqXG4gKiBAcHJvcGVydHkge3N0cmluZ30gaWRlbnRpZmllciAtIE5hbWUgb2YgY29sdW1uIChtZW1iZXIgb2YgZGF0YSByb3cgb2JqZWN0KSB0byBjb21wYXJlIGFnYWluc3QgdGhpcyBjb2x1bW4gKG1lbWJlciBvZiBkYXRhIHJvdyBvYmplY3QgbmFtZWQgYnkgYGNvbHVtbmApLlxuICovXG52YXIgQ29sdW1uTGVhZiA9IHtcbiAgICBuYW1lOiAnY29sdW1uID0gY29sdW1uJywgLy8gZGlzcGxheSBzdHJpbmcgZm9yIGRyb3AtZG93blxuXG4gICAgY3JlYXRlVmlldzogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIENyZWF0ZSB0aGUgYHZpZXdgIGhhc2ggYW5kIGluc2VydCB0aGUgdGhyZWUgZGVmYXVsdCBlbGVtZW50cyAoYGNvbHVtbmAsIGBvcGVyYXRvcmAsIGBvcGVyYW5kYCkgaW50byBgLmVsYFxuICAgICAgICBGaWx0ZXJMZWFmLnByb3RvdHlwZS5jcmVhdGVWaWV3LmNhbGwodGhpcyk7XG5cbiAgICAgICAgLy8gUmVwbGFjZSB0aGUgYG9wZXJhbmRgIGVsZW1lbnQgZnJvbSB0aGUgYHZpZXdgIGhhc2hcbiAgICAgICAgdmFyIG9sZE9wZXJhbmQgPSB0aGlzLnZpZXcub3BlcmFuZCxcbiAgICAgICAgICAgIG5ld09wZXJhbmQgPSB0aGlzLnZpZXcub3BlcmFuZCA9IHRoaXMubWFrZUVsZW1lbnQodGhpcy5yb290LnNjaGVtYSwgJ2NvbHVtbicsIHRoaXMuc29ydENvbHVtbk1lbnUpO1xuXG4gICAgICAgIC8vIFJlcGxhY2UgdGhlIG9wZXJhbmQgZWxlbWVudCB3aXRoIHRoZSBuZXcgb25lLiBUaGVyZSBhcmUgbm8gZXZlbnQgbGlzdGVuZXJzIHRvIHdvcnJ5IGFib3V0LlxuICAgICAgICB0aGlzLmVsLnJlcGxhY2VDaGlsZChuZXdPcGVyYW5kLCBvbGRPcGVyYW5kKTtcbiAgICB9LFxuXG4gICAgbWFrZVNxbE9wZXJhbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25kaXRpb25hbHMubWFrZVNxbElkZW50aWZpZXIodGhpcy5vcGVyYW5kKTtcbiAgICB9LFxuXG4gICAgb3BNZW51OiBbXG4gICAgICAgIENvbmRpdGlvbmFscy5ncm91cHMuZXF1YWxpdHksXG4gICAgICAgIENvbmRpdGlvbmFscy5ncm91cHMuaW5lcXVhbGl0aWVzLFxuICAgICAgICBDb25kaXRpb25hbHMuZ3JvdXBzLnNldHNcbiAgICBdLFxuXG4gICAgcTogZnVuY3Rpb24oZGF0YVJvdykge1xuICAgICAgICByZXR1cm4gdGhpcy52YWxPckZ1bmMoZGF0YVJvdywgdGhpcy5vcGVyYW5kKTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbHVtbkxlYWY7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciByZU9wID0gL14oKD18Pj0/fDxbPj1dPyl8KE5PVCApPyhMSUtFfElOKVxcYikvaSwgLy8gbWF0Y2hbMV1cbiAgICByZUxpdCA9IC9eJyhcXGQrKScvLFxuICAgIHJlTGl0QW55d2hlcmUgPSAvJyhcXGQrKScvLFxuICAgIHJlSW4gPSAvXlxcKCguKj8pXFwpLyxcbiAgICByZUJvb2wgPSAvXihBTkR8T1IpXFxiL2ksXG4gICAgcmVHcm91cCA9IC9eKE5PVCA/KT9cXCgvaTtcblxudmFyIFNRVCA9ICdcXCcnO1xuXG52YXIgZGVmYXVsdElkUXRzID0ge1xuICAgIGJlZzogJ1wiJyxcbiAgICBlbmQ6ICdcIidcbn07XG5cbmZ1bmN0aW9uIFBhcnNlclNxbEVycm9yKG1lc3NhZ2UpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xufVxuUGFyc2VyU3FsRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuUGFyc2VyU3FsRXJyb3IucHJvdG90eXBlLm5hbWUgPSAnUGFyc2VyU3FsRXJyb3InO1xuXG4vKiogQHR5cGVkZWYge29iamVjdH0gc3FsSWRRdHNPYmplY3RcbiAqIEBkZXNjIE9uIGEgcHJhY3RpY2FsIGxldmVsLCB0aGUgdXNlZnVsIGNoYXJhY3RlcnMgYXJlOlxuICogKiBTUUwtOTIgc3RhbmRhcmQ6IFwiZG91YmxlIHF1b3Rlc1wiXG4gKiAqIFNRTCBTZXJ2ZXI6IFwiZG91YmxlIHF1b3Rlc1wiIG9yIFxcW3NxdWFyZSBicmFja2V0c1xcXVxuICogKiBteVNRTDogXFxgdGljayBtYXJrc1xcYFxuICogQHByb3BlcnR5IHtzdHJpbmd9IGJlZyAtIFRoZSBvcGVuIHF1b3RlIGNoYXJhY3Rlci5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBlbmQgLSBUaGUgY2xvc2UgcXVvdGUgY2hhcmFjdGVyLlxuICovXG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAc3VtbWFyeSBTdHJ1Y3R1cmVkIFF1ZXJ5IExhbmd1YWdlIChTUUwpIHBhcnNlclxuICogQGF1dGhvciBKb25hdGhhbiBFaXRlbiA8am9uYXRoYW5Ab3BlbmZpbi5jb20+XG4gKiBAZGVzYyBUaGlzIGlzIGEgc3Vic2V0IG9mIFNRTCBjb25kaXRpb25hbCBleHByZXNzaW9uIHN5bnRheC5cbiAqXG4gKiBAc2VlIHtAbGluayBodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L21zMTczNTQ1LmFzcHggU1FMIFNlYXJjaCBDb25kaXRpb259XG4gKlxuICogQHBhcmFtIHttZW51SXRlbVtdfSBbb3B0aW9ucy5zY2hlbWFdIC0gQ29sdW1uIHNjaGVtYSBmb3IgY29sdW1uIG5hbWUgdmFsaWRhdGlvbi4gVGhyb3dzIGFuIGVycm9yIGlmIG5hbWUgZmFpbHMgdmFsaWRhdGlvbiAoYnV0IHNlZSBgcmVzb2x2ZUFsaWFzZXNgKS4gT21pdCB0byBza2lwIGNvbHVtbiBuYW1lIHZhbGlkYXRpb24uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnJlc29sdmVBbGlhc2VzXSAtIFZhbGlkYXRlIGNvbHVtbiBhbGlhc2VzIGFnYWluc3Qgc2NoZW1hIGFuZCB1c2UgdGhlIGFzc29jaWF0ZWQgY29sdW1uIG5hbWUgaW4gdGhlIHJldHVybmVkIGV4cHJlc3Npb24gc3RhdGUgb2JqZWN0LiBSZXF1aXJlcyBgb3B0aW9ucy5zY2hlbWFgLiBUaHJvd3MgZXJyb3IgaWYgbm8gc3VjaCBjb2x1bW4gZm91bmQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNhc2VTZW5zaXRpdmVDb2x1bW5OYW1lc10gLSBJZ25vcmUgY2FzZSB3aGlsZSB2YWxpZGF0aW5nIGNvbHVtbiBuYW1lcyBhbmQgYWxpYXNlcy5cbiAqIEBwYXJhbSB7c3FsSWRRdHNPYmplY3R9IFtvcHRpb25zLnNxbElkUXRzPXtiZWc6J1wiJyxlbmQ6J1wiJ31dXG4gKi9cbmZ1bmN0aW9uIFBhcnNlclNRTChvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICB0aGlzLnNjaGVtYSA9IG9wdGlvbnMuc2NoZW1hO1xuXG4gICAgdmFyIGlkUXRzID0gb3B0aW9ucy5zcWxJZFF0cyB8fCBkZWZhdWx0SWRRdHM7XG4gICAgdGhpcy5yZU5hbWUgPSBuZXcgUmVnRXhwKCdeKCcgKyBpZFF0cy5iZWcgKyAnKC4rPyknICsgaWRRdHMuZW5kICsgJ3woW0EtWl9dW0EtWl9AXFxcXCQjXSopXFxcXGIpJywgJ2knKTsgLy8gbWF0Y2hbMl0gfHwgbWF0Y2hbM11cbn1cblxuUGFyc2VyU1FMLnByb3RvdHlwZSA9IHtcblxuICAgIGNvbnN0cnVjdG9yOiBQYXJzZXJTUUwucHJvdG90eXBlLmNvbnN0cnVjdG9yLFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNxbFxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6c3FsU2VhcmNoQ29uZGl0aW9uXG4gICAgICovXG4gICAgcGFyc2U6IGZ1bmN0aW9uKHNxbCkge1xuICAgICAgICB2YXIgc3RhdGU7XG5cbiAgICAgICAgLy8gcmVkdWNlIGFsbCBydW5zIG9mIHdoaXRlIHNwYWNlIHRvIGEgc2luZ2xlIHNwYWNlOyB0aGVuIHRyaW1cbiAgICAgICAgc3FsID0gc3FsLnJlcGxhY2UoL1xcc1xccysvZywgJyAnKS50cmltKCk7XG5cbiAgICAgICAgc3FsID0gc3RyaXBMaXRlcmFscy5jYWxsKHRoaXMsIHNxbCk7XG4gICAgICAgIHN0YXRlID0gd2Fsay5jYWxsKHRoaXMsIHNxbCk7XG5cbiAgICAgICAgaWYgKCFzdGF0ZS5jaGlsZHJlbikge1xuICAgICAgICAgICAgc3RhdGUgPSB7IGNoaWxkcmVuOiBbIHN0YXRlIF0gfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG59O1xuXG5mdW5jdGlvbiB3YWxrKHQpIHtcbiAgICB2YXIgbSwgbmFtZSwgb3AsIG9wZXJhbmQsIGJvb2wsIHRva2VuLCB0b2tlbnMgPSBbXTtcbiAgICB2YXIgaSA9IDA7XG5cbiAgICB0ID0gdC50cmltKCk7XG5cbiAgICB3aGlsZSAoaSA8IHQubGVuZ3RoKSB7XG4gICAgICAgIG0gPSB0LnN1YnN0cihpKS5tYXRjaChyZUdyb3VwKTtcbiAgICAgICAgaWYgKG0pIHtcbiAgICAgICAgICAgIHZhciBub3QgPSAhIW1bMV07XG5cbiAgICAgICAgICAgIGkgKz0gbVswXS5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gaSwgdiA9IDE7IGogPCB0Lmxlbmd0aCAmJiB2OyArK2opIHtcbiAgICAgICAgICAgICAgICBpZiAodFtqXSA9PT0gJygnKSB7XG4gICAgICAgICAgICAgICAgICAgICsrdjtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRbal0gPT09ICcpJykge1xuICAgICAgICAgICAgICAgICAgICAtLXY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBQYXJzZXJTcWxFcnJvcignRXhwZWN0ZWQgXCIpXCInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRva2VuID0gd2Fsay5jYWxsKHRoaXMsIHQuc3Vic3RyKGksIGogLSAxIC0gaSkpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0b2tlbiAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChub3QpIHtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4ub3BlcmF0b3IgIT09ICdvcC1vcicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFBhcnNlclNxbEVycm9yKCdFeHBlY3RlZCBPUiBpbiBOT1QoLi4uKSBzdWJleHByZXNzaW9uIGJ1dCBmb3VuZCAnICsgdG9rZW4ub3BlcmF0b3Iuc3Vic3RyKDMpLnRvVXBwZXJDYXNlKCkgKyAnLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0b2tlbi5vcGVyYXRvciA9ICdvcC1ub3InO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpID0gajtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG0gPSB0LnN1YnN0cihpKS5tYXRjaCh0aGlzLnJlTmFtZSk7XG4gICAgICAgICAgICBpZiAoIW0pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VyU3FsRXJyb3IoJ0V4cGVjdGVkIGlkZW50aWZpZXIgb3IgcXVvdGVkIGlkZW50aWZpZXIuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuYW1lID0gbVsyXSB8fCBtWzNdO1xuICAgICAgICAgICAgaWYgKCEvXltBLVpfXS9pLnRlc3QodFtpXSkpIHsgaSArPSAyOyB9XG4gICAgICAgICAgICBpICs9IG5hbWUubGVuZ3RoO1xuXG4gICAgICAgICAgICBpZiAodFtpXSA9PT0gJyAnKSB7ICsraTsgfVxuICAgICAgICAgICAgbSA9IHQuc3Vic3RyKGkpLm1hdGNoKHJlT3ApO1xuICAgICAgICAgICAgaWYgKCFtKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFBhcnNlclNxbEVycm9yKCdFeHBlY3RlZCByZWxhdGlvbmFsIG9wZXJhdG9yLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBtWzFdLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICBpICs9IG9wLmxlbmd0aDtcblxuICAgICAgICAgICAgaWYgKHRbaV0gPT09ICcgJykgeyArK2k7IH1cbiAgICAgICAgICAgIGlmIChtWzRdICYmIG1bNF0udG9VcHBlckNhc2UoKSA9PT0gJ0lOJykge1xuICAgICAgICAgICAgICAgIG0gPSB0LnN1YnN0cihpKS5tYXRjaChyZUluKTtcbiAgICAgICAgICAgICAgICBpZiAoIW0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFBhcnNlclNxbEVycm9yKCdFeHBlY3RlZCBwYXJlbnRoZXNpemVkIGxpc3QuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9wZXJhbmQgPSBtWzFdO1xuICAgICAgICAgICAgICAgIGkgKz0gb3BlcmFuZC5sZW5ndGggKyAyO1xuICAgICAgICAgICAgICAgIHdoaWxlICgobSA9IG9wZXJhbmQubWF0Y2gocmVMaXRBbnl3aGVyZSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wZXJhbmQgPSBvcGVyYW5kLnJlcGxhY2UocmVMaXRBbnl3aGVyZSwgdGhpcy5saXRlcmFsc1ttWzFdXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtID0gdC5zdWJzdHIoaSkubWF0Y2gocmVMaXQpO1xuICAgICAgICAgICAgICAgIGlmICghbSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VyU3FsRXJyb3IoJ0V4cGVjdGVkIHN0cmluZyBsaXRlcmFsLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvcGVyYW5kID0gbVsxXTtcbiAgICAgICAgICAgICAgICBpICs9IG9wZXJhbmQubGVuZ3RoICsgMjtcbiAgICAgICAgICAgICAgICBvcGVyYW5kID0gdGhpcy5saXRlcmFsc1tvcGVyYW5kXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuc2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLnNjaGVtYS5sb29rdXAobmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9IGl0ZW0ubmFtZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VyU3FsRXJyb3IodGhpcy5yZXNvbHZlQWxpYXNlc1xuICAgICAgICAgICAgICAgICAgICAgICAgPyAnRXhwZWN0ZWQgdmFsaWQgY29sdW1uIG5hbWUuJ1xuICAgICAgICAgICAgICAgICAgICAgICAgOiAnRXhwZWN0ZWQgdmFsaWQgY29sdW1uIG5hbWUgb3IgYWxpYXMuJ1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdG9rZW4gPSB7XG4gICAgICAgICAgICAgICAgY29sdW1uOiBuYW1lLFxuICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBvcCxcbiAgICAgICAgICAgICAgICBvcGVyYW5kOiBvcGVyYW5kXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuXG4gICAgICAgIGlmIChpIDwgdC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICh0W2ldID09PSAnICcpIHsgKytpOyB9XG4gICAgICAgICAgICBtID0gdC5zdWJzdHIoaSkubWF0Y2gocmVCb29sKTtcbiAgICAgICAgICAgIGlmICghbSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBQYXJzZXJTcWxFcnJvcignRXhwZWN0ZWQgYm9vbGVhbiBvcGVhcmF0b3IuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBib29sID0gbVsxXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgaSArPSBib29sLmxlbmd0aDtcbiAgICAgICAgICAgIGJvb2wgPSAnb3AtJyArIGJvb2w7XG4gICAgICAgICAgICBpZiAodG9rZW5zLm9wZXJhdG9yICYmIHRva2Vucy5vcGVyYXRvciAhPT0gYm9vbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBQYXJzZXJTcWxFcnJvcignRXhwZWN0ZWQgc2FtZSBib29sZWFuIG9wZXJhdG9yIHRocm91Z2hvdXQgc3ViZXhwcmVzc2lvbi4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRva2Vucy5vcGVyYXRvciA9IGJvb2w7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodFtpXSA9PT0gJyAnKSB7ICsraTsgfVxuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICAgIHRva2Vucy5sZW5ndGggPT09IDEgPyB0b2tlbnNbMF0gOiB7XG4gICAgICAgICAgICBvcGVyYXRvcjogdG9rZW5zLm9wZXJhdG9yLFxuICAgICAgICAgICAgY2hpbGRyZW46IHRva2Vuc1xuICAgICAgICB9XG4gICAgKTtcbn1cblxuZnVuY3Rpb24gc3RyaXBMaXRlcmFscyh0KSB7XG4gICAgdmFyIGkgPSAwLCBqID0gMCwgaztcblxuICAgIHRoaXMubGl0ZXJhbHMgPSBbXTtcblxuICAgIHdoaWxlICgoaiA9IHQuaW5kZXhPZihTUVQsIGopKSA+PSAwKSB7XG4gICAgICAgIGsgPSBqO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBrID0gdC5pbmRleE9mKFNRVCwgayArIDEpO1xuICAgICAgICAgICAgaWYgKGsgPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFBhcnNlclNxbEVycm9yKCdFeHBlY3RlZCAnICsgU1FUICsgJyAoc2luZ2xlIHF1b3RlKS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAodFsrK2tdID09PSBTUVQpO1xuICAgICAgICB0aGlzLmxpdGVyYWxzLnB1c2godC5zbGljZSgrK2osIC0taykucmVwbGFjZSgvJycvZywgU1FUKSk7XG4gICAgICAgIHQgPSB0LnN1YnN0cigwLCBqKSArIGkgKyB0LnN1YnN0cihrKTtcbiAgICAgICAgaiA9IGogKyAxICsgKGkgKyAnJykubGVuZ3RoICsgMTtcbiAgICAgICAgaSsrO1xuICAgIH1cblxuICAgIHJldHVybiB0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFBhcnNlclNRTDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGNzc0luamVjdG9yID0gcmVxdWlyZSgnY3NzLWluamVjdG9yJyk7XG5cbnZhciBjc3M7IC8vIGRlZmluZWQgYnkgY29kZSBpbnNlcnRlZCBieSBndWxwZmlsZSBiZXR3ZWVuIGZvbGxvd2luZyBjb21tZW50c1xuLyogaW5qZWN0OmNzcyAqL1xuY3NzID0gJy5maWx0ZXItdHJlZXtmb250LWZhbWlseTpzYW5zLXNlcmlmO2ZvbnQtc2l6ZToxMHB0O2xpbmUtaGVpZ2h0OjEuNWVtfS5maWx0ZXItdHJlZSBsYWJlbHtmb250LXdlaWdodDo0MDB9LmZpbHRlci10cmVlIGlucHV0W3R5cGU9Y2hlY2tib3hdLC5maWx0ZXItdHJlZSBpbnB1dFt0eXBlPXJhZGlvXXttYXJnaW4tbGVmdDozcHg7bWFyZ2luLXJpZ2h0OjNweH0uZmlsdGVyLXRyZWUgb2x7bWFyZ2luLXRvcDowfS5maWx0ZXItdHJlZT5zZWxlY3R7ZmxvYXQ6cmlnaHQ7Ym9yZGVyOjFweCBkb3R0ZWQgZ3JleTtiYWNrZ3JvdW5kLWNvbG9yOnRyYW5zcGFyZW50O2JveC1zaGFkb3c6bm9uZX0uZmlsdGVyLXRyZWUtcmVtb3ZlLWJ1dHRvbntkaXNwbGF5OmlubGluZS1ibG9jazt3aWR0aDoxNXB4O2hlaWdodDoxNXB4O2JvcmRlci1yYWRpdXM6OHB4O2JhY2tncm91bmQtY29sb3I6I2U4ODtmb250LXNpemU6MTEuNXB4O2NvbG9yOiNmZmY7dGV4dC1hbGlnbjpjZW50ZXI7bGluZS1oZWlnaHQ6bm9ybWFsO2ZvbnQtc3R5bGU6bm9ybWFsO2ZvbnQtZmFtaWx5OnNhbnMtc2VyaWY7bWFyZ2luLXJpZ2h0OjRweDtjdXJzb3I6cG9pbnRlcn0uZmlsdGVyLXRyZWUtcmVtb3ZlLWJ1dHRvbjpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOnRyYW5zcGFyZW50O2NvbG9yOiNlODg7Zm9udC13ZWlnaHQ6NzAwO2JveC1zaGFkb3c6cmVkIDAgMCAycHggaW5zZXR9LmZpbHRlci10cmVlLXJlbW92ZS1idXR0b246OmJlZm9yZXtjb250ZW50OlxcJ1xcXFxkN1xcJ30uZmlsdGVyLXRyZWUgbGk6OmFmdGVye2ZvbnQtc2l6ZTo3MCU7Zm9udC1zdHlsZTppdGFsaWM7Zm9udC13ZWlnaHQ6NzAwO2NvbG9yOiMwODB9LmZpbHRlci10cmVlPm9sPmxpOmxhc3QtY2hpbGQ6OmFmdGVye2Rpc3BsYXk6bm9uZX0ub3AtYW5kPm9sLC5vcC1ub3I+b2wsLm9wLW9yPm9se3BhZGRpbmctbGVmdDo1cHg7bWFyZ2luLWxlZnQ6MjdweH0ub3Atb3I+b2w+bGk6OmFmdGVye21hcmdpbi1sZWZ0OjIuNWVtO2NvbnRlbnQ6XFwn4oCUIE9SIOKAlFxcJ30ub3AtYW5kPm9sPmxpOjphZnRlcnttYXJnaW4tbGVmdDoyLjVlbTtjb250ZW50OlxcJ+KAlCBBTkQg4oCUXFwnfS5vcC1ub3I+b2w+bGk6OmFmdGVye21hcmdpbi1sZWZ0OjIuNWVtO2NvbnRlbnQ6XFwn4oCUIE5PUiDigJRcXCd9LmZpbHRlci10cmVlLWVkaXRvcj4qe2ZvbnQtd2VpZ2h0OjcwMH0uZmlsdGVyLXRyZWUtZWRpdG9yPnNwYW57Zm9udC1zaXplOnNtYWxsZXJ9LmZpbHRlci10cmVlLWVkaXRvcj5pbnB1dFt0eXBlPXRleHRde3dpZHRoOjhlbTtwYWRkaW5nOjFweCA1cHggMnB4fS5maWx0ZXItdHJlZS13YXJuaW5ne2JhY2tncm91bmQtY29sb3I6I2ZmYyFpbXBvcnRhbnQ7Ym9yZGVyLWNvbG9yOiNlZGIhaW1wb3J0YW50O2ZvbnQtd2VpZ2h0OjQwMCFpbXBvcnRhbnR9LmZpbHRlci10cmVlLWVycm9ye2JhY2tncm91bmQtY29sb3I6I2ZjYyFpbXBvcnRhbnQ7Ym9yZGVyLWNvbG9yOiNjOTkhaW1wb3J0YW50O2ZvbnQtd2VpZ2h0OjQwMCFpbXBvcnRhbnR9LmZpbHRlci10cmVlLWRlZmF1bHQ+OmVuYWJsZWR7bWFyZ2luOjAgLjRlbTtiYWNrZ3JvdW5kLWNvbG9yOiNkZGQ7Ym9yZGVyOjFweCBzb2xpZCB0cmFuc3BhcmVudH0uZmlsdGVyLXRyZWUuZmlsdGVyLXRyZWUtdHlwZS1jb2x1bW4tZmlsdGVycz5vbD5saTpub3QoOmxhc3QtY2hpbGQpe3BhZGRpbmctYm90dG9tOi43NWVtO2JvcmRlci1ib3R0b206M3B4IGRvdWJsZSAjMDgwO21hcmdpbi1ib3R0b206Ljc1ZW19LmZpbHRlci10cmVlIC5mb290bm90ZXN7bWFyZ2luOjAgMCA2cHg7Zm9udC1zaXplOjhwdDtmb250LXdlaWdodDo0MDA7bGluZS1oZWlnaHQ6bm9ybWFsO3doaXRlLXNwYWNlOm5vcm1hbDtjb2xvcjojYzAwfS5maWx0ZXItdHJlZSAuZm9vdG5vdGVzPnB7bWFyZ2luOjB9LmZpbHRlci10cmVlIC5mb290bm90ZXM+dWx7bWFyZ2luOi0zcHggMCAwO3BhZGRpbmctbGVmdDoxN3B4O3RleHQtaW5kZXg6LTZweH0uZmlsdGVyLXRyZWUgLmZvb3Rub3Rlcz51bD5saXttYXJnaW46MnB4IDB9LmZpbHRlci10cmVlIC5mb290bm90ZXMgLmZpZWxkLW5hbWUsLmZpbHRlci10cmVlIC5mb290bm90ZXMgLmZpZWxkLXZhbHVle2ZvbnQtd2VpZ2h0OjcwMDtmb250LXN0eWxlOm5vcm1hbH0uZmlsdGVyLXRyZWUgLmZvb3Rub3RlcyAuZmllbGQtdmFsdWV7Zm9udC1mYW1pbHk6bW9ub3NwYWNlO2NvbG9yOiMwMDA7YmFja2dyb3VuZC1jb2xvcjojZGRkO3BhZGRpbmc6MCA1cHg7bWFyZ2luOjAgM3B4O2JvcmRlci1yYWRpdXM6M3B4fSc7XG4vKiBlbmRpbmplY3QgKi9cblxubW9kdWxlLmV4cG9ydHMgPSBjc3NJbmplY3Rvci5iaW5kKHRoaXMsIGNzcywgJ2ZpbHRlci10cmVlLWJhc2UnKTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqIEB0eXBlZGVmIHtmdW5jdGlvbn0gb3BlcmF0aW9uUmVkdWNlclxuICogQHBhcmFtIHtib29sZWFufSBwXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHFcbiAqIEByZXR1cm5zIHtib29sZWFufSBUaGUgcmVzdWx0IG9mIGFwcGx5aW5nIHRoZSBvcGVyYXRvciB0byB0aGUgdHdvIHBhcmFtZXRlcnMuXG4gKi9cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQHR5cGUge29wZXJhdGlvblJlZHVjZXJ9XG4gKi9cbmZ1bmN0aW9uIEFORChwLCBxKSB7XG4gICAgcmV0dXJuIHAgJiYgcTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQHR5cGUge29wZXJhdGlvblJlZHVjZXJ9XG4gKi9cbmZ1bmN0aW9uIE9SKHAsIHEpIHtcbiAgICByZXR1cm4gcCB8fCBxO1xufVxuXG4vKiogQHR5cGVkZWYge29iZWpjdH0gdHJlZU9wZXJhdG9yXG4gKiBAZGVzYyBFYWNoIGB0cmVlT3BlcmF0b3JgIG9iamVjdCBkZXNjcmliZXMgdHdvIHRoaW5nczpcbiAqXG4gKiAxLiBIb3cgdG8gdGFrZSB0aGUgdGVzdCByZXN1bHRzIG9mIF9uXyBjaGlsZCBub2RlcyBieSBhcHBseWluZyB0aGUgb3BlcmF0b3IgdG8gYWxsIHRoZSByZXN1bHRzIHRvIFwicmVkdWNlXCIgaXQgZG93biB0byBhIHNpbmdsZSByZXN1bHQuXG4gKiAyLiBIb3cgdG8gZ2VuZXJhdGUgU1FMIFdIRVJFIGNsYXVzZSBzeW50YXggdGhhdCBhcHBsaWVzIHRoZSBvcGVyYXRvciB0byBfbl8gY2hpbGQgbm9kZXMuXG4gKlxuICogQHByb3BlcnR5IHtvcGVyYXRpb25SZWR1Y2VyfSByZWR1Y2VcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gc2VlZCAtXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGFib3J0IC1cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gbmVnYXRlIC1cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBTUUwub3AgLVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFNRTC5iZWcgLVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFNRTC5lbmQgLVxuICovXG5cbi8qKiBBIGhhc2ggb2Yge0BsaW5rIHRyZWVPcGVyYXRvcn0gb2JqZWN0cy5cbiAqIEB0eXBlIHtvYmplY3R9XG4gKi9cbnZhciB0cmVlT3BlcmF0b3JzID0ge1xuICAgICdvcC1hbmQnOiB7XG4gICAgICAgIHJlZHVjZTogQU5ELFxuICAgICAgICBzZWVkOiB0cnVlLFxuICAgICAgICBhYm9ydDogZmFsc2UsXG4gICAgICAgIG5lZ2F0ZTogZmFsc2UsXG4gICAgICAgIFNRTDoge1xuICAgICAgICAgICAgb3A6ICdBTkQnLFxuICAgICAgICAgICAgYmVnOiAnKCcsXG4gICAgICAgICAgICBlbmQ6ICcpJ1xuICAgICAgICB9XG4gICAgfSxcbiAgICAnb3Atb3InOiB7XG4gICAgICAgIHJlZHVjZTogT1IsXG4gICAgICAgIHNlZWQ6IGZhbHNlLFxuICAgICAgICBhYm9ydDogdHJ1ZSxcbiAgICAgICAgbmVnYXRlOiBmYWxzZSxcbiAgICAgICAgU1FMOiB7XG4gICAgICAgICAgICBvcDogJ09SJyxcbiAgICAgICAgICAgIGJlZzogJygnLFxuICAgICAgICAgICAgZW5kOiAnKSdcbiAgICAgICAgfVxuICAgIH0sXG4gICAgJ29wLW5vcic6IHtcbiAgICAgICAgcmVkdWNlOiBPUixcbiAgICAgICAgc2VlZDogZmFsc2UsXG4gICAgICAgIGFib3J0OiB0cnVlLFxuICAgICAgICBuZWdhdGU6IHRydWUsXG4gICAgICAgIFNRTDoge1xuICAgICAgICAgICAgb3A6ICdPUicsXG4gICAgICAgICAgICBiZWc6ICdOT1QgKCcsXG4gICAgICAgICAgICBlbmQ6ICcpJ1xuICAgICAgICB9XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB0cmVlT3BlcmF0b3JzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKiBlc2xpbnQtZW52IG5vZGUsIGJyb3dzZXIgKi9cblxudmFyIGNzc0luamVjdG9yID0gcmVxdWlyZSgnY3NzLWluamVjdG9yJyk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yIEZpbkJhclxuICogQHN1bW1hcnkgQ3JlYXRlIGEgc2Nyb2xsYmFyIG9iamVjdC5cbiAqIEBkZXNjIENyZWF0aW5nIGEgc2Nyb2xsYmFyIGlzIGEgdGhyZWUtc3RlcCBwcm9jZXNzOlxuICpcbiAqIDEuIEluc3RhbnRpYXRlIHRoZSBzY3JvbGxiYXIgb2JqZWN0IGJ5IGNhbGxpbmcgdGhpcyBjb25zdHJ1Y3RvciBmdW5jdGlvbi4gVXBvbiBpbnN0YW50aWF0aW9uLCB0aGUgRE9NIGVsZW1lbnQgZm9yIHRoZSBzY3JvbGxiYXIgKHdpdGggYSBzaW5nbGUgY2hpbGQgZWxlbWVudCBmb3IgdGhlIHNjcm9sbGJhciBcInRodW1iXCIpIGlzIGNyZWF0ZWQgYnV0IGlzIG5vdCBpbnNlcnQgaXQgaW50byB0aGUgRE9NLlxuICogMi4gQWZ0ZXIgaW5zdGFudGlhdGlvbiwgaXQgaXMgdGhlIGNhbGxlcidzIHJlc3BvbnNpYmlsaXR5IHRvIGluc2VydCB0aGUgc2Nyb2xsYmFyLCB7QGxpbmsgRmluQmFyI2Jhcnx0aGlzLmJhcn0sIGludG8gdGhlIERPTS5cbiAqIDMuIEFmdGVyIGluc2VydGlvbiwgdGhlIGNhbGxlciBtdXN0IGNhbGwge0BsaW5rIEZpbkJhciNyZXNpemV8cmVzaXplKCl9IGF0IGxlYXN0IG9uY2UgdG8gc2l6ZSBhbmQgcG9zaXRpb24gdGhlIHNjcm9sbGJhciBhbmQgaXRzIHRodW1iLiBBZnRlciB0aGF0LCBgcmVzaXplKClgIHNob3VsZCBhbHNvIGJlIGNhbGxlZCByZXBlYXRlZGx5IG9uIHJlc2l6ZSBldmVudHMgKGFzIHRoZSBjb250ZW50IGVsZW1lbnQgaXMgYmVpbmcgcmVzaXplZCkuXG4gKlxuICogU3VnZ2VzdGVkIGNvbmZpZ3VyYXRpb25zOlxuICogKiBfKipVbmJvdW5kKipfPGJyLz5cbiAqIFRoZSBzY3JvbGxiYXIgc2VydmVzIG1lcmVseSBhcyBhIHNpbXBsZSByYW5nZSAoc2xpZGVyKSBjb250cm9sLiBPbWl0IGJvdGggYG9wdGlvbnMub25jaGFuZ2VgIGFuZCBgb3B0aW9ucy5jb250ZW50YC5cbiAqICogXyoqQm91bmQgdG8gdmlydHVhbCBjb250ZW50IGVsZW1lbnQqKl88YnIvPlxuICogVmlydHVhbCBjb250ZW50IGlzIHByb2plY3RlZCBpbnRvIHRoZSBlbGVtZW50IHVzaW5nIGEgY3VzdG9tIGV2ZW50IGhhbmRsZXIgc3VwcGxpZWQgYnkgdGhlIHByb2dyYW1tZXIgaW4gYG9wdGlvbnMub25jaGFuZ2VgLiBBIHR5cGljYWwgdXNlIGNhc2Ugd291bGQgYmUgdG8gaGFuZGxlIHNjcm9sbGluZyBvZiB0aGUgdmlydHVhbCBjb250ZW50LiBPdGhlciB1c2UgY2FzZXMgaW5jbHVkZSBkYXRhIHRyYW5zZm9ybWF0aW9ucywgZ3JhcGhpY3MgdHJhbnNmb3JtYXRpb25zLCBfZXRjLl9cbiAqICogXyoqQm91bmQgdG8gcmVhbCBjb250ZW50KipfPGJyLz5cbiAqIFNldCBgb3B0aW9ucy5jb250ZW50YCB0byB0aGUgXCJyZWFsXCIgY29udGVudCBlbGVtZW50IGJ1dCBvbWl0IGBvcHRpb25zLm9uY2hhbmdlYC4gVGhpcyB3aWxsIGNhdXNlIHRoZSBzY3JvbGxiYXIgdG8gdXNlIHRoZSBidWlsdC1pbiBldmVudCBoYW5kbGVyIChgdGhpcy5zY3JvbGxSZWFsQ29udGVudGApIHdoaWNoIGltcGxlbWVudHMgc21vb3RoIHNjcm9sbGluZyBvZiB0aGUgY29udGVudCBlbGVtZW50IHdpdGhpbiB0aGUgY29udGFpbmVyLlxuICpcbiAqIEBwYXJhbSB7ZmluYmFyT3B0aW9uc30gW29wdGlvbnM9e31dIC0gT3B0aW9ucyBvYmplY3QuIFNlZSB0aGUgdHlwZSBkZWZpbml0aW9uIGZvciBtZW1iZXIgZGV0YWlscy5cbiAqL1xuZnVuY3Rpb24gRmluQmFyKG9wdGlvbnMpIHtcblxuICAgIC8vIG1ha2UgYm91bmQgdmVyc2lvbnMgb2YgYWxsIHRoZSBtb3VzZSBldmVudCBoYW5kbGVyXG4gICAgdmFyIGJvdW5kID0gdGhpcy5fYm91bmQgPSB7fTtcbiAgICBmb3IgKGtleSBpbiBoYW5kbGVyc1RvQmVCb3VuZCkge1xuICAgICAgICBib3VuZFtrZXldID0gaGFuZGxlcnNUb0JlQm91bmRba2V5XS5iaW5kKHRoaXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBuYW1lIHRodW1iXG4gICAgICogQHN1bW1hcnkgVGhlIGdlbmVyYXRlZCBzY3JvbGxiYXIgdGh1bWIgZWxlbWVudC5cbiAgICAgKiBAZGVzYyBUaGUgdGh1bWIgZWxlbWVudCdzIHBhcmVudCBlbGVtZW50IGlzIGFsd2F5cyB0aGUge0BsaW5rIEZpbkJhciNiYXJ8YmFyfSBlbGVtZW50LlxuICAgICAqXG4gICAgICogVGhpcyBwcm9wZXJ0eSBpcyB0eXBpY2FsbHkgcmVmZXJlbmNlZCBpbnRlcm5hbGx5IG9ubHkuIFRoZSBzaXplIGFuZCBwb3NpdGlvbiBvZiB0aGUgdGh1bWIgZWxlbWVudCBpcyBtYWludGFpbmVkIGJ5IGBfY2FsY1RodW1iKClgLlxuICAgICAqIEB0eXBlIHtFbGVtZW50fVxuICAgICAqIEBtZW1iZXJPZiBGaW5CYXIucHJvdG90eXBlXG4gICAgICovXG4gICAgdmFyIHRodW1iID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGh1bWIuY2xhc3NMaXN0LmFkZCgndGh1bWInKTtcbiAgICB0aHVtYi5vbmNsaWNrID0gYm91bmQuc2hvcnRTdG9wO1xuICAgIHRodW1iLm9ubW91c2VvdmVyID0gYm91bmQub25tb3VzZW92ZXI7XG4gICAgdGhpcy50aHVtYiA9IHRodW1iO1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgYmFyXG4gICAgICogQHN1bW1hcnkgVGhlIGdlbmVyYXRlZCBzY3JvbGxiYXIgZWxlbWVudC5cbiAgICAgKiBAZGVzYyBUaGUgY2FsbGVyIGluc2VydHMgdGhpcyBlbGVtZW50IGludG8gdGhlIERPTSAodHlwaWNhbGx5IGludG8gdGhlIGNvbnRlbnQgY29udGFpbmVyKSBhbmQgdGhlbiBjYWxscyBpdHMge0BsaW5rIEZpbkJhciNyZXNpemV8cmVzaXplKCl9IG1ldGhvZC5cbiAgICAgKlxuICAgICAqIFRodXMgdGhlIG5vZGUgdHJlZSBpcyB0eXBpY2FsbHk6XG4gICAgICogKiBBICoqY29udGVudCBjb250YWluZXIqKiBlbGVtZW50LCB3aGljaCBjb250YWluczpcbiAgICAgKiAgICAqIFRoZSBjb250ZW50IGVsZW1lbnQocylcbiAgICAgKiAgICAqIFRoaXMgKipzY3JvbGxiYXIgZWxlbWVudCoqLCB3aGljaCBpbiB0dXJuIGNvbnRhaW5zOlxuICAgICAqICAgICAgICAqIFRoZSAqKnRodW1iIGVsZW1lbnQqKlxuICAgICAqXG4gICAgICogQHR5cGUge0VsZW1lbnR9XG4gICAgICogQG1lbWJlck9mIEZpbkJhci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICB2YXIgYmFyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICBiYXIuY2xhc3NMaXN0LmFkZCgnZmluYmFyLXZlcnRpY2FsJyk7XG5cbiAgICBiYXIuYXBwZW5kQ2hpbGQodGh1bWIpO1xuICAgIGlmICh0aGlzLnBhZ2luZykge1xuICAgICAgICBiYXIub25jbGljayA9IGJvdW5kLm9uY2xpY2s7XG4gICAgfVxuICAgIHRoaXMuYmFyID0gYmFyO1xuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAvLyBwcmVzZXRzXG4gICAgdGhpcy5vcmllbnRhdGlvbiA9ICd2ZXJ0aWNhbCc7XG4gICAgdGhpcy5fbWluID0gdGhpcy5faW5kZXggPSAwO1xuICAgIHRoaXMuX21heCA9IDEwMDtcblxuICAgIC8vIG9wdGlvbnNcbiAgICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICB2YXIgb3B0aW9uID0gb3B0aW9uc1trZXldO1xuICAgICAgICAgICAgc3dpdGNoIChrZXkpIHtcblxuICAgICAgICAgICAgY2FzZSAnaW5kZXgnOlxuICAgICAgICAgICAgICAgIHRoaXMuX2luZGV4ID0gb3B0aW9uO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdyYW5nZSc6XG4gICAgICAgICAgICAgICAgdmFsaWRSYW5nZShvcHRpb24pO1xuICAgICAgICAgICAgICAgIHRoaXMuX21pbiA9IG9wdGlvbi5taW47XG4gICAgICAgICAgICAgICAgdGhpcy5fbWF4ID0gb3B0aW9uLm1heDtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnRTaXplID0gb3B0aW9uLm1heCAtIG9wdGlvbi5taW4gKyAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAga2V5LmNoYXJBdCgwKSAhPT0gJ18nICYmXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBGaW5CYXIucHJvdG90eXBlW2tleV0gIT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gb3ZlcnJpZGUgcHJvdG90eXBlIGRlZmF1bHRzIGZvciBzdGFuZGFyZCA7XG4gICAgICAgICAgICAgICAgICAgIC8vIGV4dGVuZCB3aXRoIGFkZGl0aW9uYWwgcHJvcGVydGllcyAoZm9yIHVzZSBpbiBvbmNoYW5nZSBldmVudCBoYW5kbGVycylcbiAgICAgICAgICAgICAgICAgICAgdGhpc1trZXldID0gb3B0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgY3NzSW5qZWN0b3IoY3NzRmluQmFycywgJ2ZpbmJhci1iYXNlJywgb3B0aW9ucy5jc3NTdHlsZXNoZWV0UmVmZXJlbmNlRWxlbWVudCk7XG59XG5cbkZpbkJhci5wcm90b3R5cGUgPSB7XG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBUaGUgc2Nyb2xsYmFyIG9yaWVudGF0aW9uLlxuICAgICAqIEBkZXNjIFNldCBieSB0aGUgY29uc3RydWN0b3IgdG8gZWl0aGVyIGAndmVydGljYWwnYCBvciBgJ2hvcml6b250YWwnYC4gU2VlIHRoZSBzaW1pbGFybHkgbmFtZWQgcHJvcGVydHkgaW4gdGhlIHtAbGluayBmaW5iYXJPcHRpb25zfSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBVc2VmdWwgdmFsdWVzIGFyZSBgJ3ZlcnRpY2FsJ2AgKHRoZSBkZWZhdWx0KSBvciBgJ2hvcml6b250YWwnYC5cbiAgICAgKlxuICAgICAqIFNldHRpbmcgdGhpcyBwcm9wZXJ0eSByZXNldHMgYHRoaXMub2hgIGFuZCBgdGhpcy5kZWx0YVByb3BgIGFuZCBjaGFuZ2VzIHRoZSBjbGFzcyBuYW1lcyBzbyBhcyB0byByZXBvc2l0aW9uIHRoZSBzY3JvbGxiYXIgYXMgcGVyIHRoZSBDU1MgcnVsZXMgZm9yIHRoZSBuZXcgb3JpZW50YXRpb24uXG4gICAgICogQGRlZmF1bHQgJ3ZlcnRpY2FsJ1xuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQG1lbWJlck9mIEZpbkJhci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBzZXQgb3JpZW50YXRpb24ob3JpZW50YXRpb24pIHtcbiAgICAgICAgaWYgKG9yaWVudGF0aW9uID09PSB0aGlzLl9vcmllbnRhdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fb3JpZW50YXRpb24gPSBvcmllbnRhdGlvbjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgICAqIEBuYW1lIG9oXG4gICAgICAgICAqIEBzdW1tYXJ5IDx1Pk88L3U+cmllbnRhdGlvbiA8dT5oPC91PmFzaCBmb3IgdGhpcyBzY3JvbGxiYXIuXG4gICAgICAgICAqIEBkZXNjIFNldCBieSB0aGUgYG9yaWVudGF0aW9uYCBzZXR0ZXIgdG8gZWl0aGVyIHRoZSB2ZXJ0aWNhbCBvciB0aGUgaG9yaXpvbnRhbCBvcmllbnRhdGlvbiBoYXNoLiBUaGUgcHJvcGVydHkgc2hvdWxkIGFsd2F5cyBiZSBzeW5jaHJvbml6ZWQgd2l0aCBgb3JpZW50YXRpb25gOyBkbyBub3QgdXBkYXRlIGRpcmVjdGx5IVxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIG9iamVjdCBpcyB1c2VkIGludGVybmFsbHkgdG8gYWNjZXNzIHNjcm9sbGJhcnMnIERPTSBlbGVtZW50IHByb3BlcnRpZXMgaW4gYSBnZW5lcmFsaXplZCB3YXkgd2l0aG91dCBuZWVkaW5nIHRvIGNvbnN0YW50bHkgcXVlcnkgdGhlIHNjcm9sbGJhciBvcmllbnRhdGlvbi4gRm9yIGV4YW1wbGUsIGluc3RlYWQgb2YgZXhwbGljaXRseSBjb2RpbmcgYHRoaXMuYmFyLnRvcGAgZm9yIGEgdmVydGljYWwgc2Nyb2xsYmFyIGFuZCBgdGhpcy5iYXIubGVmdGAgZm9yIGEgaG9yaXpvbnRhbCBzY3JvbGxiYXIsIHNpbXBseSBjb2RlIGB0aGlzLmJhclt0aGlzLm9oLmxlYWRpbmddYCBpbnN0ZWFkLiBTZWUgdGhlIHtAbGluayBvcmllbnRhdGlvbkhhc2hUeXBlfSBkZWZpbml0aW9uIGZvciBkZXRhaWxzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIG9iamVjdCBpcyB1c2VmdWwgZXh0ZXJuYWxseSBmb3IgY29kaW5nIGdlbmVyYWxpemVkIHtAbGluayBmaW5iYXJPbkNoYW5nZX0gZXZlbnQgaGFuZGxlciBmdW5jdGlvbnMgdGhhdCBzZXJ2ZSBib3RoIGhvcml6b250YWwgYW5kIHZlcnRpY2FsIHNjcm9sbGJhcnMuXG4gICAgICAgICAqIEB0eXBlIHtvcmllbnRhdGlvbkhhc2hUeXBlfVxuICAgICAgICAgKiBAbWVtYmVyT2YgRmluQmFyLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vaCA9IG9yaWVudGF0aW9uSGFzaGVzW3RoaXMuX29yaWVudGF0aW9uXTtcblxuICAgICAgICBpZiAoIXRoaXMub2gpIHtcbiAgICAgICAgICAgIGVycm9yKCdJbnZhbGlkIHZhbHVlIGZvciBgb3B0aW9ucy5fb3JpZW50YXRpb24uJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQG5hbWUgZGVsdGFQcm9wXG4gICAgICAgICAqIEBzdW1tYXJ5IFRoZSBuYW1lIG9mIHRoZSBgV2hlZWxFdmVudGAgcHJvcGVydHkgdGhpcyBzY3JvbGxiYXIgc2hvdWxkIGxpc3RlbiB0by5cbiAgICAgICAgICogQGRlc2MgU2V0IGJ5IHRoZSBjb25zdHJ1Y3Rvci4gU2VlIHRoZSBzaW1pbGFybHkgbmFtZWQgcHJvcGVydHkgaW4gdGhlIHtAbGluayBmaW5iYXJPcHRpb25zfSBvYmplY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIFVzZWZ1bCB2YWx1ZXMgYXJlIGAnZGVsdGFYJ2AsIGAnZGVsdGFZJ2AsIG9yIGAnZGVsdGFaJ2AuIEEgdmFsdWUgb2YgYG51bGxgIG1lYW5zIHRvIGlnbm9yZSBtb3VzZSB3aGVlbCBldmVudHMgZW50aXJlbHkuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBtb3VzZSB3aGVlbCBpcyBvbmUtZGltZW5zaW9uYWwgYW5kIG9ubHkgZW1pdHMgZXZlbnRzIHdpdGggYGRlbHRhWWAgZGF0YS4gVGhpcyBwcm9wZXJ0eSBpcyBwcm92aWRlZCBzbyB0aGF0IHlvdSBjYW4gb3ZlcnJpZGUgdGhlIGRlZmF1bHQgb2YgYCdkZWx0YVgnYCB3aXRoIGEgdmFsdWUgb2YgYCdkZWx0YVknYCBvbiB5b3VyIGhvcml6b250YWwgc2Nyb2xsYmFyIHByaW1hcmlseSB0byBhY2NvbW1vZGF0ZSBjZXJ0YWluIFwicGFub3JhbWljXCIgaW50ZXJmYWNlIGRlc2lnbnMgd2hlcmUgdGhlIG1vdXNlIHdoZWVsIHNob3VsZCBjb250cm9sIGhvcml6b250YWwgcmF0aGVyIHRoYW4gdmVydGljYWwgc2Nyb2xsaW5nLiBKdXN0IGdpdmUgYHsgZGVsdGFQcm9wOiAnZGVsdGFZJyB9YCBpbiB5b3VyIGhvcml6b250YWwgc2Nyb2xsYmFyIGluc3RhbnRpYXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIENhdmVhdDogTm90ZSB0aGF0IGEgMi1maW5nZXIgZHJhZyBvbiBhbiBBcHBsZSB0cmFja3BhZCBlbWl0cyBldmVudHMgd2l0aCBfYm90aF8gYGRlbHRhWCBgIGFuZCBgZGVsdGFZYCBkYXRhIHNvIHlvdSBtaWdodCB3YW50IHRvIGRlbGF5IG1ha2luZyB0aGUgYWJvdmUgYWRqdXN0bWVudCB1bnRpbCB5b3UgY2FuIGRldGVybWluZSB0aGF0IHlvdSBhcmUgZ2V0dGluZyBZIGRhdGEgb25seSB3aXRoIG5vIFggZGF0YSBhdCBhbGwgKHdoaWNoIGlzIGEgc3VyZSBiZXQgeW91IG9uIGEgbW91c2Ugd2hlZWwgcmF0aGVyIHRoYW4gYSB0cmFja3BhZCkuXG5cbiAgICAgICAgICogQHR5cGUge29iamVjdHxudWxsfVxuICAgICAgICAgKiBAbWVtYmVyT2YgRmluQmFyLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kZWx0YVByb3AgPSB0aGlzLm9oLmRlbHRhO1xuXG4gICAgICAgIHRoaXMuYmFyLmNsYXNzTmFtZSA9IHRoaXMuYmFyLmNsYXNzTmFtZS5yZXBsYWNlKC8odmVydGljYWx8aG9yaXpvbnRhbCkvZywgb3JpZW50YXRpb24pO1xuXG4gICAgICAgIGlmICh0aGlzLmJhci5zdHlsZS5jc3NUZXh0IHx8IHRoaXMudGh1bWIuc3R5bGUuY3NzVGV4dCkge1xuICAgICAgICAgICAgdGhpcy5iYXIucmVtb3ZlQXR0cmlidXRlKCdzdHlsZScpO1xuICAgICAgICAgICAgdGhpcy50aHVtYi5yZW1vdmVBdHRyaWJ1dGUoJ3N0eWxlJyk7XG4gICAgICAgICAgICB0aGlzLnJlc2l6ZSgpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBnZXQgb3JpZW50YXRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vcmllbnRhdGlvbjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgQ2FsbGJhY2sgZm9yIHNjcm9sbCBldmVudHMuXG4gICAgICogQGRlc2MgU2V0IGJ5IHRoZSBjb25zdHJ1Y3RvciB2aWEgdGhlIHNpbWlsYXJseSBuYW1lZCBwcm9wZXJ0eSBpbiB0aGUge0BsaW5rIGZpbmJhck9wdGlvbnN9IG9iamVjdC4gQWZ0ZXIgaW5zdGFudGlhdGlvbiwgYHRoaXMub25jaGFuZ2VgIG1heSBiZSB1cGRhdGVkIGRpcmVjdGx5LlxuICAgICAqXG4gICAgICogVGhpcyBldmVudCBoYW5kbGVyIGlzIGNhbGxlZCB3aGVuZXZlciB0aGUgdmFsdWUgb2YgdGhlIHNjcm9sbGJhciBpcyBjaGFuZ2VkIHRocm91Z2ggdXNlciBpbnRlcmFjdGlvbi4gVGhlIHR5cGljYWwgdXNlIGNhc2UgaXMgd2hlbiB0aGUgY29udGVudCBpcyBzY3JvbGxlZC4gSXQgaXMgY2FsbGVkIHdpdGggdGhlIGBGaW5CYXJgIG9iamVjdCBhcyBpdHMgY29udGV4dCBhbmQgdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIHNjcm9sbGJhciAoaXRzIGluZGV4LCByb3VuZGVkKSBhcyB0aGUgb25seSBwYXJhbWV0ZXIuXG4gICAgICpcbiAgICAgKiBTZXQgdGhpcyBwcm9wZXJ0eSB0byBgbnVsbGAgdG8gc3RvcCBlbWl0dGluZyBzdWNoIGV2ZW50cy5cbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb24obnVtYmVyKXxudWxsfVxuICAgICAqIEBtZW1iZXJPZiBGaW5CYXIucHJvdG90eXBlXG4gICAgICovXG4gICAgb25jaGFuZ2U6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBBZGQgYSBDU1MgY2xhc3MgbmFtZSB0byB0aGUgYmFyIGVsZW1lbnQncyBjbGFzcyBsaXN0LlxuICAgICAqIEBkZXNjIFNldCBieSB0aGUgY29uc3RydWN0b3IuIFNlZSB0aGUgc2ltaWxhcmx5IG5hbWVkIHByb3BlcnR5IGluIHRoZSB7QGxpbmsgZmluYmFyT3B0aW9uc30gb2JqZWN0LlxuICAgICAqXG4gICAgICogVGhlIGJhciBlbGVtZW50J3MgY2xhc3MgbGlzdCB3aWxsIGFsd2F5cyBpbmNsdWRlIGBmaW5iYXItdmVydGljYWxgIChvciBgZmluYmFyLWhvcml6b250YWxgIGJhc2VkIG9uIHRoZSBjdXJyZW50IG9yaWVudGF0aW9uKS4gV2hlbmV2ZXIgdGhpcyBwcm9wZXJ0eSBpcyBzZXQgdG8gc29tZSB2YWx1ZSwgZmlyc3QgdGhlIG9sZCBwcmVmaXgrb3JpZW50YXRpb24gaXMgcmVtb3ZlZCBmcm9tIHRoZSBiYXIgZWxlbWVudCdzIGNsYXNzIGxpc3Q7IHRoZW4gdGhlIG5ldyBwcmVmaXgrb3JpZW50YXRpb24gaXMgYWRkZWQgdG8gdGhlIGJhciBlbGVtZW50J3MgY2xhc3MgbGlzdC4gVGhpcyBwcm9wZXJ0eSBjYXVzZXMgX2FuIGFkZGl0aW9uYWxfIGNsYXNzIG5hbWUgdG8gYmUgYWRkZWQgdG8gdGhlIGJhciBlbGVtZW50J3MgY2xhc3MgbGlzdC4gVGhlcmVmb3JlLCB0aGlzIHByb3BlcnR5IHdpbGwgb25seSBhZGQgYXQgbW9zdCBvbmUgYWRkaXRpb25hbCBjbGFzcyBuYW1lIHRvIHRoZSBsaXN0LlxuICAgICAqXG4gICAgICogVG8gcmVtb3ZlIF9jbGFzc25hbWUtb3JpZW50YXRpb25fIGZyb20gdGhlIGJhciBlbGVtZW50J3MgY2xhc3MgbGlzdCwgc2V0IHRoaXMgcHJvcGVydHkgdG8gYSBmYWxzeSB2YWx1ZSwgc3VjaCBhcyBgbnVsbGAuXG4gICAgICpcbiAgICAgKiA+IE5PVEU6IFlvdSBvbmx5IG5lZWQgdG8gc3BlY2lmeSBhbiBhZGRpdGlvbmFsIGNsYXNzIG5hbWUgd2hlbiB5b3UgbmVlZCB0byBoYXZlIG11bGx0aXBsZSBkaWZmZXJlbnQgc3R5bGVzIG9mIHNjcm9sbGJhcnMgb24gdGhlIHNhbWUgcGFnZS4gSWYgdGhpcyBpcyBub3QgYSByZXF1aXJlbWVudCwgdGhlbiB5b3UgZG9uJ3QgbmVlZCB0byBtYWtlIGEgbmV3IGNsYXNzOyB5b3Ugd291bGQganVzdCBjcmVhdGUgc29tZSBhZGRpdGlvbmFsIHJ1bGVzIHVzaW5nIHRoZSBzYW1lIHNlbGVjdG9ycyBpbiB0aGUgYnVpbHQtaW4gc3R5bGVzaGVldCAoLi4vY3NzL2ZpbmJhcnMuY3NzKTpcbiAgICAgKiAqYGRpdi5maW5iYXItdmVydGljYWxgIChvciBgZGl2LmZpbmJhci1ob3Jpem9udGFsYCkgZm9yIHRoZSBzY3JvbGxiYXJcbiAgICAgKiAqYGRpdi5maW5iYXItdmVydGljYWwgPiBkaXZgIChvciBgZGl2LmZpbmJhci1ob3Jpem9udGFsID4gZGl2YCkgZm9yIHRoZSBcInRodW1iLlwiXG4gICAgICpcbiAgICAgKiBPZiBjb3Vyc2UsIHlvdXIgcnVsZXMgc2hvdWxkIGNvbWUgYWZ0ZXIgdGhlIGJ1aWx0LWlucy5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBtZW1iZXJPZiBGaW5CYXIucHJvdG90eXBlXG4gICAgICovXG4gICAgc2V0IGNsYXNzUHJlZml4KHByZWZpeCkge1xuICAgICAgICBpZiAodGhpcy5fY2xhc3NQcmVmaXgpIHtcbiAgICAgICAgICAgIHRoaXMuYmFyLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5fY2xhc3NQcmVmaXggKyB0aGlzLm9yaWVudGF0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2NsYXNzUHJlZml4ID0gcHJlZml4O1xuXG4gICAgICAgIGlmIChwcmVmaXgpIHtcbiAgICAgICAgICAgIHRoaXMuYmFyLmNsYXNzTGlzdC5hZGQocHJlZml4ICsgJy0nICsgdGhpcy5vcmllbnRhdGlvbik7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGdldCBjbGFzc1ByZWZpeCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NsYXNzUHJlZml4O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBpbmNyZW1lbnRcbiAgICAgKiBAc3VtbWFyeSBOdW1iZXIgb2Ygc2Nyb2xsYmFyIGluZGV4IHVuaXRzIHJlcHJlc2VudGluZyBhIHBhZ2VmdWwuIFVzZWQgZXhjbHVzaXZlbHkgZm9yIHBhZ2luZyB1cCBhbmQgZG93biBhbmQgZm9yIHNldHRpbmcgdGh1bWIgc2l6ZSByZWxhdGl2ZSB0byBjb250ZW50IHNpemUuXG4gICAgICogQGRlc2MgU2V0IGJ5IHRoZSBjb25zdHJ1Y3Rvci4gU2VlIHRoZSBzaW1pbGFybHkgbmFtZWQgcHJvcGVydHkgaW4gdGhlIHtAbGluayBmaW5iYXJPcHRpb25zfSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBDYW4gYWxzbyBiZSBnaXZlbiBhcyBhIHBhcmFtZXRlciB0byB0aGUge0BsaW5rIEZpbkJhciNyZXNpemV8cmVzaXplfSBtZXRob2QsIHdoaWNoIGlzIHBlcnRpbmVudCBiZWNhdXNlIGNvbnRlbnQgYXJlYSBzaXplIGNoYW5nZXMgYWZmZWN0IHRoZSBkZWZpbml0aW9uIG9mIGEgXCJwYWdlZnVsLlwiIEhvd2V2ZXIsIHlvdSBvbmx5IG5lZWQgdG8gZG8gdGhpcyBpZiB0aGlzIHZhbHVlIGlzIGJlaW5nIHVzZWQuIEl0IG5vdCB1c2VkIHdoZW46XG4gICAgICogKiB5b3UgZGVmaW5lIGBwYWdpbmcudXBgIGFuZCBgcGFnaW5nLmRvd25gXG4gICAgICogKiB5b3VyIHNjcm9sbGJhciBpcyB1c2luZyBgc2Nyb2xsUmVhbENvbnRlbnRgXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAbWVtYmVyT2YgRmluQmFyLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGluY3JlbWVudDogMSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIGJhclN0eWxlc1xuICAgICAqIEBzdW1tYXJ5IFNjcm9sbGJhciBzdHlsZXMgdG8gYmUgYXBwbGllZCBieSB7QGxpbmsgRmluQmFyI3Jlc2l6ZXxyZXNpemUoKX0uXG4gICAgICogQGRlc2MgU2V0IGJ5IHRoZSBjb25zdHJ1Y3Rvci4gU2VlIHRoZSBzaW1pbGFybHkgbmFtZWQgcHJvcGVydHkgaW4gdGhlIHtAbGluayBmaW5iYXJPcHRpb25zfSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIGEgdmFsdWUgdG8gYmUgYXNzaWduZWQgdG8ge0BsaW5rIEZpbkJhciNzdHlsZXN8c3R5bGVzfSBvbiBlYWNoIGNhbGwgdG8ge0BsaW5rIEZpbkJhciNyZXNpemV8cmVzaXplKCl9LiBUaGF0IGlzLCBhIGhhc2ggb2YgdmFsdWVzIHRvIGJlIGNvcGllZCB0byB0aGUgc2Nyb2xsYmFyIGVsZW1lbnQncyBzdHlsZSBvYmplY3Qgb24gcmVzaXplOyBvciBgbnVsbGAgZm9yIG5vbmUuXG4gICAgICpcbiAgICAgKiBAc2VlIHtAbGluayBGaW5CYXIjc3R5bGV8c3R5bGV9XG4gICAgICogQHR5cGUge2ZpbmJhclN0eWxlc3xudWxsfVxuICAgICAqIEBtZW1iZXJPZiBGaW5CYXIucHJvdG90eXBlXG4gICAgICovXG4gICAgYmFyU3R5bGVzOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgc3R5bGVcbiAgICAgKiBAc3VtbWFyeSBBZGRpdGlvbmFsIHNjcm9sbGJhciBzdHlsZXMuXG4gICAgICogQGRlc2MgU2VlIHR5cGUgZGVmaW5pdGlvbiBmb3IgbW9yZSBkZXRhaWxzLiBUaGVzZSBzdHlsZXMgYXJlIGFwcGxpZWQgZGlyZWN0bHkgdG8gdGhlIHNjcm9sbGJhcidzIGBiYXJgIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBWYWx1ZXMgYXJlIGFkanVzdGVkIGFzIGZvbGxvd3MgYmVmb3JlIGJlaW5nIGFwcGxpZWQgdG8gdGhlIGVsZW1lbnQ6XG4gICAgICogMS4gSW5jbHVkZWQgXCJwc2V1ZG8tcHJvcGVydHlcIiBuYW1lcyBmcm9tIHRoZSBzY3JvbGxiYXIncyBvcmllbnRhdGlvbiBoYXNoLCB7QGxpbmsgRmluQmFyI29ofG9ofSwgYXJlIHRyYW5zbGF0ZWQgdG8gYWN0dWFsIHByb3BlcnR5IG5hbWVzIGJlZm9yZSBiZWluZyBhcHBsaWVkLlxuICAgICAqIDIuIFdoZW4gdGhlcmUgYXJlIG1hcmdpbnMsIHBlcmNlbnRhZ2VzIGFyZSB0cmFuc2xhdGVkIHRvIGFic29sdXRlIHBpeGVsIHZhbHVlcyBiZWNhdXNlIENTUyBpZ25vcmVzIG1hcmdpbnMgaW4gaXRzIHBlcmNlbnRhZ2UgY2FsY3VsYXRpb25zLlxuICAgICAqIDMuIElmIHlvdSBnaXZlIGEgdmFsdWUgd2l0aG91dCBhIHVuaXQgKGEgcmF3IG51bWJlciksIFwicHhcIiB1bml0IGlzIGFwcGVuZGVkLlxuICAgICAqXG4gICAgICogR2VuZXJhbCBub3RlczpcbiAgICAgKiAxLiBJdCBpcyBhbHdheXMgcHJlZmVyYWJsZSB0byBzcGVjaWZ5IHN0eWxlcyB2aWEgYSBzdHlsZXNoZWV0LiBPbmx5IHNldCB0aGlzIHByb3BlcnR5IHdoZW4geW91IG5lZWQgdG8gc3BlY2lmaWNhbGx5IG92ZXJyaWRlIChhKSBzdHlsZXNoZWV0IHZhbHVlKHMpLlxuICAgICAqIDIuIENhbiBiZSBzZXQgZGlyZWN0bHkgb3IgdmlhIGNhbGxzIHRvIHRoZSB7QGxpbmsgRmluQmFyI3Jlc2l6ZXxyZXNpemV9IG1ldGhvZC5cbiAgICAgKiAzLiBTaG91bGQgb25seSBiZSBzZXQgYWZ0ZXIgdGhlIHNjcm9sbGJhciBoYXMgYmVlbiBpbnNlcnRlZCBpbnRvIHRoZSBET00uXG4gICAgICogNC4gQmVmb3JlIGFwcGx5aW5nIHRoZXNlIG5ldyB2YWx1ZXMgdG8gdGhlIGVsZW1lbnQsIF9hbGxfIGluLWxpbmUgc3R5bGUgdmFsdWVzIGFyZSByZXNldCAoYnkgcmVtb3ZpbmcgdGhlIGVsZW1lbnQncyBgc3R5bGVgIGF0dHJpYnV0ZSksIGV4cG9zaW5nIGluaGVyaXRlZCB2YWx1ZXMgKGZyb20gc3R5bGVzaGVldHMpLlxuICAgICAqIDUuIEVtcHR5IG9iamVjdCBoYXMgbm8gZWZmZWN0LlxuICAgICAqIDYuIEZhbHNleSB2YWx1ZSBpbiBwbGFjZSBvZiBvYmplY3QgaGFzIG5vIGVmZmVjdC5cbiAgICAgKlxuICAgICAqID4gQ0FWRUFUOiBEbyBub3QgYXR0ZW1wdCB0byB0cmVhdCB0aGUgb2JqZWN0IHlvdSBhc3NpZ24gdG8gdGhpcyBwcm9wZXJ0eSBhcyBpZiBpdCB3ZXJlIGB0aGlzLmJhci5zdHlsZWAuIFNwZWNpZmljYWxseSwgY2hhbmdpbmcgdGhpcyBvYmplY3QgYWZ0ZXIgYXNzaWduaW5nIGl0IHdpbGwgaGF2ZSBubyBlZmZlY3Qgb24gdGhlIHNjcm9sbGJhci4gWW91IG11c3QgYXNzaWduIGl0IGFnYWluIGlmIHlvdSB3YW50IGl0IHRvIGhhdmUgYW4gZWZmZWN0LlxuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgRmluQmFyI2JhclN0eWxlc3xiYXJTdHlsZXN9XG4gICAgICogQHR5cGUge2ZpbmJhclN0eWxlc31cbiAgICAgKiBAbWVtYmVyT2YgRmluQmFyLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHNldCBzdHlsZShzdHlsZXMpIHtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhzdHlsZXMgPSBleHRlbmQoe30sIHN0eWxlcywgdGhpcy5fYXV4U3R5bGVzKSk7XG5cbiAgICAgICAgaWYgKGtleXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgYmFyID0gdGhpcy5iYXIsXG4gICAgICAgICAgICAgICAgYmFyUmVjdCA9IGJhci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgICAgICAgICBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lciB8fCBiYXIucGFyZW50RWxlbWVudCxcbiAgICAgICAgICAgICAgICBjb250YWluZXJSZWN0ID0gY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgICAgICAgICAgIG9oID0gdGhpcy5vaDtcblxuICAgICAgICAgICAgLy8gQmVmb3JlIGFwcGx5aW5nIG5ldyBzdHlsZXMsIHJldmVydCBhbGwgc3R5bGVzIHRvIHZhbHVlcyBpbmhlcml0ZWQgZnJvbSBzdHlsZXNoZWV0c1xuICAgICAgICAgICAgYmFyLnJlbW92ZUF0dHJpYnV0ZSgnc3R5bGUnKTtcblxuICAgICAgICAgICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsID0gc3R5bGVzW2tleV07XG5cbiAgICAgICAgICAgICAgICBpZiAoa2V5IGluIG9oKSB7XG4gICAgICAgICAgICAgICAgICAgIGtleSA9IG9oW2tleV07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFpc05hTihOdW1iZXIodmFsKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gKHZhbCB8fCAwKSArICdweCc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICgvJSQvLnRlc3QodmFsKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIGJhciBzaXplIGdpdmVuIGFzIHBlcmNlbnRhZ2Ugb2YgY29udGFpbmVyLCBpZiBiYXIgaGFzIG1hcmdpbnMsIHJlc3RhdGUgc2l6ZSBpbiBwaXhlbHMgbGVzcyBtYXJnaW5zLlxuICAgICAgICAgICAgICAgICAgICAvLyAoSWYgbGVmdCBhcyBwZXJjZW50YWdlLCBDU1MncyBjYWxjdWxhdGlvbiB3aWxsIG5vdCBleGNsdWRlIG1hcmdpbnMuKVxuICAgICAgICAgICAgICAgICAgICB2YXIgb3JpZW50ZWQgPSBheGlzW2tleV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW5zID0gYmFyUmVjdFtvcmllbnRlZC5tYXJnaW5MZWFkaW5nXSArIGJhclJlY3Rbb3JpZW50ZWQubWFyZ2luVHJhaWxpbmddO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWFyZ2lucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gcGFyc2VJbnQodmFsLCAxMCkgLyAxMDAgKiBjb250YWluZXJSZWN0W29yaWVudGVkLnNpemVdIC0gbWFyZ2lucyArICdweCc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBiYXIuc3R5bGVba2V5XSA9IHZhbDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEByZWFkb25seVxuICAgICAqIEBuYW1lIHBhZ2luZ1xuICAgICAqIEBzdW1tYXJ5IEVuYWJsZSBwYWdlIHVwL2RuIGNsaWNrcy5cbiAgICAgKiBAZGVzYyBTZXQgYnkgdGhlIGNvbnN0cnVjdG9yLiBTZWUgdGhlIHNpbWlsYXJseSBuYW1lZCBwcm9wZXJ0eSBpbiB0aGUge0BsaW5rIGZpbmJhck9wdGlvbnN9IG9iamVjdC5cbiAgICAgKlxuICAgICAqIElmIHRydXRoeSwgbGlzdGVuIGZvciBjbGlja3MgaW4gcGFnZS11cCBhbmQgcGFnZS1kb3duIHJlZ2lvbnMgb2Ygc2Nyb2xsYmFyLlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0LCBjYWxsIGAucGFnaW5nLnVwKClgIG9uIHBhZ2UtdXAgY2xpY2tzIGFuZCBgLnBhZ2luZy5kb3duKClgIHdpbGwgYmUgY2FsbGVkIG9uIHBhZ2UtZG93biBjbGlja3MuXG4gICAgICpcbiAgICAgKiBDaGFuZ2luZyB0aGUgdHJ1dGhpbmVzcyBvZiB0aGlzIHZhbHVlIGFmdGVyIGluc3RhbnRpYXRpb24gY3VycmVudGx5IGhhcyBubyBlZmZlY3QuXG4gICAgICogQHR5cGUge2Jvb2xlYW58b2JqZWN0fVxuICAgICAqIEBtZW1iZXJPZiBGaW5CYXIucHJvdG90eXBlXG4gICAgICovXG4gICAgcGFnaW5nOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgcmFuZ2VcbiAgICAgKiBAc3VtbWFyeSBTZXR0ZXIgZm9yIHRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIHNjcm9sbCB2YWx1ZXMuXG4gICAgICogQGRlc2MgU2V0IGJ5IHRoZSBjb25zdHJ1Y3Rvci4gVGhlc2UgdmFsdWVzIGFyZSB0aGUgbGltaXRzIGZvciB7QGxpbmsgRm9vQmFyI2luZGV4fGluZGV4fS5cbiAgICAgKlxuICAgICAqIFRoZSBzZXR0ZXIgYWNjZXB0cyBhbiBvYmplY3Qgd2l0aCBleGFjdGx5IHR3byBudW1lcmljIHByb3BlcnRpZXM6IGAubWluYCB3aGljaCBtdXN0IGJlIGxlc3MgdGhhbiBgLm1heGAuIFRoZSB2YWx1ZXMgYXJlIGV4dHJhY3RlZCBhbmQgdGhlIG9iamVjdCBpcyBkaXNjYXJkZWQuXG4gICAgICpcbiAgICAgKiBUaGUgZ2V0dGVyIHJldHVybnMgYSBuZXcgb2JqZWN0IHdpdGggYC5taW5gIGFuZCAnLm1heGAuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7cmFuZ2VUeXBlfVxuICAgICAqIEBtZW1iZXJPZiBGaW5CYXIucHJvdG90eXBlXG4gICAgICovXG4gICAgc2V0IHJhbmdlKHJhbmdlKSB7XG4gICAgICAgIHZhbGlkUmFuZ2UocmFuZ2UpO1xuICAgICAgICB0aGlzLl9taW4gPSByYW5nZS5taW47XG4gICAgICAgIHRoaXMuX21heCA9IHJhbmdlLm1heDtcbiAgICAgICAgdGhpcy5jb250ZW50U2l6ZSA9IHJhbmdlLm1heCAtIHJhbmdlLm1pbiArIDE7XG4gICAgICAgIHRoaXMuaW5kZXggPSB0aGlzLmluZGV4OyAvLyByZS1jbGFtcFxuICAgIH0sXG4gICAgZ2V0IHJhbmdlKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWluOiB0aGlzLl9taW4sXG4gICAgICAgICAgICBtYXg6IHRoaXMuX21heFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBJbmRleCB2YWx1ZSBvZiB0aGUgc2Nyb2xsYmFyLlxuICAgICAqIEBkZXNjIFRoaXMgaXMgdGhlIHBvc2l0aW9uIG9mIHRoZSBzY3JvbGwgdGh1bWIuXG4gICAgICpcbiAgICAgKiBTZXR0aW5nIHRoaXMgdmFsdWUgY2xhbXBzIGl0IHRvIHtAbGluayBGaW5CYXIjbWlufG1pbn0uLntAbGluayBGaW5CYXIjbWF4fG1heH0sIHNjcm9sbCB0aGUgY29udGVudCwgYW5kIG1vdmVzIHRodW1iLlxuICAgICAqXG4gICAgICogR2V0dGluZyB0aGlzIHZhbHVlIHJldHVybnMgdGhlIGN1cnJlbnQgaW5kZXguIFRoZSByZXR1cm5lZCB2YWx1ZSB3aWxsIGJlIGluIHRoZSByYW5nZSBgbWluYC4uYG1heGAuIEl0IGlzIGludGVudGlvbmFsbHkgbm90IHJvdW5kZWQuXG4gICAgICpcbiAgICAgKiBVc2UgdGhpcyB2YWx1ZSBhcyBhbiBhbHRlcm5hdGl2ZSB0byAob3IgaW4gYWRkaXRpb24gdG8pIHVzaW5nIHRoZSB7QGxpbmsgRmluQmFyI29uY2hhbmdlfG9uY2hhbmdlfSBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzZWUge0BsaW5rIEZpbkJhciNfc2V0U2Nyb2xsfF9zZXRTY3JvbGx9XG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAbWVtYmVyT2YgRmluQmFyLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHNldCBpbmRleChpZHgpIHtcbiAgICAgICAgaWR4ID0gTWF0aC5taW4odGhpcy5fbWF4LCBNYXRoLm1heCh0aGlzLl9taW4sIGlkeCkpOyAvLyBjbGFtcCBpdFxuICAgICAgICB0aGlzLl9zZXRTY3JvbGwoaWR4KTtcbiAgICAgICAgLy8gdGhpcy5fc2V0VGh1bWJTaXplKCk7XG4gICAgfSxcbiAgICBnZXQgaW5kZXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbmRleDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAc3VtbWFyeSBNb3ZlIHRoZSB0aHVtYi5cbiAgICAgKiBAZGVzYyBBbHNvIGRpc3BsYXlzIHRoZSBpbmRleCB2YWx1ZSBpbiB0aGUgdGVzdCBwYW5lbCBhbmQgaW52b2tlcyB0aGUgY2FsbGJhY2suXG4gICAgICogQHBhcmFtIGlkeCAtIFRoZSBuZXcgc2Nyb2xsIGluZGV4LCBhIHZhbHVlIGluIHRoZSByYW5nZSBgbWluYC4uYG1heGAuXG4gICAgICogQHBhcmFtIFtzY2FsZWQ9ZihpZHgpXSAtIFRoZSBuZXcgdGh1bWIgcG9zaXRpb24gaW4gcGl4ZWxzIGFuZCBzY2FsZWQgcmVsYXRpdmUgdG8gdGhlIGNvbnRhaW5pbmcge0BsaW5rIEZpbkJhciNiYXJ8YmFyfSBlbGVtZW50LCBpLmUuLCBhIHByb3BvcnRpb25hbCBudW1iZXIgaW4gdGhlIHJhbmdlIGAwYC4uYHRodW1iTWF4YC4gV2hlbiBvbWl0dGVkLCBhIGZ1bmN0aW9uIG9mIGBpZHhgIGlzIHVzZWQuXG4gICAgICogQG1lbWJlck9mIEZpbkJhci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBfc2V0U2Nyb2xsOiBmdW5jdGlvbiAoaWR4LCBzY2FsZWQpIHtcbiAgICAgICAgdGhpcy5faW5kZXggPSBpZHg7XG5cbiAgICAgICAgLy8gRGlzcGxheSB0aGUgaW5kZXggdmFsdWUgaW4gdGhlIHRlc3QgcGFuZWxcbiAgICAgICAgaWYgKHRoaXMudGVzdFBhbmVsSXRlbSAmJiB0aGlzLnRlc3RQYW5lbEl0ZW0uaW5kZXggaW5zdGFuY2VvZiBFbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLnRlc3RQYW5lbEl0ZW0uaW5kZXguaW5uZXJIVE1MID0gTWF0aC5yb3VuZChpZHgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2FsbCB0aGUgY2FsbGJhY2tcbiAgICAgICAgaWYgKHRoaXMub25jaGFuZ2UpIHtcbiAgICAgICAgICAgIHRoaXMub25jaGFuZ2UuY2FsbCh0aGlzLCBNYXRoLnJvdW5kKGlkeCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTW92ZSB0aGUgdGh1bWJcbiAgICAgICAgaWYgKHNjYWxlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzY2FsZWQgPSAoaWR4IC0gdGhpcy5fbWluKSAvICh0aGlzLl9tYXggLSB0aGlzLl9taW4pICogdGhpcy5fdGh1bWJNYXg7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50aHVtYi5zdHlsZVt0aGlzLm9oLmxlYWRpbmddID0gc2NhbGVkICsgJ3B4JztcbiAgICB9LFxuXG4gICAgc2Nyb2xsUmVhbENvbnRlbnQ6IGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgdmFyIGNvbnRhaW5lclJlY3QgPSB0aGlzLmNvbnRlbnQucGFyZW50RWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgICAgIHNpemVQcm9wID0gdGhpcy5vaC5zaXplLFxuICAgICAgICAgICAgbWF4U2Nyb2xsID0gTWF0aC5tYXgoMCwgdGhpcy5jb250ZW50W3NpemVQcm9wXSAtIGNvbnRhaW5lclJlY3Rbc2l6ZVByb3BdKSxcbiAgICAgICAgICAgIC8vc2Nyb2xsID0gTWF0aC5taW4oaWR4LCBtYXhTY3JvbGwpO1xuICAgICAgICAgICAgc2Nyb2xsID0gKGlkeCAtIHRoaXMuX21pbikgLyAodGhpcy5fbWF4IC0gdGhpcy5fbWluKSAqIG1heFNjcm9sbDtcbiAgICAgICAgLy9jb25zb2xlLmxvZygnc2Nyb2xsOiAnICsgc2Nyb2xsKTtcbiAgICAgICAgdGhpcy5jb250ZW50LnN0eWxlW3RoaXMub2gubGVhZGluZ10gPSAtc2Nyb2xsICsgJ3B4JztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgUmVjYWxjdWxhdGUgdGh1bWIgcG9zaXRpb24uXG4gICAgICpcbiAgICAgKiBAZGVzYyBUaGlzIG1ldGhvZCByZWNhbGN1bGF0ZXMgdGhlIHRodW1iIHNpemUgYW5kIHBvc2l0aW9uLiBDYWxsIGl0IG9uY2UgYWZ0ZXIgaW5zZXJ0aW5nIHlvdXIgc2Nyb2xsYmFyIGludG8gdGhlIERPTSwgYW5kIHJlcGVhdGVkbHkgd2hpbGUgcmVzaXppbmcgdGhlIHNjcm9sbGJhciAod2hpY2ggdHlwaWNhbGx5IGhhcHBlbnMgd2hlbiB0aGUgc2Nyb2xsYmFyJ3MgcGFyZW50IGlzIHJlc2l6ZWQgYnkgdXNlci5cbiAgICAgKlxuICAgICAqID4gVGhpcyBmdW5jdGlvbiBzaGlmdHMgYXJncyBpZiBmaXJzdCBhcmcgb21pdHRlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbaW5jcmVtZW50PXRoaXMuaW5jcmVtZW50XSAtIFJlc2V0cyB7QGxpbmsgRm9vQmFyI2luY3JlbWVudHxpbmNyZW1lbnR9IChzZWUpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtmaW5iYXJTdHlsZXN9IFtiYXJTdHlsZXM9dGhpcy5iYXJTdHlsZXNdIC0gKFNlZSB0eXBlIGRlZmluaXRpb24gZm9yIGRldGFpbHMuKSBTY3JvbGxiYXIgc3R5bGVzIHRvIGJlIGFwcGxpZWQgdG8gdGhlIGJhciBlbGVtZW50LlxuICAgICAqXG4gICAgICogT25seSBzcGVjaWZ5IGEgYGJhclN0eWxlc2Agb2JqZWN0IHdoZW4geW91IG5lZWQgdG8gb3ZlcnJpZGUgc3R5bGVzaGVldCB2YWx1ZXMuIElmIHByb3ZpZGVkLCBiZWNvbWVzIHRoZSBuZXcgZGVmYXVsdCAoYHRoaXMuYmFyU3R5bGVzYCksIGZvciB1c2UgYXMgYSBkZWZhdWx0IG9uIHN1YnNlcXVlbnQgY2FsbHMuXG4gICAgICpcbiAgICAgKiBJdCBpcyBnZW5lcmFsbHkgdGhlIGNhc2UgdGhhdCB0aGUgc2Nyb2xsYmFyJ3MgbmV3IHBvc2l0aW9uIGlzIHN1ZmZpY2llbnRseSBkZXNjcmliZWQgYnkgdGhlIGN1cnJlbnQgc3R5bGVzLiBUaGVyZWZvcmUsIGl0IGlzIHVudXN1YWwgdG8gbmVlZCB0byBwcm92aWRlIGEgYGJhclN0eWxlc2Agb2JqZWN0IG9uIGV2ZXJ5IGNhbGwgdG8gYHJlc2l6ZWAuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7RmluQmFyfSBTZWxmIGZvciBjaGFpbmluZy5cbiAgICAgKiBAbWVtYmVyT2YgRmluQmFyLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHJlc2l6ZTogZnVuY3Rpb24gKGluY3JlbWVudCwgYmFyU3R5bGVzKSB7XG4gICAgICAgIHZhciBiYXIgPSB0aGlzLmJhcjtcblxuICAgICAgICBpZiAoIWJhci5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICByZXR1cm47IC8vIG5vdCBpbiBET00geWV0IHNvIG5vdGhpbmcgdG8gZG9cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lciB8fCBiYXIucGFyZW50RWxlbWVudCxcbiAgICAgICAgICAgIGNvbnRhaW5lclJlY3QgPSBjb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgICAgLy8gc2hpZnQgYXJncyBpZiBpZiAxc3QgYXJnIG9taXR0ZWRcbiAgICAgICAgaWYgKHR5cGVvZiBpbmNyZW1lbnQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBiYXJTdHlsZXMgPSBpbmNyZW1lbnQ7XG4gICAgICAgICAgICBpbmNyZW1lbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnN0eWxlID0gdGhpcy5iYXJTdHlsZXMgPSBiYXJTdHlsZXMgfHwgdGhpcy5iYXJTdHlsZXM7XG5cbiAgICAgICAgLy8gQm91bmQgdG8gcmVhbCBjb250ZW50OiBDb250ZW50IHdhcyBnaXZlbiBidXQgbm8gb25jaGFuZ2UgaGFuZGxlci5cbiAgICAgICAgLy8gU2V0IHVwIC5vbmNoYW5nZSwgLmNvbnRhaW5lclNpemUsIGFuZCAuaW5jcmVtZW50LlxuICAgICAgICAvLyBOb3RlIHRoaXMgb25seSBtYWtlcyBzZW5zZSBpZiB5b3VyIGluZGV4IHVuaXQgaXMgcGl4ZWxzLlxuICAgICAgICBpZiAodGhpcy5jb250ZW50KSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMub25jaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uY2hhbmdlID0gdGhpcy5zY3JvbGxSZWFsQ29udGVudDtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnRTaXplID0gdGhpcy5jb250ZW50W3RoaXMub2guc2l6ZV07XG4gICAgICAgICAgICAgICAgdGhpcy5fbWluID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXggPSB0aGlzLmNvbnRlbnRTaXplIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vbmNoYW5nZSA9PT0gdGhpcy5zY3JvbGxSZWFsQ29udGVudCkge1xuICAgICAgICAgICAgdGhpcy5jb250YWluZXJTaXplID0gY29udGFpbmVyUmVjdFt0aGlzLm9oLnNpemVdO1xuICAgICAgICAgICAgdGhpcy5pbmNyZW1lbnQgPSB0aGlzLmNvbnRhaW5lclNpemUgLyAodGhpcy5jb250ZW50U2l6ZSAtIHRoaXMuY29udGFpbmVyU2l6ZSkgKiAodGhpcy5fbWF4IC0gdGhpcy5fbWluKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyU2l6ZSA9IDE7XG4gICAgICAgICAgICB0aGlzLmluY3JlbWVudCA9IGluY3JlbWVudCB8fCB0aGlzLmluY3JlbWVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgICAgIHRoaXMudGVzdFBhbmVsSXRlbSA9IHRoaXMudGVzdFBhbmVsSXRlbSB8fCB0aGlzLl9hZGRUZXN0UGFuZWxJdGVtKCk7XG4gICAgICAgIHRoaXMuX3NldFRodW1iU2l6ZSgpO1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG5cbiAgICAgICAgaWYgKHRoaXMuZGVsdGFQcm9wICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignd2hlZWwnLCB0aGlzLl9ib3VuZC5vbndoZWVsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBTaG9ydGVuIHRyYWlsaW5nIGVuZCBvZiBzY3JvbGxiYXIgYnkgdGhpY2tuZXNzIG9mIHNvbWUgb3RoZXIgc2Nyb2xsYmFyLlxuICAgICAqIEBkZXNjIEluIHRoZSBcImNsYXNzaWNhbFwiIHNjZW5hcmlvIHdoZXJlIHZlcnRpY2FsIHNjcm9sbCBiYXIgaXMgb24gdGhlIHJpZ2h0IGFuZCBob3Jpem9udGFsIHNjcm9sbGJhciBpcyBvbiB0aGUgYm90dG9tLCB5b3Ugd2FudCB0byBzaG9ydGVuIHRoZSBcInRyYWlsaW5nIGVuZFwiIChib3R0b20gYW5kIHJpZ2h0IGVuZHMsIHJlc3BlY3RpdmVseSkgb2YgYXQgbGVhc3Qgb25lIG9mIHRoZW0gc28gdGhleSBkb24ndCBvdmVybGF5LlxuICAgICAqXG4gICAgICogVGhpcyBjb252ZW5pZW5jZSBmdW5jdGlvbiBpcyBhbiBwcm9ncmFtbWF0aWMgYWx0ZXJuYXRpdmUgdG8gaGFyZGNvZGluZyB0aGUgY29ycmVjdCBzdHlsZSB3aXRoIHRoZSBjb3JyZWN0IHZhbHVlIGluIHlvdXIgc3R5bGVzaGVldDsgb3Igc2V0dGluZyB0aGUgY29ycmVjdCBzdHlsZSB3aXRoIHRoZSBjb3JyZWN0IHZhbHVlIGluIHRoZSB7QGxpbmsgRmluQmFyI2JhclN0eWxlc3xiYXJTdHlsZXN9IG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzZWUge0BsaW5rIEZpbkJhciNmb3Jlc2hvcnRlbkJ5fGZvcmVzaG9ydGVuQnl9LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtGaW5CYXJ8bnVsbH0gb3RoZXJGaW5CYXIgLSBPdGhlciBzY3JvbGxiYXIgdG8gYXZvaWQgYnkgc2hvcnRlbmluZyB0aGlzIG9uZTsgYG51bGxgIHJlbW92ZXMgdGhlIHRyYWlsaW5nIHNwYWNlXG4gICAgICogQHJldHVybnMge0ZpbkJhcn0gRm9yIGNoYWluaW5nXG4gICAgICovXG4gICAgc2hvcnRlbkJ5OiBmdW5jdGlvbiAob3RoZXJGaW5CYXIpIHsgcmV0dXJuIHRoaXMuc2hvcnRlbkVuZEJ5KCd0cmFpbGluZycsIG90aGVyRmluQmFyKTsgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IFNob3J0ZW4gbGVhZGluZyBlbmQgb2Ygc2Nyb2xsYmFyIGJ5IHRoaWNrbmVzcyBvZiBzb21lIG90aGVyIHNjcm9sbGJhci5cbiAgICAgKiBAZGVzYyBTdXBwb3J0cyBub24tY2xhc3NpY2FsIHNjcm9sbGJhciBzY2VuYXJpb3Mgd2hlcmUgdmVydGljYWwgc2Nyb2xsIGJhciBtYXkgYmUgb24gbGVmdCBhbmQgaG9yaXpvbnRhbCBzY3JvbGxiYXIgbWF5IGJlIG9uIHRvcCwgaW4gd2hpY2ggY2FzZSB5b3Ugd2FudCB0byBzaG9ydGVuIHRoZSBcImxlYWRpbmcgZW5kXCIgcmF0aGVyIHRoYW4gdGhlIHRyYWlsaW5nIGVuZC5cbiAgICAgKiBAc2VlIHtAbGluayBGaW5CYXIjc2hvcnRlbkJ5fHNob3J0ZW5CeX0uXG4gICAgICogQHBhcmFtIHtGaW5CYXJ8bnVsbH0gb3RoZXJGaW5CYXIgLSBPdGhlciBzY3JvbGxiYXIgdG8gYXZvaWQgYnkgc2hvcnRlbmluZyB0aGlzIG9uZTsgYG51bGxgIHJlbW92ZXMgdGhlIHRyYWlsaW5nIHNwYWNlXG4gICAgICogQHJldHVybnMge0ZpbkJhcn0gRm9yIGNoYWluaW5nXG4gICAgICovXG4gICAgZm9yZXNob3J0ZW5CeTogZnVuY3Rpb24gKG90aGVyRmluQmFyKSB7IHJldHVybiB0aGlzLnNob3J0ZW5FbmRCeSgnbGVhZGluZycsIG90aGVyRmluQmFyKTsgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IEdlbmVyYWxpemVkIHNob3J0ZW5pbmcgZnVuY3Rpb24uXG4gICAgICogQHNlZSB7QGxpbmsgRmluQmFyI3Nob3J0ZW5CeXxzaG9ydGVuQnl9LlxuICAgICAqIEBzZWUge0BsaW5rIEZpbkJhciNmb3Jlc2hvcnRlbkJ5fGZvcmVzaG9ydGVuQnl9LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3aGljaEVuZCAtIGEgQ1NTIHN0eWxlIHByb3BlcnR5IG5hbWUgb3IgYW4gb3JpZW50YXRpb24gaGFzaCBuYW1lIHRoYXQgdHJhbnNsYXRlcyB0byBhIENTUyBzdHlsZSBwcm9wZXJ0eSBuYW1lLlxuICAgICAqIEBwYXJhbSB7RmluQmFyfG51bGx9IG90aGVyRmluQmFyIC0gT3RoZXIgc2Nyb2xsYmFyIHRvIGF2b2lkIGJ5IHNob3J0ZW5pbmcgdGhpcyBvbmU7IGBudWxsYCByZW1vdmVzIHRoZSB0cmFpbGluZyBzcGFjZVxuICAgICAqIEByZXR1cm5zIHtGaW5CYXJ9IEZvciBjaGFpbmluZ1xuICAgICAqL1xuICAgIHNob3J0ZW5FbmRCeTogZnVuY3Rpb24gKHdoaWNoRW5kLCBvdGhlckZpbkJhcikge1xuICAgICAgICBpZiAoIW90aGVyRmluQmFyKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fYXV4U3R5bGVzO1xuICAgICAgICB9IGVsc2UgaWYgKG90aGVyRmluQmFyIGluc3RhbmNlb2YgRmluQmFyICYmIG90aGVyRmluQmFyLm9yaWVudGF0aW9uICE9PSB0aGlzLm9yaWVudGF0aW9uKSB7XG4gICAgICAgICAgICB2YXIgb3RoZXJTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKG90aGVyRmluQmFyLmJhciksXG4gICAgICAgICAgICAgICAgb29oID0gb3JpZW50YXRpb25IYXNoZXNbb3RoZXJGaW5CYXIub3JpZW50YXRpb25dO1xuICAgICAgICAgICAgdGhpcy5fYXV4U3R5bGVzID0ge307XG4gICAgICAgICAgICB0aGlzLl9hdXhTdHlsZXNbd2hpY2hFbmRdID0gb3RoZXJTdHlsZVtvb2gudGhpY2tuZXNzXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpczsgLy8gZm9yIGNoYWluaW5nXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHN1bW1hcnkgU2V0cyB0aGUgcHJvcG9ydGlvbmFsIHRodW1iIHNpemUgYW5kIGhpZGVzIHRodW1iIHdoZW4gMTAwJS5cbiAgICAgKiBAZGVzYyBUaGUgdGh1bWIgc2l6ZSBoYXMgYW4gYWJzb2x1dGUgbWluaW11bSBvZiAyMCAocGl4ZWxzKS5cbiAgICAgKiBAbWVtYmVyT2YgRmluQmFyLnByb3RvdHlwZVxuICAgICAqL1xuICAgIF9zZXRUaHVtYlNpemU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG9oID0gdGhpcy5vaCxcbiAgICAgICAgICAgIHRodW1iQ29tcCA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMudGh1bWIpLFxuICAgICAgICAgICAgdGh1bWJNYXJnaW5MZWFkaW5nID0gcGFyc2VJbnQodGh1bWJDb21wW29oLm1hcmdpbkxlYWRpbmddKSxcbiAgICAgICAgICAgIHRodW1iTWFyZ2luVHJhaWxpbmcgPSBwYXJzZUludCh0aHVtYkNvbXBbb2gubWFyZ2luVHJhaWxpbmddKSxcbiAgICAgICAgICAgIHRodW1iTWFyZ2lucyA9IHRodW1iTWFyZ2luTGVhZGluZyArIHRodW1iTWFyZ2luVHJhaWxpbmcsXG4gICAgICAgICAgICBiYXJTaXplID0gdGhpcy5iYXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClbb2guc2l6ZV0sXG4gICAgICAgICAgICB0aHVtYlNpemUgPSBNYXRoLm1heCgyMCwgYmFyU2l6ZSAqIHRoaXMuY29udGFpbmVyU2l6ZSAvIHRoaXMuY29udGVudFNpemUpO1xuXG4gICAgICAgIGlmICh0aGlzLmNvbnRhaW5lclNpemUgPCB0aGlzLmNvbnRlbnRTaXplKSB7XG4gICAgICAgICAgICB0aGlzLmJhci5zdHlsZS52aXNpYmlsaXR5ID0gJ3Zpc2libGUnO1xuICAgICAgICAgICAgdGhpcy50aHVtYi5zdHlsZVtvaC5zaXplXSA9IHRodW1iU2l6ZSArICdweCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmJhci5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQG5hbWUgX3RodW1iTWF4XG4gICAgICAgICAqIEBzdW1tYXJ5IE1heGltdW0gb2Zmc2V0IG9mIHRodW1iJ3MgbGVhZGluZyBlZGdlLlxuICAgICAgICAgKiBAZGVzYyBUaGlzIGlzIHRoZSBwaXhlbCBvZmZzZXQgd2l0aGluIHRoZSBzY3JvbGxiYXIgb2YgdGhlIHRodW1iIHdoZW4gaXQgaXMgYXQgaXRzIG1heGltdW0gcG9zaXRpb24gYXQgdGhlIGV4dHJlbWUgZW5kIG9mIGl0cyByYW5nZS5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyB2YWx1ZSB0YWtlcyBpbnRvIGFjY291bnQgdGhlIG5ld2x5IGNhbGN1bGF0ZWQgc2l6ZSBvZiB0aGUgdGh1bWIgZWxlbWVudCAoaW5jbHVkaW5nIGl0cyBtYXJnaW5zKSBhbmQgdGhlIGlubmVyIHNpemUgb2YgdGhlIHNjcm9sbGJhciAodGhlIHRodW1iJ3MgY29udGFpbmluZyBlbGVtZW50LCBpbmNsdWRpbmcgX2l0c18gbWFyZ2lucykuXG4gICAgICAgICAqXG4gICAgICAgICAqIE5PVEU6IFNjcm9sbGJhciBwYWRkaW5nIGlzIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgYW5kIGFzc3VtZWQgdG8gYmUgMCBpbiB0aGUgY3VycmVudCBpbXBsZW1lbnRhdGlvbiBhbmQgaXMgYXNzdW1lZCB0byBiZSBgMGA7IHVzZSB0aHVtYiBtYXJnaW5zIGluIHBsYWNlIG9mIHNjcm9sbGJhciBwYWRkaW5nLlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKiBAbWVtYmVyT2YgRmluQmFyLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fdGh1bWJNYXggPSBiYXJTaXplIC0gdGh1bWJTaXplIC0gdGh1bWJNYXJnaW5zO1xuXG4gICAgICAgIHRoaXMuX3RodW1iTWFyZ2luTGVhZGluZyA9IHRodW1iTWFyZ2luTGVhZGluZzsgLy8gdXNlZCBpbiBtb3VzZWRvd25cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgUmVtb3ZlIHRoZSBzY3JvbGxiYXIuXG4gICAgICogQGRlc2MgVW5ob29rcyBhbGwgdGhlIGV2ZW50IGhhbmRsZXJzIGFuZCB0aGVuIHJlbW92ZXMgdGhlIGVsZW1lbnQgZnJvbSB0aGUgRE9NLiBBbHdheXMgY2FsbCB0aGlzIG1ldGhvZCBwcmlvciB0byBkaXNwb3Npbmcgb2YgdGhlIHNjcm9sbGJhciBvYmplY3QuXG4gICAgICogQG1lbWJlck9mIEZpbkJhci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICByZW1vdmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlRXZ0KCdtb3VzZWRvd24nKTtcbiAgICAgICAgdGhpcy5fcmVtb3ZlRXZ0KCdtb3VzZW1vdmUnKTtcbiAgICAgICAgdGhpcy5fcmVtb3ZlRXZ0KCdtb3VzZXVwJyk7XG5cbiAgICAgICAgKHRoaXMuY29udGFpbmVyIHx8IHRoaXMuYmFyLnBhcmVudEVsZW1lbnQpLl9yZW1vdmVFdnQoJ3doZWVsJywgdGhpcy5fYm91bmQub253aGVlbCk7XG5cbiAgICAgICAgdGhpcy5iYXIub25jbGljayA9XG4gICAgICAgICAgICB0aGlzLnRodW1iLm9uY2xpY2sgPVxuICAgICAgICAgICAgICAgIHRoaXMudGh1bWIub25tb3VzZW92ZXIgPVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRodW1iLnRyYW5zaXRpb25lbmQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50aHVtYi5vbm1vdXNlb3V0ID0gbnVsbDtcblxuICAgICAgICB0aGlzLmJhci5yZW1vdmUoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAZnVuY3Rpb24gX2FkZFRlc3RQYW5lbEl0ZW1cbiAgICAgKiBAc3VtbWFyeSBBcHBlbmQgYSB0ZXN0IHBhbmVsIGVsZW1lbnQuXG4gICAgICogQGRlc2MgSWYgdGhlcmUgaXMgYSB0ZXN0IHBhbmVsIGluIHRoZSBET00gKHR5cGljYWxseSBhbiBgPG9sPi4uLjwvb2w+YCBlbGVtZW50KSB3aXRoIGNsYXNzIG5hbWVzIG9mIGJvdGggYHRoaXMuY2xhc3NQcmVmaXhgIGFuZCBgJ3Rlc3QtcGFuZWwnYCAob3IsIGJhcnJpbmcgdGhhdCwgYW55IGVsZW1lbnQgd2l0aCBjbGFzcyBuYW1lIGAndGVzdC1wYW5lbCdgKSwgYW4gYDxsaT4uLi48L2xpPmAgZWxlbWVudCB3aWxsIGJlIGNyZWF0ZWQgYW5kIGFwcGVuZGVkIHRvIGl0LiBUaGlzIG5ldyBlbGVtZW50IHdpbGwgY29udGFpbiBhIHNwYW4gZm9yIGVhY2ggY2xhc3MgbmFtZSBnaXZlbi5cbiAgICAgKlxuICAgICAqIFlvdSBzaG91bGQgZGVmaW5lIGEgQ1NTIHNlbGVjdG9yIGAubGlzdGVuaW5nYCBmb3IgdGhlc2Ugc3BhbnMuIFRoaXMgY2xhc3Mgd2lsbCBiZSBhZGRlZCB0byB0aGUgc3BhbnMgdG8gYWx0ZXIgdGhlaXIgYXBwZWFyYW5jZSB3aGVuIGEgbGlzdGVuZXIgaXMgYWRkZWQgd2l0aCB0aGF0IGNsYXNzIG5hbWUgKHByZWZpeGVkIHdpdGggJ29uJykuXG4gICAgICpcbiAgICAgKiAoVGhpcyBpcyBhbiBpbnRlcm5hbCBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCBvbmNlIGJ5IHRoZSBjb25zdHJ1Y3RvciBvbiBldmVyeSBpbnN0YW50aWF0aW9uLilcbiAgICAgKiBAcmV0dXJucyB7RWxlbWVudHx1bmRlZmluZWR9IFRoZSBhcHBlbmRlZCBgPGxpPi4uLjwvbGk+YCBlbGVtZW50IG9yIGB1bmRlZmluZWRgIGlmIHRoZXJlIGlzIG5vIHRlc3QgcGFuZWwuXG4gICAgICogQG1lbWJlck9mIEZpbkJhci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBfYWRkVGVzdFBhbmVsSXRlbTogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdGVzdFBhbmVsSXRlbSxcbiAgICAgICAgICAgIHRlc3RQYW5lbEVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuJyArIHRoaXMuX2NsYXNzUHJlZml4ICsgJy50ZXN0LXBhbmVsJykgfHwgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnRlc3QtcGFuZWwnKTtcblxuICAgICAgICBpZiAodGVzdFBhbmVsRWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIHRlc3RQYW5lbEl0ZW1QYXJ0TmFtZXMgPSBbICdtb3VzZWRvd24nLCAnbW91c2Vtb3ZlJywgJ21vdXNldXAnLCAnaW5kZXgnIF0sXG4gICAgICAgICAgICAgICAgaXRlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpJyk7XG5cbiAgICAgICAgICAgIHRlc3RQYW5lbEl0ZW1QYXJ0TmFtZXMuZm9yRWFjaChmdW5jdGlvbiAocGFydE5hbWUpIHtcbiAgICAgICAgICAgICAgICBpdGVtLmlubmVySFRNTCArPSAnPHNwYW4gY2xhc3M9XCInICsgcGFydE5hbWUgKyAnXCI+JyArIHBhcnROYW1lLnJlcGxhY2UoJ21vdXNlJywgJycpICsgJzwvc3Bhbj4nO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRlc3RQYW5lbEVsZW1lbnQuYXBwZW5kQ2hpbGQoaXRlbSk7XG5cbiAgICAgICAgICAgIHRlc3RQYW5lbEl0ZW0gPSB7fTtcbiAgICAgICAgICAgIHRlc3RQYW5lbEl0ZW1QYXJ0TmFtZXMuZm9yRWFjaChmdW5jdGlvbiAocGFydE5hbWUpIHtcbiAgICAgICAgICAgICAgICB0ZXN0UGFuZWxJdGVtW3BhcnROYW1lXSA9IGl0ZW0uZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShwYXJ0TmFtZSlbMF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0ZXN0UGFuZWxJdGVtO1xuICAgIH0sXG5cbiAgICBfYWRkRXZ0OiBmdW5jdGlvbiAoZXZ0TmFtZSkge1xuICAgICAgICB2YXIgc3B5ID0gdGhpcy50ZXN0UGFuZWxJdGVtICYmIHRoaXMudGVzdFBhbmVsSXRlbVtldnROYW1lXTtcbiAgICAgICAgaWYgKHNweSkgeyBzcHkuY2xhc3NMaXN0LmFkZCgnbGlzdGVuaW5nJyk7IH1cbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoZXZ0TmFtZSwgdGhpcy5fYm91bmRbJ29uJyArIGV2dE5hbWVdKTtcbiAgICB9LFxuXG4gICAgX3JlbW92ZUV2dDogZnVuY3Rpb24gKGV2dE5hbWUpIHtcbiAgICAgICAgdmFyIHNweSA9IHRoaXMudGVzdFBhbmVsSXRlbSAmJiB0aGlzLnRlc3RQYW5lbEl0ZW1bZXZ0TmFtZV07XG4gICAgICAgIGlmIChzcHkpIHsgc3B5LmNsYXNzTGlzdC5yZW1vdmUoJ2xpc3RlbmluZycpOyB9XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKGV2dE5hbWUsIHRoaXMuX2JvdW5kWydvbicgKyBldnROYW1lXSk7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gZXh0ZW5kKG9iaikge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBvYmpuID0gYXJndW1lbnRzW2ldO1xuICAgICAgICBpZiAob2Jqbikge1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIG9iam4pIHtcbiAgICAgICAgICAgICAgICBvYmpba2V5XSA9IG9iam5ba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiB2YWxpZFJhbmdlKHJhbmdlKSB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhyYW5nZSksXG4gICAgICAgIHZhbGlkID0gIGtleXMubGVuZ3RoID09PSAyICYmXG4gICAgICAgICAgICB0eXBlb2YgcmFuZ2UubWluID09PSAnbnVtYmVyJyAmJlxuICAgICAgICAgICAgdHlwZW9mIHJhbmdlLm1heCA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgICAgIHJhbmdlLm1pbiA8PSByYW5nZS5tYXg7XG5cbiAgICBpZiAoIXZhbGlkKSB7XG4gICAgICAgIGVycm9yKCdJbnZhbGlkIC5yYW5nZSBvYmplY3QuJyk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYW5kbGVyc1RvQmVCb3VuZFxuICogQHR5cGUge29iamVjdH1cbiAqIEBkZXNjIFRoZSBmdW5jdGlvbnMgZGVmaW5lZCBpbiB0aGlzIG9iamVjdCBhcmUgYWxsIERPTSBldmVudCBoYW5kbGVycyB0aGF0IGFyZSBib3VuZCBieSB0aGUgRmluQmFyIGNvbnN0cnVjdG9yIHRvIGVhY2ggbmV3IGluc3RhbmNlLiBJbiBvdGhlciB3b3JkcywgdGhlIGB0aGlzYCB2YWx1ZSBvZiB0aGVzZSBoYW5kbGVycywgb25jZSBib3VuZCwgcmVmZXIgdG8gdGhlIEZpbkJhciBvYmplY3QgYW5kIG5vdCB0byB0aGUgZXZlbnQgZW1pdHRlci4gXCJEbyBub3QgY29uc3VtZSByYXcuXCJcbiAqL1xudmFyIGhhbmRsZXJzVG9CZUJvdW5kID0ge1xuICAgIHNob3J0U3RvcDogZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfSxcblxuICAgIG9ud2hlZWw6IGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgdGhpcy5pbmRleCArPSBldnRbdGhpcy5kZWx0YVByb3BdO1xuICAgICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0sXG5cbiAgICBvbmNsaWNrOiBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgIHZhciB0aHVtYkJveCA9IHRoaXMudGh1bWIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgICAgICBnb2luZ1VwID0gZXZ0W3RoaXMub2guY29vcmRpbmF0ZV0gPCB0aHVtYkJveFt0aGlzLm9oLmxlYWRpbmddO1xuXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5wYWdpbmcgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB0aGlzLmluZGV4ID0gdGhpcy5wYWdpbmdbZ29pbmdVcCA/ICd1cCcgOiAnZG93biddKE1hdGgucm91bmQodGhpcy5pbmRleCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pbmRleCArPSBnb2luZ1VwID8gLXRoaXMuaW5jcmVtZW50IDogdGhpcy5pbmNyZW1lbnQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBtYWtlIHRoZSB0aHVtYiBnbG93IG1vbWVudGFyaWx5XG4gICAgICAgIHRoaXMudGh1bWIuY2xhc3NMaXN0LmFkZCgnaG92ZXInKTtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB0aGlzLnRodW1iLmFkZEV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCBmdW5jdGlvbiB3YWl0Rm9ySXQoKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCB3YWl0Rm9ySXQpO1xuICAgICAgICAgICAgc2VsZi5fYm91bmQub25tb3VzZXVwKGV2dCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9LFxuXG4gICAgb25tb3VzZW92ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50aHVtYi5jbGFzc0xpc3QuYWRkKCdob3ZlcicpO1xuICAgICAgICB0aGlzLnRodW1iLm9ubW91c2VvdXQgPSB0aGlzLl9ib3VuZC5vbm1vdXNlb3V0O1xuICAgICAgICB0aGlzLl9hZGRFdnQoJ21vdXNlZG93bicpO1xuICAgIH0sXG5cbiAgICBvbm1vdXNlb3V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3JlbW92ZUV2dCgnbW91c2Vkb3duJyk7XG4gICAgICAgIHRoaXMudGh1bWIub25tb3VzZW92ZXIgPSB0aGlzLl9ib3VuZC5vbm1vdXNlb3ZlcjtcbiAgICAgICAgdGhpcy50aHVtYi5jbGFzc0xpc3QucmVtb3ZlKCdob3ZlcicpO1xuICAgIH0sXG5cbiAgICBvbm1vdXNlZG93bjogZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICB0aGlzLl9yZW1vdmVFdnQoJ21vdXNlZG93bicpO1xuICAgICAgICB0aGlzLnRodW1iLm9ubW91c2VvdmVyID0gdGhpcy50aHVtYi5vbm1vdXNlb3V0ID0gbnVsbDtcblxuICAgICAgICB2YXIgdGh1bWJCb3ggPSB0aGlzLnRodW1iLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB0aGlzLnBpbk9mZnNldCA9IGV2dFt0aGlzLm9oLmF4aXNdIC0gdGh1bWJCb3hbdGhpcy5vaC5sZWFkaW5nXSArIHRoaXMuYmFyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpW3RoaXMub2gubGVhZGluZ10gKyB0aGlzLl90aHVtYk1hcmdpbkxlYWRpbmc7XG4gICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5jdXJzb3IgPSAnZGVmYXVsdCc7XG5cbiAgICAgICAgdGhpcy5fYWRkRXZ0KCdtb3VzZW1vdmUnKTtcbiAgICAgICAgdGhpcy5fYWRkRXZ0KCdtb3VzZXVwJyk7XG5cbiAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9LFxuXG4gICAgb25tb3VzZW1vdmU6IGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgdmFyIHNjYWxlZCA9IE1hdGgubWluKHRoaXMuX3RodW1iTWF4LCBNYXRoLm1heCgwLCBldnRbdGhpcy5vaC5heGlzXSAtIHRoaXMucGluT2Zmc2V0KSk7XG4gICAgICAgIHZhciBpZHggPSBzY2FsZWQgLyB0aGlzLl90aHVtYk1heCAqICh0aGlzLl9tYXggLSB0aGlzLl9taW4pICsgdGhpcy5fbWluO1xuXG4gICAgICAgIHRoaXMuX3NldFNjcm9sbChpZHgsIHNjYWxlZCk7XG5cbiAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9LFxuXG4gICAgb25tb3VzZXVwOiBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgIHRoaXMuX3JlbW92ZUV2dCgnbW91c2Vtb3ZlJyk7XG4gICAgICAgIHRoaXMuX3JlbW92ZUV2dCgnbW91c2V1cCcpO1xuXG4gICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5jdXJzb3IgPSAnYXV0byc7XG5cbiAgICAgICAgdmFyIHRodW1iQm94ID0gdGhpcy50aHVtYi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgdGh1bWJCb3gubGVmdCA8PSBldnQuY2xpZW50WCAmJiBldnQuY2xpZW50WCA8PSB0aHVtYkJveC5yaWdodCAmJlxuICAgICAgICAgICAgdGh1bWJCb3gudG9wIDw9IGV2dC5jbGllbnRZICYmIGV2dC5jbGllbnRZIDw9IHRodW1iQm94LmJvdHRvbVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHRoaXMuX2JvdW5kLm9ubW91c2VvdmVyKGV2dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9ib3VuZC5vbm1vdXNlb3V0KGV2dCk7XG4gICAgICAgIH1cblxuICAgICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbn07XG5cbnZhciBvcmllbnRhdGlvbkhhc2hlcyA9IHtcbiAgICB2ZXJ0aWNhbDoge1xuICAgICAgICBjb29yZGluYXRlOiAgICAgJ2NsaWVudFknLFxuICAgICAgICBheGlzOiAgICAgICAgICAgJ3BhZ2VZJyxcbiAgICAgICAgc2l6ZTogICAgICAgICAgICdoZWlnaHQnLFxuICAgICAgICBvdXRzaWRlOiAgICAgICAgJ3JpZ2h0JyxcbiAgICAgICAgaW5zaWRlOiAgICAgICAgICdsZWZ0JyxcbiAgICAgICAgbGVhZGluZzogICAgICAgICd0b3AnLFxuICAgICAgICB0cmFpbGluZzogICAgICAgJ2JvdHRvbScsXG4gICAgICAgIG1hcmdpbkxlYWRpbmc6ICAnbWFyZ2luVG9wJyxcbiAgICAgICAgbWFyZ2luVHJhaWxpbmc6ICdtYXJnaW5Cb3R0b20nLFxuICAgICAgICB0aGlja25lc3M6ICAgICAgJ3dpZHRoJyxcbiAgICAgICAgZGVsdGE6ICAgICAgICAgICdkZWx0YVknXG4gICAgfSxcbiAgICBob3Jpem9udGFsOiB7XG4gICAgICAgIGNvb3JkaW5hdGU6ICAgICAnY2xpZW50WCcsXG4gICAgICAgIGF4aXM6ICAgICAgICAgICAncGFnZVgnLFxuICAgICAgICBzaXplOiAgICAgICAgICAgJ3dpZHRoJyxcbiAgICAgICAgb3V0c2lkZTogICAgICAgICdib3R0b20nLFxuICAgICAgICBpbnNpZGU6ICAgICAgICAgJ3RvcCcsXG4gICAgICAgIGxlYWRpbmc6ICAgICAgICAnbGVmdCcsXG4gICAgICAgIHRyYWlsaW5nOiAgICAgICAncmlnaHQnLFxuICAgICAgICBtYXJnaW5MZWFkaW5nOiAgJ21hcmdpbkxlZnQnLFxuICAgICAgICBtYXJnaW5UcmFpbGluZzogJ21hcmdpblJpZ2h0JyxcbiAgICAgICAgdGhpY2tuZXNzOiAgICAgICdoZWlnaHQnLFxuICAgICAgICBkZWx0YTogICAgICAgICAgJ2RlbHRhWCdcbiAgICB9XG59O1xuXG52YXIgYXhpcyA9IHtcbiAgICB0b3A6ICAgICd2ZXJ0aWNhbCcsXG4gICAgYm90dG9tOiAndmVydGljYWwnLFxuICAgIGhlaWdodDogJ3ZlcnRpY2FsJyxcbiAgICBsZWZ0OiAgICdob3Jpem9udGFsJyxcbiAgICByaWdodDogICdob3Jpem9udGFsJyxcbiAgICB3aWR0aDogICdob3Jpem9udGFsJ1xufTtcblxudmFyIGNzc0ZpbkJhcnM7IC8vIGRlZmluaXRpb24gaW5zZXJ0ZWQgYnkgZ3VscGZpbGUgYmV0d2VlbiBmb2xsb3dpbmcgY29tbWVudHNcbi8qIGluamVjdDpjc3MgKi9cbmNzc0ZpbkJhcnMgPSAnZGl2LmZpbmJhci1ob3Jpem9udGFsLGRpdi5maW5iYXItdmVydGljYWx7cG9zaXRpb246YWJzb2x1dGU7bWFyZ2luOjNweH1kaXYuZmluYmFyLWhvcml6b250YWw+LnRodW1iLGRpdi5maW5iYXItdmVydGljYWw+LnRodW1ie3Bvc2l0aW9uOmFic29sdXRlO2JhY2tncm91bmQtY29sb3I6I2QzZDNkMzstd2Via2l0LWJveC1zaGFkb3c6MCAwIDFweCAjMDAwOy1tb3otYm94LXNoYWRvdzowIDAgMXB4ICMwMDA7Ym94LXNoYWRvdzowIDAgMXB4ICMwMDA7Ym9yZGVyLXJhZGl1czo0cHg7bWFyZ2luOjJweDtvcGFjaXR5Oi40O3RyYW5zaXRpb246b3BhY2l0eSAuNXN9ZGl2LmZpbmJhci1ob3Jpem9udGFsPi50aHVtYi5ob3ZlcixkaXYuZmluYmFyLXZlcnRpY2FsPi50aHVtYi5ob3ZlcntvcGFjaXR5OjE7dHJhbnNpdGlvbjpvcGFjaXR5IC41c31kaXYuZmluYmFyLXZlcnRpY2Fse3RvcDowO2JvdHRvbTowO3JpZ2h0OjA7d2lkdGg6MTFweH1kaXYuZmluYmFyLXZlcnRpY2FsPi50aHVtYnt0b3A6MDtyaWdodDowO3dpZHRoOjdweH1kaXYuZmluYmFyLWhvcml6b250YWx7bGVmdDowO3JpZ2h0OjA7Ym90dG9tOjA7aGVpZ2h0OjExcHh9ZGl2LmZpbmJhci1ob3Jpem9udGFsPi50aHVtYntsZWZ0OjA7Ym90dG9tOjA7aGVpZ2h0OjdweH0nO1xuLyogZW5kaW5qZWN0ICovXG5cbmZ1bmN0aW9uIGVycm9yKG1zZykge1xuICAgIHRocm93ICdmaW5iYXJzOiAnICsgbXNnO1xufVxuXG4vLyBJbnRlcmZhY2Vcbm1vZHVsZS5leHBvcnRzID0gRmluQmFyO1xuIiwiLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHJlY3Rhbmd1bGFyID0gcmVxdWlyZSgncmVjdGFuZ3VsYXInKTtcblxudmFyIGdlc3R1cmVzID0gcmVxdWlyZSgnLi9qcy9wb2x5bWVyZ2VzdHVyZXMuZGV2LmpzJyk7XG52YXIgR3JhcGhpY3NDb250ZXh0ID0gcmVxdWlyZSgnLi9qcy9HcmFwaGljc0NvbnRleHQuanMnKTtcblxudmFyIFJFU0laRV9QT0xMSU5HX0lOVEVSVkFMID0gMjAwLFxuICAgIHBhaW50YWJsZXMgPSBbXSxcbiAgICByZXNpemFibGVzID0gW10sXG4gICAgcGFpbnRMb29wUnVubmluZyA9IHRydWUsXG4gICAgcmVzaXplTG9vcFJ1bm5pbmcgPSB0cnVlLFxuICAgIGNoYXJNYXAgPSBtYWtlQ2hhck1hcCgpO1xuXG5mdW5jdGlvbiBDYW52YXMoZGl2LCBjb21wb25lbnQsIG9wdGlvbnMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB0aGlzLmRpdiA9IGRpdjtcbiAgICB0aGlzLmNvbXBvbmVudCA9IGNvbXBvbmVudDtcblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHRoaXMuZG91YmxlQ2xpY2tEZWxheSA9IG9wdGlvbnMuZG91YmxlQ2xpY2tEZWxheSB8fCAzMjU7XG5cbiAgICB0aGlzLmRyYWdFbmR0aW1lID0gRGF0ZS5ub3coKTtcblxuICAgIHRoaXMuY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgdGhpcy5kaXYuYXBwZW5kQ2hpbGQodGhpcy5jYW52YXMpO1xuXG4gICAgdGhpcy5jYW52YXMuc3R5bGUub3V0bGluZSA9ICdub25lJztcblxuICAgIC8vIHRoaXMuZm9jdXNlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgIC8vIHRoaXMuZm9jdXNlci5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgLy8gdGhpcy5mb2N1c2VyLnN0eWxlLnRvcCA9ICcwcHgnO1xuICAgIC8vIHRoaXMuZm9jdXNlci5zdHlsZS5sZWZ0ID0gJzBweCc7XG4gICAgLy8gdGhpcy5mb2N1c2VyLnN0eWxlLnpJbmRleCA9ICctMSc7XG4gICAgLy8gdGhpcy5mb2N1c2VyLnN0eWxlLm91dGxpbmUgPSAnbm9uZSc7XG4gICAgLy8gdGhpcy5kaXYuYXBwZW5kQ2hpbGQodGhpcy5mb2N1c2VyKTtcblxuICAgIHRoaXMuY2FudmFzQ1RYID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICB0aGlzLmdjID0gbmV3IEdyYXBoaWNzQ29udGV4dCh0aGlzLmNhbnZhc0NUWCk7XG5cbiAgICB0aGlzLmJ1ZmZlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIHRoaXMuYnVmZmVyQ1RYID0gdGhpcy5idWZmZXIuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICB0aGlzLmJ1ZmZlckdDID0gbmV3IEdyYXBoaWNzQ29udGV4dCh0aGlzLmJ1ZmZlckNUWCk7XG5cbiAgICB0aGlzLm1vdXNlTG9jYXRpb24gPSBuZXcgcmVjdGFuZ3VsYXIuUG9pbnQoLTEsIC0xKTtcbiAgICB0aGlzLmRyYWdzdGFydCA9IG5ldyByZWN0YW5ndWxhci5Qb2ludCgtMSwgLTEpO1xuICAgIC8vdGhpcy5vcmlnaW4gPSBuZXcgcmVjdGFuZ3VsYXIuUG9pbnQoMCwgMCk7XG4gICAgdGhpcy5ib3VuZHMgPSBuZXcgcmVjdGFuZ3VsYXIuUmVjdGFuZ2xlKDAsIDAsIDAsIDApO1xuICAgIHRoaXMuaGFzTW91c2UgPSBmYWxzZTtcblxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKHNlbGYuaGFzTW91c2UgfHwgc2VsZi5pc0RyYWdnaW5nKCkpIHtcbiAgICAgICAgICAgIHNlbGYuZmlubW91c2Vtb3ZlKGUpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgc2VsZi5maW5tb3VzZXVwKGUpO1xuICAgIH0pO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3doZWVsJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBzZWxmLmZpbndoZWVsbW92ZWQoZSk7XG4gICAgfSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgc2VsZi5maW5rZXlkb3duKGUpO1xuICAgIH0pO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBzZWxmLmZpbmtleXVwKGUpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5jYW52YXMub25tb3VzZW92ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgc2VsZi5oYXNNb3VzZSA9IHRydWU7XG4gICAgfTtcbiAgICB0aGlzLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdmb2N1cycsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgc2VsZi5maW5mb2N1c2dhaW5lZChlKTtcbiAgICB9KTtcbiAgICB0aGlzLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBzZWxmLmZpbmZvY3VzbG9zdChlKTtcbiAgICB9KTtcbiAgICB0aGlzLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIHNlbGYuZmlubW91c2Vkb3duKGUpO1xuICAgIH0pO1xuICAgIHRoaXMuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3V0JywgZnVuY3Rpb24oZSkge1xuICAgICAgICBzZWxmLmhhc01vdXNlID0gZmFsc2U7XG4gICAgICAgIHNlbGYuZmlubW91c2VvdXQoZSk7XG4gICAgfSk7XG4gICAgdGhpcy5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIHNlbGYuZmluY2xpY2soZSk7XG4gICAgfSk7XG4gICAgdGhpcy5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIHNlbGYuZmluY29udGV4dG1lbnUoZSk7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0pO1xuXG4gICAgZ2VzdHVyZXMuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLmNhbnZhcywgJ3RhcCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgc2VsZi5maW50YXAoZSk7XG4gICAgfSk7XG4gICAgZ2VzdHVyZXMuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLmNhbnZhcywgJ2hvbGRwdWxzZScsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgc2VsZi5maW5ob2xkcHVsc2UoZSk7XG4gICAgfSk7XG4gICAgZ2VzdHVyZXMuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLmNhbnZhcywgJ2ZsaWNrJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBzZWxmLmZpbmZsaWNrKGUpO1xuICAgIH0pO1xuICAgIGdlc3R1cmVzLmFkZEV2ZW50TGlzdGVuZXIodGhpcy5jYW52YXMsICdyZWxlYXNlJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBzZWxmLmZpbnJlbGVhc2UoZSk7XG4gICAgfSk7XG4gICAgZ2VzdHVyZXMuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLmNhbnZhcywgJ3RyYWNrc3RhcnQnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIHNlbGYuZmludHJhY2tzdGFydChlKTtcbiAgICB9KTtcbiAgICBnZXN0dXJlcy5hZGRFdmVudExpc3RlbmVyKHRoaXMuY2FudmFzLCAndHJhY2snLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIHNlbGYuZmludHJhY2soZSk7XG4gICAgfSk7XG4gICAgZ2VzdHVyZXMuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLmNhbnZhcywgJ3RyYWNrZW5kJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBzZWxmLmZpbnRyYWNrZW5kKGUpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5jYW52YXMuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsIDApO1xuICAgIHRoaXMuY2FudmFzLmNvbnRlbnRFZGl0YWJsZSA9IHRydWU7XG5cbiAgICB0aGlzLnJlc2l6ZSgpO1xuXG4gICAgdGhpcy5iZWdpblJlc2l6aW5nKCk7XG4gICAgdGhpcy5iZWdpblBhaW50aW5nKCk7XG59XG5cbkNhbnZhcy5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IENhbnZhcy5wcm90b3R5cGUuY29uc3RydWN0b3IsXG4gICAgZGl2OiBudWxsLFxuICAgIGNvbXBvbmVudDogbnVsbCxcbiAgICBnZXN0dXJlczogZ2VzdHVyZXMsIC8vIFRPRE86IHdoeSBkbyB3ZSBuZWVkIHRoaXM/ICh3YXMgcHJldmlvdXNseSBhdCBib3R0b20gb2YgZmlsZSlcbiAgICBjYW52YXM6IG51bGwsXG4gICAgY2FudmFzQ1RYOiBudWxsLFxuICAgIGZvY3VzZXI6IG51bGwsXG4gICAgYnVmZmVyOiBudWxsLFxuICAgIGN0eDogbnVsbCxcbiAgICBtb3VzZUxvY2F0aW9uOiBudWxsLFxuICAgIGhvbGRQdWxzZUNvdW50OiAtMSxcbiAgICBkcmFnc3RhcnQ6IG51bGwsXG4gICAgb3JpZ2luOiBudWxsLFxuICAgIGJvdW5kczogbnVsbCxcbiAgICBkaXJ0eTogZmFsc2UsXG4gICAgc2l6ZTogbnVsbCxcbiAgICBtb3VzZWRvd246IGZhbHNlLFxuICAgIGRyYWdnaW5nOiBmYWxzZSxcbiAgICByZXBlYXRLZXlDb3VudDogMCxcbiAgICByZXBlYXRLZXk6IG51bGwsXG4gICAgcmVwZWF0S2V5U3RhcnRUaW1lOiAwLFxuICAgIGN1cnJlbnRLZXlzOiBbXSxcbiAgICBoYXNNb3VzZTogZmFsc2UsXG4gICAgbGFzdERvdWJsZUNsaWNrVGltZTogMCxcbiAgICBkcmFnRW5kVGltZTogMCxcbiAgICBsYXN0UmVwYWludFRpbWU6IDAsXG5cbiAgICBhZGRFdmVudExpc3RlbmVyOiBmdW5jdGlvbihuYW1lLCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGNhbGxiYWNrKTtcbiAgICB9LFxuXG4gICAgc3RvcFBhaW50TG9vcDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHBhaW50TG9vcFJ1bm5pbmcgPSBmYWxzZTtcbiAgICB9LFxuXG4gICAgcmVzdGFydFBhaW50TG9vcDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChwYWludExvb3BSdW5uaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47IC8vIGFscmVhZHkgcnVubmluZ1xuICAgICAgICB9XG4gICAgICAgIHBhaW50TG9vcFJ1bm5pbmcgPSB0cnVlO1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocGFpbnRMb29wRnVuY3Rpb24pO1xuICAgIH0sXG5cbiAgICBzdG9wUmVzaXplTG9vcDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlc2l6ZUxvb3BSdW5uaW5nID0gZmFsc2U7XG4gICAgfSxcblxuICAgIHJlc3RhcnRSZXNpemVMb29wOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHJlc2l6ZUxvb3BSdW5uaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47IC8vIGFscmVhZHkgcnVubmluZ1xuICAgICAgICB9XG4gICAgICAgIHJlc2l6ZUxvb3BSdW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgc2V0SW50ZXJ2YWwocmVzaXphYmxlc0xvb3BGdW5jdGlvbiwgMjAwKTtcbiAgICB9LFxuXG4gICAgZGV0YWNoZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnN0b3BQYWludGluZygpO1xuICAgICAgICB0aGlzLnN0b3BSZXNpemluZygpO1xuICAgIH0sXG5cbiAgICB1c2VIaURQSTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBvbmVudC5yZXNvbHZlUHJvcGVydHkoJ3VzZUhpRFBJJyk7XG4gICAgfSxcblxuICAgIHVzZUJpdEJsaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21wb25lbnQucmVzb2x2ZVByb3BlcnR5KCd1c2VCaXRCbGl0Jyk7XG4gICAgfSxcblxuICAgIGdldEZQUzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBmcHMgPSB0aGlzLmNvbXBvbmVudC5yZXNvbHZlUHJvcGVydHkoJ3JlcGFpbnRJbnRlcnZhbFJhdGUnKTtcbiAgICAgICAgcmV0dXJuIGZwcyA/IHBhcnNlSW50KGZwcykgOiAwO1xuICAgIH0sXG5cbiAgICB0aWNrUGFpbnQ6IGZ1bmN0aW9uKG5vdykge1xuICAgICAgICB2YXIgZnBzID0gdGhpcy5nZXRGUFMoKTtcbiAgICAgICAgaWYgKGZwcyA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbnRlcnZhbCA9IDEwMDAgLyBmcHM7XG5cbiAgICAgICAgdmFyIGVsYXBzZWQgPSBub3cgLSB0aGlzLmxhc3RSZXBhaW50VGltZTtcbiAgICAgICAgaWYgKGVsYXBzZWQgPiBpbnRlcnZhbCAmJiB0aGlzLmRpcnR5KSB7XG4gICAgICAgICAgICB0aGlzLmxhc3RSZXBhaW50VGltZSA9IG5vdyAtIChlbGFwc2VkICUgaW50ZXJ2YWwpO1xuICAgICAgICAgICAgdGhpcy5wYWludE5vdygpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGJlZ2luUGFpbnRpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgICB0aGlzLnRpY2tQYWludGVyID0gZnVuY3Rpb24obm93KSB7XG4gICAgICAgICAgICBzZWxmLnRpY2tQYWludChub3cpO1xuICAgICAgICB9O1xuICAgICAgICBwYWludGFibGVzLnB1c2godGhpcyk7XG4gICAgfSxcblxuICAgIHN0b3BQYWludGluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHBhaW50YWJsZXMuc3BsaWNlKHBhaW50YWJsZXMuaW5kZXhPZih0aGlzKSwgMSk7XG4gICAgfSxcblxuICAgIGJlZ2luUmVzaXppbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHRoaXMudGlja1Jlc2l6ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNlbGYuY2hlY2tzaXplKCk7XG4gICAgICAgIH07XG4gICAgICAgIHJlc2l6YWJsZXMucHVzaCh0aGlzKTtcbiAgICB9LFxuXG4gICAgc3RvcFJlc2l6aW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmVzaXphYmxlcy5zcGxpY2UocmVzaXphYmxlcy5pbmRleE9mKHRoaXMpLCAxKTtcbiAgICB9LFxuXG4gICAgc3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmJlZ2luUGFpbnRpbmcoKTtcbiAgICAgICAgdGhpcy5iZWdpblJlc2l6aW5nKCk7XG4gICAgfSxcblxuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnN0b3BQYWludGluZygpO1xuICAgICAgICB0aGlzLnN0b3BSZXNpemluZygpO1xuICAgIH0sXG5cbiAgICBjaGVja3NpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvL3RoaXMgaXMgZXhwZW5zaXZlIGxldHMgZG8gaXQgYXQgc29tZSBtb2R1bG9cbiAgICAgICAgdmFyIHNpemVOb3cgPSB0aGlzLmRpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgaWYgKHNpemVOb3cud2lkdGggIT09IHRoaXMuc2l6ZS53aWR0aCB8fCBzaXplTm93LmhlaWdodCAhPT0gdGhpcy5zaXplLmhlaWdodCkge1xuICAgICAgICAgICAgdGhpcy5zaXplQ2hhbmdlZE5vdGlmaWNhdGlvbigpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHNpemVDaGFuZ2VkTm90aWZpY2F0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5yZXNpemUoKTtcbiAgICB9LFxuXG4gICAgcmVzaXplOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGJveCA9IHRoaXMuc2l6ZSA9IHRoaXMuZGl2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICAgIHRoaXMuY2FudmFzLndpZHRoID0gdGhpcy5idWZmZXIud2lkdGggPSBib3gud2lkdGg7XG4gICAgICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IHRoaXMuYnVmZmVyLmhlaWdodCA9IGJveC5oZWlnaHQ7XG5cbiAgICAgICAgLy9maXggYWxhIHNpciBzcGlua2EsIHNlZVxuICAgICAgICAvL2h0dHA6Ly93d3cuaHRtbDVyb2Nrcy5jb20vZW4vdHV0b3JpYWxzL2NhbnZhcy9oaWRwaS9cbiAgICAgICAgLy9qdXN0IGFkZCAnaGRwaScgYXMgYW4gYXR0cmlidXRlIHRvIHRoZSBmaW4tY2FudmFzIHRhZ1xuICAgICAgICB2YXIgcmF0aW8gPSAxO1xuICAgICAgICB2YXIgdXNlQml0QmxpdCA9IHRoaXMudXNlQml0QmxpdCgpO1xuICAgICAgICB2YXIgaXNISURQSSA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvICYmIHRoaXMudXNlSGlEUEkoKTtcbiAgICAgICAgaWYgKGlzSElEUEkpIHtcbiAgICAgICAgICAgIHZhciBkZXZpY2VQaXhlbFJhdGlvID0gd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMTtcbiAgICAgICAgICAgIHZhciBiYWNraW5nU3RvcmVSYXRpbyA9IHRoaXMuY2FudmFzQ1RYLndlYmtpdEJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICAgICAgICAgICAgICB0aGlzLmNhbnZhc0NUWC5tb3pCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5jYW52YXNDVFgubXNCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5jYW52YXNDVFgub0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICAgICAgICAgICAgICB0aGlzLmNhbnZhc0NUWC5iYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IDE7XG5cbiAgICAgICAgICAgIHJhdGlvID0gZGV2aWNlUGl4ZWxSYXRpbyAvIGJhY2tpbmdTdG9yZVJhdGlvO1xuICAgICAgICAgICAgLy90aGlzLmNhbnZhc0NUWC5zY2FsZShyYXRpbywgcmF0aW8pO1xuICAgICAgICB9XG4gICAgICAgIHZhciB3aWR0aCA9IHRoaXMuY2FudmFzLmdldEF0dHJpYnV0ZSgnd2lkdGgnKTtcbiAgICAgICAgdmFyIGhlaWdodCA9IHRoaXMuY2FudmFzLmdldEF0dHJpYnV0ZSgnaGVpZ2h0Jyk7XG4gICAgICAgIHRoaXMuY2FudmFzLndpZHRoID0gdGhpcy5idWZmZXIud2lkdGggPSB3aWR0aCAqIHJhdGlvO1xuICAgICAgICB0aGlzLmNhbnZhcy5oZWlnaHQgPSB0aGlzLmJ1ZmZlci5oZWlnaHQgPSBoZWlnaHQgKiByYXRpbztcblxuICAgICAgICB0aGlzLmNhbnZhcy5zdHlsZS53aWR0aCA9IHRoaXMuYnVmZmVyLnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICAgICAgICB0aGlzLmNhbnZhcy5zdHlsZS5oZWlnaHQgPSB0aGlzLmJ1ZmZlci5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuXG4gICAgICAgIHRoaXMuYnVmZmVyQ1RYLnNjYWxlKHJhdGlvLCByYXRpbyk7XG4gICAgICAgIGlmIChpc0hJRFBJICYmICF1c2VCaXRCbGl0KSB7XG4gICAgICAgICAgICB0aGlzLmNhbnZhc0NUWC5zY2FsZShyYXRpbywgcmF0aW8pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy90aGlzLm9yaWdpbiA9IG5ldyByZWN0YW5ndWxhci5Qb2ludChNYXRoLnJvdW5kKHRoaXMuc2l6ZS5sZWZ0KSwgTWF0aC5yb3VuZCh0aGlzLnNpemUudG9wKSk7XG4gICAgICAgIHRoaXMuYm91bmRzID0gbmV3IHJlY3Rhbmd1bGFyLlJlY3RhbmdsZSgwLCAwLCBib3gud2lkdGgsIGJveC5oZWlnaHQpO1xuICAgICAgICAvL3NldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjb21wID0gdGhpcy5jb21wb25lbnQ7XG4gICAgICAgIGlmIChjb21wKSB7XG4gICAgICAgICAgICBjb21wLnNldEJvdW5kcyh0aGlzLmJvdW5kcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXNpemVOb3RpZmljYXRpb24oKTtcbiAgICAgICAgdGhpcy5wYWludE5vdygpO1xuICAgICAgICAvL30pO1xuICAgIH0sXG5cbiAgICByZXNpemVOb3RpZmljYXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAvL3RvIGJlIG92ZXJyaWRkZW5cbiAgICB9LFxuXG4gICAgZ2V0Qm91bmRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYm91bmRzO1xuICAgIH0sXG5cbiAgICBwYWludE5vdzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdGhpcy5zYWZlUGFpbnRJbW1lZGlhdGVseShmdW5jdGlvbihnYykge1xuICAgICAgICAgICAgZ2MuY2xlYXJSZWN0KDAsIDAsIHNlbGYuY2FudmFzLndpZHRoLCBzZWxmLmNhbnZhcy5oZWlnaHQpO1xuXG4gICAgICAgICAgICB2YXIgY29tcCA9IHNlbGYuY29tcG9uZW50O1xuICAgICAgICAgICAgaWYgKGNvbXApIHtcbiAgICAgICAgICAgICAgICBjb21wLnBhaW50KGdjKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VsZi5kaXJ0eSA9IGZhbHNlO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgc2FmZVBhaW50SW1tZWRpYXRlbHk6IGZ1bmN0aW9uKHBhaW50RnVuY3Rpb24pIHtcbiAgICAgICAgdmFyIHVzZUJpdEJsaXQgPSB0aGlzLnVzZUJpdEJsaXQoKSxcbiAgICAgICAgICAgIGdjID0gdXNlQml0QmxpdCA/IHRoaXMuYnVmZmVyR0MgOiB0aGlzLmdjO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZ2Muc2F2ZSgpO1xuICAgICAgICAgICAgcGFpbnRGdW5jdGlvbihnYyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBnYy5yZXN0b3JlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVzZUJpdEJsaXQpIHtcbiAgICAgICAgICAgIHRoaXMuZmx1c2hCdWZmZXIoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBmbHVzaEJ1ZmZlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmJ1ZmZlci53aWR0aCA+IDAgJiYgdGhpcy5idWZmZXIuaGVpZ2h0ID4gMCkge1xuICAgICAgICAgICAgdGhpcy5jYW52YXNDVFguZHJhd0ltYWdlKHRoaXMuYnVmZmVyLCAwLCAwKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBkaXNwYXRjaE5ld0V2ZW50OiBmdW5jdGlvbihldmVudCwgbmFtZSwgZGV0YWlsKSB7XG4gICAgICAgIGRldGFpbCA9IHtcbiAgICAgICAgICAgIGRldGFpbDogZGV0YWlsIHx8IHt9XG4gICAgICAgIH07XG4gICAgICAgIGRldGFpbC5kZXRhaWwucHJpbWl0aXZlRXZlbnQgPSBldmVudDtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FudmFzLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KG5hbWUsIGRldGFpbCkpO1xuICAgIH0sXG5cbiAgICBkaXNwYXRjaE5ld01vdXNlS2V5c0V2ZW50OiBmdW5jdGlvbihldmVudCwgbmFtZSwgZGV0YWlsKSB7XG4gICAgICAgIGRldGFpbCA9IGRldGFpbCB8fCB7fTtcbiAgICAgICAgZGV0YWlsLm1vdXNlID0gdGhpcy5tb3VzZUxvY2F0aW9uO1xuICAgICAgICBkZXRhaWwua2V5cyA9IHRoaXMuY3VycmVudEtleXM7XG4gICAgICAgIHJldHVybiB0aGlzLmRpc3BhdGNoTmV3RXZlbnQoZXZlbnQsIG5hbWUsIGRldGFpbCk7XG4gICAgfSxcblxuICAgIGZpbm1vdXNlbW92ZTogZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAoIXRoaXMuaXNEcmFnZ2luZygpICYmIHRoaXMubW91c2Vkb3duKSB7XG4gICAgICAgICAgICB0aGlzLmJlRHJhZ2dpbmcoKTtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hOZXdNb3VzZUtleXNFdmVudChlLCAnZmluLWNhbnZhcy1kcmFnc3RhcnQnLCB7XG4gICAgICAgICAgICAgICAgaXNSaWdodENsaWNrOiB0aGlzLmlzUmlnaHRDbGljayhlKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmRyYWdzdGFydCA9IG5ldyByZWN0YW5ndWxhci5Qb2ludCh0aGlzLm1vdXNlTG9jYXRpb24ueCwgdGhpcy5tb3VzZUxvY2F0aW9uLnkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW91c2VMb2NhdGlvbiA9IHRoaXMuZ2V0TG9jYWwoZSk7XG4gICAgICAgIC8vY29uc29sZS5sb2codGhpcy5tb3VzZUxvY2F0aW9uKTtcbiAgICAgICAgaWYgKHRoaXMuaXNEcmFnZ2luZygpKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoTmV3TW91c2VLZXlzRXZlbnQoZSwgJ2Zpbi1jYW52YXMtZHJhZycsIHtcbiAgICAgICAgICAgICAgICBkcmFnc3RhcnQ6IHRoaXMuZHJhZ3N0YXJ0LFxuICAgICAgICAgICAgICAgIGlzUmlnaHRDbGljazogdGhpcy5pc1JpZ2h0Q2xpY2soZSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmJvdW5kcy5jb250YWlucyh0aGlzLm1vdXNlTG9jYXRpb24pKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoTmV3TW91c2VLZXlzRXZlbnQoZSwgJ2Zpbi1jYW52YXMtbW91c2Vtb3ZlJyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZmlubW91c2Vkb3duOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHRoaXMubW91c2VMb2NhdGlvbiA9IHRoaXMubW91c2VEb3duTG9jYXRpb24gPSB0aGlzLmdldExvY2FsKGUpO1xuICAgICAgICB0aGlzLm1vdXNlZG93biA9IHRydWU7XG5cbiAgICAgICAgdGhpcy5kaXNwYXRjaE5ld01vdXNlS2V5c0V2ZW50KGUsICdmaW4tY2FudmFzLW1vdXNlZG93bicsIHtcbiAgICAgICAgICAgIGlzUmlnaHRDbGljazogdGhpcy5pc1JpZ2h0Q2xpY2soZSlcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudGFrZUZvY3VzKCk7XG4gICAgfSxcblxuICAgIGZpbm1vdXNldXA6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNEcmFnZ2luZygpKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoTmV3TW91c2VLZXlzRXZlbnQoZSwgJ2Zpbi1jYW52YXMtZHJhZ2VuZCcsIHtcbiAgICAgICAgICAgICAgICBkcmFnc3RhcnQ6IHRoaXMuZHJhZ3N0YXJ0LFxuICAgICAgICAgICAgICAgIGlzUmlnaHRDbGljazogdGhpcy5pc1JpZ2h0Q2xpY2soZSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5iZU5vdERyYWdnaW5nKCk7XG4gICAgICAgICAgICB0aGlzLmRyYWdFbmR0aW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1vdXNlZG93biA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRpc3BhdGNoTmV3TW91c2VLZXlzRXZlbnQoZSwgJ2Zpbi1jYW52YXMtbW91c2V1cCcsIHtcbiAgICAgICAgICAgIGlzUmlnaHRDbGljazogdGhpcy5pc1JpZ2h0Q2xpY2soZSlcbiAgICAgICAgfSk7XG4gICAgICAgIC8vdGhpcy5tb3VzZUxvY2F0aW9uID0gbmV3IHJlY3Rhbmd1bGFyLlBvaW50KC0xLCAtMSk7XG4gICAgfSxcblxuICAgIGZpbm1vdXNlb3V0OiBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmICghdGhpcy5tb3VzZWRvd24pIHtcbiAgICAgICAgICAgIHRoaXMubW91c2VMb2NhdGlvbiA9IG5ldyByZWN0YW5ndWxhci5Qb2ludCgtMSwgLTEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hOZXdNb3VzZUtleXNFdmVudChlLCAnZmluLWNhbnZhcy1tb3VzZW91dCcpO1xuICAgIH0sXG5cbiAgICBmaW53aGVlbG1vdmVkOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRHJhZ2dpbmcoKSB8fCAhdGhpcy5oYXNGb2N1cygpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoTmV3TW91c2VLZXlzRXZlbnQoZSwgJ2Zpbi1jYW52YXMtd2hlZWxtb3ZlZCcsIHtcbiAgICAgICAgICAgIGlzUmlnaHRDbGljazogdGhpcy5pc1JpZ2h0Q2xpY2soZSlcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIGZpbmNsaWNrOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmICh0aGlzLmRvdWJsZUNsaWNrVGltZXIgJiYgRGF0ZS5ub3coKSAtIHRoaXMubGFzdENsaWNrVGltZSA8IHRoaXMuZG91YmxlQ2xpY2tEZWxheSkge1xuICAgICAgICAgICAgLy90aGlzIGlzIGEgZG91YmxlIGNsaWNrLi4uXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5kb3VibGVDbGlja1RpbWVyKTsgLy8gcHJldmVudCBjbGljayBldmVudFxuICAgICAgICAgICAgdGhpcy5kb3VibGVDbGlja1RpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5maW5kYmxjbGljayhlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubGFzdENsaWNrVGltZSA9IERhdGUubm93KCk7XG5cbiAgICAgICAgICAgIHRoaXMuZG91YmxlQ2xpY2tUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kb3VibGVDbGlja1RpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHRoaXMubW91c2VMb2NhdGlvbiA9IHRoaXMuZ2V0TG9jYWwoZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaE5ld01vdXNlS2V5c0V2ZW50KGUsICdmaW4tY2FudmFzLWNsaWNrJywge1xuICAgICAgICAgICAgICAgICAgICBpc1JpZ2h0Q2xpY2s6IHRoaXMuaXNSaWdodENsaWNrKGUpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LmJpbmQodGhpcyksIHRoaXMuZG91YmxlQ2xpY2tEZWxheSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZmlucmVsZWFzZTogZnVuY3Rpb24oZSkge1xuICAgICAgICB0aGlzLmhvbGRQdWxzZUNvdW50ID0gMDtcbiAgICAgICAgdGhpcy5tb3VzZUxvY2F0aW9uID0gdGhpcy5nZXRMb2NhbChlKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaE5ld01vdXNlS2V5c0V2ZW50KGUsICdmaW4tY2FudmFzLXJlbGVhc2UnKTtcbiAgICB9LFxuXG4gICAgZmluZmxpY2s6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc0ZvY3VzKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1vdXNlTG9jYXRpb24gPSB0aGlzLmdldExvY2FsKGUpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoTmV3TW91c2VLZXlzRXZlbnQoZSwgJ2Zpbi1jYW52YXMtZmxpY2snLCB7XG4gICAgICAgICAgICBpc1JpZ2h0Q2xpY2s6IHRoaXMuaXNSaWdodENsaWNrKGUpXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBmaW50cmFja3N0YXJ0OiBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmICghdGhpcy5oYXNGb2N1cygpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb3VzZUxvY2F0aW9uID0gdGhpcy5nZXRMb2NhbChlKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaE5ld01vdXNlS2V5c0V2ZW50KGUsICdmaW4tY2FudmFzLXRyYWNrc3RhcnQnKTtcbiAgICB9LFxuXG4gICAgZmludHJhY2s6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc0ZvY3VzKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1vdXNlTG9jYXRpb24gPSB0aGlzLmdldExvY2FsKGUpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoTmV3TW91c2VLZXlzRXZlbnQoZSwgJ2Zpbi1jYW52YXMtdHJhY2snKTtcbiAgICB9LFxuXG4gICAgZmludHJhY2tlbmQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdGhpcy5tb3VzZUxvY2F0aW9uID0gdGhpcy5nZXRMb2NhbChlKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaE5ld01vdXNlS2V5c0V2ZW50KGUsICdmaW4tY2FudmFzLXRyYWNrZW5kJyk7XG4gICAgfSxcblxuICAgIGZpbmhvbGQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdGhpcy5tb3VzZUxvY2F0aW9uID0gdGhpcy5nZXRMb2NhbChlKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaE5ld01vdXNlS2V5c0V2ZW50KGUsICdmaW4tY2FudmFzLWhvbGQnLCB7XG4gICAgICAgICAgICBpc1JpZ2h0Q2xpY2s6IHRoaXMuaXNSaWdodENsaWNrKGUpXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBmaW5ob2xkcHVsc2U6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdGhpcy5tb3VzZUxvY2F0aW9uID0gdGhpcy5nZXRMb2NhbChlKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaE5ld01vdXNlS2V5c0V2ZW50KGUsICdmaW4tY2FudmFzLWhvbGRwdWxzZScsIHtcbiAgICAgICAgICAgIGNvdW50OiB0aGlzLmhvbGRQdWxzZUNvdW50KytcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIGZpbnRhcDogZnVuY3Rpb24oZSkge1xuICAgICAgICAvL3RoaXMgbm9uc2Vuc2UgaXMgdG8gaG9sZCBhIHRhcCBpZiBpdCdzIHJlYWxseSBhIGRvdWJsZSBjbGlja1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICB2YXIgZGlmID0gbm93IC0gdGhpcy5sYXN0RG91YmxlQ2xpY2tUaW1lO1xuICAgICAgICBpZiAoZGlmIDwgMzAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy9kcmFnZW5kIGlzIGFsc28gY2F1c2luZyBhIHRhcFxuICAgICAgICAvL2xldHMgZml4IHRoaXMgaGVyZVxuICAgICAgICBpZiAobm93IC0gdGhpcy5kcmFnRW5kdGltZSA8IDEwMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzZWxmLl9maW50YXAoZSk7XG4gICAgICAgIH0sIDE4MCk7XG4gICAgfSxcblxuICAgIF9maW50YXA6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgLy90aGlzIG5vbnNlbnNlIGlzIHRvIGhvbGQgYSB0YXAgaWYgaXQncyByZWFsbHkgYSBkb3VibGUgY2xpY2tcbiAgICAgICAgdmFyIG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIHZhciBkaWYgPSBub3cgLSB0aGlzLmxhc3REb3VibGVDbGlja1RpbWU7XG4gICAgICAgIGlmIChkaWYgPCAzMDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm1vdXNlRG93bkxvY2F0aW9uKSB7IC8vIG1heWJlIG5vIG1vdXNlZG93biBvbiBhIHBob25lP1xuICAgICAgICAgICAgdGhpcy5tb3VzZUxvY2F0aW9uID0gdGhpcy5tb3VzZURvd25Mb2NhdGlvbjsgLy8gbW91c2UgbWF5IGhhdmUgbW92ZWQgc2luY2UgbW91c2Vkb3duXG4gICAgICAgICAgICB0aGlzLm1vdXNlRG93bkxvY2F0aW9uID0gdW5kZWZpbmVkOyAvLyBjb25zdW1lIGl0IChtYXliZSBub3QgbmVlZGVkOyBvbmNlIGEgbW91c2Vkb3duIGFsd2F5cyBhIG1vdXNlZG93bilcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hOZXdNb3VzZUtleXNFdmVudChlLCAnZmluLWNhbnZhcy10YXAnLCB7XG4gICAgICAgICAgICBpc1JpZ2h0Q2xpY2s6IHRoaXMuaXNSaWdodENsaWNrKGUpXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBmaW5kYmxjbGljazogZnVuY3Rpb24oZSkge1xuICAgICAgICB0aGlzLm1vdXNlTG9jYXRpb24gPSB0aGlzLmdldExvY2FsKGUpO1xuICAgICAgICB0aGlzLmxhc3REb3VibGVDbGlja1RpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoTmV3TW91c2VLZXlzRXZlbnQoZSwgJ2Zpbi1jYW52YXMtZGJsY2xpY2snLCB7XG4gICAgICAgICAgICBpc1JpZ2h0Q2xpY2s6IHRoaXMuaXNSaWdodENsaWNrKGUpXG4gICAgICAgIH0pO1xuICAgICAgICAvL2NvbnNvbGUubG9nKCdkYmxjbGljaycsIHRoaXMuY3VycmVudEtleXMpO1xuICAgIH0sXG5cbiAgICBnZXRDaGFyTWFwOiBmdW5jdGlvbigpIHsgLy9UT0RPOiBUaGlzIGlzIHN0YXRpYy4gTWFrZSBpdCBhIHByb3BlcnR5IG9mIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgICAgcmV0dXJuIGNoYXJNYXA7XG4gICAgfSxcblxuICAgIGZpbmtleWRvd246IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc0ZvY3VzKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB2YXIga2V5Q2hhciA9IGUuc2hpZnRLZXkgPyBjaGFyTWFwW2Uua2V5Q29kZV1bMV0gOiBjaGFyTWFwW2Uua2V5Q29kZV1bMF07XG4gICAgICAgIGlmIChlLnJlcGVhdCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucmVwZWF0S2V5ID09PSBrZXlDaGFyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXBlYXRLZXlDb3VudCsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcGVhdEtleSA9IGtleUNoYXI7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXBlYXRLZXlTdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZXBlYXRLZXkgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5yZXBlYXRLZXlDb3VudCA9IDA7XG4gICAgICAgICAgICB0aGlzLnJlcGVhdEtleVN0YXJ0VGltZSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY3VycmVudEtleXMuaW5kZXhPZihrZXlDaGFyKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudEtleXMucHVzaChrZXlDaGFyKTtcbiAgICAgICAgfVxuICAgICAgICAvL2NvbnNvbGUubG9nKGtleUNoYXIsIGUua2V5Q29kZSk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hOZXdFdmVudChlLCAnZmluLWNhbnZhcy1rZXlkb3duJywge1xuICAgICAgICAgICAgYWx0OiBlLmFsdEtleSxcbiAgICAgICAgICAgIGN0cmw6IGUuY3RybEtleSxcbiAgICAgICAgICAgIGNoYXI6IGtleUNoYXIsXG4gICAgICAgICAgICBjb2RlOiBlLmNoYXJDb2RlLFxuICAgICAgICAgICAga2V5OiBlLmtleUNvZGUsXG4gICAgICAgICAgICBtZXRhOiBlLm1ldGFLZXksXG4gICAgICAgICAgICByZXBlYXRDb3VudDogdGhpcy5yZXBlYXRLZXlDb3VudCxcbiAgICAgICAgICAgIHJlcGVhdFN0YXJ0VGltZTogdGhpcy5yZXBlYXRLZXlTdGFydFRpbWUsXG4gICAgICAgICAgICBzaGlmdDogZS5zaGlmdEtleSxcbiAgICAgICAgICAgIGlkZW50aWZpZXI6IGUua2V5SWRlbnRpZmllcixcbiAgICAgICAgICAgIGN1cnJlbnRLZXlzOiB0aGlzLmN1cnJlbnRLZXlzLnNsaWNlKDApXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBmaW5rZXl1cDogZnVuY3Rpb24oZSkge1xuICAgICAgICB2YXIga2V5Q2hhciA9IGUuc2hpZnRLZXkgPyBjaGFyTWFwW2Uua2V5Q29kZV1bMV0gOiBjaGFyTWFwW2Uua2V5Q29kZV1bMF07XG4gICAgICAgIHRoaXMuY3VycmVudEtleXMuc3BsaWNlKHRoaXMuY3VycmVudEtleXMuaW5kZXhPZihrZXlDaGFyKSwgMSk7XG4gICAgICAgIGlmICghdGhpcy5oYXNGb2N1cygpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXBlYXRLZXlDb3VudCA9IDA7XG4gICAgICAgIHRoaXMucmVwZWF0S2V5ID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZXBlYXRLZXlTdGFydFRpbWUgPSAwO1xuICAgICAgICB0aGlzLmRpc3BhdGNoTmV3RXZlbnQoZSwgJ2Zpbi1jYW52YXMta2V5dXAnLCB7XG4gICAgICAgICAgICBhbHQ6IGUuYWx0S2V5LFxuICAgICAgICAgICAgY3RybDogZS5jdHJsS2V5LFxuICAgICAgICAgICAgY2hhcjoga2V5Q2hhcixcbiAgICAgICAgICAgIGNvZGU6IGUuY2hhckNvZGUsXG4gICAgICAgICAgICBrZXk6IGUua2V5Q29kZSxcbiAgICAgICAgICAgIG1ldGE6IGUubWV0YUtleSxcbiAgICAgICAgICAgIHJlcGVhdDogZS5yZXBlYXQsXG4gICAgICAgICAgICBzaGlmdDogZS5zaGlmdEtleSxcbiAgICAgICAgICAgIGlkZW50aWZpZXI6IGUua2V5SWRlbnRpZmllcixcbiAgICAgICAgICAgIGN1cnJlbnRLZXlzOiB0aGlzLmN1cnJlbnRLZXlzLnNsaWNlKDApXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBmaW5mb2N1c2dhaW5lZDogZnVuY3Rpb24oZSkge1xuICAgICAgICB0aGlzLmRpc3BhdGNoTmV3RXZlbnQoZSwgJ2Zpbi1jYW52YXMtZm9jdXMtZ2FpbmVkJyk7XG4gICAgfSxcblxuICAgIGZpbmZvY3VzbG9zdDogZnVuY3Rpb24oZSkge1xuICAgICAgICB0aGlzLmRpc3BhdGNoTmV3RXZlbnQoZSwgJ2Zpbi1jYW52YXMtZm9jdXMtbG9zdCcpO1xuICAgIH0sXG5cbiAgICBmaW5jb250ZXh0bWVudTogZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAoZS5jdHJsS2V5ICYmIHRoaXMuY3VycmVudEtleXMuaW5kZXhPZignQ1RSTCcpID09PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50S2V5cy5wdXNoKCdDVFJMJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZG91YmxlUmlnaHRDbGlja1RpbWVyICYmIERhdGUubm93KCkgLSB0aGlzLmxhc3RDbGlja1RpbWUgPCB0aGlzLmRvdWJsZUNsaWNrRGVsYXkpIHtcbiAgICAgICAgICAgIC8vdGhpcyBpcyBhIGRvdWJsZSBjbGljay4uLlxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZG91YmxlUmlnaHRDbGlja1RpbWVyKTsgLy8gcHJldmVudCBjb250ZXh0IG1lbnUgZXZlbnRcbiAgICAgICAgICAgIHRoaXMuZG91YmxlUmlnaHRDbGlja1RpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5maW5kYmxjbGljayhlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubGFzdENsaWNrVGltZSA9IERhdGUubm93KCk7XG5cbiAgICAgICAgICAgIHRoaXMuZG91YmxlUmlnaHRDbGlja1RpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRvdWJsZVJpZ2h0Q2xpY2tUaW1lciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoTmV3TW91c2VLZXlzRXZlbnQoZSwgJ2Zpbi1jYW52YXMtY29udGV4dC1tZW51Jywge1xuICAgICAgICAgICAgICAgICAgICBpc1JpZ2h0Q2xpY2s6IHRoaXMuaXNSaWdodENsaWNrKGUpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LmJpbmQodGhpcyksIHRoaXMuZG91YmxlQ2xpY2tEZWxheSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVwYWludDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBmcHMgPSB0aGlzLmdldEZQUygpO1xuICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgaWYgKCFwYWludExvb3BSdW5uaW5nIHx8IGZwcyA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5wYWludE5vdygpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGdldE1vdXNlTG9jYXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb3VzZUxvY2F0aW9uO1xuICAgIH0sXG5cbiAgICBnZXRPcmlnaW46IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVjdCA9IHRoaXMuY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB2YXIgcCA9IG5ldyByZWN0YW5ndWxhci5Qb2ludChyZWN0LmxlZnQsIHJlY3QudG9wKTtcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfSxcblxuICAgIGdldExvY2FsOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciByZWN0ID0gdGhpcy5jYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHZhciBwID0gbmV3IHJlY3Rhbmd1bGFyLlBvaW50KGUuY2xpZW50WCAtIHJlY3QubGVmdCwgZS5jbGllbnRZIC0gcmVjdC50b3ApO1xuICAgICAgICByZXR1cm4gcDtcbiAgICB9LFxuXG4gICAgaGFzRm9jdXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gdGhpcy5jYW52YXM7XG4gICAgfSxcblxuICAgIHRha2VGb2N1czogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLmhhc0ZvY3VzKCkpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jYW52YXMuZm9jdXMoKTtcbiAgICAgICAgICAgIH0sIDEwKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBiZURyYWdnaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5kcmFnZ2luZyA9IHRydWU7XG4gICAgICAgIHRoaXMuZGlzYWJsZURvY3VtZW50RWxlbWVudFNlbGVjdGlvbigpO1xuICAgIH0sXG5cbiAgICBiZU5vdERyYWdnaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmVuYWJsZURvY3VtZW50RWxlbWVudFNlbGVjdGlvbigpO1xuICAgIH0sXG5cbiAgICBpc0RyYWdnaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJhZ2dpbmc7XG4gICAgfSxcblxuICAgIGRpc2FibGVEb2N1bWVudEVsZW1lbnRTZWxlY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3R5bGUgPSBkb2N1bWVudC5ib2R5LnN0eWxlO1xuICAgICAgICBzdHlsZS5jc3NUZXh0ID0gc3R5bGUuY3NzVGV4dCArICctd2Via2l0LXVzZXItc2VsZWN0OiBub25lJztcbiAgICB9LFxuXG4gICAgZW5hYmxlRG9jdW1lbnRFbGVtZW50U2VsZWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHN0eWxlID0gZG9jdW1lbnQuYm9keS5zdHlsZTtcbiAgICAgICAgc3R5bGUuY3NzVGV4dCA9IHN0eWxlLmNzc1RleHQucmVwbGFjZSgnLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZScsICcnKTtcbiAgICB9LFxuXG4gICAgc2V0Rm9jdXNhYmxlOiBmdW5jdGlvbih0cnV0aHkpIHtcbiAgICAgICAgdGhpcy5mb2N1c2VyLnN0eWxlLmRpc3BsYXkgPSB0cnV0aHkgPyAnJyA6ICdub25lJztcbiAgICB9LFxuXG4gICAgaXNSaWdodENsaWNrOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciBpc1JpZ2h0TUI7XG4gICAgICAgIGUgPSBlIHx8IHdpbmRvdy5ldmVudDtcblxuICAgICAgICBpZiAoJ3doaWNoJyBpbiBlKSB7IC8vIEdlY2tvIChGaXJlZm94KSwgV2ViS2l0IChTYWZhcmkvQ2hyb21lKSAmIE9wZXJhXG4gICAgICAgICAgICBpc1JpZ2h0TUIgPSBlLndoaWNoID09PSAzO1xuICAgICAgICB9IGVsc2UgaWYgKCdidXR0b24nIGluIGUpIHsgLy8gSUUsIE9wZXJhXG4gICAgICAgICAgICBpc1JpZ2h0TUIgPSBlLmJ1dHRvbiA9PT0gMjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNSaWdodE1CO1xuICAgIH0sXG5cbiAgICBkaXNwYXRjaEV2ZW50OiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbnZhcy5kaXNwYXRjaEV2ZW50KGUpO1xuICAgIH1cbn07XG5cbmZ1bmN0aW9uIHBhaW50TG9vcEZ1bmN0aW9uKG5vdykge1xuICAgIGlmICghcGFpbnRMb29wUnVubmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFpbnRhYmxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcGFpbnRhYmxlc1tpXS50aWNrUGFpbnRlcihub3cpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShwYWludExvb3BGdW5jdGlvbik7XG59XG5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUocGFpbnRMb29wRnVuY3Rpb24pO1xuXG5mdW5jdGlvbiByZXNpemFibGVzTG9vcEZ1bmN0aW9uKG5vdykge1xuICAgIGlmICghcmVzaXplTG9vcFJ1bm5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc2l6YWJsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc2l6YWJsZXNbaV0udGlja1Jlc2l6ZXIobm93KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbnNldEludGVydmFsKHJlc2l6YWJsZXNMb29wRnVuY3Rpb24sIFJFU0laRV9QT0xMSU5HX0lOVEVSVkFMKTtcblxuZnVuY3Rpb24gbWFrZUNoYXJNYXAoKSB7XG4gICAgdmFyIG1hcCA9IFtdO1xuXG4gICAgdmFyIGVtcHR5ID0gWycnLCAnJ107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgICAgIG1hcFtpXSA9IGVtcHR5O1xuICAgIH1cblxuICAgIG1hcFsyN10gPSBbJ0VTQycsICdFU0NTSElGVCddO1xuICAgIG1hcFsxOTJdID0gWydgJywgJ34nXTtcbiAgICBtYXBbNDldID0gWycxJywgJyEnXTtcbiAgICBtYXBbNTBdID0gWycyJywgJ0AnXTtcbiAgICBtYXBbNTFdID0gWyczJywgJyMnXTtcbiAgICBtYXBbNTJdID0gWyc0JywgJyQnXTtcbiAgICBtYXBbNTNdID0gWyc1JywgJyUnXTtcbiAgICBtYXBbNTRdID0gWyc2JywgJ14nXTtcbiAgICBtYXBbNTVdID0gWyc3JywgJyYnXTtcbiAgICBtYXBbNTZdID0gWyc4JywgJyonXTtcbiAgICBtYXBbNTddID0gWyc5JywgJygnXTtcbiAgICBtYXBbNDhdID0gWycwJywgJyknXTtcbiAgICBtYXBbMTg5XSA9IFsnLScsICdfJ107XG4gICAgbWFwWzE4N10gPSBbJz0nLCAnKyddO1xuICAgIG1hcFs4XSA9IFsnQkFDS1NQQUNFJywgJ0JBQ0tTUEFDRVNISUZUJ107XG4gICAgbWFwWzQ2XSA9IFsnREVMRVRFJywgJ0RFTEVURVNISUZUJ107XG4gICAgbWFwWzldID0gWydUQUInLCAnVEFCU0hJRlQnXTtcbiAgICBtYXBbODFdID0gWydxJywgJ1EnXTtcbiAgICBtYXBbODddID0gWyd3JywgJ1cnXTtcbiAgICBtYXBbNjldID0gWydlJywgJ0UnXTtcbiAgICBtYXBbODJdID0gWydyJywgJ1InXTtcbiAgICBtYXBbODRdID0gWyd0JywgJ1QnXTtcbiAgICBtYXBbODldID0gWyd5JywgJ1knXTtcbiAgICBtYXBbODVdID0gWyd1JywgJ1UnXTtcbiAgICBtYXBbNzNdID0gWydpJywgJ0knXTtcbiAgICBtYXBbNzldID0gWydvJywgJ08nXTtcbiAgICBtYXBbODBdID0gWydwJywgJ1AnXTtcbiAgICBtYXBbMjE5XSA9IFsnWycsICd7J107XG4gICAgbWFwWzIyMV0gPSBbJ10nLCAnfSddO1xuICAgIG1hcFsyMjBdID0gWydcXFxcJywgJ3wnXTtcbiAgICBtYXBbMjIwXSA9IFsnQ0FQU0xPQ0snLCAnQ0FQU0xPQ0tTSElGVCddO1xuICAgIG1hcFs2NV0gPSBbJ2EnLCAnQSddO1xuICAgIG1hcFs4M10gPSBbJ3MnLCAnUyddO1xuICAgIG1hcFs2OF0gPSBbJ2QnLCAnRCddO1xuICAgIG1hcFs3MF0gPSBbJ2YnLCAnRiddO1xuICAgIG1hcFs3MV0gPSBbJ2cnLCAnRyddO1xuICAgIG1hcFs3Ml0gPSBbJ2gnLCAnSCddO1xuICAgIG1hcFs3NF0gPSBbJ2onLCAnSiddO1xuICAgIG1hcFs3NV0gPSBbJ2snLCAnSyddO1xuICAgIG1hcFs3Nl0gPSBbJ2wnLCAnTCddO1xuICAgIG1hcFsxODZdID0gWyc7JywgJzonXTtcbiAgICBtYXBbMjIyXSA9IFsnXFwnJywgJ3wnXTtcbiAgICBtYXBbMTNdID0gWydSRVRVUk4nLCAnUkVUVVJOU0hJRlQnXTtcbiAgICBtYXBbMTZdID0gWydTSElGVCcsICdTSElGVCddO1xuICAgIG1hcFs5MF0gPSBbJ3onLCAnWiddO1xuICAgIG1hcFs4OF0gPSBbJ3gnLCAnWCddO1xuICAgIG1hcFs2N10gPSBbJ2MnLCAnQyddO1xuICAgIG1hcFs4Nl0gPSBbJ3YnLCAnViddO1xuICAgIG1hcFs2Nl0gPSBbJ2InLCAnQiddO1xuICAgIG1hcFs3OF0gPSBbJ24nLCAnTiddO1xuICAgIG1hcFs3N10gPSBbJ20nLCAnTSddO1xuICAgIG1hcFsxODhdID0gWycsJywgJzwnXTtcbiAgICBtYXBbMTkwXSA9IFsnLicsICc+J107XG4gICAgbWFwWzE5MV0gPSBbJy8nLCAnPyddO1xuICAgIG1hcFsxNl0gPSBbJ1NISUZUJywgJ1NISUZUJ107XG4gICAgbWFwWzE3XSA9IFsnQ1RSTCcsICdDVFJMU0hJRlQnXTtcbiAgICBtYXBbMThdID0gWydBTFQnLCAnQUxUU0hJRlQnXTtcbiAgICBtYXBbOTFdID0gWydDT01NQU5ETEVGVCcsICdDT01NQU5ETEVGVFNISUZUJ107XG4gICAgbWFwWzMyXSA9IFsnU1BBQ0UnLCAnU1BBQ0VTSElGVCddO1xuICAgIG1hcFs5M10gPSBbJ0NPTU1BTkRSSUdIVCcsICdDT01NQU5EUklHSFRTSElGVCddO1xuICAgIG1hcFsxOF0gPSBbJ0FMVCcsICdBTFRTSElGVCddO1xuICAgIG1hcFszOF0gPSBbJ1VQJywgJ1VQU0hJRlQnXTtcbiAgICBtYXBbMzddID0gWydMRUZUJywgJ0xFRlRTSElGVCddO1xuICAgIG1hcFs0MF0gPSBbJ0RPV04nLCAnRE9XTlNISUZUJ107XG4gICAgbWFwWzM5XSA9IFsnUklHSFQnLCAnUklHSFRTSElGVCddO1xuXG4gICAgbWFwWzMzXSA9IFsnUEFHRVVQJywgJ1BBR0VVUFNISUZUJ107XG4gICAgbWFwWzM0XSA9IFsnUEFHRURPV04nLCAnUEFHRURPV05TSElGVCddO1xuICAgIG1hcFszNV0gPSBbJ1BBR0VSSUdIVCcsICdQQUdFUklHSFRTSElGVCddOyAvLyBFTkRcbiAgICBtYXBbMzZdID0gWydQQUdFTEVGVCcsICdQQUdFTEVGVFNISUZUJ107IC8vIEhPTUVcblxuICAgIG1hcFsxMTJdID0gWydGMScsICdGMVNISUZUJ107XG4gICAgbWFwWzExM10gPSBbJ0YyJywgJ0YyU0hJRlQnXTtcbiAgICBtYXBbMTE0XSA9IFsnRjMnLCAnRjNTSElGVCddO1xuICAgIG1hcFsxMTVdID0gWydGNCcsICdGNFNISUZUJ107XG4gICAgbWFwWzExNl0gPSBbJ0Y1JywgJ0Y1U0hJRlQnXTtcbiAgICBtYXBbMTE3XSA9IFsnRjYnLCAnRjZTSElGVCddO1xuICAgIG1hcFsxMThdID0gWydGNycsICdGN1NISUZUJ107XG4gICAgbWFwWzExOV0gPSBbJ0Y4JywgJ0Y4U0hJRlQnXTtcbiAgICBtYXBbMTIwXSA9IFsnRjknLCAnRjlTSElGVCddO1xuICAgIG1hcFsxMjFdID0gWydGMTAnLCAnRjEwU0hJRlQnXTtcbiAgICBtYXBbMTIyXSA9IFsnRjExJywgJ0YxUzFISUZUJ107XG4gICAgbWFwWzEyM10gPSBbJ0YxMicsICdGMTIxSElGVCddO1xuXG4gICAgcmV0dXJuIG1hcDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDYW52YXM7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBjb25zb2xlTG9nZ2VyID0gcmVxdWlyZSgnLi9nYy1jb25zb2xlLWxvZ2dlcicpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIGdjIC0gVGhlIDItRCBncmFwaGljcyBjb250ZXh0IGZyb20geW91ciBjYW52YXNcbiAqIEBwYXJhbSB7Ym9vbGVhbnxhcGlMb2dnZXJ9IFtsb2dnZXI9dHJ1ZV1cbiAqICogYHRydWVgIHVzZXMgYGdjLWNvbnNvbGUtbG9nZ2VyYCBmdW5jdGlvbiBib3VuZCB0byAnZ2MuJyBhcyBwcmVmaXhcbiAqICogc3RyaW5nIHVzZXMgYGdjLWNvbnNvbGUtbG9nZ2VyYCBmdW5jdGlvbiBib3VuZCB0byBzdHJpbmdcbiAqICogZnVuY3Rpb24gdXNlZCBhcyBpc1xuICovXG5mdW5jdGlvbiBHcmFwaGljc0NvbnRleHQoZ2MsIGxvZ2dlcikge1xuICAgIHRoaXMuZ2MgPSBnYztcblxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgcmVXRUJLSVQgPSAvXndlYmtpdC87XG5cbiAgICBzd2l0Y2ggKHR5cGVvZiBsb2dnZXIpIHtcblxuICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgbG9nZ2VyID0gIGNvbnNvbGVMb2dnZXIuYmluZCh1bmRlZmluZWQsIGxvZ2dlciArICcuJyk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgIGlmIChsb2dnZXIgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIgPSBjb25zb2xlTG9nZ2VyLmJpbmQodW5kZWZpbmVkLCAnZ2MuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICAgICAgICBpZiAobG9nZ2VyLmxlbmd0aCAhPT0gMykge1xuICAgICAgICAgICAgICAgIHRocm93ICdHcmFwaGljc0NvbnRleHQ6IFVzZXItc3VwcGxpZWQgQVBJIGxvZ2dlciBmdW5jdGlvbiBkb2VzIG5vdCBhY2NlcHQgdGhyZWUgcGFyYW1ldGVycy4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGxvZ2dlciA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIFN0dWIgb3V0IGFsbCB0aGUgcHJvdG90eXBlIG1lbWJlcnMgb2YgdGhlIGNhbnZhcyAyRCBncmFwaGljcyBjb250ZXh0OlxuICAgIE9iamVjdC5rZXlzKE9iamVjdC5nZXRQcm90b3R5cGVPZihnYykpLmZvckVhY2goTWFrZVN0dWIpO1xuXG4gICAgLy8gU29tZSBvbGRlciBicm93c2VycyAoZS5nLiwgQ2hyb21lIDQwKSBkaWQgbm90IGhhdmUgYWxsIG1lbWJlcnMgb2YgY2FudmFzXG4gICAgLy8gMkQgZ3JhcGhpY3MgY29udGV4dCBpbiB0aGUgcHJvdG90eXBlIHNvIHdlIG1ha2UgdGhpcyBhZGRpdGlvbmFsIGNhbGw6XG4gICAgT2JqZWN0LmtleXMoZ2MpLmZvckVhY2goTWFrZVN0dWIpO1xuXG4gICAgZnVuY3Rpb24gTWFrZVN0dWIoa2V5KSB7XG4gICAgICAgIGlmIChrZXkgaW4gR3JhcGhpY3NDb250ZXh0LnByb3RvdHlwZSB8fCByZVdFQktJVC50ZXN0KGtleSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGdjW2tleV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHNlbGZba2V5XSA9ICFsb2dnZXIgPyBnY1trZXldLmJpbmQoZ2MpIDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvZ2dlcihrZXksIGFyZ3VtZW50cywgZ2Nba2V5XS5hcHBseShnYywgYXJndW1lbnRzKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNlbGYsIGtleSwge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBnY1trZXldO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbG9nZ2VyID8gbG9nZ2VyKGtleSwgJ2dldHRlcicsIHJlc3VsdCkgOiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGdjW2tleV0gPSBsb2dnZXIgPyBsb2dnZXIoa2V5LCAnc2V0dGVyJywgdmFsdWUpIDogdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gR3JhcGhpY3NDb250ZXh0O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgWUlFTERTID0gJ1xcdTI3RjknOyAvLyBMT05HIFJJR0hUV0FSRFMgRE9VQkxFIEFSUk9XXG5cbmZ1bmN0aW9uIGNvbnNvbGVMb2dnZXIocHJlZml4LCBuYW1lLCBhcmdzLCB2YWx1ZSkge1xuICAgIHZhciByZXN1bHQgPSB2YWx1ZTtcblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJlc3VsdCA9ICdcIicgKyByZXN1bHQgKyAnXCInO1xuICAgIH1cblxuICAgIG5hbWUgPSBwcmVmaXggKyBuYW1lO1xuXG4gICAgc3dpdGNoIChhcmdzKSB7XG4gICAgICAgIGNhc2UgJ2dldHRlcic6XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhuYW1lLCAnPScsIHJlc3VsdCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdzZXR0ZXInOlxuICAgICAgICAgICAgY29uc29sZS5sb2cobmFtZSwgWUlFTERTLCByZXN1bHQpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDogLy8gbWV0aG9kIGNhbGxcbiAgICAgICAgICAgIG5hbWUgKz0gJygnICsgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncykuam9pbignLCAnKSArICcpJztcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKG5hbWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhuYW1lLCBZSUVMRFMsIHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnNvbGVMb2dnZXI7XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSAqL1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuICogQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbiAqIHN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4gKi9cbi8vbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuKGZ1bmN0aW9uKHNjb3BlKSB7XG4gICAgdmFyIGhhc0Z1bGxQYXRoID0gZmFsc2U7XG5cbiAgICAvLyB0ZXN0IGZvciBmdWxsIGV2ZW50IHBhdGggc3VwcG9ydFxuICAgIHZhciBwYXRoVGVzdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ21ldGEnKTtcbiAgICBpZiAocGF0aFRlc3QuY3JlYXRlU2hhZG93Um9vdCkge1xuICAgICAgICB2YXIgc3IgPSBwYXRoVGVzdC5jcmVhdGVTaGFkb3dSb290KCk7XG4gICAgICAgIHZhciBzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgICBzci5hcHBlbmRDaGlsZChzKTtcbiAgICAgICAgcGF0aFRlc3QuYWRkRXZlbnRMaXN0ZW5lcigndGVzdHBhdGgnLCBmdW5jdGlvbihldikge1xuICAgICAgICAgICAgaWYgKGV2LnBhdGgpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgc3BhbiBpcyBpbiB0aGUgZXZlbnQgcGF0aCwgdGhlbiBwYXRoWzBdIGlzIHRoZSByZWFsIHNvdXJjZSBmb3IgYWxsIGV2ZW50c1xuICAgICAgICAgICAgICAgIGhhc0Z1bGxQYXRoID0gZXYucGF0aFswXSA9PT0gcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGV2ID0gbmV3IEN1c3RvbUV2ZW50KCd0ZXN0cGF0aCcsIHtcbiAgICAgICAgICAgIGJ1YmJsZXM6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIG11c3QgYWRkIG5vZGUgdG8gRE9NIHRvIHRyaWdnZXIgZXZlbnQgbGlzdGVuZXJcbiAgICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChwYXRoVGVzdCk7XG4gICAgICAgIHMuZGlzcGF0Y2hFdmVudChldik7XG4gICAgICAgIHBhdGhUZXN0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQocGF0aFRlc3QpO1xuICAgICAgICBzciA9IHMgPSBudWxsO1xuICAgIH1cbiAgICBwYXRoVGVzdCA9IG51bGw7XG5cbiAgICB2YXIgdGFyZ2V0ID0ge1xuICAgICAgICBzaGFkb3c6IGZ1bmN0aW9uKGluRWwpIHtcbiAgICAgICAgICAgIGlmIChpbkVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluRWwuc2hhZG93Um9vdCB8fCBpbkVsLndlYmtpdFNoYWRvd1Jvb3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNhblRhcmdldDogZnVuY3Rpb24oc2hhZG93KSB7XG4gICAgICAgICAgICByZXR1cm4gc2hhZG93ICYmIEJvb2xlYW4oc2hhZG93LmVsZW1lbnRGcm9tUG9pbnQpO1xuICAgICAgICB9LFxuICAgICAgICB0YXJnZXRpbmdTaGFkb3c6IGZ1bmN0aW9uKGluRWwpIHtcbiAgICAgICAgICAgIHZhciBzID0gdGhpcy5zaGFkb3coaW5FbCk7XG4gICAgICAgICAgICBpZiAodGhpcy5jYW5UYXJnZXQocykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb2xkZXJTaGFkb3c6IGZ1bmN0aW9uKHNoYWRvdykge1xuICAgICAgICAgICAgdmFyIG9zID0gc2hhZG93Lm9sZGVyU2hhZG93Um9vdDtcbiAgICAgICAgICAgIGlmICghb3MpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2UgPSBzaGFkb3cucXVlcnlTZWxlY3Rvcignc2hhZG93Jyk7XG4gICAgICAgICAgICAgICAgaWYgKHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIG9zID0gc2Uub2xkZXJTaGFkb3dSb290O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvcztcbiAgICAgICAgfSxcbiAgICAgICAgYWxsU2hhZG93czogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIHNoYWRvd3MgPSBbXSxcbiAgICAgICAgICAgICAgICBzID0gdGhpcy5zaGFkb3coZWxlbWVudCk7XG4gICAgICAgICAgICB3aGlsZSAocykge1xuICAgICAgICAgICAgICAgIHNoYWRvd3MucHVzaChzKTtcbiAgICAgICAgICAgICAgICBzID0gdGhpcy5vbGRlclNoYWRvdyhzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzaGFkb3dzO1xuICAgICAgICB9LFxuICAgICAgICBzZWFyY2hSb290OiBmdW5jdGlvbihpblJvb3QsIHgsIHkpIHtcbiAgICAgICAgICAgIHZhciB0LCBzdCwgc3IsIG9zO1xuICAgICAgICAgICAgaWYgKGluUm9vdCkge1xuICAgICAgICAgICAgICAgIHQgPSBpblJvb3QuZWxlbWVudEZyb21Qb2ludCh4LCB5KTtcbiAgICAgICAgICAgICAgICBpZiAodCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBmb3VuZCBlbGVtZW50LCBjaGVjayBpZiBpdCBoYXMgYSBTaGFkb3dSb290XG4gICAgICAgICAgICAgICAgICAgIHNyID0gdGhpcy50YXJnZXRpbmdTaGFkb3codCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpblJvb3QgIT09IGRvY3VtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGZvciBzaWJsaW5nIHJvb3RzXG4gICAgICAgICAgICAgICAgICAgIHNyID0gdGhpcy5vbGRlclNoYWRvdyhpblJvb3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBzZWFyY2ggb3RoZXIgcm9vdHMsIGZhbGwgYmFjayB0byBsaWdodCBkb20gZWxlbWVudFxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNlYXJjaFJvb3Qoc3IsIHgsIHkpIHx8IHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG93bmVyOiBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcyA9IGVsZW1lbnQ7XG4gICAgICAgICAgICAvLyB3YWxrIHVwIHVudGlsIHlvdSBoaXQgdGhlIHNoYWRvdyByb290IG9yIGRvY3VtZW50XG4gICAgICAgICAgICB3aGlsZSAocy5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgcyA9IHMucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRoZSBvd25lciBlbGVtZW50IGlzIGV4cGVjdGVkIHRvIGJlIGEgRG9jdW1lbnQgb3IgU2hhZG93Um9vdFxuICAgICAgICAgICAgaWYgKHMubm9kZVR5cGUgIT0gTm9kZS5ET0NVTUVOVF9OT0RFICYmIHMubm9kZVR5cGUgIT0gTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgcyA9IGRvY3VtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgIH0sXG4gICAgICAgIGZpbmRUYXJnZXQ6IGZ1bmN0aW9uKGluRXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChoYXNGdWxsUGF0aCAmJiBpbkV2ZW50LnBhdGggJiYgaW5FdmVudC5wYXRoLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbkV2ZW50LnBhdGhbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgeCA9IGluRXZlbnQuY2xpZW50WCxcbiAgICAgICAgICAgICAgICB5ID0gaW5FdmVudC5jbGllbnRZO1xuICAgICAgICAgICAgLy8gaWYgdGhlIGxpc3RlbmVyIGlzIGluIHRoZSBzaGFkb3cgcm9vdCwgaXQgaXMgbXVjaCBmYXN0ZXIgdG8gc3RhcnQgdGhlcmVcbiAgICAgICAgICAgIHZhciBzID0gdGhpcy5vd25lcihpbkV2ZW50LnRhcmdldCk7XG4gICAgICAgICAgICAvLyBpZiB4LCB5IGlzIG5vdCBpbiB0aGlzIHJvb3QsIGZhbGwgYmFjayB0byBkb2N1bWVudCBzZWFyY2hcbiAgICAgICAgICAgIGlmICghcy5lbGVtZW50RnJvbVBvaW50KHgsIHkpKSB7XG4gICAgICAgICAgICAgICAgcyA9IGRvY3VtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VhcmNoUm9vdChzLCB4LCB5KTtcbiAgICAgICAgfSxcbiAgICAgICAgZmluZFRvdWNoQWN0aW9uOiBmdW5jdGlvbihpbkV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgbjtcbiAgICAgICAgICAgIGlmIChoYXNGdWxsUGF0aCAmJiBpbkV2ZW50LnBhdGggJiYgaW5FdmVudC5wYXRoLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciBwYXRoID0gaW5FdmVudC5wYXRoO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBuID0gcGF0aFtpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG4ubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFICYmIG4uaGFzQXR0cmlidXRlKCd0b3VjaC1hY3Rpb24nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG4uZ2V0QXR0cmlidXRlKCd0b3VjaC1hY3Rpb24nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbiA9IGluRXZlbnQudGFyZ2V0O1xuICAgICAgICAgICAgICAgIHdoaWxlIChuKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSAmJiBuLmhhc0F0dHJpYnV0ZSgndG91Y2gtYWN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuLmdldEF0dHJpYnV0ZSgndG91Y2gtYWN0aW9uJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbiA9IG4ucGFyZW50Tm9kZSB8fCBuLmhvc3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYXV0byBpcyBkZWZhdWx0XG4gICAgICAgICAgICByZXR1cm4gXCJhdXRvXCI7XG4gICAgICAgIH0sXG4gICAgICAgIExDQTogZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgaWYgKGEgPT09IGIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhICYmICFiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYiAmJiAhYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFiICYmICFhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZmFzdCBjYXNlLCBhIGlzIGEgZGlyZWN0IGRlc2NlbmRhbnQgb2YgYiBvciB2aWNlIHZlcnNhXG4gICAgICAgICAgICBpZiAoYS5jb250YWlucyAmJiBhLmNvbnRhaW5zKGIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYi5jb250YWlucyAmJiBiLmNvbnRhaW5zKGEpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYWRlcHRoID0gdGhpcy5kZXB0aChhKTtcbiAgICAgICAgICAgIHZhciBiZGVwdGggPSB0aGlzLmRlcHRoKGIpO1xuICAgICAgICAgICAgdmFyIGQgPSBhZGVwdGggLSBiZGVwdGg7XG4gICAgICAgICAgICBpZiAoZCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgYSA9IHRoaXMud2FsayhhLCBkKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYiA9IHRoaXMud2FsayhiLCAtZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoYSAmJiBiICYmIGEgIT09IGIpIHtcbiAgICAgICAgICAgICAgICBhID0gYS5wYXJlbnROb2RlIHx8IGEuaG9zdDtcbiAgICAgICAgICAgICAgICBiID0gYi5wYXJlbnROb2RlIHx8IGIuaG9zdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICB9LFxuICAgICAgICB3YWxrOiBmdW5jdGlvbihuLCB1KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgbiAmJiAoaSA8IHUpOyBpKyspIHtcbiAgICAgICAgICAgICAgICBuID0gbi5wYXJlbnROb2RlIHx8IG4uaG9zdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICB9LFxuICAgICAgICBkZXB0aDogZnVuY3Rpb24obikge1xuICAgICAgICAgICAgdmFyIGQgPSAwO1xuICAgICAgICAgICAgd2hpbGUgKG4pIHtcbiAgICAgICAgICAgICAgICBkKys7XG4gICAgICAgICAgICAgICAgbiA9IG4ucGFyZW50Tm9kZSB8fCBuLmhvc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgfSxcbiAgICAgICAgZGVlcENvbnRhaW5zOiBmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICB2YXIgY29tbW9uID0gdGhpcy5MQ0EoYSwgYik7XG4gICAgICAgICAgICAvLyBpZiBhIGlzIHRoZSBjb21tb24gYW5jZXN0b3IsIGl0IG11c3QgXCJkZWVwbHlcIiBjb250YWluIGJcbiAgICAgICAgICAgIHJldHVybiBjb21tb24gPT09IGE7XG4gICAgICAgIH0sXG4gICAgICAgIGluc2lkZU5vZGU6IGZ1bmN0aW9uKG5vZGUsIHgsIHkpIHtcbiAgICAgICAgICAgIHZhciByZWN0ID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIHJldHVybiAocmVjdC5sZWZ0IDw9IHgpICYmICh4IDw9IHJlY3QucmlnaHQpICYmIChyZWN0LnRvcCA8PSB5KSAmJiAoeSA8PSByZWN0LmJvdHRvbSk7XG4gICAgICAgIH0sXG4gICAgICAgIHBhdGg6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgcDtcbiAgICAgICAgICAgIGlmIChoYXNGdWxsUGF0aCAmJiBldmVudC5wYXRoICYmIGV2ZW50LnBhdGgubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcCA9IGV2ZW50LnBhdGg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHAgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgbiA9IHRoaXMuZmluZFRhcmdldChldmVudCk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKG4pIHtcbiAgICAgICAgICAgICAgICAgICAgcC5wdXNoKG4pO1xuICAgICAgICAgICAgICAgICAgICBuID0gbi5wYXJlbnROb2RlIHx8IG4uaG9zdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgc2NvcGUudGFyZ2V0RmluZGluZyA9IHRhcmdldDtcbiAgICAvKipcbiAgICAgKiBHaXZlbiBhbiBldmVudCwgZmluZHMgdGhlIFwiZGVlcGVzdFwiIG5vZGUgdGhhdCBjb3VsZCBoYXZlIGJlZW4gdGhlIG9yaWdpbmFsIHRhcmdldCBiZWZvcmUgU2hhZG93RE9NIHJldGFyZ2V0dGluZ1xuICAgICAqXG4gICAgICogQHBhcmFtIHtFdmVudH0gRXZlbnQgQW4gZXZlbnQgb2JqZWN0IHdpdGggY2xpZW50WCBhbmQgY2xpZW50WSBwcm9wZXJ0aWVzXG4gICAgICogQHJldHVybiB7RWxlbWVudH0gVGhlIHByb2JhYmxlIGV2ZW50IG9yaWduaW5hdG9yXG4gICAgICovXG4gICAgc2NvcGUuZmluZFRhcmdldCA9IHRhcmdldC5maW5kVGFyZ2V0LmJpbmQodGFyZ2V0KTtcbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIGlmIHRoZSBcImNvbnRhaW5lclwiIG5vZGUgZGVlcGx5IGNvbnRhaW5zIHRoZSBcImNvbnRhaW5lZVwiIG5vZGUsIGluY2x1ZGluZyBzaXR1YXRpb25zIHdoZXJlIHRoZSBcImNvbnRhaW5lZVwiIGlzIGNvbnRhaW5lZCBieSBvbmUgb3IgbW9yZSBTaGFkb3dET01cbiAgICAgKiByb290cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZX0gY29udGFpbmVyXG4gICAgICogQHBhcmFtIHtOb2RlfSBjb250YWluZWVcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIHNjb3BlLmRlZXBDb250YWlucyA9IHRhcmdldC5kZWVwQ29udGFpbnMuYmluZCh0YXJnZXQpO1xuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBpZiB0aGUgeC95IHBvc2l0aW9uIGlzIGluc2lkZSB0aGUgZ2l2ZW4gbm9kZS5cbiAgICAgKlxuICAgICAqIEV4YW1wbGU6XG4gICAgICpcbiAgICAgKiAgICAgZnVuY3Rpb24gdXBIYW5kbGVyKGV2ZW50KSB7XG4gICAgICogICAgICAgdmFyIGlubm9kZSA9IFBvbHltZXJHZXN0dXJlcy5pbnNpZGVOb2RlKGV2ZW50LnRhcmdldCwgZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSk7XG4gICAgICogICAgICAgaWYgKGlubm9kZSkge1xuICAgICAqICAgICAgICAgLy8gd2FpdCBmb3IgdGFwP1xuICAgICAqICAgICAgIH0gZWxzZSB7XG4gICAgICogICAgICAgICAvLyB0YXAgd2lsbCBuZXZlciBoYXBwZW5cbiAgICAgKiAgICAgICB9XG4gICAgICogICAgIH1cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4IFNjcmVlbiBYIHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgc2NyZWVuIFkgcG9zaXRpb25cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIHNjb3BlLmluc2lkZU5vZGUgPSB0YXJnZXQuaW5zaWRlTm9kZTtcblxufSkoZXhwb3J0cyk7XG5cbihmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBzaGFkb3dTZWxlY3Rvcih2KSB7XG4gICAgICAgIHJldHVybiAnaHRtbCAvZGVlcC8gJyArIHNlbGVjdG9yKHYpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNlbGVjdG9yKHYpIHtcbiAgICAgICAgcmV0dXJuICdbdG91Y2gtYWN0aW9uPVwiJyArIHYgKyAnXCJdJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydWxlKHYpIHtcbiAgICAgICAgcmV0dXJuICd7IC1tcy10b3VjaC1hY3Rpb246ICcgKyB2ICsgJzsgdG91Y2gtYWN0aW9uOiAnICsgdiArICc7fSc7XG4gICAgfVxuICAgIHZhciBhdHRyaWIyY3NzID0gW1xuICAgICAgICAnbm9uZScsXG4gICAgICAgICdhdXRvJyxcbiAgICAgICAgJ3Bhbi14JyxcbiAgICAgICAgJ3Bhbi15Jywge1xuICAgICAgICAgICAgcnVsZTogJ3Bhbi14IHBhbi15JyxcbiAgICAgICAgICAgIHNlbGVjdG9yczogW1xuICAgICAgICAgICAgICAgICdwYW4teCBwYW4teScsXG4gICAgICAgICAgICAgICAgJ3Bhbi15IHBhbi14J1xuICAgICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICAnbWFuaXB1bGF0aW9uJ1xuICAgIF07XG4gICAgdmFyIHN0eWxlcyA9ICcnO1xuICAgIC8vIG9ubHkgaW5zdGFsbCBzdHlsZXNoZWV0IGlmIHRoZSBicm93c2VyIGhhcyB0b3VjaCBhY3Rpb24gc3VwcG9ydFxuICAgIHZhciBoYXNUb3VjaEFjdGlvbiA9IHR5cGVvZiBkb2N1bWVudC5oZWFkLnN0eWxlLnRvdWNoQWN0aW9uID09PSAnc3RyaW5nJztcbiAgICAvLyBvbmx5IGFkZCBzaGFkb3cgc2VsZWN0b3JzIGlmIHNoYWRvd2RvbSBpcyBzdXBwb3J0ZWRcbiAgICB2YXIgaGFzU2hhZG93Um9vdCA9ICF3aW5kb3cuU2hhZG93RE9NUG9seWZpbGwgJiYgZG9jdW1lbnQuaGVhZC5jcmVhdGVTaGFkb3dSb290O1xuXG4gICAgaWYgKGhhc1RvdWNoQWN0aW9uKSB7XG4gICAgICAgIGF0dHJpYjJjc3MuZm9yRWFjaChmdW5jdGlvbihyKSB7XG4gICAgICAgICAgICBpZiAoU3RyaW5nKHIpID09PSByKSB7XG4gICAgICAgICAgICAgICAgc3R5bGVzICs9IHNlbGVjdG9yKHIpICsgcnVsZShyKSArICdcXG4nO1xuICAgICAgICAgICAgICAgIGlmIChoYXNTaGFkb3dSb290KSB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlcyArPSBzaGFkb3dTZWxlY3RvcihyKSArIHJ1bGUocikgKyAnXFxuJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0eWxlcyArPSByLnNlbGVjdG9ycy5tYXAoc2VsZWN0b3IpICsgcnVsZShyLnJ1bGUpICsgJ1xcbic7XG4gICAgICAgICAgICAgICAgaWYgKGhhc1NoYWRvd1Jvb3QpIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVzICs9IHIuc2VsZWN0b3JzLm1hcChzaGFkb3dTZWxlY3RvcikgKyBydWxlKHIucnVsZSkgKyAnXFxuJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgICAgIGVsLnRleHRDb250ZW50ID0gc3R5bGVzO1xuICAgICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKGVsKTtcbiAgICB9XG59KSgpO1xuXG4vKipcbiAqIFRoaXMgaXMgdGhlIGNvbnN0cnVjdG9yIGZvciBuZXcgUG9pbnRlckV2ZW50cy5cbiAqXG4gKiBOZXcgUG9pbnRlciBFdmVudHMgbXVzdCBiZSBnaXZlbiBhIHR5cGUsIGFuZCBhbiBvcHRpb25hbCBkaWN0aW9uYXJ5IG9mXG4gKiBpbml0aWFsaXphdGlvbiBwcm9wZXJ0aWVzLlxuICpcbiAqIER1ZSB0byBjZXJ0YWluIHBsYXRmb3JtIHJlcXVpcmVtZW50cywgZXZlbnRzIHJldHVybmVkIGZyb20gdGhlIGNvbnN0cnVjdG9yXG4gKiBpZGVudGlmeSBhcyBNb3VzZUV2ZW50cy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7U3RyaW5nfSBpblR5cGUgVGhlIHR5cGUgb2YgdGhlIGV2ZW50IHRvIGNyZWF0ZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbaW5EaWN0XSBBbiBvcHRpb25hbCBkaWN0aW9uYXJ5IG9mIGluaXRpYWwgZXZlbnQgcHJvcGVydGllcy5cbiAqIEByZXR1cm4ge0V2ZW50fSBBIG5ldyBQb2ludGVyRXZlbnQgb2YgdHlwZSBgaW5UeXBlYCBhbmQgaW5pdGlhbGl6ZWQgd2l0aCBwcm9wZXJ0aWVzIGZyb20gYGluRGljdGAuXG4gKi9cbihmdW5jdGlvbihzY29wZSkge1xuXG4gICAgdmFyIE1PVVNFX1BST1BTID0gW1xuICAgICAgICAnYnViYmxlcycsXG4gICAgICAgICdjYW5jZWxhYmxlJyxcbiAgICAgICAgJ3ZpZXcnLFxuICAgICAgICAnZGV0YWlsJyxcbiAgICAgICAgJ3NjcmVlblgnLFxuICAgICAgICAnc2NyZWVuWScsXG4gICAgICAgICdjbGllbnRYJyxcbiAgICAgICAgJ2NsaWVudFknLFxuICAgICAgICAnY3RybEtleScsXG4gICAgICAgICdhbHRLZXknLFxuICAgICAgICAnc2hpZnRLZXknLFxuICAgICAgICAnbWV0YUtleScsXG4gICAgICAgICdidXR0b24nLFxuICAgICAgICAncmVsYXRlZFRhcmdldCcsXG4gICAgICAgICdwYWdlWCcsXG4gICAgICAgICdwYWdlWSdcbiAgICBdO1xuXG4gICAgdmFyIE1PVVNFX0RFRkFVTFRTID0gW1xuICAgICAgICBmYWxzZSxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIG51bGwsXG4gICAgICAgIG51bGwsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICAwLFxuICAgICAgICBudWxsLFxuICAgICAgICAwLFxuICAgICAgICAwXG4gICAgXTtcblxuICAgIHZhciBOT1BfRkFDVE9SWSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7fTtcbiAgICB9O1xuXG4gICAgdmFyIGV2ZW50RmFjdG9yeSA9IHtcbiAgICAgICAgLy8gVE9ETyhkZnJlZWRtKTogdGhpcyBpcyBvdmVycmlkZGVuIGJ5IHRhcCByZWNvZ25pemVyLCBuZWVkcyByZXZpZXdcbiAgICAgICAgcHJldmVudFRhcDogTk9QX0ZBQ1RPUlksXG4gICAgICAgIG1ha2VCYXNlRXZlbnQ6IGZ1bmN0aW9uKGluVHlwZSwgaW5EaWN0KSB7XG4gICAgICAgICAgICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuICAgICAgICAgICAgZS5pbml0RXZlbnQoaW5UeXBlLCBpbkRpY3QuYnViYmxlcyB8fCBmYWxzZSwgaW5EaWN0LmNhbmNlbGFibGUgfHwgZmFsc2UpO1xuICAgICAgICAgICAgZS5wcmV2ZW50VGFwID0gZXZlbnRGYWN0b3J5LnByZXZlbnRUYXAoZSk7XG4gICAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgfSxcbiAgICAgICAgbWFrZUdlc3R1cmVFdmVudDogZnVuY3Rpb24oaW5UeXBlLCBpbkRpY3QpIHtcbiAgICAgICAgICAgIGluRGljdCA9IGluRGljdCB8fCBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgICAgICAgICB2YXIgZSA9IHRoaXMubWFrZUJhc2VFdmVudChpblR5cGUsIGluRGljdCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IE9iamVjdC5rZXlzKGluRGljdCksIGs7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgayA9IGtleXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKGsgIT09ICdidWJibGVzJyAmJiBrICE9PSAnY2FuY2VsYWJsZScpIHtcbiAgICAgICAgICAgICAgICAgICAgZVtrXSA9IGluRGljdFtrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgfSxcbiAgICAgICAgbWFrZVBvaW50ZXJFdmVudDogZnVuY3Rpb24oaW5UeXBlLCBpbkRpY3QpIHtcbiAgICAgICAgICAgIGluRGljdCA9IGluRGljdCB8fCBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgICAgICAgICB2YXIgZSA9IHRoaXMubWFrZUJhc2VFdmVudChpblR5cGUsIGluRGljdCk7XG4gICAgICAgICAgICAvLyBkZWZpbmUgaW5oZXJpdGVkIE1vdXNlRXZlbnQgcHJvcGVydGllc1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDIsIHA7IGkgPCBNT1VTRV9QUk9QUy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHAgPSBNT1VTRV9QUk9QU1tpXTtcbiAgICAgICAgICAgICAgICBlW3BdID0gaW5EaWN0W3BdIHx8IE1PVVNFX0RFRkFVTFRTW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZS5idXR0b25zID0gaW5EaWN0LmJ1dHRvbnMgfHwgMDtcblxuICAgICAgICAgICAgLy8gU3BlYyByZXF1aXJlcyB0aGF0IHBvaW50ZXJzIHdpdGhvdXQgcHJlc3N1cmUgc3BlY2lmaWVkIHVzZSAwLjUgZm9yIGRvd25cbiAgICAgICAgICAgIC8vIHN0YXRlIGFuZCAwIGZvciB1cCBzdGF0ZS5cbiAgICAgICAgICAgIHZhciBwcmVzc3VyZSA9IDA7XG4gICAgICAgICAgICBpZiAoaW5EaWN0LnByZXNzdXJlKSB7XG4gICAgICAgICAgICAgICAgcHJlc3N1cmUgPSBpbkRpY3QucHJlc3N1cmU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHByZXNzdXJlID0gZS5idXR0b25zID8gMC41IDogMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gYWRkIHgveSBwcm9wZXJ0aWVzIGFsaWFzZWQgdG8gY2xpZW50WC9ZXG4gICAgICAgICAgICBlLnggPSBlLmNsaWVudFg7XG4gICAgICAgICAgICBlLnkgPSBlLmNsaWVudFk7XG5cbiAgICAgICAgICAgIC8vIGRlZmluZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgUG9pbnRlckV2ZW50IGludGVyZmFjZVxuICAgICAgICAgICAgZS5wb2ludGVySWQgPSBpbkRpY3QucG9pbnRlcklkIHx8IDA7XG4gICAgICAgICAgICBlLndpZHRoID0gaW5EaWN0LndpZHRoIHx8IDA7XG4gICAgICAgICAgICBlLmhlaWdodCA9IGluRGljdC5oZWlnaHQgfHwgMDtcbiAgICAgICAgICAgIGUucHJlc3N1cmUgPSBwcmVzc3VyZTtcbiAgICAgICAgICAgIGUudGlsdFggPSBpbkRpY3QudGlsdFggfHwgMDtcbiAgICAgICAgICAgIGUudGlsdFkgPSBpbkRpY3QudGlsdFkgfHwgMDtcbiAgICAgICAgICAgIGUucG9pbnRlclR5cGUgPSBpbkRpY3QucG9pbnRlclR5cGUgfHwgJyc7XG4gICAgICAgICAgICBlLmh3VGltZXN0YW1wID0gaW5EaWN0Lmh3VGltZXN0YW1wIHx8IDA7XG4gICAgICAgICAgICBlLmlzUHJpbWFyeSA9IGluRGljdC5pc1ByaW1hcnkgfHwgZmFsc2U7XG4gICAgICAgICAgICBlLl9zb3VyY2UgPSBpbkRpY3QuX3NvdXJjZSB8fCAnJztcbiAgICAgICAgICAgIHJldHVybiBlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHNjb3BlLmV2ZW50RmFjdG9yeSA9IGV2ZW50RmFjdG9yeTtcbn0pKGV4cG9ydHMpO1xuXG4vKipcbiAqIFRoaXMgbW9kdWxlIGltcGxlbWVudHMgYW4gbWFwIG9mIHBvaW50ZXIgc3RhdGVzXG4gKi9cbihmdW5jdGlvbihzY29wZSkge1xuICAgIHZhciBVU0VfTUFQID0gd2luZG93Lk1hcCAmJiB3aW5kb3cuTWFwLnByb3RvdHlwZS5mb3JFYWNoO1xuICAgIHZhciBQT0lOVEVSU19GTiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaXplO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBQb2ludGVyTWFwKCkge1xuICAgICAgICBpZiAoVVNFX01BUCkge1xuICAgICAgICAgICAgdmFyIG0gPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICBtLnBvaW50ZXJzID0gUE9JTlRFUlNfRk47XG4gICAgICAgICAgICByZXR1cm4gbTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMua2V5cyA9IFtdO1xuICAgICAgICAgICAgdGhpcy52YWx1ZXMgPSBbXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIFBvaW50ZXJNYXAucHJvdG90eXBlID0ge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uKGluSWQsIGluRXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBpID0gdGhpcy5rZXlzLmluZGV4T2YoaW5JZCk7XG4gICAgICAgICAgICBpZiAoaSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZXNbaV0gPSBpbkV2ZW50O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmtleXMucHVzaChpbklkKTtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlcy5wdXNoKGluRXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBoYXM6IGZ1bmN0aW9uKGluSWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmtleXMuaW5kZXhPZihpbklkKSA+IC0xO1xuICAgICAgICB9LFxuICAgICAgICAnZGVsZXRlJzogZnVuY3Rpb24oaW5JZCkge1xuICAgICAgICAgICAgdmFyIGkgPSB0aGlzLmtleXMuaW5kZXhPZihpbklkKTtcbiAgICAgICAgICAgIGlmIChpID4gLTEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmtleXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbihpbklkKSB7XG4gICAgICAgICAgICB2YXIgaSA9IHRoaXMua2V5cy5pbmRleE9mKGluSWQpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVzW2ldO1xuICAgICAgICB9LFxuICAgICAgICBjbGVhcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLmtleXMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIHRoaXMudmFsdWVzLmxlbmd0aCA9IDA7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIHJldHVybiB2YWx1ZSwga2V5LCBtYXBcbiAgICAgICAgZm9yRWFjaDogZnVuY3Rpb24oY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWVzLmZvckVhY2goZnVuY3Rpb24odiwgaSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwodGhpc0FyZywgdiwgdGhpcy5rZXlzW2ldLCB0aGlzKTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9LFxuICAgICAgICBwb2ludGVyczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5rZXlzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBzY29wZS5Qb2ludGVyTWFwID0gUG9pbnRlck1hcDtcbn0pKGV4cG9ydHMpO1xuXG4oZnVuY3Rpb24oc2NvcGUpIHtcbiAgICB2YXIgQ0xPTkVfUFJPUFMgPSBbXG4gICAgICAgIC8vIE1vdXNlRXZlbnRcbiAgICAgICAgJ2J1YmJsZXMnLFxuICAgICAgICAnY2FuY2VsYWJsZScsXG4gICAgICAgICd2aWV3JyxcbiAgICAgICAgJ2RldGFpbCcsXG4gICAgICAgICdzY3JlZW5YJyxcbiAgICAgICAgJ3NjcmVlblknLFxuICAgICAgICAnY2xpZW50WCcsXG4gICAgICAgICdjbGllbnRZJyxcbiAgICAgICAgJ2N0cmxLZXknLFxuICAgICAgICAnYWx0S2V5JyxcbiAgICAgICAgJ3NoaWZ0S2V5JyxcbiAgICAgICAgJ21ldGFLZXknLFxuICAgICAgICAnYnV0dG9uJyxcbiAgICAgICAgJ3JlbGF0ZWRUYXJnZXQnLFxuICAgICAgICAvLyBET00gTGV2ZWwgM1xuICAgICAgICAnYnV0dG9ucycsXG4gICAgICAgIC8vIFBvaW50ZXJFdmVudFxuICAgICAgICAncG9pbnRlcklkJyxcbiAgICAgICAgJ3dpZHRoJyxcbiAgICAgICAgJ2hlaWdodCcsXG4gICAgICAgICdwcmVzc3VyZScsXG4gICAgICAgICd0aWx0WCcsXG4gICAgICAgICd0aWx0WScsXG4gICAgICAgICdwb2ludGVyVHlwZScsXG4gICAgICAgICdod1RpbWVzdGFtcCcsXG4gICAgICAgICdpc1ByaW1hcnknLFxuICAgICAgICAvLyBldmVudCBpbnN0YW5jZVxuICAgICAgICAndHlwZScsXG4gICAgICAgICd0YXJnZXQnLFxuICAgICAgICAnY3VycmVudFRhcmdldCcsXG4gICAgICAgICd3aGljaCcsXG4gICAgICAgICdwYWdlWCcsXG4gICAgICAgICdwYWdlWScsXG4gICAgICAgICd0aW1lU3RhbXAnLFxuICAgICAgICAvLyBnZXN0dXJlIGFkZG9uc1xuICAgICAgICAncHJldmVudFRhcCcsXG4gICAgICAgICd0YXBQcmV2ZW50ZWQnLFxuICAgICAgICAnX3NvdXJjZSdcbiAgICBdO1xuXG4gICAgdmFyIENMT05FX0RFRkFVTFRTID0gW1xuICAgICAgICAvLyBNb3VzZUV2ZW50XG4gICAgICAgIGZhbHNlLFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIDAsXG4gICAgICAgIG51bGwsXG4gICAgICAgIC8vIERPTSBMZXZlbCAzXG4gICAgICAgIDAsXG4gICAgICAgIC8vIFBvaW50ZXJFdmVudFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAnJyxcbiAgICAgICAgMCxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIC8vIGV2ZW50IGluc3RhbmNlXG4gICAgICAgICcnLFxuICAgICAgICBudWxsLFxuICAgICAgICBudWxsLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICBmdW5jdGlvbigpIHt9LFxuICAgICAgICBmYWxzZVxuICAgIF07XG5cbiAgICB2YXIgSEFTX1NWR19JTlNUQU5DRSA9ICh0eXBlb2YgU1ZHRWxlbWVudEluc3RhbmNlICE9PSAndW5kZWZpbmVkJyk7XG5cbiAgICB2YXIgZXZlbnRGYWN0b3J5ID0gc2NvcGUuZXZlbnRGYWN0b3J5O1xuXG4gICAgLy8gc2V0IG9mIHJlY29nbml6ZXJzIHRvIHJ1biBmb3IgdGhlIGN1cnJlbnRseSBoYW5kbGVkIGV2ZW50XG4gICAgdmFyIGN1cnJlbnRHZXN0dXJlcztcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbW9kdWxlIGlzIGZvciBub3JtYWxpemluZyBldmVudHMuIE1vdXNlIGFuZCBUb3VjaCBldmVudHMgd2lsbCBiZVxuICAgICAqIGNvbGxlY3RlZCBoZXJlLCBhbmQgZmlyZSBQb2ludGVyRXZlbnRzIHRoYXQgaGF2ZSB0aGUgc2FtZSBzZW1hbnRpY3MsIG5vXG4gICAgICogbWF0dGVyIHRoZSBzb3VyY2UuXG4gICAgICogRXZlbnRzIGZpcmVkOlxuICAgICAqICAgLSBwb2ludGVyZG93bjogYSBwb2ludGluZyBpcyBhZGRlZFxuICAgICAqICAgLSBwb2ludGVydXA6IGEgcG9pbnRlciBpcyByZW1vdmVkXG4gICAgICogICAtIHBvaW50ZXJtb3ZlOiBhIHBvaW50ZXIgaXMgbW92ZWRcbiAgICAgKiAgIC0gcG9pbnRlcm92ZXI6IGEgcG9pbnRlciBjcm9zc2VzIGludG8gYW4gZWxlbWVudFxuICAgICAqICAgLSBwb2ludGVyb3V0OiBhIHBvaW50ZXIgbGVhdmVzIGFuIGVsZW1lbnRcbiAgICAgKiAgIC0gcG9pbnRlcmNhbmNlbDogYSBwb2ludGVyIHdpbGwgbm8gbG9uZ2VyIGdlbmVyYXRlIGV2ZW50c1xuICAgICAqL1xuICAgIHZhciBkaXNwYXRjaGVyID0ge1xuICAgICAgICBJU19JT1M6IGZhbHNlLFxuICAgICAgICBwb2ludGVybWFwOiBuZXcgc2NvcGUuUG9pbnRlck1hcCgpLFxuICAgICAgICByZXF1aXJlZEdlc3R1cmVzOiBuZXcgc2NvcGUuUG9pbnRlck1hcCgpLFxuICAgICAgICBldmVudE1hcDogT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgICAgLy8gU2NvcGUgb2JqZWN0cyBmb3IgbmF0aXZlIGV2ZW50cy5cbiAgICAgICAgLy8gVGhpcyBleGlzdHMgZm9yIGVhc2Ugb2YgdGVzdGluZy5cbiAgICAgICAgZXZlbnRTb3VyY2VzOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgICBldmVudFNvdXJjZUxpc3Q6IFtdLFxuICAgICAgICBnZXN0dXJlczogW10sXG4gICAgICAgIC8vIG1hcCBnZXN0dXJlIGV2ZW50IC0+IHtsaXN0ZW5lcnM6IGludCwgaW5kZXg6IGdlc3R1cmVzW2ludF19XG4gICAgICAgIGRlcGVuZGVuY3lNYXA6IHtcbiAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSBkb3duIGFuZCB1cCBhcmUgaW4gdGhlIG1hcCB0byB0cmlnZ2VyIFwicmVnaXN0ZXJcIlxuICAgICAgICAgICAgZG93bjoge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyczogMCxcbiAgICAgICAgICAgICAgICBpbmRleDogLTFcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1cDoge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyczogMCxcbiAgICAgICAgICAgICAgICBpbmRleDogLTFcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZ2VzdHVyZVF1ZXVlOiBbXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZCBhIG5ldyBldmVudCBzb3VyY2UgdGhhdCB3aWxsIGdlbmVyYXRlIHBvaW50ZXIgZXZlbnRzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBgaW5Tb3VyY2VgIG11c3QgY29udGFpbiBhbiBhcnJheSBvZiBldmVudCBuYW1lcyBuYW1lZCBgZXZlbnRzYCwgYW5kXG4gICAgICAgICAqIGZ1bmN0aW9ucyB3aXRoIHRoZSBuYW1lcyBzcGVjaWZpZWQgaW4gdGhlIGBldmVudHNgIGFycmF5LlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBBIG5hbWUgZm9yIHRoZSBldmVudCBzb3VyY2VcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBBIG5ldyBzb3VyY2Ugb2YgcGxhdGZvcm0gZXZlbnRzLlxuICAgICAgICAgKi9cbiAgICAgICAgcmVnaXN0ZXJTb3VyY2U6IGZ1bmN0aW9uKG5hbWUsIHNvdXJjZSkge1xuICAgICAgICAgICAgdmFyIHMgPSBzb3VyY2U7XG4gICAgICAgICAgICB2YXIgbmV3RXZlbnRzID0gcy5ldmVudHM7XG4gICAgICAgICAgICBpZiAobmV3RXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgbmV3RXZlbnRzLmZvckVhY2goZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc1tlXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ldmVudE1hcFtlXSA9IHNbZV0uYmluZChzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRTb3VyY2VzW25hbWVdID0gcztcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50U291cmNlTGlzdC5wdXNoKHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICByZWdpc3Rlckdlc3R1cmU6IGZ1bmN0aW9uKG5hbWUsIHNvdXJjZSkge1xuICAgICAgICAgICAgdmFyIG9iaiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgICBvYmoubGlzdGVuZXJzID0gMDtcbiAgICAgICAgICAgIG9iai5pbmRleCA9IHRoaXMuZ2VzdHVyZXMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGc7IGkgPCBzb3VyY2UuZXhwb3Nlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGcgPSBzb3VyY2UuZXhwb3Nlc1tpXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGVwZW5kZW5jeU1hcFtnXSA9IG9iajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZ2VzdHVyZXMucHVzaChzb3VyY2UpO1xuICAgICAgICB9LFxuICAgICAgICByZWdpc3RlcjogZnVuY3Rpb24oZWxlbWVudCwgaW5pdGlhbCkge1xuICAgICAgICAgICAgdmFyIGwgPSB0aGlzLmV2ZW50U291cmNlTGlzdC5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgZXM7XG4gICAgICAgICAgICAgICAgKGkgPCBsKSAmJiAoZXMgPSB0aGlzLmV2ZW50U291cmNlTGlzdFtpXSk7IGkrKykge1xuICAgICAgICAgICAgICAgIC8vIGNhbGwgZXZlbnRzb3VyY2UgcmVnaXN0ZXJcbiAgICAgICAgICAgICAgICBlcy5yZWdpc3Rlci5jYWxsKGVzLCBlbGVtZW50LCBpbml0aWFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdW5yZWdpc3RlcjogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIGwgPSB0aGlzLmV2ZW50U291cmNlTGlzdC5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgZXM7XG4gICAgICAgICAgICAgICAgKGkgPCBsKSAmJiAoZXMgPSB0aGlzLmV2ZW50U291cmNlTGlzdFtpXSk7IGkrKykge1xuICAgICAgICAgICAgICAgIC8vIGNhbGwgZXZlbnRzb3VyY2UgcmVnaXN0ZXJcbiAgICAgICAgICAgICAgICBlcy51bnJlZ2lzdGVyLmNhbGwoZXMsIGVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvLyBFVkVOVFNcbiAgICAgICAgZG93bjogZnVuY3Rpb24oaW5FdmVudCkge1xuICAgICAgICAgICAgdGhpcy5yZXF1aXJlZEdlc3R1cmVzLnNldChpbkV2ZW50LnBvaW50ZXJJZCwgY3VycmVudEdlc3R1cmVzKTtcbiAgICAgICAgICAgIHRoaXMuZmlyZUV2ZW50KCdkb3duJywgaW5FdmVudCk7XG4gICAgICAgIH0sXG4gICAgICAgIG1vdmU6IGZ1bmN0aW9uKGluRXZlbnQpIHtcbiAgICAgICAgICAgIC8vIHBpcGUgbW92ZSBldmVudHMgaW50byBnZXN0dXJlIHF1ZXVlIGRpcmVjdGx5XG4gICAgICAgICAgICBpbkV2ZW50LnR5cGUgPSAnbW92ZSc7XG4gICAgICAgICAgICB0aGlzLmZpbGxHZXN0dXJlUXVldWUoaW5FdmVudCk7XG4gICAgICAgIH0sXG4gICAgICAgIHVwOiBmdW5jdGlvbihpbkV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLmZpcmVFdmVudCgndXAnLCBpbkV2ZW50KTtcbiAgICAgICAgICAgIHRoaXMucmVxdWlyZWRHZXN0dXJlcy5kZWxldGUoaW5FdmVudC5wb2ludGVySWQpO1xuICAgICAgICB9LFxuICAgICAgICBjYW5jZWw6IGZ1bmN0aW9uKGluRXZlbnQpIHtcbiAgICAgICAgICAgIGluRXZlbnQudGFwUHJldmVudGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZmlyZUV2ZW50KCd1cCcsIGluRXZlbnQpO1xuICAgICAgICAgICAgdGhpcy5yZXF1aXJlZEdlc3R1cmVzLmRlbGV0ZShpbkV2ZW50LnBvaW50ZXJJZCk7XG4gICAgICAgIH0sXG4gICAgICAgIGFkZEdlc3R1cmVEZXBlbmRlbmN5OiBmdW5jdGlvbihub2RlLCBjdXJyZW50R2VzdHVyZXMpIHtcbiAgICAgICAgICAgIHZhciBnZXN0dXJlc1dhbnRlZCA9IG5vZGUuX3BnRXZlbnRzO1xuICAgICAgICAgICAgaWYgKGdlc3R1cmVzV2FudGVkICYmIGN1cnJlbnRHZXN0dXJlcykge1xuICAgICAgICAgICAgICAgIHZhciBnayA9IE9iamVjdC5rZXlzKGdlc3R1cmVzV2FudGVkKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgciwgcmksIGc7IGkgPCBnay5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAvLyBnZXN0dXJlXG4gICAgICAgICAgICAgICAgICAgIGcgPSBna1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGdlc3R1cmVzV2FudGVkW2ddID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbG9va3VwIGdlc3R1cmUgcmVjb2duaXplclxuICAgICAgICAgICAgICAgICAgICAgICAgciA9IHRoaXMuZGVwZW5kZW5jeU1hcFtnXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlY29nbml6ZXIgaW5kZXhcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpID0gciA/IHIuaW5kZXggOiAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRHZXN0dXJlc1tyaV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvLyBMSVNURU5FUiBMT0dJQ1xuICAgICAgICBldmVudEhhbmRsZXI6IGZ1bmN0aW9uKGluRXZlbnQpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgdXNlZCB0byBwcmV2ZW50IG11bHRpcGxlIGRpc3BhdGNoIG9mIGV2ZW50cyBmcm9tXG4gICAgICAgICAgICAvLyBwbGF0Zm9ybSBldmVudHMuIFRoaXMgY2FuIGhhcHBlbiB3aGVuIHR3byBlbGVtZW50cyBpbiBkaWZmZXJlbnQgc2NvcGVzXG4gICAgICAgICAgICAvLyBhcmUgc2V0IHVwIHRvIGNyZWF0ZSBwb2ludGVyIGV2ZW50cywgd2hpY2ggaXMgcmVsZXZhbnQgdG8gU2hhZG93IERPTS5cblxuICAgICAgICAgICAgdmFyIHR5cGUgPSBpbkV2ZW50LnR5cGU7XG5cbiAgICAgICAgICAgIC8vIG9ubHkgZ2VuZXJhdGUgdGhlIGxpc3Qgb2YgZGVzaXJlZCBldmVudHMgb24gXCJkb3duXCJcbiAgICAgICAgICAgIGlmICh0eXBlID09PSAndG91Y2hzdGFydCcgfHwgdHlwZSA9PT0gJ21vdXNlZG93bicgfHwgdHlwZSA9PT0gJ3BvaW50ZXJkb3duJyB8fCB0eXBlID09PSAnTVNQb2ludGVyRG93bicpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWluRXZlbnQuX2hhbmRsZWRCeVBHKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRHZXN0dXJlcyA9IHt9O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGluIElPUyBtb2RlLCB0aGVyZSBpcyBvbmx5IGEgbGlzdGVuZXIgb24gdGhlIGRvY3VtZW50LCBzbyB0aGlzIGlzIG5vdCByZS1lbnRyYW50XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuSVNfSU9TKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBldiA9IGluRXZlbnQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSAndG91Y2hzdGFydCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdCA9IGluRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzZXQgdXAgYSBmYWtlIGV2ZW50IHRvIGdpdmUgdG8gdGhlIHBhdGggYnVpbGRlclxuICAgICAgICAgICAgICAgICAgICAgICAgZXYgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBpbkV2ZW50LnRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGllbnRYOiBjdC5jbGllbnRYLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWVudFk6IGN0LmNsaWVudFksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogaW5FdmVudC5wYXRoXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIHVzZSBldmVudCBwYXRoIGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIGJ1aWxkIGEgcGF0aCBmcm9tIHRhcmdldCBmaW5kaW5nXG4gICAgICAgICAgICAgICAgICAgIHZhciBub2RlcyA9IGluRXZlbnQucGF0aCB8fCBzY29wZS50YXJnZXRGaW5kaW5nLnBhdGgoZXYpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbjsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuID0gbm9kZXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEdlc3R1cmVEZXBlbmRlbmN5KG4sIGN1cnJlbnRHZXN0dXJlcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEdlc3R1cmVEZXBlbmRlbmN5KGluRXZlbnQuY3VycmVudFRhcmdldCwgY3VycmVudEdlc3R1cmVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpbkV2ZW50Ll9oYW5kbGVkQnlQRykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBmbiA9IHRoaXMuZXZlbnRNYXAgJiYgdGhpcy5ldmVudE1hcFt0eXBlXTtcbiAgICAgICAgICAgIGlmIChmbikge1xuICAgICAgICAgICAgICAgIGZuKGluRXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5FdmVudC5faGFuZGxlZEJ5UEcgPSB0cnVlO1xuICAgICAgICB9LFxuICAgICAgICAvLyBzZXQgdXAgZXZlbnQgbGlzdGVuZXJzXG4gICAgICAgIGxpc3RlbjogZnVuY3Rpb24odGFyZ2V0LCBldmVudHMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gZXZlbnRzLmxlbmd0aCwgZTtcbiAgICAgICAgICAgICAgICAoaSA8IGwpICYmIChlID0gZXZlbnRzW2ldKTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRFdmVudCh0YXJnZXQsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvLyByZW1vdmUgZXZlbnQgbGlzdGVuZXJzXG4gICAgICAgIHVubGlzdGVuOiBmdW5jdGlvbih0YXJnZXQsIGV2ZW50cykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBldmVudHMubGVuZ3RoLCBlO1xuICAgICAgICAgICAgICAgIChpIDwgbCkgJiYgKGUgPSBldmVudHNbaV0pOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUV2ZW50KHRhcmdldCwgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGFkZEV2ZW50OiBmdW5jdGlvbih0YXJnZXQsIGV2ZW50TmFtZSkge1xuICAgICAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCB0aGlzLmJvdW5kSGFuZGxlcik7XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZUV2ZW50OiBmdW5jdGlvbih0YXJnZXQsIGV2ZW50TmFtZSkge1xuICAgICAgICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCB0aGlzLmJvdW5kSGFuZGxlcik7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIEVWRU5UIENSRUFUSU9OIEFORCBUUkFDS0lOR1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBFdmVudCBvZiB0eXBlIGBpblR5cGVgLCBiYXNlZCBvbiB0aGUgaW5mb3JtYXRpb24gaW5cbiAgICAgICAgICogYGluRXZlbnRgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gaW5UeXBlIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdHlwZSBvZiBldmVudCB0byBjcmVhdGVcbiAgICAgICAgICogQHBhcmFtIHtFdmVudH0gaW5FdmVudCBBIHBsYXRmb3JtIGV2ZW50IHdpdGggYSB0YXJnZXRcbiAgICAgICAgICogQHJldHVybiB7RXZlbnR9IEEgUG9pbnRlckV2ZW50IG9mIHR5cGUgYGluVHlwZWBcbiAgICAgICAgICovXG4gICAgICAgIG1ha2VFdmVudDogZnVuY3Rpb24oaW5UeXBlLCBpbkV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgZSA9IGV2ZW50RmFjdG9yeS5tYWtlUG9pbnRlckV2ZW50KGluVHlwZSwgaW5FdmVudCk7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0ID0gaW5FdmVudC5wcmV2ZW50RGVmYXVsdDtcbiAgICAgICAgICAgIGUudGFwUHJldmVudGVkID0gaW5FdmVudC50YXBQcmV2ZW50ZWQ7XG4gICAgICAgICAgICBlLl90YXJnZXQgPSBlLl90YXJnZXQgfHwgaW5FdmVudC50YXJnZXQ7XG4gICAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gbWFrZSBhbmQgZGlzcGF0Y2ggYW4gZXZlbnQgaW4gb25lIGNhbGxcbiAgICAgICAgZmlyZUV2ZW50OiBmdW5jdGlvbihpblR5cGUsIGluRXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBlID0gdGhpcy5tYWtlRXZlbnQoaW5UeXBlLCBpbkV2ZW50KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRpc3BhdGNoRXZlbnQoZSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGEgc25hcHNob3Qgb2YgaW5FdmVudCwgd2l0aCB3cml0YWJsZSBwcm9wZXJ0aWVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0V2ZW50fSBpbkV2ZW50IEFuIGV2ZW50IHRoYXQgY29udGFpbnMgcHJvcGVydGllcyB0byBjb3B5LlxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEFuIG9iamVjdCBjb250YWluaW5nIHNoYWxsb3cgY29waWVzIG9mIGBpbkV2ZW50YCdzXG4gICAgICAgICAqICAgIHByb3BlcnRpZXMuXG4gICAgICAgICAqL1xuICAgICAgICBjbG9uZUV2ZW50OiBmdW5jdGlvbihpbkV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgZXZlbnRDb3B5ID0gT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgICAgICAgICAgICBwO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBDTE9ORV9QUk9QUy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHAgPSBDTE9ORV9QUk9QU1tpXTtcbiAgICAgICAgICAgICAgICBldmVudENvcHlbcF0gPSBpbkV2ZW50W3BdIHx8IENMT05FX0RFRkFVTFRTW2ldO1xuICAgICAgICAgICAgICAgIC8vIFdvcmsgYXJvdW5kIFNWR0luc3RhbmNlRWxlbWVudCBzaGFkb3cgdHJlZVxuICAgICAgICAgICAgICAgIC8vIFJldHVybiB0aGUgPHVzZT4gZWxlbWVudCB0aGF0IGlzIHJlcHJlc2VudGVkIGJ5IHRoZSBpbnN0YW5jZSBmb3IgU2FmYXJpLCBDaHJvbWUsIElFLlxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIGJlaGF2aW9yIGltcGxlbWVudGVkIGJ5IEZpcmVmb3guXG4gICAgICAgICAgICAgICAgaWYgKHAgPT09ICd0YXJnZXQnIHx8IHAgPT09ICdyZWxhdGVkVGFyZ2V0Jykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoSEFTX1NWR19JTlNUQU5DRSAmJiBldmVudENvcHlbcF0gaW5zdGFuY2VvZiBTVkdFbGVtZW50SW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50Q29weVtwXSA9IGV2ZW50Q29weVtwXS5jb3JyZXNwb25kaW5nVXNlRWxlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGtlZXAgdGhlIHNlbWFudGljcyBvZiBwcmV2ZW50RGVmYXVsdFxuICAgICAgICAgICAgZXZlbnRDb3B5LnByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaW5FdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBldmVudENvcHk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNwYXRjaGVzIHRoZSBldmVudCB0byBpdHMgdGFyZ2V0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0V2ZW50fSBpbkV2ZW50IFRoZSBldmVudCB0byBiZSBkaXNwYXRjaGVkLlxuICAgICAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIGFuIGV2ZW50IGhhbmRsZXIgcmV0dXJucyB0cnVlLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICAgICAqL1xuICAgICAgICBkaXNwYXRjaEV2ZW50OiBmdW5jdGlvbihpbkV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgdCA9IGluRXZlbnQuX3RhcmdldDtcbiAgICAgICAgICAgIGlmICh0KSB7XG4gICAgICAgICAgICAgICAgdC5kaXNwYXRjaEV2ZW50KGluRXZlbnQpO1xuICAgICAgICAgICAgICAgIC8vIGNsb25lIHRoZSBldmVudCBmb3IgdGhlIGdlc3R1cmUgc3lzdGVtIHRvIHByb2Nlc3NcbiAgICAgICAgICAgICAgICAvLyBjbG9uZSBhZnRlciBkaXNwYXRjaCB0byBwaWNrIHVwIGdlc3R1cmUgcHJldmVudGlvbiBjb2RlXG4gICAgICAgICAgICAgICAgdmFyIGNsb25lID0gdGhpcy5jbG9uZUV2ZW50KGluRXZlbnQpO1xuICAgICAgICAgICAgICAgIGNsb25lLnRhcmdldCA9IHQ7XG4gICAgICAgICAgICAgICAgdGhpcy5maWxsR2VzdHVyZVF1ZXVlKGNsb25lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZ2VzdHVyZVRyaWdnZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gcHJvY2VzcyB0aGUgZ2VzdHVyZSBxdWV1ZVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGUsIHJnOyBpIDwgdGhpcy5nZXN0dXJlUXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBlID0gdGhpcy5nZXN0dXJlUXVldWVbaV07XG4gICAgICAgICAgICAgICAgcmcgPSBlLl9yZXF1aXJlZEdlc3R1cmVzO1xuICAgICAgICAgICAgICAgIGlmIChyZykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMCwgZywgZm47IGogPCB0aGlzLmdlc3R1cmVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvbmx5IHJ1biByZWNvZ25pemVyIGlmIGFuIGVsZW1lbnQgaW4gdGhlIHNvdXJjZSBldmVudCdzIHBhdGggaXMgbGlzdGVuaW5nIGZvciB0aG9zZSBnZXN0dXJlc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJnW2pdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZyA9IHRoaXMuZ2VzdHVyZXNbal07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm4gPSBnW2UudHlwZV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZuLmNhbGwoZywgZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5nZXN0dXJlUXVldWUubGVuZ3RoID0gMDtcbiAgICAgICAgfSxcbiAgICAgICAgZmlsbEdlc3R1cmVRdWV1ZTogZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgICAgIC8vIG9ubHkgdHJpZ2dlciB0aGUgZ2VzdHVyZSBxdWV1ZSBvbmNlXG4gICAgICAgICAgICBpZiAoIXRoaXMuZ2VzdHVyZVF1ZXVlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLmJvdW5kR2VzdHVyZVRyaWdnZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXYuX3JlcXVpcmVkR2VzdHVyZXMgPSB0aGlzLnJlcXVpcmVkR2VzdHVyZXMuZ2V0KGV2LnBvaW50ZXJJZCk7XG4gICAgICAgICAgICB0aGlzLmdlc3R1cmVRdWV1ZS5wdXNoKGV2KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgZGlzcGF0Y2hlci5ib3VuZEhhbmRsZXIgPSBkaXNwYXRjaGVyLmV2ZW50SGFuZGxlci5iaW5kKGRpc3BhdGNoZXIpO1xuICAgIGRpc3BhdGNoZXIuYm91bmRHZXN0dXJlVHJpZ2dlciA9IGRpc3BhdGNoZXIuZ2VzdHVyZVRyaWdnZXIuYmluZChkaXNwYXRjaGVyKTtcbiAgICBzY29wZS5kaXNwYXRjaGVyID0gZGlzcGF0Y2hlcjtcblxuICAgIC8qKlxuICAgICAqIExpc3RlbiBmb3IgYGdlc3R1cmVgIG9uIGBub2RlYCB3aXRoIHRoZSBgaGFuZGxlcmAgZnVuY3Rpb25cbiAgICAgKlxuICAgICAqIElmIGBoYW5kbGVyYCBpcyB0aGUgZmlyc3QgbGlzdGVuZXIgZm9yIGBnZXN0dXJlYCwgdGhlIHVuZGVybHlpbmcgZ2VzdHVyZSByZWNvZ25pemVyIGlzIHRoZW4gZW5hYmxlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBnZXN0dXJlXG4gICAgICogQHJldHVybiBCb29sZWFuIGBnZXN0dXJlYCBpcyBhIHZhbGlkIGdlc3R1cmVcbiAgICAgKi9cbiAgICBzY29wZS5hY3RpdmF0ZUdlc3R1cmUgPSBmdW5jdGlvbihub2RlLCBnZXN0dXJlKSB7XG4gICAgICAgIHZhciBnID0gZ2VzdHVyZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB2YXIgZGVwID0gZGlzcGF0Y2hlci5kZXBlbmRlbmN5TWFwW2ddO1xuICAgICAgICBpZiAoZGVwKSB7XG4gICAgICAgICAgICB2YXIgcmVjb2duaXplciA9IGRpc3BhdGNoZXIuZ2VzdHVyZXNbZGVwLmluZGV4XTtcbiAgICAgICAgICAgIGlmICghbm9kZS5fcGdMaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaGVyLnJlZ2lzdGVyKG5vZGUpO1xuICAgICAgICAgICAgICAgIG5vZGUuX3BnTGlzdGVuZXJzID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRPRE8oZGZyZWVkbSk6IHJlLWV2YWx1YXRlIGJvb2trZWVwaW5nIHRvIGF2b2lkIHVzaW5nIGF0dHJpYnV0ZXNcbiAgICAgICAgICAgIGlmIChyZWNvZ25pemVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRvdWNoQWN0aW9uID0gcmVjb2duaXplci5kZWZhdWx0QWN0aW9ucyAmJiByZWNvZ25pemVyLmRlZmF1bHRBY3Rpb25zW2ddO1xuICAgICAgICAgICAgICAgIHZhciBhY3Rpb25Ob2RlO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAobm9kZS5ub2RlVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIE5vZGUuRUxFTUVOVF9OT0RFOlxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uTm9kZSA9IG5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBOb2RlLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREU6XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb25Ob2RlID0gbm9kZS5ob3N0O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb25Ob2RlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodG91Y2hBY3Rpb24gJiYgYWN0aW9uTm9kZSAmJiAhYWN0aW9uTm9kZS5oYXNBdHRyaWJ1dGUoJ3RvdWNoLWFjdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbk5vZGUuc2V0QXR0cmlidXRlKCd0b3VjaC1hY3Rpb24nLCB0b3VjaEFjdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFub2RlLl9wZ0V2ZW50cykge1xuICAgICAgICAgICAgICAgIG5vZGUuX3BnRXZlbnRzID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlLl9wZ0V2ZW50c1tnXSA9IChub2RlLl9wZ0V2ZW50c1tnXSB8fCAwKSArIDE7XG4gICAgICAgICAgICBub2RlLl9wZ0xpc3RlbmVycysrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBCb29sZWFuKGRlcCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogTGlzdGVuIGZvciBgZ2VzdHVyZWAgZnJvbSBgbm9kZWAgd2l0aCBgaGFuZGxlcmAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZ2VzdHVyZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGNhcHR1cmVcbiAgICAgKi9cbiAgICBzY29wZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24obm9kZSwgZ2VzdHVyZSwgaGFuZGxlciwgY2FwdHVyZSkge1xuICAgICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAgICAgc2NvcGUuYWN0aXZhdGVHZXN0dXJlKG5vZGUsIGdlc3R1cmUpO1xuICAgICAgICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKGdlc3R1cmUsIGhhbmRsZXIsIGNhcHR1cmUpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRlYXJzIGRvd24gdGhlIGdlc3R1cmUgY29uZmlndXJhdGlvbiBmb3IgYG5vZGVgXG4gICAgICpcbiAgICAgKiBJZiBgaGFuZGxlcmAgaXMgdGhlIGxhc3QgbGlzdGVuZXIgZm9yIGBnZXN0dXJlYCwgdGhlIHVuZGVybHlpbmcgZ2VzdHVyZSByZWNvZ25pemVyIGlzIGRpc2FibGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBub2RlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGdlc3R1cmVcbiAgICAgKiBAcmV0dXJuIEJvb2xlYW4gYGdlc3R1cmVgIGlzIGEgdmFsaWQgZ2VzdHVyZVxuICAgICAqL1xuICAgIHNjb3BlLmRlYWN0aXZhdGVHZXN0dXJlID0gZnVuY3Rpb24obm9kZSwgZ2VzdHVyZSkge1xuICAgICAgICB2YXIgZyA9IGdlc3R1cmUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgdmFyIGRlcCA9IGRpc3BhdGNoZXIuZGVwZW5kZW5jeU1hcFtnXTtcbiAgICAgICAgaWYgKGRlcCkge1xuICAgICAgICAgICAgaWYgKG5vZGUuX3BnTGlzdGVuZXJzID4gMCkge1xuICAgICAgICAgICAgICAgIG5vZGUuX3BnTGlzdGVuZXJzLS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9kZS5fcGdMaXN0ZW5lcnMgPT09IDApIHtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaGVyLnVucmVnaXN0ZXIobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9kZS5fcGdFdmVudHMpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5fcGdFdmVudHNbZ10gPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuX3BnRXZlbnRzW2ddLS07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5fcGdFdmVudHNbZ10gPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQm9vbGVhbihkZXApO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTdG9wIGxpc3RlbmluZyBmb3IgYGdlc3R1cmVgIGZyb20gYG5vZGVgIHdpdGggYGhhbmRsZXJgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBub2RlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGdlc3R1cmVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBjYXB0dXJlXG4gICAgICovXG4gICAgc2NvcGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKG5vZGUsIGdlc3R1cmUsIGhhbmRsZXIsIGNhcHR1cmUpIHtcbiAgICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICAgIHNjb3BlLmRlYWN0aXZhdGVHZXN0dXJlKG5vZGUsIGdlc3R1cmUpO1xuICAgICAgICAgICAgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKGdlc3R1cmUsIGhhbmRsZXIsIGNhcHR1cmUpO1xuICAgICAgICB9XG4gICAgfTtcbn0pKGV4cG9ydHMpO1xuXG4oZnVuY3Rpb24oc2NvcGUpIHtcbiAgICB2YXIgZGlzcGF0Y2hlciA9IHNjb3BlLmRpc3BhdGNoZXI7XG4gICAgdmFyIHBvaW50ZXJtYXAgPSBkaXNwYXRjaGVyLnBvaW50ZXJtYXA7XG4gICAgLy8gcmFkaXVzIGFyb3VuZCB0b3VjaGVuZCB0aGF0IHN3YWxsb3dzIG1vdXNlIGV2ZW50c1xuICAgIHZhciBERURVUF9ESVNUID0gMjU7XG5cbiAgICB2YXIgV0hJQ0hfVE9fQlVUVE9OUyA9IFswLCAxLCA0LCAyXTtcblxuICAgIHZhciBjdXJyZW50QnV0dG9ucyA9IDA7XG5cbiAgICB2YXIgRklSRUZPWF9MSU5VWCA9IC9MaW51eC4qRmlyZWZveFxcLy9pO1xuXG4gICAgdmFyIEhBU19CVVRUT05TID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBmaXJlZm94IG9uIGxpbnV4IHJldHVybnMgc3BlYy1pbmNvcnJlY3QgdmFsdWVzIGZvciBtb3VzZXVwLmJ1dHRvbnNcbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL01vdXNlRXZlbnQuYnV0dG9ucyNTZWVfYWxzb1xuICAgICAgICAvLyBodHRwczovL2NvZGVyZXZpZXcuY2hyb21pdW0ub3JnLzcyNzU5MzAwMy8jbXNnMTZcbiAgICAgICAgaWYgKEZJUkVGT1hfTElOVVgudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE1vdXNlRXZlbnQoJ3Rlc3QnLCB7XG4gICAgICAgICAgICAgICAgYnV0dG9uczogMVxuICAgICAgICAgICAgfSkuYnV0dG9ucyA9PT0gMTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfSkoKTtcblxuICAgIC8vIGhhbmRsZXIgYmxvY2sgZm9yIG5hdGl2ZSBtb3VzZSBldmVudHNcbiAgICB2YXIgbW91c2VFdmVudHMgPSB7XG4gICAgICAgIFBPSU5URVJfSUQ6IDEsXG4gICAgICAgIFBPSU5URVJfVFlQRTogJ21vdXNlJyxcbiAgICAgICAgZXZlbnRzOiBbXG4gICAgICAgICAgICAnbW91c2Vkb3duJyxcbiAgICAgICAgICAgICdtb3VzZW1vdmUnLFxuICAgICAgICAgICAgJ21vdXNldXAnXG4gICAgICAgIF0sXG4gICAgICAgIGV4cG9zZXM6IFtcbiAgICAgICAgICAgICdkb3duJyxcbiAgICAgICAgICAgICd1cCcsXG4gICAgICAgICAgICAnbW92ZSdcbiAgICAgICAgXSxcbiAgICAgICAgcmVnaXN0ZXI6IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgICAgICAgZGlzcGF0Y2hlci5saXN0ZW4odGFyZ2V0LCB0aGlzLmV2ZW50cyk7XG4gICAgICAgIH0sXG4gICAgICAgIHVucmVnaXN0ZXI6IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgICAgICAgaWYgKHRhcmdldC5ub2RlVHlwZSA9PT0gTm9kZS5ET0NVTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGlzcGF0Y2hlci51bmxpc3Rlbih0YXJnZXQsIHRoaXMuZXZlbnRzKTtcbiAgICAgICAgfSxcbiAgICAgICAgbGFzdFRvdWNoZXM6IFtdLFxuICAgICAgICAvLyBjb2xsaWRlIHdpdGggdGhlIGdsb2JhbCBtb3VzZSBsaXN0ZW5lclxuICAgICAgICBpc0V2ZW50U2ltdWxhdGVkRnJvbVRvdWNoOiBmdW5jdGlvbihpbkV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgbHRzID0gdGhpcy5sYXN0VG91Y2hlcztcbiAgICAgICAgICAgIHZhciB4ID0gaW5FdmVudC5jbGllbnRYLFxuICAgICAgICAgICAgICAgIHkgPSBpbkV2ZW50LmNsaWVudFk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGx0cy5sZW5ndGgsIHQ7IGkgPCBsICYmICh0ID0gbHRzW2ldKTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgLy8gc2ltdWxhdGVkIG1vdXNlIGV2ZW50cyB3aWxsIGJlIHN3YWxsb3dlZCBuZWFyIGEgcHJpbWFyeSB0b3VjaGVuZFxuICAgICAgICAgICAgICAgIHZhciBkeCA9IE1hdGguYWJzKHggLSB0LngpLFxuICAgICAgICAgICAgICAgICAgICBkeSA9IE1hdGguYWJzKHkgLSB0LnkpO1xuICAgICAgICAgICAgICAgIGlmIChkeCA8PSBERURVUF9ESVNUICYmIGR5IDw9IERFRFVQX0RJU1QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBwcmVwYXJlRXZlbnQ6IGZ1bmN0aW9uKGluRXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBlID0gZGlzcGF0Y2hlci5jbG9uZUV2ZW50KGluRXZlbnQpO1xuICAgICAgICAgICAgZS5wb2ludGVySWQgPSB0aGlzLlBPSU5URVJfSUQ7XG4gICAgICAgICAgICBlLmlzUHJpbWFyeSA9IHRydWU7XG4gICAgICAgICAgICBlLnBvaW50ZXJUeXBlID0gdGhpcy5QT0lOVEVSX1RZUEU7XG4gICAgICAgICAgICBlLl9zb3VyY2UgPSAnbW91c2UnO1xuICAgICAgICAgICAgaWYgKCFIQVNfQlVUVE9OUykge1xuICAgICAgICAgICAgICAgIHZhciB0eXBlID0gaW5FdmVudC50eXBlO1xuICAgICAgICAgICAgICAgIHZhciBiaXQgPSBXSElDSF9UT19CVVRUT05TW2luRXZlbnQud2hpY2hdIHx8IDA7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdtb3VzZWRvd24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRCdXR0b25zIHw9IGJpdDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdtb3VzZXVwJykge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50QnV0dG9ucyAmPSB+Yml0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlLmJ1dHRvbnMgPSBjdXJyZW50QnV0dG9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBlO1xuICAgICAgICB9LFxuICAgICAgICBtb3VzZWRvd246IGZ1bmN0aW9uKGluRXZlbnQpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0V2ZW50U2ltdWxhdGVkRnJvbVRvdWNoKGluRXZlbnQpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHAgPSBwb2ludGVybWFwLmhhcyh0aGlzLlBPSU5URVJfSUQpO1xuICAgICAgICAgICAgICAgIHZhciBlID0gdGhpcy5wcmVwYXJlRXZlbnQoaW5FdmVudCk7XG4gICAgICAgICAgICAgICAgZS50YXJnZXQgPSBzY29wZS5maW5kVGFyZ2V0KGluRXZlbnQpO1xuICAgICAgICAgICAgICAgIHBvaW50ZXJtYXAuc2V0KHRoaXMuUE9JTlRFUl9JRCwgZS50YXJnZXQpO1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoZXIuZG93bihlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbW91c2Vtb3ZlOiBmdW5jdGlvbihpbkV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNFdmVudFNpbXVsYXRlZEZyb21Ub3VjaChpbkV2ZW50KSkge1xuICAgICAgICAgICAgICAgIHZhciB0YXJnZXQgPSBwb2ludGVybWFwLmdldCh0aGlzLlBPSU5URVJfSUQpO1xuICAgICAgICAgICAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGUgPSB0aGlzLnByZXBhcmVFdmVudChpbkV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgZS50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgICAgICAgICAgICAgIC8vIGhhbmRsZSBjYXNlIHdoZXJlIHdlIG1pc3NlZCBhIG1vdXNldXBcbiAgICAgICAgICAgICAgICAgICAgaWYgKChIQVNfQlVUVE9OUyA/IGUuYnV0dG9ucyA6IGUud2hpY2gpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIUhBU19CVVRUT05TKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEJ1dHRvbnMgPSBlLmJ1dHRvbnMgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2hlci5jYW5jZWwoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNsZWFudXBNb3VzZShlLmJ1dHRvbnMpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2hlci5tb3ZlKGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBtb3VzZXVwOiBmdW5jdGlvbihpbkV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNFdmVudFNpbXVsYXRlZEZyb21Ub3VjaChpbkV2ZW50KSkge1xuICAgICAgICAgICAgICAgIHZhciBlID0gdGhpcy5wcmVwYXJlRXZlbnQoaW5FdmVudCk7XG4gICAgICAgICAgICAgICAgZS5yZWxhdGVkVGFyZ2V0ID0gc2NvcGUuZmluZFRhcmdldChpbkV2ZW50KTtcbiAgICAgICAgICAgICAgICBlLnRhcmdldCA9IHBvaW50ZXJtYXAuZ2V0KHRoaXMuUE9JTlRFUl9JRCk7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2hlci51cChlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFudXBNb3VzZShlLmJ1dHRvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjbGVhbnVwTW91c2U6IGZ1bmN0aW9uKGJ1dHRvbnMpIHtcbiAgICAgICAgICAgIGlmIChidXR0b25zID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcG9pbnRlcm1hcC5kZWxldGUodGhpcy5QT0lOVEVSX0lEKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBzY29wZS5tb3VzZUV2ZW50cyA9IG1vdXNlRXZlbnRzO1xufSkoZXhwb3J0cyk7XG5cbihmdW5jdGlvbihzY29wZSkge1xuICAgIHZhciBkaXNwYXRjaGVyID0gc2NvcGUuZGlzcGF0Y2hlcjtcbiAgICB2YXIgYWxsU2hhZG93cyA9IHNjb3BlLnRhcmdldEZpbmRpbmcuYWxsU2hhZG93cy5iaW5kKHNjb3BlLnRhcmdldEZpbmRpbmcpO1xuICAgIHZhciBwb2ludGVybWFwID0gZGlzcGF0Y2hlci5wb2ludGVybWFwO1xuICAgIHZhciB0b3VjaE1hcCA9IEFycmF5LnByb3RvdHlwZS5tYXAuY2FsbC5iaW5kKEFycmF5LnByb3RvdHlwZS5tYXApO1xuICAgIC8vIFRoaXMgc2hvdWxkIGJlIGxvbmcgZW5vdWdoIHRvIGlnbm9yZSBjb21wYXQgbW91c2UgZXZlbnRzIG1hZGUgYnkgdG91Y2hcbiAgICB2YXIgREVEVVBfVElNRU9VVCA9IDI1MDA7XG4gICAgdmFyIERFRFVQX0RJU1QgPSAyNTtcbiAgICB2YXIgQ0xJQ0tfQ09VTlRfVElNRU9VVCA9IDIwMDtcbiAgICB2YXIgSFlTVEVSRVNJUyA9IDIwO1xuICAgIHZhciBBVFRSSUIgPSAndG91Y2gtYWN0aW9uJztcbiAgICAvLyBUT0RPKGRmcmVlZG0pOiBkaXNhYmxlIHVudGlsIGh0dHA6Ly9jcmJ1Zy5jb20vMzk5NzY1IGlzIHJlc29sdmVkXG4gICAgLy8gdmFyIEhBU19UT1VDSF9BQ1RJT04gPSBBVFRSSUIgaW4gZG9jdW1lbnQuaGVhZC5zdHlsZTtcbiAgICB2YXIgSEFTX1RPVUNIX0FDVElPTiA9IGZhbHNlO1xuXG4gICAgLy8gaGFuZGxlciBibG9jayBmb3IgbmF0aXZlIHRvdWNoIGV2ZW50c1xuICAgIHZhciB0b3VjaEV2ZW50cyA9IHtcbiAgICAgICAgSVNfSU9TOiBmYWxzZSxcbiAgICAgICAgZXZlbnRzOiBbXG4gICAgICAgICAgICAndG91Y2hzdGFydCcsXG4gICAgICAgICAgICAndG91Y2htb3ZlJyxcbiAgICAgICAgICAgICd0b3VjaGVuZCcsXG4gICAgICAgICAgICAndG91Y2hjYW5jZWwnXG4gICAgICAgIF0sXG4gICAgICAgIGV4cG9zZXM6IFtcbiAgICAgICAgICAgICdkb3duJyxcbiAgICAgICAgICAgICd1cCcsXG4gICAgICAgICAgICAnbW92ZSdcbiAgICAgICAgXSxcbiAgICAgICAgcmVnaXN0ZXI6IGZ1bmN0aW9uKHRhcmdldCwgaW5pdGlhbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuSVNfSU9TID8gaW5pdGlhbCA6ICFpbml0aWFsKSB7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2hlci5saXN0ZW4odGFyZ2V0LCB0aGlzLmV2ZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHVucmVnaXN0ZXI6IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLklTX0lPUykge1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoZXIudW5saXN0ZW4odGFyZ2V0LCB0aGlzLmV2ZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNjcm9sbFR5cGVzOiB7XG4gICAgICAgICAgICBFTUlUVEVSOiAnbm9uZScsXG4gICAgICAgICAgICBYU0NST0xMRVI6ICdwYW4teCcsXG4gICAgICAgICAgICBZU0NST0xMRVI6ICdwYW4teScsXG4gICAgICAgIH0sXG4gICAgICAgIHRvdWNoQWN0aW9uVG9TY3JvbGxUeXBlOiBmdW5jdGlvbih0b3VjaEFjdGlvbikge1xuICAgICAgICAgICAgdmFyIHQgPSB0b3VjaEFjdGlvbjtcbiAgICAgICAgICAgIHZhciBzdCA9IHRoaXMuc2Nyb2xsVHlwZXM7XG4gICAgICAgICAgICBpZiAodCA9PT0gc3QuRU1JVFRFUikge1xuICAgICAgICAgICAgICAgIHJldHVybiAnbm9uZSc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHQgPT09IHN0LlhTQ1JPTExFUikge1xuICAgICAgICAgICAgICAgIHJldHVybiAnWCc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHQgPT09IHN0LllTQ1JPTExFUikge1xuICAgICAgICAgICAgICAgIHJldHVybiAnWSc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAnWFknO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBQT0lOVEVSX1RZUEU6ICd0b3VjaCcsXG4gICAgICAgIGZpcnN0VG91Y2g6IG51bGwsXG4gICAgICAgIGlzUHJpbWFyeVRvdWNoOiBmdW5jdGlvbihpblRvdWNoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maXJzdFRvdWNoID09PSBpblRvdWNoLmlkZW50aWZpZXI7XG4gICAgICAgIH0sXG4gICAgICAgIHNldFByaW1hcnlUb3VjaDogZnVuY3Rpb24oaW5Ub3VjaCkge1xuICAgICAgICAgICAgLy8gc2V0IHByaW1hcnkgdG91Y2ggaWYgdGhlcmUgbm8gcG9pbnRlcnMsIG9yIHRoZSBvbmx5IHBvaW50ZXIgaXMgdGhlIG1vdXNlXG4gICAgICAgICAgICBpZiAocG9pbnRlcm1hcC5wb2ludGVycygpID09PSAwIHx8IChwb2ludGVybWFwLnBvaW50ZXJzKCkgPT09IDEgJiYgcG9pbnRlcm1hcC5oYXMoMSkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJzdFRvdWNoID0gaW5Ub3VjaC5pZGVudGlmaWVyO1xuICAgICAgICAgICAgICAgIHRoaXMuZmlyc3RYWSA9IHtcbiAgICAgICAgICAgICAgICAgICAgWDogaW5Ub3VjaC5jbGllbnRYLFxuICAgICAgICAgICAgICAgICAgICBZOiBpblRvdWNoLmNsaWVudFlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXMuZmlyc3RUYXJnZXQgPSBpblRvdWNoLnRhcmdldDtcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbGluZyA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5jYW5jZWxSZXNldENsaWNrQ291bnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlUHJpbWFyeVBvaW50ZXI6IGZ1bmN0aW9uKGluUG9pbnRlcikge1xuICAgICAgICAgICAgaWYgKGluUG9pbnRlci5pc1ByaW1hcnkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpcnN0VG91Y2ggPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuZmlyc3RYWSA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNldENsaWNrQ291bnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY2xpY2tDb3VudDogMCxcbiAgICAgICAgcmVzZXRJZDogbnVsbCxcbiAgICAgICAgcmVzZXRDbGlja0NvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBmbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xpY2tDb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNldElkID0gbnVsbDtcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMucmVzZXRJZCA9IHNldFRpbWVvdXQoZm4sIENMSUNLX0NPVU5UX1RJTUVPVVQpO1xuICAgICAgICB9LFxuICAgICAgICBjYW5jZWxSZXNldENsaWNrQ291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucmVzZXRJZCkge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnJlc2V0SWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB0eXBlVG9CdXR0b25zOiBmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgICAgICB2YXIgcmV0ID0gMDtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSAndG91Y2hzdGFydCcgfHwgdHlwZSA9PT0gJ3RvdWNobW92ZScpIHtcbiAgICAgICAgICAgICAgICByZXQgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfSxcbiAgICAgICAgZmluZFRhcmdldDogZnVuY3Rpb24odG91Y2gsIGlkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50VG91Y2hFdmVudC50eXBlID09PSAndG91Y2hzdGFydCcpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc1ByaW1hcnlUb3VjaCh0b3VjaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZhc3RQYXRoID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xpZW50WDogdG91Y2guY2xpZW50WCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsaWVudFk6IHRvdWNoLmNsaWVudFksXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiB0aGlzLmN1cnJlbnRUb3VjaEV2ZW50LnBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IHRoaXMuY3VycmVudFRvdWNoRXZlbnQudGFyZ2V0XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzY29wZS5maW5kVGFyZ2V0KGZhc3RQYXRoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2NvcGUuZmluZFRhcmdldCh0b3VjaCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcmV1c2UgdGFyZ2V0IHdlIGZvdW5kIGluIHRvdWNoc3RhcnRcbiAgICAgICAgICAgIHJldHVybiBwb2ludGVybWFwLmdldChpZCk7XG4gICAgICAgIH0sXG4gICAgICAgIHRvdWNoVG9Qb2ludGVyOiBmdW5jdGlvbihpblRvdWNoKSB7XG4gICAgICAgICAgICB2YXIgY3RlID0gdGhpcy5jdXJyZW50VG91Y2hFdmVudDtcbiAgICAgICAgICAgIHZhciBlID0gZGlzcGF0Y2hlci5jbG9uZUV2ZW50KGluVG91Y2gpO1xuICAgICAgICAgICAgLy8gU3BlYyBzcGVjaWZpZXMgdGhhdCBwb2ludGVySWQgMSBpcyByZXNlcnZlZCBmb3IgTW91c2UuXG4gICAgICAgICAgICAvLyBUb3VjaCBpZGVudGlmaWVycyBjYW4gc3RhcnQgYXQgMC5cbiAgICAgICAgICAgIC8vIEFkZCAyIHRvIHRoZSB0b3VjaCBpZGVudGlmaWVyIGZvciBjb21wYXRpYmlsaXR5LlxuICAgICAgICAgICAgdmFyIGlkID0gZS5wb2ludGVySWQgPSBpblRvdWNoLmlkZW50aWZpZXIgKyAyO1xuICAgICAgICAgICAgZS50YXJnZXQgPSB0aGlzLmZpbmRUYXJnZXQoaW5Ub3VjaCwgaWQpO1xuICAgICAgICAgICAgZS5idWJibGVzID0gdHJ1ZTtcbiAgICAgICAgICAgIGUuY2FuY2VsYWJsZSA9IHRydWU7XG4gICAgICAgICAgICBlLmRldGFpbCA9IHRoaXMuY2xpY2tDb3VudDtcbiAgICAgICAgICAgIGUuYnV0dG9ucyA9IHRoaXMudHlwZVRvQnV0dG9ucyhjdGUudHlwZSk7XG4gICAgICAgICAgICBlLndpZHRoID0gaW5Ub3VjaC53ZWJraXRSYWRpdXNYIHx8IGluVG91Y2gucmFkaXVzWCB8fCAwO1xuICAgICAgICAgICAgZS5oZWlnaHQgPSBpblRvdWNoLndlYmtpdFJhZGl1c1kgfHwgaW5Ub3VjaC5yYWRpdXNZIHx8IDA7XG4gICAgICAgICAgICBlLnByZXNzdXJlID0gaW5Ub3VjaC53ZWJraXRGb3JjZSB8fCBpblRvdWNoLmZvcmNlIHx8IDAuNTtcbiAgICAgICAgICAgIGUuaXNQcmltYXJ5ID0gdGhpcy5pc1ByaW1hcnlUb3VjaChpblRvdWNoKTtcbiAgICAgICAgICAgIGUucG9pbnRlclR5cGUgPSB0aGlzLlBPSU5URVJfVFlQRTtcbiAgICAgICAgICAgIGUuX3NvdXJjZSA9ICd0b3VjaCc7XG4gICAgICAgICAgICAvLyBmb3J3YXJkIHRvdWNoIHByZXZlbnREZWZhdWx0c1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHNlbGYuc2Nyb2xsaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgc2VsZi5maXJzdFhZID0gbnVsbDtcbiAgICAgICAgICAgICAgICBjdGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgfSxcbiAgICAgICAgcHJvY2Vzc1RvdWNoZXM6IGZ1bmN0aW9uKGluRXZlbnQsIGluRnVuY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciB0bCA9IGluRXZlbnQuY2hhbmdlZFRvdWNoZXM7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRUb3VjaEV2ZW50ID0gaW5FdmVudDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCB0LCBwOyBpIDwgdGwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0ID0gdGxbaV07XG4gICAgICAgICAgICAgICAgcCA9IHRoaXMudG91Y2hUb1BvaW50ZXIodCk7XG4gICAgICAgICAgICAgICAgaWYgKGluRXZlbnQudHlwZSA9PT0gJ3RvdWNoc3RhcnQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50ZXJtYXAuc2V0KHAucG9pbnRlcklkLCBwLnRhcmdldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwb2ludGVybWFwLmhhcyhwLnBvaW50ZXJJZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5GdW5jdGlvbi5jYWxsKHRoaXMsIHApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaW5FdmVudC50eXBlID09PSAndG91Y2hlbmQnIHx8IGluRXZlbnQuX2NhbmNlbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsZWFuVXBQb2ludGVyKHApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLy8gRm9yIHNpbmdsZSBheGlzIHNjcm9sbGVycywgZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBlbGVtZW50IHNob3VsZCBlbWl0XG4gICAgICAgIC8vIHBvaW50ZXIgZXZlbnRzIG9yIGJlaGF2ZSBhcyBhIHNjcm9sbGVyXG4gICAgICAgIHNob3VsZFNjcm9sbDogZnVuY3Rpb24oaW5FdmVudCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZmlyc3RYWSkge1xuICAgICAgICAgICAgICAgIHZhciByZXQ7XG4gICAgICAgICAgICAgICAgdmFyIHRvdWNoQWN0aW9uID0gc2NvcGUudGFyZ2V0RmluZGluZy5maW5kVG91Y2hBY3Rpb24oaW5FdmVudCk7XG4gICAgICAgICAgICAgICAgdmFyIHNjcm9sbEF4aXMgPSB0aGlzLnRvdWNoQWN0aW9uVG9TY3JvbGxUeXBlKHRvdWNoQWN0aW9uKTtcbiAgICAgICAgICAgICAgICBpZiAoc2Nyb2xsQXhpcyA9PT0gJ25vbmUnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgZWxlbWVudCBpcyBhIHRvdWNoLWFjdGlvbjogbm9uZSwgc2hvdWxkIG5ldmVyIHNjcm9sbFxuICAgICAgICAgICAgICAgICAgICByZXQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNjcm9sbEF4aXMgPT09ICdYWScpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBlbGVtZW50IHNob3VsZCBhbHdheXMgc2Nyb2xsXG4gICAgICAgICAgICAgICAgICAgIHJldCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBpbkV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdO1xuICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayB0aGUgaW50ZW5kZWQgc2Nyb2xsIGF4aXMsIGFuZCBvdGhlciBheGlzXG4gICAgICAgICAgICAgICAgICAgIHZhciBhID0gc2Nyb2xsQXhpcztcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9hID0gc2Nyb2xsQXhpcyA9PT0gJ1knID8gJ1gnIDogJ1knO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGEgPSBNYXRoLmFicyh0WydjbGllbnQnICsgYV0gLSB0aGlzLmZpcnN0WFlbYV0pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZG9hID0gTWF0aC5hYnModFsnY2xpZW50JyArIG9hXSAtIHRoaXMuZmlyc3RYWVtvYV0pO1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiBkZWx0YSBpbiB0aGUgc2Nyb2xsIGF4aXMgPiBkZWx0YSBvdGhlciBheGlzLCBzY3JvbGwgaW5zdGVhZCBvZlxuICAgICAgICAgICAgICAgICAgICAvLyBtYWtpbmcgZXZlbnRzXG4gICAgICAgICAgICAgICAgICAgIHJldCA9IGRhID49IGRvYTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZmluZFRvdWNoOiBmdW5jdGlvbihpblRMLCBpbklkKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGluVEwubGVuZ3RoLCB0OyBpIDwgbCAmJiAodCA9IGluVExbaV0pOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodC5pZGVudGlmaWVyID09PSBpbklkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLy8gSW4gc29tZSBpbnN0YW5jZXMsIGEgdG91Y2hzdGFydCBjYW4gaGFwcGVuIHdpdGhvdXQgYSB0b3VjaGVuZC4gVGhpc1xuICAgICAgICAvLyBsZWF2ZXMgdGhlIHBvaW50ZXJtYXAgaW4gYSBicm9rZW4gc3RhdGUuXG4gICAgICAgIC8vIFRoZXJlZm9yZSwgb24gZXZlcnkgdG91Y2hzdGFydCwgd2UgcmVtb3ZlIHRoZSB0b3VjaGVzIHRoYXQgZGlkIG5vdCBmaXJlIGFcbiAgICAgICAgLy8gdG91Y2hlbmQgZXZlbnQuXG4gICAgICAgIC8vIFRvIGtlZXAgc3RhdGUgZ2xvYmFsbHkgY29uc2lzdGVudCwgd2UgZmlyZSBhXG4gICAgICAgIC8vIHBvaW50ZXJjYW5jZWwgZm9yIHRoaXMgXCJhYmFuZG9uZWRcIiB0b3VjaFxuICAgICAgICB2YWN1dW1Ub3VjaGVzOiBmdW5jdGlvbihpbkV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgdGwgPSBpbkV2ZW50LnRvdWNoZXM7XG4gICAgICAgICAgICAvLyBwb2ludGVybWFwLnBvaW50ZXJzKCkgc2hvdWxkIGJlIDwgdGwubGVuZ3RoIGhlcmUsIGFzIHRoZSB0b3VjaHN0YXJ0IGhhcyBub3RcbiAgICAgICAgICAgIC8vIGJlZW4gcHJvY2Vzc2VkIHlldC5cbiAgICAgICAgICAgIGlmIChwb2ludGVybWFwLnBvaW50ZXJzKCkgPj0gdGwubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGQgPSBbXTtcbiAgICAgICAgICAgICAgICBwb2ludGVybWFwLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBOZXZlciByZW1vdmUgcG9pbnRlcklkID09IDEsIHdoaWNoIGlzIG1vdXNlLlxuICAgICAgICAgICAgICAgICAgICAvLyBUb3VjaCBpZGVudGlmaWVycyBhcmUgMiBzbWFsbGVyIHRoYW4gdGhlaXIgcG9pbnRlcklkLCB3aGljaCBpcyB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gaW5kZXggaW4gcG9pbnRlcm1hcC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleSAhPT0gMSAmJiAhdGhpcy5maW5kVG91Y2godGwsIGtleSAtIDIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZC5wdXNoKHApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgZC5mb3JFYWNoKGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW5jZWwocCk7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50ZXJtYXAuZGVsZXRlKHAucG9pbnRlcklkKTtcbiAgICAgICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdG91Y2hzdGFydDogZnVuY3Rpb24oaW5FdmVudCkge1xuICAgICAgICAgICAgdGhpcy52YWN1dW1Ub3VjaGVzKGluRXZlbnQpO1xuICAgICAgICAgICAgdGhpcy5zZXRQcmltYXJ5VG91Y2goaW5FdmVudC5jaGFuZ2VkVG91Y2hlc1swXSk7XG4gICAgICAgICAgICB0aGlzLmRlZHVwU3ludGhNb3VzZShpbkV2ZW50KTtcbiAgICAgICAgICAgIGlmICghdGhpcy5zY3JvbGxpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsaWNrQ291bnQrKztcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NUb3VjaGVzKGluRXZlbnQsIHRoaXMuZG93bik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGRvd246IGZ1bmN0aW9uKGluUG9pbnRlcikge1xuICAgICAgICAgICAgZGlzcGF0Y2hlci5kb3duKGluUG9pbnRlcik7XG4gICAgICAgIH0sXG4gICAgICAgIHRvdWNobW92ZTogZnVuY3Rpb24oaW5FdmVudCkge1xuICAgICAgICAgICAgaWYgKEhBU19UT1VDSF9BQ1RJT04pIHtcbiAgICAgICAgICAgICAgICAvLyB0b3VjaGV2ZW50LmNhbmNlbGFibGUgPT0gZmFsc2UgaXMgc2VudCB3aGVuIHRoZSBwYWdlIGlzIHNjcm9sbGluZyB1bmRlciBuYXRpdmUgVG91Y2ggQWN0aW9uIGluIENocm9tZSAzNlxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZ3JvdXBzLmdvb2dsZS5jb20vYS9jaHJvbWl1bS5vcmcvZC9tc2cvaW5wdXQtZGV2L3dIbnl1a2NZQmNBL2I5a210d00xakpRSlxuICAgICAgICAgICAgICAgIGlmIChpbkV2ZW50LmNhbmNlbGFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzVG91Y2hlcyhpbkV2ZW50LCB0aGlzLm1vdmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnNjcm9sbGluZykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zY3JvbGxpbmcgPT09IG51bGwgJiYgdGhpcy5zaG91bGRTY3JvbGwoaW5FdmVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbkV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NUb3VjaGVzKGluRXZlbnQsIHRoaXMubW92ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZmlyc3RYWSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IGluRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF07XG4gICAgICAgICAgICAgICAgICAgIHZhciBkeCA9IHQuY2xpZW50WCAtIHRoaXMuZmlyc3RYWS5YO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZHkgPSB0LmNsaWVudFkgLSB0aGlzLmZpcnN0WFkuWTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRkID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRkID49IEhZU1RFUkVTSVMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudG91Y2hjYW5jZWwoaW5FdmVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZpcnN0WFkgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBtb3ZlOiBmdW5jdGlvbihpblBvaW50ZXIpIHtcbiAgICAgICAgICAgIGRpc3BhdGNoZXIubW92ZShpblBvaW50ZXIpO1xuICAgICAgICB9LFxuICAgICAgICB0b3VjaGVuZDogZnVuY3Rpb24oaW5FdmVudCkge1xuICAgICAgICAgICAgdGhpcy5kZWR1cFN5bnRoTW91c2UoaW5FdmVudCk7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NUb3VjaGVzKGluRXZlbnQsIHRoaXMudXApO1xuICAgICAgICB9LFxuICAgICAgICB1cDogZnVuY3Rpb24oaW5Qb2ludGVyKSB7XG4gICAgICAgICAgICBpblBvaW50ZXIucmVsYXRlZFRhcmdldCA9IHNjb3BlLmZpbmRUYXJnZXQoaW5Qb2ludGVyKTtcbiAgICAgICAgICAgIGRpc3BhdGNoZXIudXAoaW5Qb2ludGVyKTtcbiAgICAgICAgfSxcbiAgICAgICAgY2FuY2VsOiBmdW5jdGlvbihpblBvaW50ZXIpIHtcbiAgICAgICAgICAgIGRpc3BhdGNoZXIuY2FuY2VsKGluUG9pbnRlcik7XG4gICAgICAgIH0sXG4gICAgICAgIHRvdWNoY2FuY2VsOiBmdW5jdGlvbihpbkV2ZW50KSB7XG4gICAgICAgICAgICBpbkV2ZW50Ll9jYW5jZWwgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzVG91Y2hlcyhpbkV2ZW50LCB0aGlzLmNhbmNlbCk7XG4gICAgICAgIH0sXG4gICAgICAgIGNsZWFuVXBQb2ludGVyOiBmdW5jdGlvbihpblBvaW50ZXIpIHtcbiAgICAgICAgICAgIHBvaW50ZXJtYXBbJ2RlbGV0ZSddKGluUG9pbnRlci5wb2ludGVySWQpO1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVQcmltYXJ5UG9pbnRlcihpblBvaW50ZXIpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBwcmV2ZW50IHN5bnRoIG1vdXNlIGV2ZW50cyBmcm9tIGNyZWF0aW5nIHBvaW50ZXIgZXZlbnRzXG4gICAgICAgIGRlZHVwU3ludGhNb3VzZTogZnVuY3Rpb24oaW5FdmVudCkge1xuICAgICAgICAgICAgdmFyIGx0cyA9IHNjb3BlLm1vdXNlRXZlbnRzLmxhc3RUb3VjaGVzO1xuICAgICAgICAgICAgdmFyIHQgPSBpbkV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdO1xuICAgICAgICAgICAgLy8gb25seSB0aGUgcHJpbWFyeSBmaW5nZXIgd2lsbCBzeW50aCBtb3VzZSBldmVudHNcbiAgICAgICAgICAgIGlmICh0aGlzLmlzUHJpbWFyeVRvdWNoKHQpKSB7XG4gICAgICAgICAgICAgICAgLy8gcmVtZW1iZXIgeC95IG9mIGxhc3QgdG91Y2hcbiAgICAgICAgICAgICAgICB2YXIgbHQgPSB7XG4gICAgICAgICAgICAgICAgICAgIHg6IHQuY2xpZW50WCxcbiAgICAgICAgICAgICAgICAgICAgeTogdC5jbGllbnRZXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBsdHMucHVzaChsdCk7XG4gICAgICAgICAgICAgICAgdmFyIGZuID0gKGZ1bmN0aW9uKGx0cywgbHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSBsdHMuaW5kZXhPZihsdCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGx0cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KS5iaW5kKG51bGwsIGx0cywgbHQpO1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZm4sIERFRFVQX1RJTUVPVVQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIHByZXZlbnQgXCJnaG9zdCBjbGlja3NcIiB0aGF0IGNvbWUgZnJvbSBlbGVtZW50cyB0aGF0IHdlcmUgcmVtb3ZlZCBpbiBhIHRvdWNoIGhhbmRsZXJcbiAgICB2YXIgU1RPUF9QUk9QX0ZOID0gRXZlbnQucHJvdG90eXBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiB8fCBFdmVudC5wcm90b3R5cGUuc3RvcFByb3BhZ2F0aW9uO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgdmFyIHggPSBldi5jbGllbnRYLFxuICAgICAgICAgICAgeSA9IGV2LmNsaWVudFk7XG4gICAgICAgIC8vIGNoZWNrIGlmIGEgY2xpY2sgaXMgd2l0aGluIERFRFVQX0RJU1QgcHggcmFkaXVzIG9mIHRoZSB0b3VjaHN0YXJ0XG4gICAgICAgIHZhciBjbG9zZVRvID0gZnVuY3Rpb24odG91Y2gpIHtcbiAgICAgICAgICAgIHZhciBkeCA9IE1hdGguYWJzKHggLSB0b3VjaC54KSxcbiAgICAgICAgICAgICAgICBkeSA9IE1hdGguYWJzKHkgLSB0b3VjaC55KTtcbiAgICAgICAgICAgIHJldHVybiAoZHggPD0gREVEVVBfRElTVCAmJiBkeSA8PSBERURVUF9ESVNUKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gaWYgY2xpY2sgY29vcmRpbmF0ZXMgYXJlIGNsb3NlIHRvIHRvdWNoIGNvb3JkaW5hdGVzLCBhc3N1bWUgdGhlIGNsaWNrIGNhbWUgZnJvbSBhIHRvdWNoXG4gICAgICAgIHZhciB3YXNUb3VjaGVkID0gc2NvcGUubW91c2VFdmVudHMubGFzdFRvdWNoZXMuc29tZShjbG9zZVRvKTtcbiAgICAgICAgLy8gaWYgdGhlIGNsaWNrIGNhbWUgZnJvbSB0b3VjaCwgYW5kIHRoZSB0b3VjaHN0YXJ0IHRhcmdldCBpcyBub3QgaW4gdGhlIHBhdGggb2YgdGhlIGNsaWNrIGV2ZW50LFxuICAgICAgICAvLyB0aGVuIHRoZSB0b3VjaHN0YXJ0IHRhcmdldCB3YXMgcHJvYmFibHkgcmVtb3ZlZCwgYW5kIHRoZSBjbGljayBzaG91bGQgYmUgXCJidXN0ZWRcIlxuICAgICAgICB2YXIgcGF0aCA9IHNjb3BlLnRhcmdldEZpbmRpbmcucGF0aChldik7XG4gICAgICAgIGlmICh3YXNUb3VjaGVkKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAocGF0aFtpXSA9PT0gdG91Y2hFdmVudHMuZmlyc3RUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBTVE9QX1BST1BfRk4uY2FsbChldik7XG4gICAgICAgIH1cbiAgICB9LCB0cnVlKTtcblxuICAgIHNjb3BlLnRvdWNoRXZlbnRzID0gdG91Y2hFdmVudHM7XG59KShleHBvcnRzKTtcblxuKGZ1bmN0aW9uKHNjb3BlKSB7XG4gICAgdmFyIGRpc3BhdGNoZXIgPSBzY29wZS5kaXNwYXRjaGVyO1xuICAgIHZhciBwb2ludGVybWFwID0gZGlzcGF0Y2hlci5wb2ludGVybWFwO1xuICAgIHZhciBIQVNfQklUTUFQX1RZUEUgPSB3aW5kb3cuTVNQb2ludGVyRXZlbnQgJiYgdHlwZW9mIHdpbmRvdy5NU1BvaW50ZXJFdmVudC5NU1BPSU5URVJfVFlQRV9NT1VTRSA9PT0gJ251bWJlcic7XG4gICAgdmFyIG1zRXZlbnRzID0ge1xuICAgICAgICBldmVudHM6IFtcbiAgICAgICAgICAgICdNU1BvaW50ZXJEb3duJyxcbiAgICAgICAgICAgICdNU1BvaW50ZXJNb3ZlJyxcbiAgICAgICAgICAgICdNU1BvaW50ZXJVcCcsXG4gICAgICAgICAgICAnTVNQb2ludGVyQ2FuY2VsJyxcbiAgICAgICAgXSxcbiAgICAgICAgcmVnaXN0ZXI6IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgICAgICAgZGlzcGF0Y2hlci5saXN0ZW4odGFyZ2V0LCB0aGlzLmV2ZW50cyk7XG4gICAgICAgIH0sXG4gICAgICAgIHVucmVnaXN0ZXI6IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgICAgICAgaWYgKHRhcmdldC5ub2RlVHlwZSA9PT0gTm9kZS5ET0NVTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGlzcGF0Y2hlci51bmxpc3Rlbih0YXJnZXQsIHRoaXMuZXZlbnRzKTtcbiAgICAgICAgfSxcbiAgICAgICAgUE9JTlRFUl9UWVBFUzogW1xuICAgICAgICAgICAgJycsXG4gICAgICAgICAgICAndW5hdmFpbGFibGUnLFxuICAgICAgICAgICAgJ3RvdWNoJyxcbiAgICAgICAgICAgICdwZW4nLFxuICAgICAgICAgICAgJ21vdXNlJ1xuICAgICAgICBdLFxuICAgICAgICBwcmVwYXJlRXZlbnQ6IGZ1bmN0aW9uKGluRXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBlID0gaW5FdmVudDtcbiAgICAgICAgICAgIGUgPSBkaXNwYXRjaGVyLmNsb25lRXZlbnQoaW5FdmVudCk7XG4gICAgICAgICAgICBpZiAoSEFTX0JJVE1BUF9UWVBFKSB7XG4gICAgICAgICAgICAgICAgZS5wb2ludGVyVHlwZSA9IHRoaXMuUE9JTlRFUl9UWVBFU1tpbkV2ZW50LnBvaW50ZXJUeXBlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGUuX3NvdXJjZSA9ICdtcyc7XG4gICAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgfSxcbiAgICAgICAgY2xlYW51cDogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgIHBvaW50ZXJtYXBbJ2RlbGV0ZSddKGlkKTtcbiAgICAgICAgfSxcbiAgICAgICAgTVNQb2ludGVyRG93bjogZnVuY3Rpb24oaW5FdmVudCkge1xuICAgICAgICAgICAgdmFyIGUgPSB0aGlzLnByZXBhcmVFdmVudChpbkV2ZW50KTtcbiAgICAgICAgICAgIGUudGFyZ2V0ID0gc2NvcGUuZmluZFRhcmdldChpbkV2ZW50KTtcbiAgICAgICAgICAgIHBvaW50ZXJtYXAuc2V0KGluRXZlbnQucG9pbnRlcklkLCBlLnRhcmdldCk7XG4gICAgICAgICAgICBkaXNwYXRjaGVyLmRvd24oZSk7XG4gICAgICAgIH0sXG4gICAgICAgIE1TUG9pbnRlck1vdmU6IGZ1bmN0aW9uKGluRXZlbnQpIHtcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSBwb2ludGVybWFwLmdldChpbkV2ZW50LnBvaW50ZXJJZCk7XG4gICAgICAgICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGUgPSB0aGlzLnByZXBhcmVFdmVudChpbkV2ZW50KTtcbiAgICAgICAgICAgICAgICBlLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaGVyLm1vdmUoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIE1TUG9pbnRlclVwOiBmdW5jdGlvbihpbkV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgZSA9IHRoaXMucHJlcGFyZUV2ZW50KGluRXZlbnQpO1xuICAgICAgICAgICAgZS5yZWxhdGVkVGFyZ2V0ID0gc2NvcGUuZmluZFRhcmdldChpbkV2ZW50KTtcbiAgICAgICAgICAgIGUudGFyZ2V0ID0gcG9pbnRlcm1hcC5nZXQoZS5wb2ludGVySWQpO1xuICAgICAgICAgICAgZGlzcGF0Y2hlci51cChlKTtcbiAgICAgICAgICAgIHRoaXMuY2xlYW51cChpbkV2ZW50LnBvaW50ZXJJZCk7XG4gICAgICAgIH0sXG4gICAgICAgIE1TUG9pbnRlckNhbmNlbDogZnVuY3Rpb24oaW5FdmVudCkge1xuICAgICAgICAgICAgdmFyIGUgPSB0aGlzLnByZXBhcmVFdmVudChpbkV2ZW50KTtcbiAgICAgICAgICAgIGUucmVsYXRlZFRhcmdldCA9IHNjb3BlLmZpbmRUYXJnZXQoaW5FdmVudCk7XG4gICAgICAgICAgICBlLnRhcmdldCA9IHBvaW50ZXJtYXAuZ2V0KGUucG9pbnRlcklkKTtcbiAgICAgICAgICAgIGRpc3BhdGNoZXIuY2FuY2VsKGUpO1xuICAgICAgICAgICAgdGhpcy5jbGVhbnVwKGluRXZlbnQucG9pbnRlcklkKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBzY29wZS5tc0V2ZW50cyA9IG1zRXZlbnRzO1xufSkoZXhwb3J0cyk7XG5cbihmdW5jdGlvbihzY29wZSkge1xuICAgIHZhciBkaXNwYXRjaGVyID0gc2NvcGUuZGlzcGF0Y2hlcjtcbiAgICB2YXIgcG9pbnRlcm1hcCA9IGRpc3BhdGNoZXIucG9pbnRlcm1hcDtcbiAgICB2YXIgcG9pbnRlckV2ZW50cyA9IHtcbiAgICAgICAgZXZlbnRzOiBbXG4gICAgICAgICAgICAncG9pbnRlcmRvd24nLFxuICAgICAgICAgICAgJ3BvaW50ZXJtb3ZlJyxcbiAgICAgICAgICAgICdwb2ludGVydXAnLFxuICAgICAgICAgICAgJ3BvaW50ZXJjYW5jZWwnXG4gICAgICAgIF0sXG4gICAgICAgIHByZXBhcmVFdmVudDogZnVuY3Rpb24oaW5FdmVudCkge1xuICAgICAgICAgICAgdmFyIGUgPSBkaXNwYXRjaGVyLmNsb25lRXZlbnQoaW5FdmVudCk7XG4gICAgICAgICAgICBlLl9zb3VyY2UgPSAncG9pbnRlcic7XG4gICAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVnaXN0ZXI6IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgICAgICAgZGlzcGF0Y2hlci5saXN0ZW4odGFyZ2V0LCB0aGlzLmV2ZW50cyk7XG4gICAgICAgIH0sXG4gICAgICAgIHVucmVnaXN0ZXI6IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgICAgICAgaWYgKHRhcmdldC5ub2RlVHlwZSA9PT0gTm9kZS5ET0NVTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGlzcGF0Y2hlci51bmxpc3Rlbih0YXJnZXQsIHRoaXMuZXZlbnRzKTtcbiAgICAgICAgfSxcbiAgICAgICAgY2xlYW51cDogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgIHBvaW50ZXJtYXBbJ2RlbGV0ZSddKGlkKTtcbiAgICAgICAgfSxcbiAgICAgICAgcG9pbnRlcmRvd246IGZ1bmN0aW9uKGluRXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBlID0gdGhpcy5wcmVwYXJlRXZlbnQoaW5FdmVudCk7XG4gICAgICAgICAgICBlLnRhcmdldCA9IHNjb3BlLmZpbmRUYXJnZXQoaW5FdmVudCk7XG4gICAgICAgICAgICBwb2ludGVybWFwLnNldChlLnBvaW50ZXJJZCwgZS50YXJnZXQpO1xuICAgICAgICAgICAgZGlzcGF0Y2hlci5kb3duKGUpO1xuICAgICAgICB9LFxuICAgICAgICBwb2ludGVybW92ZTogZnVuY3Rpb24oaW5FdmVudCkge1xuICAgICAgICAgICAgdmFyIHRhcmdldCA9IHBvaW50ZXJtYXAuZ2V0KGluRXZlbnQucG9pbnRlcklkKTtcbiAgICAgICAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZSA9IHRoaXMucHJlcGFyZUV2ZW50KGluRXZlbnQpO1xuICAgICAgICAgICAgICAgIGUudGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoZXIubW92ZShlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcG9pbnRlcnVwOiBmdW5jdGlvbihpbkV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgZSA9IHRoaXMucHJlcGFyZUV2ZW50KGluRXZlbnQpO1xuICAgICAgICAgICAgZS5yZWxhdGVkVGFyZ2V0ID0gc2NvcGUuZmluZFRhcmdldChpbkV2ZW50KTtcbiAgICAgICAgICAgIGUudGFyZ2V0ID0gcG9pbnRlcm1hcC5nZXQoZS5wb2ludGVySWQpO1xuICAgICAgICAgICAgZGlzcGF0Y2hlci51cChlKTtcbiAgICAgICAgICAgIHRoaXMuY2xlYW51cChpbkV2ZW50LnBvaW50ZXJJZCk7XG4gICAgICAgIH0sXG4gICAgICAgIHBvaW50ZXJjYW5jZWw6IGZ1bmN0aW9uKGluRXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBlID0gdGhpcy5wcmVwYXJlRXZlbnQoaW5FdmVudCk7XG4gICAgICAgICAgICBlLnJlbGF0ZWRUYXJnZXQgPSBzY29wZS5maW5kVGFyZ2V0KGluRXZlbnQpO1xuICAgICAgICAgICAgZS50YXJnZXQgPSBwb2ludGVybWFwLmdldChlLnBvaW50ZXJJZCk7XG4gICAgICAgICAgICBkaXNwYXRjaGVyLmNhbmNlbChlKTtcbiAgICAgICAgICAgIHRoaXMuY2xlYW51cChpbkV2ZW50LnBvaW50ZXJJZCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgc2NvcGUucG9pbnRlckV2ZW50cyA9IHBvaW50ZXJFdmVudHM7XG59KShleHBvcnRzKTtcblxuLyoqXG4gKiBUaGlzIG1vZHVsZSBjb250YWlucyB0aGUgaGFuZGxlcnMgZm9yIG5hdGl2ZSBwbGF0Zm9ybSBldmVudHMuXG4gKiBGcm9tIGhlcmUsIHRoZSBkaXNwYXRjaGVyIGlzIGNhbGxlZCB0byBjcmVhdGUgdW5pZmllZCBwb2ludGVyIGV2ZW50cy5cbiAqIEluY2x1ZGVkIGFyZSB0b3VjaCBldmVudHMgKHYxKSwgbW91c2UgZXZlbnRzLCBhbmQgTVNQb2ludGVyRXZlbnRzLlxuICovXG4oZnVuY3Rpb24oc2NvcGUpIHtcblxuICAgIHZhciBkaXNwYXRjaGVyID0gc2NvcGUuZGlzcGF0Y2hlcjtcbiAgICB2YXIgbmF2ID0gd2luZG93Lm5hdmlnYXRvcjtcblxuICAgIGlmICh3aW5kb3cuUG9pbnRlckV2ZW50KSB7XG4gICAgICAgIGRpc3BhdGNoZXIucmVnaXN0ZXJTb3VyY2UoJ3BvaW50ZXInLCBzY29wZS5wb2ludGVyRXZlbnRzKTtcbiAgICB9IGVsc2UgaWYgKG5hdi5tc1BvaW50ZXJFbmFibGVkKSB7XG4gICAgICAgIGRpc3BhdGNoZXIucmVnaXN0ZXJTb3VyY2UoJ21zJywgc2NvcGUubXNFdmVudHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGRpc3BhdGNoZXIucmVnaXN0ZXJTb3VyY2UoJ21vdXNlJywgc2NvcGUubW91c2VFdmVudHMpO1xuICAgICAgICBpZiAod2luZG93Lm9udG91Y2hzdGFydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBkaXNwYXRjaGVyLnJlZ2lzdGVyU291cmNlKCd0b3VjaCcsIHNjb3BlLnRvdWNoRXZlbnRzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFdvcmsgYXJvdW5kIGlPUyBidWdzIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzU2MjggYW5kIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzY1MDZcbiAgICB2YXIgdWEgPSBuYXZpZ2F0b3IudXNlckFnZW50O1xuICAgIHZhciBJU19JT1MgPSB1YS5tYXRjaCgvaVBhZHxpUGhvbmV8aVBvZC8pICYmICdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdztcblxuICAgIGRpc3BhdGNoZXIuSVNfSU9TID0gSVNfSU9TO1xuICAgIHNjb3BlLnRvdWNoRXZlbnRzLklTX0lPUyA9IElTX0lPUztcblxuICAgIGRpc3BhdGNoZXIucmVnaXN0ZXIoZG9jdW1lbnQsIHRydWUpO1xufSkoZXhwb3J0cyk7XG5cbi8qKlxuICogVGhpcyBldmVudCBkZW5vdGVzIHRoZSBiZWdpbm5pbmcgb2YgYSBzZXJpZXMgb2YgdHJhY2tpbmcgZXZlbnRzLlxuICpcbiAqIEBtb2R1bGUgUG9pbnRlckdlc3R1cmVzXG4gKiBAc3VibW9kdWxlIEV2ZW50c1xuICogQGNsYXNzIHRyYWNrc3RhcnRcbiAqL1xuLyoqXG4gKiBQaXhlbHMgbW92ZWQgaW4gdGhlIHggZGlyZWN0aW9uIHNpbmNlIHRyYWNrc3RhcnQuXG4gKiBAdHlwZSBOdW1iZXJcbiAqIEBwcm9wZXJ0eSBkeFxuICovXG4vKipcbiAqIFBpeGVzIG1vdmVkIGluIHRoZSB5IGRpcmVjdGlvbiBzaW5jZSB0cmFja3N0YXJ0LlxuICogQHR5cGUgTnVtYmVyXG4gKiBAcHJvcGVydHkgZHlcbiAqL1xuLyoqXG4gKiBQaXhlbHMgbW92ZWQgaW4gdGhlIHggZGlyZWN0aW9uIHNpbmNlIHRoZSBsYXN0IHRyYWNrLlxuICogQHR5cGUgTnVtYmVyXG4gKiBAcHJvcGVydHkgZGR4XG4gKi9cbi8qKlxuICogUGl4bGVzIG1vdmVkIGluIHRoZSB5IGRpcmVjdGlvbiBzaW5jZSB0aGUgbGFzdCB0cmFjay5cbiAqIEB0eXBlIE51bWJlclxuICogQHByb3BlcnR5IGRkeVxuICovXG4vKipcbiAqIFRoZSBjbGllbnRYIHBvc2l0aW9uIG9mIHRoZSB0cmFjayBnZXN0dXJlLlxuICogQHR5cGUgTnVtYmVyXG4gKiBAcHJvcGVydHkgY2xpZW50WFxuICovXG4vKipcbiAqIFRoZSBjbGllbnRZIHBvc2l0aW9uIG9mIHRoZSB0cmFjayBnZXN0dXJlLlxuICogQHR5cGUgTnVtYmVyXG4gKiBAcHJvcGVydHkgY2xpZW50WVxuICovXG4vKipcbiAqIFRoZSBwYWdlWCBwb3NpdGlvbiBvZiB0aGUgdHJhY2sgZ2VzdHVyZS5cbiAqIEB0eXBlIE51bWJlclxuICogQHByb3BlcnR5IHBhZ2VYXG4gKi9cbi8qKlxuICogVGhlIHBhZ2VZIHBvc2l0aW9uIG9mIHRoZSB0cmFjayBnZXN0dXJlLlxuICogQHR5cGUgTnVtYmVyXG4gKiBAcHJvcGVydHkgcGFnZVlcbiAqL1xuLyoqXG4gKiBUaGUgc2NyZWVuWCBwb3NpdGlvbiBvZiB0aGUgdHJhY2sgZ2VzdHVyZS5cbiAqIEB0eXBlIE51bWJlclxuICogQHByb3BlcnR5IHNjcmVlblhcbiAqL1xuLyoqXG4gKiBUaGUgc2NyZWVuWSBwb3NpdGlvbiBvZiB0aGUgdHJhY2sgZ2VzdHVyZS5cbiAqIEB0eXBlIE51bWJlclxuICogQHByb3BlcnR5IHNjcmVlbllcbiAqL1xuLyoqXG4gKiBUaGUgbGFzdCB4IGF4aXMgZGlyZWN0aW9uIG9mIHRoZSBwb2ludGVyLlxuICogQHR5cGUgTnVtYmVyXG4gKiBAcHJvcGVydHkgeERpcmVjdGlvblxuICovXG4vKipcbiAqIFRoZSBsYXN0IHkgYXhpcyBkaXJlY3Rpb24gb2YgdGhlIHBvaW50ZXIuXG4gKiBAdHlwZSBOdW1iZXJcbiAqIEBwcm9wZXJ0eSB5RGlyZWN0aW9uXG4gKi9cbi8qKlxuICogQSBzaGFyZWQgb2JqZWN0IGJldHdlZW4gYWxsIHRyYWNraW5nIGV2ZW50cy5cbiAqIEB0eXBlIE9iamVjdFxuICogQHByb3BlcnR5IHRyYWNrSW5mb1xuICovXG4vKipcbiAqIFRoZSBlbGVtZW50IGN1cnJlbnRseSB1bmRlciB0aGUgcG9pbnRlci5cbiAqIEB0eXBlIEVsZW1lbnRcbiAqIEBwcm9wZXJ0eSByZWxhdGVkVGFyZ2V0XG4gKi9cbi8qKlxuICogVGhlIHR5cGUgb2YgcG9pbnRlciB0aGF0IG1ha2UgdGhlIHRyYWNrIGdlc3R1cmUuXG4gKiBAdHlwZSBTdHJpbmdcbiAqIEBwcm9wZXJ0eSBwb2ludGVyVHlwZVxuICovXG4vKipcbiAqXG4gKiBUaGlzIGV2ZW50IGZpcmVzIGZvciBhbGwgcG9pbnRlciBtb3ZlbWVudCBiZWluZyB0cmFja2VkLlxuICpcbiAqIEBjbGFzcyB0cmFja1xuICogQGV4dGVuZHMgdHJhY2tzdGFydFxuICovXG4vKipcbiAqIFRoaXMgZXZlbnQgZmlyZXMgd2hlbiB0aGUgcG9pbnRlciBpcyBubyBsb25nZXIgYmVpbmcgdHJhY2tlZC5cbiAqXG4gKiBAY2xhc3MgdHJhY2tlbmRcbiAqIEBleHRlbmRzIHRyYWNrc3RhcnRcbiAqL1xuXG4oZnVuY3Rpb24oc2NvcGUpIHtcbiAgICB2YXIgZGlzcGF0Y2hlciA9IHNjb3BlLmRpc3BhdGNoZXI7XG4gICAgdmFyIGV2ZW50RmFjdG9yeSA9IHNjb3BlLmV2ZW50RmFjdG9yeTtcbiAgICB2YXIgcG9pbnRlcm1hcCA9IG5ldyBzY29wZS5Qb2ludGVyTWFwKCk7XG4gICAgdmFyIHRyYWNrID0ge1xuICAgICAgICBldmVudHM6IFtcbiAgICAgICAgICAgICdkb3duJyxcbiAgICAgICAgICAgICdtb3ZlJyxcbiAgICAgICAgICAgICd1cCcsXG4gICAgICAgIF0sXG4gICAgICAgIGV4cG9zZXM6IFtcbiAgICAgICAgICAgICd0cmFja3N0YXJ0JyxcbiAgICAgICAgICAgICd0cmFjaycsXG4gICAgICAgICAgICAndHJhY2t4JyxcbiAgICAgICAgICAgICd0cmFja3knLFxuICAgICAgICAgICAgJ3RyYWNrZW5kJ1xuICAgICAgICBdLFxuICAgICAgICBkZWZhdWx0QWN0aW9uczoge1xuICAgICAgICAgICAgJ3RyYWNrJzogJ25vbmUnLFxuICAgICAgICAgICAgJ3RyYWNreCc6ICdwYW4teScsXG4gICAgICAgICAgICAndHJhY2t5JzogJ3Bhbi14J1xuICAgICAgICB9LFxuICAgICAgICBXSUdHTEVfVEhSRVNIT0xEOiA0LFxuICAgICAgICBjbGFtcERpcjogZnVuY3Rpb24oaW5EZWx0YSkge1xuICAgICAgICAgICAgcmV0dXJuIGluRGVsdGEgPiAwID8gMSA6IC0xO1xuICAgICAgICB9LFxuICAgICAgICBjYWxjUG9zaXRpb25EZWx0YTogZnVuY3Rpb24oaW5BLCBpbkIpIHtcbiAgICAgICAgICAgIHZhciB4ID0gMCxcbiAgICAgICAgICAgICAgICB5ID0gMDtcbiAgICAgICAgICAgIGlmIChpbkEgJiYgaW5CKSB7XG4gICAgICAgICAgICAgICAgeCA9IGluQi5wYWdlWCAtIGluQS5wYWdlWDtcbiAgICAgICAgICAgICAgICB5ID0gaW5CLnBhZ2VZIC0gaW5BLnBhZ2VZO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgICAgIHk6IHlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGZpcmVUcmFjazogZnVuY3Rpb24oaW5UeXBlLCBpbkV2ZW50LCBpblRyYWNraW5nRGF0YSkge1xuICAgICAgICAgICAgdmFyIHQgPSBpblRyYWNraW5nRGF0YTtcbiAgICAgICAgICAgIHZhciBkID0gdGhpcy5jYWxjUG9zaXRpb25EZWx0YSh0LmRvd25FdmVudCwgaW5FdmVudCk7XG4gICAgICAgICAgICB2YXIgZGQgPSB0aGlzLmNhbGNQb3NpdGlvbkRlbHRhKHQubGFzdE1vdmVFdmVudCwgaW5FdmVudCk7XG4gICAgICAgICAgICBpZiAoZGQueCkge1xuICAgICAgICAgICAgICAgIHQueERpcmVjdGlvbiA9IHRoaXMuY2xhbXBEaXIoZGQueCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGluVHlwZSA9PT0gJ3RyYWNreCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGQueSkge1xuICAgICAgICAgICAgICAgIHQueURpcmVjdGlvbiA9IHRoaXMuY2xhbXBEaXIoZGQueSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGluVHlwZSA9PT0gJ3RyYWNreScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZ2VzdHVyZVByb3RvID0ge1xuICAgICAgICAgICAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICAgICAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB0cmFja0luZm86IHQudHJhY2tJbmZvLFxuICAgICAgICAgICAgICAgIHJlbGF0ZWRUYXJnZXQ6IGluRXZlbnQucmVsYXRlZFRhcmdldCxcbiAgICAgICAgICAgICAgICBwb2ludGVyVHlwZTogaW5FdmVudC5wb2ludGVyVHlwZSxcbiAgICAgICAgICAgICAgICBwb2ludGVySWQ6IGluRXZlbnQucG9pbnRlcklkLFxuICAgICAgICAgICAgICAgIF9zb3VyY2U6ICd0cmFjaydcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoaW5UeXBlICE9PSAndHJhY2t5Jykge1xuICAgICAgICAgICAgICAgIGdlc3R1cmVQcm90by54ID0gaW5FdmVudC54O1xuICAgICAgICAgICAgICAgIGdlc3R1cmVQcm90by5keCA9IGQueDtcbiAgICAgICAgICAgICAgICBnZXN0dXJlUHJvdG8uZGR4ID0gZGQueDtcbiAgICAgICAgICAgICAgICBnZXN0dXJlUHJvdG8uY2xpZW50WCA9IGluRXZlbnQuY2xpZW50WDtcbiAgICAgICAgICAgICAgICBnZXN0dXJlUHJvdG8ucGFnZVggPSBpbkV2ZW50LnBhZ2VYO1xuICAgICAgICAgICAgICAgIGdlc3R1cmVQcm90by5zY3JlZW5YID0gaW5FdmVudC5zY3JlZW5YO1xuICAgICAgICAgICAgICAgIGdlc3R1cmVQcm90by54RGlyZWN0aW9uID0gdC54RGlyZWN0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGluVHlwZSAhPT0gJ3RyYWNreCcpIHtcbiAgICAgICAgICAgICAgICBnZXN0dXJlUHJvdG8uZHkgPSBkLnk7XG4gICAgICAgICAgICAgICAgZ2VzdHVyZVByb3RvLmRkeSA9IGRkLnk7XG4gICAgICAgICAgICAgICAgZ2VzdHVyZVByb3RvLnkgPSBpbkV2ZW50Lnk7XG4gICAgICAgICAgICAgICAgZ2VzdHVyZVByb3RvLmNsaWVudFkgPSBpbkV2ZW50LmNsaWVudFk7XG4gICAgICAgICAgICAgICAgZ2VzdHVyZVByb3RvLnBhZ2VZID0gaW5FdmVudC5wYWdlWTtcbiAgICAgICAgICAgICAgICBnZXN0dXJlUHJvdG8uc2NyZWVuWSA9IGluRXZlbnQuc2NyZWVuWTtcbiAgICAgICAgICAgICAgICBnZXN0dXJlUHJvdG8ueURpcmVjdGlvbiA9IHQueURpcmVjdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBlID0gZXZlbnRGYWN0b3J5Lm1ha2VHZXN0dXJlRXZlbnQoaW5UeXBlLCBnZXN0dXJlUHJvdG8pO1xuICAgICAgICAgICAgdC5kb3duVGFyZ2V0LmRpc3BhdGNoRXZlbnQoZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGRvd246IGZ1bmN0aW9uKGluRXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChpbkV2ZW50LmlzUHJpbWFyeSAmJiAoaW5FdmVudC5wb2ludGVyVHlwZSA9PT0gJ21vdXNlJyA/IGluRXZlbnQuYnV0dG9ucyA9PT0gMSA6IHRydWUpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHAgPSB7XG4gICAgICAgICAgICAgICAgICAgIGRvd25FdmVudDogaW5FdmVudCxcbiAgICAgICAgICAgICAgICAgICAgZG93blRhcmdldDogaW5FdmVudC50YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgIHRyYWNrSW5mbzoge30sXG4gICAgICAgICAgICAgICAgICAgIGxhc3RNb3ZlRXZlbnQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHhEaXJlY3Rpb246IDAsXG4gICAgICAgICAgICAgICAgICAgIHlEaXJlY3Rpb246IDAsXG4gICAgICAgICAgICAgICAgICAgIHRyYWNraW5nOiBmYWxzZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcG9pbnRlcm1hcC5zZXQoaW5FdmVudC5wb2ludGVySWQsIHApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBtb3ZlOiBmdW5jdGlvbihpbkV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgcCA9IHBvaW50ZXJtYXAuZ2V0KGluRXZlbnQucG9pbnRlcklkKTtcbiAgICAgICAgICAgIGlmIChwKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFwLnRyYWNraW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkID0gdGhpcy5jYWxjUG9zaXRpb25EZWx0YShwLmRvd25FdmVudCwgaW5FdmVudCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtb3ZlID0gZC54ICogZC54ICsgZC55ICogZC55O1xuICAgICAgICAgICAgICAgICAgICAvLyBzdGFydCB0cmFja2luZyBvbmx5IGlmIGZpbmdlciBtb3ZlcyBtb3JlIHRoYW4gV0lHR0xFX1RIUkVTSE9MRFxuICAgICAgICAgICAgICAgICAgICBpZiAobW92ZSA+IHRoaXMuV0lHR0xFX1RIUkVTSE9MRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcC50cmFja2luZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBwLmxhc3RNb3ZlRXZlbnQgPSBwLmRvd25FdmVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmlyZVRyYWNrKCd0cmFja3N0YXJ0JywgaW5FdmVudCwgcCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHAudHJhY2tpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maXJlVHJhY2soJ3RyYWNrJywgaW5FdmVudCwgcCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlyZVRyYWNrKCd0cmFja3gnLCBpbkV2ZW50LCBwKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maXJlVHJhY2soJ3RyYWNreScsIGluRXZlbnQsIHApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwLmxhc3RNb3ZlRXZlbnQgPSBpbkV2ZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB1cDogZnVuY3Rpb24oaW5FdmVudCkge1xuICAgICAgICAgICAgdmFyIHAgPSBwb2ludGVybWFwLmdldChpbkV2ZW50LnBvaW50ZXJJZCk7XG4gICAgICAgICAgICBpZiAocCkge1xuICAgICAgICAgICAgICAgIGlmIChwLnRyYWNraW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlyZVRyYWNrKCd0cmFja2VuZCcsIGluRXZlbnQsIHApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwb2ludGVybWFwLmRlbGV0ZShpbkV2ZW50LnBvaW50ZXJJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGRpc3BhdGNoZXIucmVnaXN0ZXJHZXN0dXJlKCd0cmFjaycsIHRyYWNrKTtcbn0pKGV4cG9ydHMpO1xuXG4vKipcbiAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiBhIHBvaW50ZXIgaXMgaGVsZCBkb3duIGZvciAyMDBtcy5cbiAqXG4gKiBAbW9kdWxlIFBvaW50ZXJHZXN0dXJlc1xuICogQHN1Ym1vZHVsZSBFdmVudHNcbiAqIEBjbGFzcyBob2xkXG4gKi9cbi8qKlxuICogVHlwZSBvZiBwb2ludGVyIHRoYXQgbWFkZSB0aGUgaG9sZGluZyBldmVudC5cbiAqIEB0eXBlIFN0cmluZ1xuICogQHByb3BlcnR5IHBvaW50ZXJUeXBlXG4gKi9cbi8qKlxuICogU2NyZWVuIFggYXhpcyBwb3NpdGlvbiBvZiB0aGUgaGVsZCBwb2ludGVyXG4gKiBAdHlwZSBOdW1iZXJcbiAqIEBwcm9wZXJ0eSBjbGllbnRYXG4gKi9cbi8qKlxuICogU2NyZWVuIFkgYXhpcyBwb3NpdGlvbiBvZiB0aGUgaGVsZCBwb2ludGVyXG4gKiBAdHlwZSBOdW1iZXJcbiAqIEBwcm9wZXJ0eSBjbGllbnRZXG4gKi9cbi8qKlxuICogVHlwZSBvZiBwb2ludGVyIHRoYXQgbWFkZSB0aGUgaG9sZGluZyBldmVudC5cbiAqIEB0eXBlIFN0cmluZ1xuICogQHByb3BlcnR5IHBvaW50ZXJUeXBlXG4gKi9cbi8qKlxuICogVGhpcyBldmVudCBpcyBmaXJlZCBldmVyeSAyMDBtcyB3aGlsZSBhIHBvaW50ZXIgaXMgaGVsZCBkb3duLlxuICpcbiAqIEBjbGFzcyBob2xkcHVsc2VcbiAqIEBleHRlbmRzIGhvbGRcbiAqL1xuLyoqXG4gKiBNaWxsaXNlY29uZHMgcG9pbnRlciBoYXMgYmVlbiBoZWxkIGRvd24uXG4gKiBAdHlwZSBOdW1iZXJcbiAqIEBwcm9wZXJ0eSBob2xkVGltZVxuICovXG4vKipcbiAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiBhIGhlbGQgcG9pbnRlciBpcyByZWxlYXNlZCBvciBtb3ZlZC5cbiAqXG4gKiBAY2xhc3MgcmVsZWFzZVxuICovXG5cbihmdW5jdGlvbihzY29wZSkge1xuICAgIHZhciBkaXNwYXRjaGVyID0gc2NvcGUuZGlzcGF0Y2hlcjtcbiAgICB2YXIgZXZlbnRGYWN0b3J5ID0gc2NvcGUuZXZlbnRGYWN0b3J5O1xuICAgIHZhciBob2xkID0ge1xuICAgICAgICAvLyB3YWl0IGF0IGxlYXN0IEhPTERfREVMQVkgbXMgYmV0d2VlbiBob2xkIGFuZCBwdWxzZSBldmVudHNcbiAgICAgICAgSE9MRF9ERUxBWTogMjAwLFxuICAgICAgICAvLyBwb2ludGVyIGNhbiBtb3ZlIFdJR0dMRV9USFJFU0hPTEQgcGl4ZWxzIGJlZm9yZSBub3QgY291bnRpbmcgYXMgYSBob2xkXG4gICAgICAgIFdJR0dMRV9USFJFU0hPTEQ6IDE2LFxuICAgICAgICBldmVudHM6IFtcbiAgICAgICAgICAgICdkb3duJyxcbiAgICAgICAgICAgICdtb3ZlJyxcbiAgICAgICAgICAgICd1cCcsXG4gICAgICAgIF0sXG4gICAgICAgIGV4cG9zZXM6IFtcbiAgICAgICAgICAgICdob2xkJyxcbiAgICAgICAgICAgICdob2xkcHVsc2UnLFxuICAgICAgICAgICAgJ3JlbGVhc2UnXG4gICAgICAgIF0sXG4gICAgICAgIGhlbGRQb2ludGVyOiBudWxsLFxuICAgICAgICBob2xkSm9iOiBudWxsLFxuICAgICAgICBwdWxzZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaG9sZCA9IERhdGUubm93KCkgLSB0aGlzLmhlbGRQb2ludGVyLnRpbWVTdGFtcDtcbiAgICAgICAgICAgIHZhciB0eXBlID0gdGhpcy5oZWxkID8gJ2hvbGRwdWxzZScgOiAnaG9sZCc7XG4gICAgICAgICAgICB0aGlzLmZpcmVIb2xkKHR5cGUsIGhvbGQpO1xuICAgICAgICAgICAgdGhpcy5oZWxkID0gdHJ1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgY2FuY2VsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5ob2xkSm9iKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmhlbGQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpcmVIb2xkKCdyZWxlYXNlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmhlbGQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuaGVsZFBvaW50ZXIgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy50YXJnZXQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5ob2xkSm9iID0gbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgZG93bjogZnVuY3Rpb24oaW5FdmVudCkge1xuICAgICAgICAgICAgaWYgKGluRXZlbnQuaXNQcmltYXJ5ICYmICF0aGlzLmhlbGRQb2ludGVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oZWxkUG9pbnRlciA9IGluRXZlbnQ7XG4gICAgICAgICAgICAgICAgdGhpcy50YXJnZXQgPSBpbkV2ZW50LnRhcmdldDtcbiAgICAgICAgICAgICAgICB0aGlzLmhvbGRKb2IgPSBzZXRJbnRlcnZhbCh0aGlzLnB1bHNlLmJpbmQodGhpcyksIHRoaXMuSE9MRF9ERUxBWSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHVwOiBmdW5jdGlvbihpbkV2ZW50KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5oZWxkUG9pbnRlciAmJiB0aGlzLmhlbGRQb2ludGVyLnBvaW50ZXJJZCA9PT0gaW5FdmVudC5wb2ludGVySWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbmNlbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBtb3ZlOiBmdW5jdGlvbihpbkV2ZW50KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5oZWxkUG9pbnRlciAmJiB0aGlzLmhlbGRQb2ludGVyLnBvaW50ZXJJZCA9PT0gaW5FdmVudC5wb2ludGVySWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgeCA9IGluRXZlbnQuY2xpZW50WCAtIHRoaXMuaGVsZFBvaW50ZXIuY2xpZW50WDtcbiAgICAgICAgICAgICAgICB2YXIgeSA9IGluRXZlbnQuY2xpZW50WSAtIHRoaXMuaGVsZFBvaW50ZXIuY2xpZW50WTtcbiAgICAgICAgICAgICAgICBpZiAoKHggKiB4ICsgeSAqIHkpID4gdGhpcy5XSUdHTEVfVEhSRVNIT0xEKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBmaXJlSG9sZDogZnVuY3Rpb24oaW5UeXBlLCBpbkhvbGRUaW1lKSB7XG4gICAgICAgICAgICB2YXIgcCA9IHtcbiAgICAgICAgICAgICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgcG9pbnRlclR5cGU6IHRoaXMuaGVsZFBvaW50ZXIucG9pbnRlclR5cGUsXG4gICAgICAgICAgICAgICAgcG9pbnRlcklkOiB0aGlzLmhlbGRQb2ludGVyLnBvaW50ZXJJZCxcbiAgICAgICAgICAgICAgICB4OiB0aGlzLmhlbGRQb2ludGVyLmNsaWVudFgsXG4gICAgICAgICAgICAgICAgeTogdGhpcy5oZWxkUG9pbnRlci5jbGllbnRZLFxuICAgICAgICAgICAgICAgIF9zb3VyY2U6ICdob2xkJ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChpbkhvbGRUaW1lKSB7XG4gICAgICAgICAgICAgICAgcC5ob2xkVGltZSA9IGluSG9sZFRpbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZSA9IGV2ZW50RmFjdG9yeS5tYWtlR2VzdHVyZUV2ZW50KGluVHlwZSwgcCk7XG4gICAgICAgICAgICB0aGlzLnRhcmdldC5kaXNwYXRjaEV2ZW50KGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBkaXNwYXRjaGVyLnJlZ2lzdGVyR2VzdHVyZSgnaG9sZCcsIGhvbGQpO1xufSkoZXhwb3J0cyk7XG5cbi8qKlxuICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIGEgcG9pbnRlciBxdWlja2x5IGdvZXMgZG93biBhbmQgdXAsIGFuZCBpcyB1c2VkIHRvXG4gKiBkZW5vdGUgYWN0aXZhdGlvbi5cbiAqXG4gKiBBbnkgZ2VzdHVyZSBldmVudCBjYW4gcHJldmVudCB0aGUgdGFwIGV2ZW50IGZyb20gYmVpbmcgY3JlYXRlZCBieSBjYWxsaW5nXG4gKiBgZXZlbnQucHJldmVudFRhcGAuXG4gKlxuICogQW55IHBvaW50ZXIgZXZlbnQgY2FuIHByZXZlbnQgdGhlIHRhcCBieSBzZXR0aW5nIHRoZSBgdGFwUHJldmVudGVkYCBwcm9wZXJ0eVxuICogb24gaXRzZWxmLlxuICpcbiAqIEBtb2R1bGUgUG9pbnRlckdlc3R1cmVzXG4gKiBAc3VibW9kdWxlIEV2ZW50c1xuICogQGNsYXNzIHRhcFxuICovXG4vKipcbiAqIFggYXhpcyBwb3NpdGlvbiBvZiB0aGUgdGFwLlxuICogQHByb3BlcnR5IHhcbiAqIEB0eXBlIE51bWJlclxuICovXG4vKipcbiAqIFkgYXhpcyBwb3NpdGlvbiBvZiB0aGUgdGFwLlxuICogQHByb3BlcnR5IHlcbiAqIEB0eXBlIE51bWJlclxuICovXG4vKipcbiAqIFR5cGUgb2YgdGhlIHBvaW50ZXIgdGhhdCBtYWRlIHRoZSB0YXAuXG4gKiBAcHJvcGVydHkgcG9pbnRlclR5cGVcbiAqIEB0eXBlIFN0cmluZ1xuICovXG4oZnVuY3Rpb24oc2NvcGUpIHtcbiAgICB2YXIgZGlzcGF0Y2hlciA9IHNjb3BlLmRpc3BhdGNoZXI7XG4gICAgdmFyIGV2ZW50RmFjdG9yeSA9IHNjb3BlLmV2ZW50RmFjdG9yeTtcbiAgICB2YXIgcG9pbnRlcm1hcCA9IG5ldyBzY29wZS5Qb2ludGVyTWFwKCk7XG4gICAgdmFyIHRhcCA9IHtcbiAgICAgICAgZXZlbnRzOiBbXG4gICAgICAgICAgICAnZG93bicsXG4gICAgICAgICAgICAndXAnXG4gICAgICAgIF0sXG4gICAgICAgIGV4cG9zZXM6IFtcbiAgICAgICAgICAgICd0YXAnXG4gICAgICAgIF0sXG4gICAgICAgIGRvd246IGZ1bmN0aW9uKGluRXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChpbkV2ZW50LmlzUHJpbWFyeSAmJiAhaW5FdmVudC50YXBQcmV2ZW50ZWQpIHtcbiAgICAgICAgICAgICAgICBwb2ludGVybWFwLnNldChpbkV2ZW50LnBvaW50ZXJJZCwge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IGluRXZlbnQudGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICBidXR0b25zOiBpbkV2ZW50LmJ1dHRvbnMsXG4gICAgICAgICAgICAgICAgICAgIHg6IGluRXZlbnQuY2xpZW50WCxcbiAgICAgICAgICAgICAgICAgICAgeTogaW5FdmVudC5jbGllbnRZXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNob3VsZFRhcDogZnVuY3Rpb24oZSwgZG93blN0YXRlKSB7XG4gICAgICAgICAgICB2YXIgdGFwID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChlLnBvaW50ZXJUeXBlID09PSAnbW91c2UnKSB7XG4gICAgICAgICAgICAgICAgLy8gb25seSBhbGxvdyBsZWZ0IGNsaWNrIHRvIHRhcCBmb3IgbW91c2VcbiAgICAgICAgICAgICAgICB0YXAgPSAoZS5idXR0b25zIF4gMSkgJiYgKGRvd25TdGF0ZS5idXR0b25zICYgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGFwICYmICFlLnRhcFByZXZlbnRlZDtcbiAgICAgICAgfSxcbiAgICAgICAgdXA6IGZ1bmN0aW9uKGluRXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IHBvaW50ZXJtYXAuZ2V0KGluRXZlbnQucG9pbnRlcklkKTtcbiAgICAgICAgICAgIGlmIChzdGFydCAmJiB0aGlzLnNob3VsZFRhcChpbkV2ZW50LCBzdGFydCkpIHtcbiAgICAgICAgICAgICAgICAvLyB1cC5yZWxhdGVkVGFyZ2V0IGlzIHRhcmdldCBjdXJyZW50bHkgdW5kZXIgZmluZ2VyXG4gICAgICAgICAgICAgICAgdmFyIHQgPSBzY29wZS50YXJnZXRGaW5kaW5nLkxDQShzdGFydC50YXJnZXQsIGluRXZlbnQucmVsYXRlZFRhcmdldCk7XG4gICAgICAgICAgICAgICAgaWYgKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGUgPSBldmVudEZhY3RvcnkubWFrZUdlc3R1cmVFdmVudCgndGFwJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB4OiBpbkV2ZW50LmNsaWVudFgsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiBpbkV2ZW50LmNsaWVudFksXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWw6IGluRXZlbnQuZGV0YWlsLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRlclR5cGU6IGluRXZlbnQucG9pbnRlclR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludGVySWQ6IGluRXZlbnQucG9pbnRlcklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWx0S2V5OiBpbkV2ZW50LmFsdEtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0cmxLZXk6IGluRXZlbnQuY3RybEtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFLZXk6IGluRXZlbnQubWV0YUtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoaWZ0S2V5OiBpbkV2ZW50LnNoaWZ0S2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgX3NvdXJjZTogJ3RhcCdcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHQuZGlzcGF0Y2hFdmVudChlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb2ludGVybWFwLmRlbGV0ZShpbkV2ZW50LnBvaW50ZXJJZCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIHBhdGNoIGV2ZW50RmFjdG9yeSB0byByZW1vdmUgaWQgZnJvbSB0YXAncyBwb2ludGVybWFwIGZvciBwcmV2ZW50VGFwIGNhbGxzXG4gICAgZXZlbnRGYWN0b3J5LnByZXZlbnRUYXAgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGUudGFwUHJldmVudGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHBvaW50ZXJtYXAuZGVsZXRlKGUucG9pbnRlcklkKTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIGRpc3BhdGNoZXIucmVnaXN0ZXJHZXN0dXJlKCd0YXAnLCB0YXApO1xufSkoZXhwb3J0cyk7XG5cbi8qXG4gKiBCYXNpYyBzdHJhdGVneTogZmluZCB0aGUgZmFydGhlc3QgYXBhcnQgcG9pbnRzLCB1c2UgYXMgZGlhbWV0ZXIgb2YgY2lyY2xlXG4gKiByZWFjdCB0byBzaXplIGNoYW5nZSBhbmQgcm90YXRpb24gb2YgdGhlIGNob3JkXG4gKi9cblxuLyoqXG4gKiBAbW9kdWxlIHBvaW50ZXItZ2VzdHVyZXNcbiAqIEBzdWJtb2R1bGUgRXZlbnRzXG4gKiBAY2xhc3MgcGluY2hcbiAqL1xuLyoqXG4gKiBTY2FsZSBvZiB0aGUgcGluY2ggem9vbSBnZXN0dXJlXG4gKiBAcHJvcGVydHkgc2NhbGVcbiAqIEB0eXBlIE51bWJlclxuICovXG4vKipcbiAqIENlbnRlciBYIHBvc2l0aW9uIG9mIHBvaW50ZXJzIGNhdXNpbmcgcGluY2hcbiAqIEBwcm9wZXJ0eSBjZW50ZXJYXG4gKiBAdHlwZSBOdW1iZXJcbiAqL1xuLyoqXG4gKiBDZW50ZXIgWSBwb3NpdGlvbiBvZiBwb2ludGVycyBjYXVzaW5nIHBpbmNoXG4gKiBAcHJvcGVydHkgY2VudGVyWVxuICogQHR5cGUgTnVtYmVyXG4gKi9cblxuLyoqXG4gKiBAbW9kdWxlIHBvaW50ZXItZ2VzdHVyZXNcbiAqIEBzdWJtb2R1bGUgRXZlbnRzXG4gKiBAY2xhc3Mgcm90YXRlXG4gKi9cbi8qKlxuICogQW5nbGUgKGluIGRlZ3JlZXMpIG9mIHJvdGF0aW9uLiBNZWFzdXJlZCBmcm9tIHN0YXJ0aW5nIHBvc2l0aW9ucyBvZiBwb2ludGVycy5cbiAqIEBwcm9wZXJ0eSBhbmdsZVxuICogQHR5cGUgTnVtYmVyXG4gKi9cbi8qKlxuICogQ2VudGVyIFggcG9zaXRpb24gb2YgcG9pbnRlcnMgY2F1c2luZyByb3RhdGlvblxuICogQHByb3BlcnR5IGNlbnRlclhcbiAqIEB0eXBlIE51bWJlclxuICovXG4vKipcbiAqIENlbnRlciBZIHBvc2l0aW9uIG9mIHBvaW50ZXJzIGNhdXNpbmcgcm90YXRpb25cbiAqIEBwcm9wZXJ0eSBjZW50ZXJZXG4gKiBAdHlwZSBOdW1iZXJcbiAqL1xuKGZ1bmN0aW9uKHNjb3BlKSB7XG4gICAgdmFyIGRpc3BhdGNoZXIgPSBzY29wZS5kaXNwYXRjaGVyO1xuICAgIHZhciBldmVudEZhY3RvcnkgPSBzY29wZS5ldmVudEZhY3Rvcnk7XG4gICAgdmFyIHBvaW50ZXJtYXAgPSBuZXcgc2NvcGUuUG9pbnRlck1hcCgpO1xuICAgIHZhciBSQURfVE9fREVHID0gMTgwIC8gTWF0aC5QSTtcbiAgICB2YXIgcGluY2ggPSB7XG4gICAgICAgIGV2ZW50czogW1xuICAgICAgICAgICAgJ2Rvd24nLFxuICAgICAgICAgICAgJ3VwJyxcbiAgICAgICAgICAgICdtb3ZlJyxcbiAgICAgICAgICAgICdjYW5jZWwnXG4gICAgICAgIF0sXG4gICAgICAgIGV4cG9zZXM6IFtcbiAgICAgICAgICAgICdwaW5jaHN0YXJ0JyxcbiAgICAgICAgICAgICdwaW5jaCcsXG4gICAgICAgICAgICAncGluY2hlbmQnLFxuICAgICAgICAgICAgJ3JvdGF0ZSdcbiAgICAgICAgXSxcbiAgICAgICAgZGVmYXVsdEFjdGlvbnM6IHtcbiAgICAgICAgICAgICdwaW5jaCc6ICdub25lJyxcbiAgICAgICAgICAgICdyb3RhdGUnOiAnbm9uZSdcbiAgICAgICAgfSxcbiAgICAgICAgcmVmZXJlbmNlOiB7fSxcbiAgICAgICAgZG93bjogZnVuY3Rpb24oaW5FdmVudCkge1xuICAgICAgICAgICAgcG9pbnRlcm1hcC5zZXQoaW5FdmVudC5wb2ludGVySWQsIGluRXZlbnQpO1xuICAgICAgICAgICAgaWYgKHBvaW50ZXJtYXAucG9pbnRlcnMoKSA9PSAyKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBvaW50cyA9IHRoaXMuY2FsY0Nob3JkKCk7XG4gICAgICAgICAgICAgICAgdmFyIGFuZ2xlID0gdGhpcy5jYWxjQW5nbGUocG9pbnRzKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlZmVyZW5jZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgYW5nbGU6IGFuZ2xlLFxuICAgICAgICAgICAgICAgICAgICBkaWFtZXRlcjogcG9pbnRzLmRpYW1ldGVyLFxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IHNjb3BlLnRhcmdldEZpbmRpbmcuTENBKHBvaW50cy5hLnRhcmdldCwgcG9pbnRzLmIudGFyZ2V0KVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICB0aGlzLmZpcmVQaW5jaCgncGluY2hzdGFydCcsIHBvaW50cy5kaWFtZXRlciwgcG9pbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdXA6IGZ1bmN0aW9uKGluRXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBwID0gcG9pbnRlcm1hcC5nZXQoaW5FdmVudC5wb2ludGVySWQpO1xuICAgICAgICAgICAgdmFyIG51bSA9IHBvaW50ZXJtYXAucG9pbnRlcnMoKTtcbiAgICAgICAgICAgIGlmIChwKSB7XG4gICAgICAgICAgICAgICAgaWYgKG51bSA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAvLyBmaXJlICdwaW5jaGVuZCcgYmVmb3JlIGRlbGV0aW5nIHBvaW50ZXJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBvaW50cyA9IHRoaXMuY2FsY0Nob3JkKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlyZVBpbmNoKCdwaW5jaGVuZCcsIHBvaW50cy5kaWFtZXRlciwgcG9pbnRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcG9pbnRlcm1hcC5kZWxldGUoaW5FdmVudC5wb2ludGVySWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBtb3ZlOiBmdW5jdGlvbihpbkV2ZW50KSB7XG4gICAgICAgICAgICBpZiAocG9pbnRlcm1hcC5oYXMoaW5FdmVudC5wb2ludGVySWQpKSB7XG4gICAgICAgICAgICAgICAgcG9pbnRlcm1hcC5zZXQoaW5FdmVudC5wb2ludGVySWQsIGluRXZlbnQpO1xuICAgICAgICAgICAgICAgIGlmIChwb2ludGVybWFwLnBvaW50ZXJzKCkgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FsY1BpbmNoUm90YXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjYW5jZWw6IGZ1bmN0aW9uKGluRXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMudXAoaW5FdmVudCk7XG4gICAgICAgIH0sXG4gICAgICAgIGZpcmVQaW5jaDogZnVuY3Rpb24odHlwZSwgZGlhbWV0ZXIsIHBvaW50cykge1xuICAgICAgICAgICAgdmFyIHpvb20gPSBkaWFtZXRlciAvIHRoaXMucmVmZXJlbmNlLmRpYW1ldGVyO1xuICAgICAgICAgICAgdmFyIGUgPSBldmVudEZhY3RvcnkubWFrZUdlc3R1cmVFdmVudCh0eXBlLCB7XG4gICAgICAgICAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHNjYWxlOiB6b29tLFxuICAgICAgICAgICAgICAgIGNlbnRlclg6IHBvaW50cy5jZW50ZXIueCxcbiAgICAgICAgICAgICAgICBjZW50ZXJZOiBwb2ludHMuY2VudGVyLnksXG4gICAgICAgICAgICAgICAgX3NvdXJjZTogJ3BpbmNoJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnJlZmVyZW5jZS50YXJnZXQuZGlzcGF0Y2hFdmVudChlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZmlyZVJvdGF0ZTogZnVuY3Rpb24oYW5nbGUsIHBvaW50cykge1xuICAgICAgICAgICAgdmFyIGRpZmYgPSBNYXRoLnJvdW5kKChhbmdsZSAtIHRoaXMucmVmZXJlbmNlLmFuZ2xlKSAlIDM2MCk7XG4gICAgICAgICAgICB2YXIgZSA9IGV2ZW50RmFjdG9yeS5tYWtlR2VzdHVyZUV2ZW50KCdyb3RhdGUnLCB7XG4gICAgICAgICAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGFuZ2xlOiBkaWZmLFxuICAgICAgICAgICAgICAgIGNlbnRlclg6IHBvaW50cy5jZW50ZXIueCxcbiAgICAgICAgICAgICAgICBjZW50ZXJZOiBwb2ludHMuY2VudGVyLnksXG4gICAgICAgICAgICAgICAgX3NvdXJjZTogJ3BpbmNoJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnJlZmVyZW5jZS50YXJnZXQuZGlzcGF0Y2hFdmVudChlKTtcbiAgICAgICAgfSxcbiAgICAgICAgY2FsY1BpbmNoUm90YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBwb2ludHMgPSB0aGlzLmNhbGNDaG9yZCgpO1xuICAgICAgICAgICAgdmFyIGRpYW1ldGVyID0gcG9pbnRzLmRpYW1ldGVyO1xuICAgICAgICAgICAgdmFyIGFuZ2xlID0gdGhpcy5jYWxjQW5nbGUocG9pbnRzKTtcbiAgICAgICAgICAgIGlmIChkaWFtZXRlciAhPSB0aGlzLnJlZmVyZW5jZS5kaWFtZXRlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlyZVBpbmNoKCdwaW5jaCcsIGRpYW1ldGVyLCBwb2ludHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFuZ2xlICE9IHRoaXMucmVmZXJlbmNlLmFuZ2xlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJlUm90YXRlKGFuZ2xlLCBwb2ludHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjYWxjQ2hvcmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHBvaW50ZXJzID0gW107XG4gICAgICAgICAgICBwb2ludGVybWFwLmZvckVhY2goZnVuY3Rpb24ocCkge1xuICAgICAgICAgICAgICAgIHBvaW50ZXJzLnB1c2gocCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBkaXN0ID0gMDtcbiAgICAgICAgICAgIC8vIHN0YXJ0IHdpdGggYXQgbGVhc3QgdHdvIHBvaW50ZXJzXG4gICAgICAgICAgICB2YXIgcG9pbnRzID0ge1xuICAgICAgICAgICAgICAgIGE6IHBvaW50ZXJzWzBdLFxuICAgICAgICAgICAgICAgIGI6IHBvaW50ZXJzWzFdXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIHgsIHksIGQ7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGEgPSBwb2ludGVyc1tpXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gaSArIDE7IGogPCBwb2ludGVycy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYiA9IHBvaW50ZXJzW2pdO1xuICAgICAgICAgICAgICAgICAgICB4ID0gTWF0aC5hYnMoYS5jbGllbnRYIC0gYi5jbGllbnRYKTtcbiAgICAgICAgICAgICAgICAgICAgeSA9IE1hdGguYWJzKGEuY2xpZW50WSAtIGIuY2xpZW50WSk7XG4gICAgICAgICAgICAgICAgICAgIGQgPSB4ICsgeTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGQgPiBkaXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXN0ID0gZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhOiBhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGI6IGJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB4ID0gTWF0aC5hYnMocG9pbnRzLmEuY2xpZW50WCArIHBvaW50cy5iLmNsaWVudFgpIC8gMjtcbiAgICAgICAgICAgIHkgPSBNYXRoLmFicyhwb2ludHMuYS5jbGllbnRZICsgcG9pbnRzLmIuY2xpZW50WSkgLyAyO1xuICAgICAgICAgICAgcG9pbnRzLmNlbnRlciA9IHtcbiAgICAgICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgICAgIHk6IHlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBwb2ludHMuZGlhbWV0ZXIgPSBkaXN0O1xuICAgICAgICAgICAgcmV0dXJuIHBvaW50cztcbiAgICAgICAgfSxcbiAgICAgICAgY2FsY0FuZ2xlOiBmdW5jdGlvbihwb2ludHMpIHtcbiAgICAgICAgICAgIHZhciB4ID0gcG9pbnRzLmEuY2xpZW50WCAtIHBvaW50cy5iLmNsaWVudFg7XG4gICAgICAgICAgICB2YXIgeSA9IHBvaW50cy5hLmNsaWVudFkgLSBwb2ludHMuYi5jbGllbnRZO1xuICAgICAgICAgICAgcmV0dXJuICgzNjAgKyBNYXRoLmF0YW4yKHksIHgpICogUkFEX1RPX0RFRykgJSAzNjA7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGRpc3BhdGNoZXIucmVnaXN0ZXJHZXN0dXJlKCdwaW5jaCcsIHBpbmNoKTtcbn0pKGV4cG9ydHMpOyIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihudW1Sb3dzKSB7XG5cbiAgICB2YXIgZmlyc3ROYW1lcyA9IFsnT2xpdmlhJywgJ1NvcGhpYScsICdBdmEnLCAnSXNhYmVsbGEnLCAnQm95JywgJ0xpYW0nLCAnTm9haCcsICdFdGhhbicsICdNYXNvbicsICdMb2dhbicsICdNb2UnLCAnTGFycnknLCAnQ3VybHknLCAnU2hlbXAnLCAnR3JvdWNobycsICdIYXJwbycsICdDaGljbycsICdaZXBwbycsICdTdGFubGV5JywgJ0hhcmR5J107XG4gICAgdmFyIGxhc3ROYW1lcyA9IFsnV2lydHMnLCAnT25laWwnLCAnU21pdGgnLCAnQmFyYmFyb3NhJywgJ1NvcHJhbm8nLCAnR290dGknLCAnQ29sdW1ibycsICdMdWNpYW5vJywgJ0RvZXJyZScsICdEZVBlbmEnXTtcbiAgICB2YXIgbW9udGhzID0gWycwMScsICcwMicsICcwMycsICcwNCcsICcwNScsICcwNicsICcwNycsICcwOCcsICcwOScsICcxMCcsICcxMScsICcxMiddO1xuICAgIHZhciBkYXlzID0gWycwMScsICcwMicsICcwMycsICcwNCcsICcwNScsICcwNicsICcwNycsICcwOCcsICcwOScsICcxMCcsICcxMScsICcxMicsICcxMycsICcxNCcsICcxNScsICcxNicsICcxNycsICcxOCcsICcxOScsICcyMCcsICcyMScsICcyMicsICcyMycsICcyNCcsICcyNScsICcyNicsICcyNycsICcyOCcsICcyOScsICczMCddO1xuICAgIHZhciBzdGF0ZXMgPSBbJ0FsYWJhbWEnLCAnQWxhc2thJywgJ0FyaXpvbmEnLCAnQXJrYW5zYXMnLCAnQ2FsaWZvcm5pYScsICdDb2xvcmFkbycsICdDb25uZWN0aWN1dCcsICdEZWxhd2FyZScsICdGbG9yaWRhJywgJ0dlb3JnaWEnLCAnSGF3YWlpJywgJ0lkYWhvJywgJ0lsbGlub2lzJywgJ0luZGlhbmEnLCAnSW93YScsICdLYW5zYXMnLCAnS2VudHVja3knLCAnTG91aXNpYW5hJywgJ01haW5lJywgJ01hcnlsYW5kJywgJ01hc3NhY2h1c2V0dHMnLCAnTWljaGlnYW4nLCAnTWlubmVzb3RhJywgJ01pc3Npc3NpcHBpJywgJ01pc3NvdXJpJywgJ01vbnRhbmEnLCAnTmVicmFza2EnLCAnTmV2YWRhJywgJ05ldyBIYW1wc2hpcmUnLCAnTmV3IEplcnNleScsICdOZXcgTWV4aWNvJywgJ05ldyBZb3JrJywgJ05vcnRoIENhcm9saW5hJywgJ05vcnRoIERha290YScsICdPaGlvJywgJ09rbGFob21hJywgJ09yZWdvbicsICdQZW5uc3lsdmFuaWEnLCAnUmhvZGUgSXNsYW5kJywgJ1NvdXRoIENhcm9saW5hJywgJ1NvdXRoIERha290YScsICdUZW5uZXNzZWUnLCAnVGV4YXMnLCAnVXRhaCcsICdWZXJtb250JywgJ1ZpcmdpbmlhJywgJ1dhc2hpbmd0b24nLCAnV2VzdCBWaXJnaW5pYScsICdXaXNjb25zaW4nLCAnV3lvbWluZyddO1xuXG4gICAgdmFyIHJhbmRvbUZ1bmMgPSBNYXRoLnJhbmRvbTtcbiAgICAvL3ZhciByYW5kb21GdW5jID0gcm5kO1xuICAgIHZhciByYW5kb21QZXJzb24gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGZpcnN0TmFtZSA9IE1hdGgucm91bmQoKGZpcnN0TmFtZXMubGVuZ3RoIC0gMSkgKiByYW5kb21GdW5jKCkpO1xuICAgICAgICB2YXIgbGFzdE5hbWUgPSBNYXRoLnJvdW5kKChsYXN0TmFtZXMubGVuZ3RoIC0gMSkgKiByYW5kb21GdW5jKCkpO1xuICAgICAgICB2YXIgcGV0cyA9IE1hdGgucm91bmQoMTAgKiByYW5kb21GdW5jKCkpO1xuICAgICAgICB2YXIgYmlydGh5ZWFyID0gMTkwMCArIE1hdGgucm91bmQocmFuZG9tRnVuYygpICogMTE0KTtcbiAgICAgICAgdmFyIGJpcnRobW9udGggPSBNYXRoLnJvdW5kKHJhbmRvbUZ1bmMoKSAqIDExKTtcbiAgICAgICAgdmFyIGJpcnRoZGF5ID0gTWF0aC5yb3VuZChyYW5kb21GdW5jKCkgKiAyOSk7XG4gICAgICAgIHZhciBiaXJ0aHN0YXRlID0gTWF0aC5yb3VuZChyYW5kb21GdW5jKCkgKiA0OSk7XG4gICAgICAgIHZhciByZXNpZGVuY2VzdGF0ZSA9IE1hdGgucm91bmQocmFuZG9tRnVuYygpICogNDkpO1xuICAgICAgICB2YXIgdHJhdmVsID0gcmFuZG9tRnVuYygpICogMTAwMDtcbiAgICAgICAgdmFyIGluY29tZSA9IHJhbmRvbUZ1bmMoKSAqIDEwMDAwMDtcbiAgICAgICAgdmFyIGVtcGxveWVkID0gTWF0aC5yb3VuZChyYW5kb21GdW5jKCkpO1xuICAgICAgICB2YXIgcGVyc29uID0ge1xuICAgICAgICAgICAgbGFzdF9uYW1lOiBsYXN0TmFtZXNbbGFzdE5hbWVdLFxuICAgICAgICAgICAgLy9qc2hpbnQgaWdub3JlOmxpbmVcbiAgICAgICAgICAgIGZpcnN0X25hbWU6IGZpcnN0TmFtZXNbZmlyc3ROYW1lXSxcbiAgICAgICAgICAgIC8vanNoaW50IGlnbm9yZTpsaW5lXG4gICAgICAgICAgICBwZXRzOiBwZXRzLFxuICAgICAgICAgICAgYmlydGhEYXRlOiBiaXJ0aHllYXIgKyAnLScgKyBtb250aHNbYmlydGhtb250aF0gKyAnLScgKyBkYXlzW2JpcnRoZGF5XSxcbiAgICAgICAgICAgIGJpcnRoU3RhdGU6IHN0YXRlc1tiaXJ0aHN0YXRlXSxcbiAgICAgICAgICAgIHJlc2lkZW5jZVN0YXRlOiBzdGF0ZXNbcmVzaWRlbmNlc3RhdGVdLFxuICAgICAgICAgICAgZW1wbG95ZWQ6IGVtcGxveWVkID09PSAxLFxuICAgICAgICAgICAgaW5jb21lOiBpbmNvbWUsXG4gICAgICAgICAgICB0cmF2ZWw6IHRyYXZlbFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcGVyc29uO1xuICAgIH07XG5cbiAgICB2YXIgZGF0YSA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtUm93czsgaSsrKSB7XG4gICAgICAgIHZhciBwZXJzb24gPSByYW5kb21QZXJzb24oKTtcbiAgICAgICAgcGVyc29uLm9yZGVyID0gaTtcbiAgICAgICAgZGF0YS5wdXNoKHBlcnNvbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGE7XG5cbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBKU0RhdGFTb3VyY2U6IHJlcXVpcmUoJy4vanMvRGF0YVNvdXJjZScpLFxuICAgIERhdGFTb3VyY2VTb3J0ZXI6IHJlcXVpcmUoJy4vanMvRGF0YVNvdXJjZVNvcnRlcicpLFxuICAgIERhdGFTb3VyY2VTb3J0ZXJDb21wb3NpdGU6IHJlcXVpcmUoJy4vanMvRGF0YVNvdXJjZVNvcnRlckNvbXBvc2l0ZScpLFxuICAgIERhdGFTb3VyY2VHbG9iYWxGaWx0ZXI6IHJlcXVpcmUoJy4vanMvRGF0YVNvdXJjZUdsb2JhbEZpbHRlcicpLFxuICAgIERhdGFTb3VyY2VBZ2dyZWdhdG9yOiByZXF1aXJlKCcuL2pzL0RhdGFTb3VyY2VBZ2dyZWdhdG9yJyksXG4gICAgRGF0YVNvdXJjZVRyZWV2aWV3OiByZXF1aXJlKCcuL2pzL0RhdGFTb3VyY2VUcmVldmlldycpLFxuICAgIERhdGFOb2RlR3JvdXBTb3J0ZXI6IHJlcXVpcmUoJy4vanMvRGF0YU5vZGVHcm91cFNvcnRlcicpLFxuICAgIHV0aWw6IHtcbiAgICAgICAgYWdncmVnYXRpb25zOiByZXF1aXJlKCcuL2pzL3V0aWwvYWdncmVnYXRpb25zJyksXG4gICAgICAgIE1hcHB5OiByZXF1aXJlKCcuL2pzL3V0aWwvTWFwcHknKSxcbiAgICAgICAgc3RhYmxlU29ydDogcmVxdWlyZSgnLi9qcy91dGlsL3N0YWJsZVNvcnQnKSxcbiAgICAgICAgaGVhZGVyaWZ5OiByZXF1aXJlKCcuL2pzL3V0aWwvaGVhZGVyaWZ5JyksXG4gICAgICAgIGdlbmVyYXRlU2FtcGxlRGF0YTogcmVxdWlyZSgnLi9nZW5lcmF0ZVNhbXBsZURhdGEuanMnKVxuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIEJhc2UoKSB7fVxuQmFzZS5leHRlbmQgPSByZXF1aXJlKCdleHRlbmQtbWUnKTtcblxuQmFzZS5wcm90b3R5cGUuY2xpY2sgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5kYXRhU291cmNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFTb3VyY2UuY2xpY2suYXBwbHkodGhpcy5kYXRhU291cmNlLCBhcmd1bWVudHMpO1xuICAgIH1cbn07XG5cbkJhc2UucHJvdG90eXBlLmZpbmRSb3cgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5kYXRhU291cmNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFTb3VyY2UuZmluZFJvdy5hcHBseSh0aGlzLmRhdGFTb3VyY2UsIGFyZ3VtZW50cyk7XG4gICAgfVxufTtcblxuQmFzZS5wcm90b3R5cGUucmV2ZWFsUm93ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuZGF0YVNvdXJjZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhU291cmNlLnJldmVhbFJvdy5hcHBseSh0aGlzLmRhdGFTb3VyY2UsIGFyZ3VtZW50cyk7XG4gICAgfVxufTtcblxuQmFzZS5wcm90b3R5cGUucmVwbGFjZUluZGVudCA9ICdfJztcblxuQmFzZS5wcm90b3R5cGUuZml4SW5kZW50Rm9yVGFibGVEaXNwbGF5ID0gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgdmFyIGNvdW50ID0gc3RyaW5nLnNlYXJjaCgvXFxTLyk7XG4gICAgdmFyIGVuZCA9IHN0cmluZy5zdWJzdHJpbmcoY291bnQpO1xuICAgIHZhciByZXN1bHQgPSBBcnJheShjb3VudCArIDEpLmpvaW4odGhpcy5yZXBsYWNlSW5kZW50KSArIGVuZDtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuQmFzZS5wcm90b3R5cGUuZHVtcCA9IGZ1bmN0aW9uKG1heCkge1xuICAgIG1heCA9IE1hdGgubWluKHRoaXMuZ2V0Um93Q291bnQoKSwgbWF4IHx8IE1hdGgubWF4KDEwMCwgdGhpcy5nZXRSb3dDb3VudCgpKSk7XG4gICAgdmFyIGRhdGEgPSBbXTtcbiAgICB2YXIgZmllbGRzID0gdGhpcy5nZXRIZWFkZXJzKCk7XG4gICAgdmFyIGNDb3VudCA9IHRoaXMuZ2V0Q29sdW1uQ291bnQoKTtcbiAgICB2YXIgdmlld01ha2VzU2Vuc2UgPSB0aGlzLnZpZXdNYWtlc1NlbnNlO1xuICAgIGZvciAodmFyIHIgPSAwOyByIDwgbWF4OyByKyspIHtcbiAgICAgICAgdmFyIHJvdyA9IHt9O1xuICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IGNDb3VudDsgYysrKSB7XG4gICAgICAgICAgICB2YXIgdmFsID0gdGhpcy5nZXRWYWx1ZShjLCByKTtcbiAgICAgICAgICAgIGlmIChjID09PSAwICYmIHZpZXdNYWtlc1NlbnNlKSB7XG4gICAgICAgICAgICAgICAgdmFsID0gdGhpcy5maXhJbmRlbnRGb3JUYWJsZURpc3BsYXkodmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJvd1tmaWVsZHNbY11dID0gdmFsO1xuICAgICAgICB9XG4gICAgICAgIGRhdGFbcl0gPSByb3c7XG4gICAgfVxuICAgIGNvbnNvbGUudGFibGUoZGF0YSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJhc2U7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBCYXNlID0gcmVxdWlyZSgnLi9CYXNlJyk7XG5cbi8qKlxuICogU2VlIHtAbGluayBEYXRhQmFzZU5vZGUjaW5pdGlhbGl6ZXxpbml0aWFsaXplKCl9IG1ldGhvZCBmb3IgcGFyYW1ldGVycy5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgRGF0YU5vZGVCYXNlID0gQmFzZS5leHRlbmQoJ0RhdGFOb2RlQmFzZScsIHtcblxuICAgIGlzTnVsbE9iamVjdDogZmFsc2UsXG5cbiAgICBJTkRFTlQ6ICcgICAnLCAvLyAzIHNwYWNlc1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFOb2RlQmFzZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyT2YgRGF0YU5vZGVCYXNlLnByb3RvdHlwZVxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cblxuICAgICAgICB0aGlzLmxhYmVsID0ga2V5O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyT2YgRGF0YU5vZGVCYXNlLnByb3RvdHlwZVxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nW119XG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRhdGEgPSBbJyddOyAvLyBUT0RPOiBXaHkgaXMgdGhpcyBmaXJzdCBlbGVtZW50IG5lZWRlZD9cblxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlck9mIERhdGFOb2RlQmFzZS5wcm90b3R5cGVcbiAgICAgICAgICogQHR5cGUge251bWJlcltdfVxuICAgICAgICAgKiBAZGVmYXVsdCBbJyddXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmluZGV4ID0gW107IC8vIFRPRE86IGZvcm1lcmx5IHJvd0luZGV4XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXJPZiBEYXRhTm9kZUJhc2UucHJvdG90eXBlXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5oYXNDaGlsZHJlbiA9IGZhbHNlOyAvLyBUT0RPOiBXaGVyZS9ob3cgaXMgdGhpcyB1c2VkP1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyT2YgRGF0YU5vZGVCYXNlLnByb3RvdHlwZVxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAwXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRlcHRoID0gMDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlck9mIERhdGFOb2RlQmFzZS5wcm90b3R5cGVcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5oZWlnaHQgPSAxO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyT2YgRGF0YU5vZGVCYXNlLnByb3RvdHlwZVxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZXhwYW5kZWQgPSBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFOb2RlTGVhZi5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0geFxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGdldFZhbHVlOiBmdW5jdGlvbih4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFbeF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhTm9kZUxlYWYucHJvdG90eXBlXG4gICAgICogQHBhcmFtIGRlcHRoXG4gICAgICovXG4gICAgdG9BcnJheTogZnVuY3Rpb24oZGVwdGgpIHtcbiAgICAgICAgdGhpcy5kZXB0aCA9IGRlcHRoO1xuICAgICAgICB0aGlzLmRhdGFbMF0gPSB0aGlzLmNvbXB1dGVEZXB0aFN0cmluZygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YU5vZGVMZWFmLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgY29tcHV0ZURlcHRoU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5KHRoaXMuZGVwdGggKyAxKS5qb2luKHRoaXMuSU5ERU5UKSArICcgICcgKyB0aGlzLmxhYmVsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YU5vZGVMZWFmLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgY29tcHV0ZUhlaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YU5vZGVMZWFmLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cbiAgICBnZXRJbmRleDogZnVuY3Rpb24oKSB7IC8vIFRPRE86IGZvcm1lcmx5IGdldEFsbFJvd0luZGV4ZXNcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhTm9kZUxlYWYucHJvdG90eXBlXG4gICAgICogQHBhcmFtIGFnZ3JlZ2F0b3JcbiAgICAgKi9cbiAgICBjb21wdXRlQWdncmVnYXRlczogZnVuY3Rpb24oYWdncmVnYXRvcikge1xuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmdldEluZGV4KCk7XG5cbiAgICAgICAgaWYgKGluZGV4Lmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGdyb3Vwc09mZnNldCA9IE51bWJlcihhZ2dyZWdhdG9yLmhhc0dyb3VwcygpKTtcblxuICAgICAgICAgICAgLy8gcmVkaW1lbnNpb24gdGhlIGRhdGFcbiAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuICAgICAgICAgICAgZGF0YS5sZW5ndGggPSBncm91cHNPZmZzZXQgKyBhZ2dyZWdhdG9yLmFnZ3JlZ2F0ZXMubGVuZ3RoO1xuXG4gICAgICAgICAgICB2YXIgc29ydGVyID0gYWdncmVnYXRvci5zb3J0ZXJJbnN0YW5jZTtcbiAgICAgICAgICAgIHNvcnRlci5pbmRleCA9IGluZGV4O1xuXG4gICAgICAgICAgICBhZ2dyZWdhdG9yLmFnZ3JlZ2F0ZXMuZm9yRWFjaChmdW5jdGlvbihhZ2dyZWdhdGUsIGkpIHtcbiAgICAgICAgICAgICAgICBkYXRhW2dyb3Vwc09mZnNldCArIGldID0gYWdncmVnYXRlKHNvcnRlcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YU5vZGVMZWFmLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSBhZ2dyZWdhdG9yXG4gICAgICovXG4gICAgYnVpbGRWaWV3OiBmdW5jdGlvbihhZ2dyZWdhdG9yKSB7XG4gICAgICAgIGFnZ3JlZ2F0b3IuYWRkVmlldyh0aGlzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFOb2RlTGVhZi5wcm90b3R5cGVcbiAgICAgKi9cbiAgICB0b2dnbGVFeHBhbnNpb25TdGF0ZTogZnVuY3Rpb24oKSB7IC8qIGFnZ3JlZ2F0b3IgKi9cbiAgICAgICAgLy9kbyBub3RoaW5nIGJ5IGRlZmF1bHRcbiAgICB9LFxuXG4gICAgc29ydEdyb3VwczogZnVuY3Rpb24oZ3JvdXBTb3J0ZXIpIHtcbiAgICB9XG59KTtcblxuLy9EYXRhTm9kZUJhc2UucHJvdG90eXBlLmFwcGx5QWdncmVnYXRlcyA9IERhdGFOb2RlQmFzZS5wcm90b3R5cGUuY29tcHV0ZUFnZ3JlZ2F0ZXM7XG5cbm1vZHVsZS5leHBvcnRzID0gRGF0YU5vZGVCYXNlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgTWFwID0gcmVxdWlyZSgnLi91dGlsL01hcHB5Jyk7XG52YXIgRGF0YU5vZGVCYXNlID0gcmVxdWlyZSgnLi9EYXRhTm9kZUJhc2UnKTtcblxudmFyIGV4cGFuZGVkTWFwID0ge1xuICAgIHRydWU6ICdcXHUyNWJjJywgLy8gQkxBQ0sgRE9XTi1QT0lOVElORyBUUklBTkdMRSBha2EgJ+KWvCdcbiAgICBmYWxzZTogJ1xcdTI1YjYnIC8vIEJMQUNLIFJJR0hULVBPSU5USU5HIFRSSUFOR0xFIGFrYSAn4pa2J1xufTtcblxuLyoqXG4gKiA+IFNlZSB7QGxpbmsgRGF0YU5vZGVHcm91cCNpbml0aWFsaXplfGluaXRpYWxpemUoKX0gbWV0aG9kIGZvciBjb25zdHJ1Y3RvciBwYXJhbWV0ZXJzLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBEYXRhTm9kZUJhc2VcbiAqL1xudmFyIERhdGFOb2RlR3JvdXAgPSBEYXRhTm9kZUJhc2UuZXh0ZW5kKCdEYXRhTm9kZUdyb3VwJywge1xuXG4gICAgZXh0ZW5kYWJsZTogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhTm9kZUdyb3VwLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSBrZXlcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IG5ldyBNYXAoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFOb2RlR3JvdXAucHJvdG90eXBlXG4gICAgICogQHBhcmFtIGRlcHRoXG4gICAgICovXG4gICAgdG9BcnJheTogZnVuY3Rpb24oZGVwdGgpIHtcbiAgICAgICAgdGhpcy5kZXB0aCA9IGRlcHRoO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbi52YWx1ZXM7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICAgICAgY2hpbGQudG9BcnJheShkZXB0aCArIDEpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5kYXRhWzBdID0gdGhpcy5jb21wdXRlRGVwdGhTdHJpbmcoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFOb2RlR3JvdXAucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBjb21wdXRlRGVwdGhTdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3RyaW5nID0gQXJyYXkodGhpcy5kZXB0aCArIDEpLmpvaW4odGhpcy5JTkRFTlQpICtcbiAgICAgICAgICAgIGV4cGFuZGVkTWFwW3RoaXMuZXhwYW5kZWRdICsgJyAnICtcbiAgICAgICAgICAgIHRoaXMubGFiZWw7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhTm9kZUdyb3VwLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGdldEluZGV4OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5kZXgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmluZGV4ID0gdGhpcy5jb21wdXRlSW5kZXgoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5pbmRleDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFOb2RlR3JvdXAucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuICAgIGNvbXB1dGVJbmRleDogZnVuY3Rpb24oKSB7IC8vIFRPRE86IGZvcm1lcmx5IGNvbXB1dGVBbGxSb3dJbmRleGVzXG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgcmVzdWx0LmFwcGVuZCA9IGFwcGVuZDtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgICAgICByZXN1bHQuYXBwZW5kKGNoaWxkLmdldEluZGV4KCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFOb2RlR3JvdXAucHJvdG90eXBlXG4gICAgICogQHBhcmFtIGFnZ3JlZ2F0b3JcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtleHBhbmRdIC0gT25lIG9mOlxuICAgICAqICogYHRydWVgIC0gRXhwYW5kIGFsbCByb3dzIHRoYXQgYXJlIGN1cnJlbnRseSBjb2xsYXBzZWQuXG4gICAgICogKiBgZmFsc2VgIC0gQ29sbGFwc2UgYWxsIHJvd3MgdGhhdCBhcmUgY3VycmVudGx5IGV4cGFuZGVkLlxuICAgICAqICogYHVuZGVmaW5lZGAgKG9yIG9taXR0ZWQpIC0gRXhwYW5kIGFsbCBjdXJyZW50bHkgY29sbGFwc2VkIHJvd3M7IGNvbGxhcHNlIGFsbCBjdXJyZW50bHkgZXhwYW5kZWQgcm93cy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gSWYgdGhpcyBjYWxsIHJlc3VsdGVkIGluIGEgc3RhdGUgY2hhbmdlLlxuICAgICAqL1xuICAgIHRvZ2dsZUV4cGFuc2lvblN0YXRlOiBmdW5jdGlvbihhZ2dyZWdhdG9yLCBleHBhbmQpIHsgLyogYWdncmVnYXRvciAqL1xuICAgICAgICBpZiAoZXhwYW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGV4cGFuZCA9ICF0aGlzLmV4cGFuZGVkO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjaGFuZ2VkID0gdGhpcy5leHBhbmRlZCBeIGV4cGFuZDtcbiAgICAgICAgdGhpcy5leHBhbmRlZCA9IGV4cGFuZDtcbiAgICAgICAgdGhpcy5kYXRhWzBdID0gdGhpcy5jb21wdXRlRGVwdGhTdHJpbmcoKTtcbiAgICAgICAgaWYgKHRoaXMuZXhwYW5kZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY29tcHV0ZUFnZ3JlZ2F0ZXMoYWdncmVnYXRvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICEhY2hhbmdlZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFOb2RlR3JvdXAucHJvdG90eXBlXG4gICAgICogQHBhcmFtIGFnZ3JlZ2F0b3JcbiAgICAgKi9cbiAgICBjb21wdXRlQWdncmVnYXRlczogZnVuY3Rpb24oYWdncmVnYXRvcikge1xuICAgICAgICBEYXRhTm9kZUJhc2UucHJvdG90eXBlLmNvbXB1dGVBZ2dyZWdhdGVzLmNhbGwodGhpcywgYWdncmVnYXRvcik7IC8vIGNhbGwgYmFzZSBjbGFzcydzIHZlcnNpb25cbiAgICAgICAgaWYgKHRoaXMuZXhwYW5kZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICAgICAgICAgIGNoaWxkLmNvbXB1dGVBZ2dyZWdhdGVzKGFnZ3JlZ2F0b3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFOb2RlR3JvdXAucHJvdG90eXBlXG4gICAgICogQHBhcmFtIGFnZ3JlZ2F0b3JcbiAgICAgKi9cbiAgICBidWlsZFZpZXc6IGZ1bmN0aW9uKGFnZ3JlZ2F0b3IpIHtcbiAgICAgICAgYWdncmVnYXRvci52aWV3LnB1c2godGhpcyk7XG4gICAgICAgIGlmICh0aGlzLmV4cGFuZGVkKSB7XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgICAgICAgICBjaGlsZC5idWlsZFZpZXcoYWdncmVnYXRvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YU5vZGVHcm91cC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGNvbXB1dGVIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaGVpZ2h0ID0gMTtcblxuICAgICAgICBpZiAodGhpcy5leHBhbmRlZCkge1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gaGVpZ2h0ICsgY2hpbGQuY29tcHV0ZUhlaWdodCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKHRoaXMuaGVpZ2h0ID0gaGVpZ2h0KTtcbiAgICB9LFxuXG4gICAgc29ydFdpdGg6IGZ1bmN0aW9uKHNvcnRlcikge1xuICAgICAgICBpZiAodGhpcy5leHBhbmRlZCkge1xuICAgICAgICAgICAgc29ydGVyLnNvcnRHcm91cCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICAgICAgICAgIGNoaWxkLnNvcnRXaXRoKHNvcnRlcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgY2xlYXJHcm91cFNvcnRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMub3JpZ2luYWxPcmRlcikge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm9yaWdpbmFsT3JkZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoaWxkcmVuW2ldID0gdGhpcy5vcmlnaW5hbE9yZGVyW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICAgICAgY2hpbGQuY2xlYXJHcm91cFNvcnRzKCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxufSk7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBzdW1tYXJ5IEFycmF5IG1peGluIHRvIGFwcGVuZCBhbm90aGVyIGFycmF5IHRvIGVuZCBvZiBgdGhpc2Agb25lLlxuICogQGRlc2MgQXBwZW5kcyBpbiBwbGFjZSwgdW5saWtlIGB0aGlzLmNvbmNhdCgpYCB3aGljaCBjcmVhdGVzIGEgbmV3IGFycmF5LlxuICogVXNlcyBsZXNzIG1lbW9yeSB0aGFuIGNvbmNhdCwgaW1wb3J0YW50IHdoZW4gYGFwcGVuZGl4YCBpcyBodWdlLlxuICogPiBDQVVUSU9OOiBNdXRhdGVzIGB0aGlzYCBhcnJheSFcbiAqIEBwYXJhbSB7QXJyYXl9IGFwcGVuZGl4XG4gKiBAcmV0dXJucyB7QXJyYXl9IFJlZmVyZW5jZSB0byBgdGhpc2AgKGZvciBjb252ZW5pZW5jZSlcbiAqL1xuZnVuY3Rpb24gYXBwZW5kKGFwcGVuZGl4KSB7XG4gICAgdGhpcy5zcGxpY2UuYmluZCh0aGlzLCB0aGlzLmxlbmd0aCwgMCkuYXBwbHkodGhpcywgYXBwZW5kaXgpO1xuICAgIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGFOb2RlR3JvdXA7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBCYXNlID0gcmVxdWlyZSgnLi9CYXNlJyk7XG52YXIgc3RhYmxlU29ydCA9IHJlcXVpcmUoJy4vdXRpbC9zdGFibGVTb3J0Jykuc29ydDtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIERhdGFTb3VyY2VJbmRleGVkXG4gKi9cbnZhciBEYXRhTm9kZUdyb3VwU29ydGVyID0gQmFzZS5leHRlbmQoJ0RhdGFOb2RlR3JvdXBTb3J0ZXInLCB7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZVNvcnRlckNvbXBvc2l0ZS5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihkYXRhU291cmNlKSB7XG4gICAgICAgIHRoaXMuZGF0YVNvdXJjZSA9IGRhdGFTb3VyY2U7XG4gICAgICAgIHRoaXMuc29ydHMgPSBbXTtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZVNvcnRlckNvbXBvc2l0ZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgZ2V0Um93OiBmdW5jdGlvbih5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxhc3QuZ2V0Um93KHkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZVNvcnRlckNvbXBvc2l0ZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0gY29sdW1uSW5kZXhcbiAgICAgKiBAcGFyYW0gZGlyZWN0aW9uXG4gICAgICovXG4gICAgc29ydE9uOiBmdW5jdGlvbihjb2x1bW5JbmRleCwgZGlyZWN0aW9uKSB7XG4gICAgICAgIHRoaXMuc29ydHMucHVzaCh7IGNvbHVtbkluZGV4OiBjb2x1bW5JbmRleCwgZGlyZWN0aW9uOiBkaXJlY3Rpb24gfSk7XG4gICAgfSxcblxuICAgIHNldFNvcnRzOiBmdW5jdGlvbihzb3J0cykge1xuICAgICAgICB0aGlzLnNvcnRzID0gc29ydHMgfHwgW107XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlU29ydGVyQ29tcG9zaXRlLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGFwcGx5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5kYXRhU291cmNlLnNvcnRHcm91cHModGhpcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlU29ydGVyQ29tcG9zaXRlLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGNsZWFyU29ydHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnNvcnRzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuZGF0YVNvdXJjZS5idWlsZFZpZXcoKTtcbiAgICB9LFxuXG4gICAgc29ydEdyb3VwOiBmdW5jdGlvbihncm91cCkge1xuICAgICAgICBpZiAoIWdyb3VwLm9yaWdpbmFsT3JkZXIpIHtcbiAgICAgICAgICAgIGdyb3VwLm9yaWdpbmFsT3JkZXIgPSBncm91cC5jaGlsZHJlbi5zbGljZSgwKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc29ydHMgPSB0aGlzLnNvcnRzO1xuICAgICAgICBmb3IgKHZhciBpID0gc29ydHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIHRoaXMuc29ydEdyb3VwT25FYWNoKGdyb3VwLCBzb3J0c1tzb3J0cy5sZW5ndGggLSBpIC0gMV0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHNvcnRHcm91cE9uRWFjaDogZnVuY3Rpb24oZ3JvdXAsIHNvcnRTcGVjKSB7XG4gICAgICAgIC8vIHdlIGFjdHVhbGx5IHNvcnQgdGhlIGNoaWxkcmVuIGhlcmUuLi4uXG4gICAgICAgIHZhciBjaGlsZHJlbiA9IGdyb3VwLmNoaWxkcmVuLnNsaWNlKDApO1xuICAgICAgICB2YXIgaW5kZXhWZWN0b3IgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpbmRleFZlY3RvcltpXSA9IGk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGFibGVTb3J0KGluZGV4VmVjdG9yLCBmdW5jdGlvbihyb3dOdW1iZXIpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW3Jvd051bWJlcl07XG4gICAgICAgICAgICBpZiAoc29ydFNwZWMuY29sdW1uSW5kZXggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGQubGFiZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2hpbGQuZGF0YVtzb3J0U3BlYy5jb2x1bW5JbmRleF07XG4gICAgICAgIH0sIHNvcnRTcGVjLmRpcmVjdGlvbik7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBncm91cC5jaGlsZHJlbltpXSA9IGNoaWxkcmVuW2luZGV4VmVjdG9yW2ldXTtcbiAgICAgICAgfVxuICAgIH1cblxufSk7XG5cbkRhdGFOb2RlR3JvdXBTb3J0ZXIucHJvdG90eXBlLmFwcGx5U29ydHMgPSBmdW5jdGlvbigpIHtcbiAgICAoY29uc29sZS53YXJuIHx8IGNvbnNvbGUubG9nKS5jYWxsKGNvbnNvbGUsICdhcHBseVNvcnRzIGRlcHJlY2F0ZWQ7IHVzZSBhcHBseScpO1xuICAgIHRoaXMuYXBwbHkoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRGF0YU5vZGVHcm91cFNvcnRlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIERhdGFOb2RlQmFzZSA9IHJlcXVpcmUoJy4vRGF0YU5vZGVCYXNlJyk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBEYXRhTm9kZUJhc2VcbiAqL1xudmFyIERhdGFOb2RlTGVhZiA9IERhdGFOb2RlQmFzZS5leHRlbmQoJ0RhdGFOb2RlTGVhZicsIHtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhTm9kZUxlYWYucHJvdG90eXBlXG4gICAgICogQHBhcmFtIGRlcHRoXG4gICAgICovXG4gICAgdG9BcnJheTogZnVuY3Rpb24oZGVwdGgpIHtcbiAgICAgICAgdGhpcy5kZXB0aCA9IGRlcHRoO1xuICAgICAgICB0aGlzLmRhdGFbMF0gPSB0aGlzLmNvbXB1dGVEZXB0aFN0cmluZygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YU5vZGVMZWFmLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtudW1lcltdfVxuICAgICAqL1xuICAgIGdldEluZGV4OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhTm9kZUxlYWYucHJvdG90eXBlXG4gICAgICogQHBhcmFtIGFnZ3JlZ2F0b3JcbiAgICAgKi9cbiAgICBidWlsZFZpZXc6IGZ1bmN0aW9uKGFnZ3JlZ2F0b3IpIHtcbiAgICAgICAgYWdncmVnYXRvci5hZGRWaWV3KHRoaXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YU5vZGVMZWFmLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgY29tcHV0ZUhlaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH0sXG5cbiAgICBzb3J0V2l0aDogZnVuY3Rpb24oc29ydGVyKSB7XG4gICAgICAvLyBkbyBub3RoaW5nIHdlIGhhdmUgbm8gY2hpbGRyZW4gdG8gc29ydFxuICAgIH0sXG5cbiAgICBjbGVhckdyb3VwU29ydHM6IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gZG8gbm90aGluZyB3ZSBoYXZlIG5vIGNoaWxkcmVuIHRvIHNvcnRcbiAgICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGFOb2RlTGVhZjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIERhdGFOb2RlR3JvdXAgPSByZXF1aXJlKCcuL0RhdGFOb2RlR3JvdXAnKTtcblxuLyoqXG4gKiBTZWUge0BsaW5rIERhdGFOb2RlR3JvdXAjaW5pdGlhbGl6ZXxpbml0aWFsaXplKCl9IG1ldGhvZCBmb3IgcGFyYW1ldGVycy5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgRGF0YU5vZGVHcm91cFxuICovXG52YXIgRGF0YU5vZGVUcmVlID0gRGF0YU5vZGVHcm91cC5leHRlbmQoJ0RhdGFOb2RlVHJlZScsIHtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhTm9kZUdyb3VwLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSAwO1xuICAgICAgICB0aGlzLmV4cGFuZGVkID0gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFOb2RlR3JvdXAucHJvdG90eXBlXG4gICAgICovXG4gICAgdG9BcnJheTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuLnZhbHVlcztcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgICAgICBjaGlsZC50b0FycmF5KDApO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFOb2RlR3JvdXAucHJvdG90eXBlXG4gICAgICogQHBhcmFtIGFnZ3JlZ2F0b3JcbiAgICAgKi9cbiAgICBidWlsZFZpZXc6IGZ1bmN0aW9uKGFnZ3JlZ2F0b3IpIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgICAgICBjaGlsZC5idWlsZFZpZXcoYWdncmVnYXRvcik7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YU5vZGVHcm91cC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGNvbXB1dGVIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaGVpZ2h0ID0gMTtcblxuICAgICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgICAgIGhlaWdodCA9IGhlaWdodCArIGNoaWxkLmNvbXB1dGVIZWlnaHQoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuICh0aGlzLmhlaWdodCA9IGhlaWdodCk7XG4gICAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBEYXRhTm9kZVRyZWU7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBCYXNlID0gcmVxdWlyZSgnLi9CYXNlJyk7XG52YXIgaGVhZGVyaWZ5ID0gcmVxdWlyZSgnLi91dGlsL2hlYWRlcmlmeScpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3RbXX0gZGF0YVxuICogQHBhcmFtIHtzdHJpbmdbXX0gZmllbGRzXG4gKi9cbnZhciBEYXRhU291cmNlID0gQmFzZS5leHRlbmQoJ0RhdGFTb3VyY2UnLCB7XG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oZGF0YSwgZmllbGRzKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nW119XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZpZWxkcyA9IGZpZWxkcyB8fCBjb21wdXRlRmllbGROYW1lcyhkYXRhWzBdKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge29iamVjdFtdfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB9LFxuXG4gICAgaXNOdWxsT2JqZWN0OiBmYWxzZSxcblxuICAgIGdldERhdGFJbmRleDogZnVuY3Rpb24oeSkge1xuICAgICAgICByZXR1cm4geTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2UucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHlcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0W119XG4gICAgICovXG4gICAgZ2V0Um93OiBmdW5jdGlvbih5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFbeV07XG4gICAgfSxcblxuICAgIGZpbmRSb3c6IGZ1bmN0aW9uKGNvbHVtbk5hbWUsIHZhbHVlKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLmRhdGEuZmluZChmdW5jdGlvbihyb3cpIHsgcmV0dXJuIHJvd1tjb2x1bW5OYW1lXSA9PT0gdmFsdWU7IH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB4XG4gICAgICogQHBhcmFtIHlcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBnZXRWYWx1ZTogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICB2YXIgcm93ID0gdGhpcy5nZXRSb3coeSk7XG4gICAgICAgIGlmICghcm93KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcm93W3RoaXMuZmllbGRzW3hdXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2UucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAqL1xuICAgIHNldFZhbHVlOiBmdW5jdGlvbih4LCB5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmdldFJvdyh5KVt0aGlzLmZpZWxkc1t4XV0gPSB2YWx1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2UucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXRSb3dDb3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEubGVuZ3RoO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZS5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldENvbHVtbkNvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RmllbGRzKCkubGVuZ3RoO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZS5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyW119XG4gICAgICovXG4gICAgZ2V0RmllbGRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmllbGRzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZS5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nW119XG4gICAgICovXG4gICAgZ2V0SGVhZGVyczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0aGlzLmhlYWRlcnMgPSB0aGlzLmhlYWRlcnMgfHwgdGhpcy5nZXREZWZhdWx0SGVhZGVycygpLm1hcChmdW5jdGlvbihlYWNoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlYWRlcmlmeS50cmFuc2Zvcm0oZWFjaCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZS5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nW119XG4gICAgICovXG4gICAgZ2V0RGVmYXVsdEhlYWRlcnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRGaWVsZHMoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2UucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gZmllbGRzXG4gICAgICovXG4gICAgc2V0RmllbGRzOiBmdW5jdGlvbihmaWVsZHMpIHtcbiAgICAgICAgdGhpcy5maWVsZHMgPSBmaWVsZHM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IGhlYWRlcnNcbiAgICAgKi9cbiAgICBzZXRIZWFkZXJzOiBmdW5jdGlvbihoZWFkZXJzKSB7XG4gICAgICAgIGlmICghKGhlYWRlcnMgaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICAgICAgICAgIGVycm9yKCdzZXRIZWFkZXJzJywgJ3BhcmFtICMxIGBoZWFkZXJzYCBub3QgYXJyYXknKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhlYWRlcnMgPSBoZWFkZXJzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZS5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBnZXRHcmFuZFRvdGFsczogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vbm90aGluZyBoZXJlXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSBhcnJheU9mVW5pZm9ybU9iamVjdHNcbiAgICAgKi9cbiAgICBzZXREYXRhOiBmdW5jdGlvbihhcnJheU9mVW5pZm9ybU9iamVjdHMpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gYXJyYXlPZlVuaWZvcm1PYmplY3RzO1xuICAgIH1cbn0pO1xuXG5mdW5jdGlvbiBlcnJvcihtZXRob2ROYW1lLCBtZXNzYWdlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdEYXRhU291cmNlLicgKyBtZXRob2ROYW1lICsgJzogJyArIG1lc3NhZ2UpO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge29iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJucyB7c3RyaW5nW119XG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVGaWVsZE5hbWVzKG9iamVjdCkge1xuICAgIGlmICghb2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iamVjdCB8fCBbXSkuZmlsdGVyKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgcmV0dXJuIGUuc3Vic3RyKDAsIDIpICE9PSAnX18nO1xuICAgIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGFTb3VyY2U7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBCYXNlID0gcmVxdWlyZSgnLi9CYXNlJyk7XG52YXIgRGF0YVNvdXJjZVNvcnRlciA9IHJlcXVpcmUoJy4vRGF0YVNvdXJjZVNvcnRlcicpO1xudmFyIERhdGFOb2RlVHJlZSA9IHJlcXVpcmUoJy4vRGF0YU5vZGVUcmVlJyk7XG52YXIgRGF0YU5vZGVHcm91cCA9IHJlcXVpcmUoJy4vRGF0YU5vZGVHcm91cCcpO1xudmFyIERhdGFOb2RlTGVhZiA9IHJlcXVpcmUoJy4vRGF0YU5vZGVMZWFmJyk7XG52YXIgaGVhZGVyaWZ5ID0gcmVxdWlyZSgnLi91dGlsL2hlYWRlcmlmeScpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtEYXRhU291cmNlfSBkYXRhU291cmNlXG4gKi9cbnZhciBEYXRhU291cmNlQWdncmVnYXRvciA9IEJhc2UuZXh0ZW5kKCdEYXRhU291cmNlQWdncmVnYXRvcicsIHtcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihkYXRhU291cmNlKSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlQWdncmVnYXRvci5wcm90b3R5cGVcbiAgICAgICAgICogQHR5cGUge0RhdGFTb3VyY2V9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRhdGFTb3VyY2UgPSBkYXRhU291cmNlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUFnZ3JlZ2F0b3IucHJvdG90eXBlXG4gICAgICAgICAqIEB0eXBlIHtEYXRhTm9kZVRyZWV9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRyZWUgPSBuZXcgRGF0YU5vZGVUcmVlKCdUb3RhbHMnKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VBZ2dyZWdhdG9yLnByb3RvdHlwZVxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyW119XG4gICAgICAgICAqIEBkZWZhdWx0IFtdXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmluZGV4ID0gW107XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlQWdncmVnYXRvci5wcm90b3R5cGVcbiAgICAgICAgICogQHR5cGUge0FycmF5fVxuICAgICAgICAgKiBAZGVmYXVsdCBbXVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hZ2dyZWdhdGVzID0gW107XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlQWdncmVnYXRvci5wcm90b3R5cGVcbiAgICAgICAgICogQHR5cGUge0FycmF5fVxuICAgICAgICAgKiBAZGVmYXVsdCBbXVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ncm91cEJ5cyA9IFtdO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUFnZ3JlZ2F0b3IucHJvdG90eXBlXG4gICAgICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgICAgICogQGRlZmF1bHQgW11cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudmlldyA9IFtdO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUFnZ3JlZ2F0b3IucHJvdG90eXBlXG4gICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAqIEBkZWZhdWx0IHt9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNvcnRlckluc3RhbmNlID0ge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlQWdncmVnYXRvci5wcm90b3R5cGVcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucHJlc29ydEdyb3VwcyA9IHRydWU7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlQWdncmVnYXRvci5wcm90b3R5cGVcbiAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICogQGRlZmF1bHQge31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGFzdEFnZ3JlZ2F0ZSA9IHt9O1xuXG4gICAgICAgIHRoaXMuc2V0QWdncmVnYXRlcyh7fSk7XG4gICAgfSxcblxuICAgIGlzTnVsbE9iamVjdDogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUFnZ3JlZ2F0b3IucHJvdG90eXBlXG4gICAgICogQHBhcmFtIGFnZ3JlZ2F0aW9uc1xuICAgICAqL1xuICAgIHNldEFnZ3JlZ2F0ZXM6IGZ1bmN0aW9uKGFnZ3JlZ2F0aW9ucykge1xuICAgICAgICB0aGlzLmxhc3RBZ2dyZWdhdGUgPSBhZ2dyZWdhdGlvbnM7XG4gICAgICAgIHRoaXMuY2xlYXJBZ2dyZWdhdGlvbnMoKTtcblxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gYWdncmVnYXRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLmFkZEFnZ3JlZ2F0ZShrZXksIGFnZ3JlZ2F0aW9uc1trZXldKTtcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIGdldEZpZWxkczogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy52aWV3TWFrZXNTZW5zZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhU291cmNlLmdldEZpZWxkcygpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmaWVsZHMgPSB0aGlzLmdldEhlYWRlcnMoKS5tYXAoZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgcmV0dXJuIGUudG9Mb3dlckNhc2UoKS5zcGxpdCgnICcpLmpvaW4oJ18nKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmaWVsZHM7XG4gICAgfSxcblxuICAgIGdldEhlYWRlcnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMudmlld01ha2VzU2Vuc2UoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVNvdXJjZS5nZXRIZWFkZXJzKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGhlYWRlcnMgPSB0aGlzLmFnZ3JlZ2F0ZXMubWFwKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBlLmhlYWRlcjtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLmhhc0dyb3VwcygpKSB7XG4gICAgICAgICAgICBoZWFkZXJzLnVuc2hpZnQoJ1RyZWUnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGVhZGVycztcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlQWdncmVnYXRvci5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0gbGFiZWxcbiAgICAgKiBAcGFyYW0gZnVuY1xuICAgICAqL1xuICAgIGFkZEFnZ3JlZ2F0ZTogZnVuY3Rpb24obGFiZWwsIGZ1bmMpIHtcbiAgICAgICAgZnVuYy5oZWFkZXIgPSBoZWFkZXJpZnkudHJhbnNmb3JtKGxhYmVsKTtcbiAgICAgICAgdGhpcy5hZ2dyZWdhdGVzLnB1c2goZnVuYyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlQWdncmVnYXRvci5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0gY29sdW1uSW5kZXhBcnJheVxuICAgICAqL1xuICAgIHNldEdyb3VwQnlzOiBmdW5jdGlvbihjb2x1bW5JbmRleEFycmF5KSB7XG4gICAgICAgIHZhciBncm91cEJ5cyA9IHRoaXMuZ3JvdXBCeXM7XG4gICAgICAgIGdyb3VwQnlzLmxlbmd0aCA9IDA7XG4gICAgICAgIGNvbHVtbkluZGV4QXJyYXkuZm9yRWFjaChmdW5jdGlvbihjb2x1bW5JbmRleCkge1xuICAgICAgICAgICAgZ3JvdXBCeXMucHVzaChjb2x1bW5JbmRleCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNldEFnZ3JlZ2F0ZXModGhpcy5sYXN0QWdncmVnYXRlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VBZ2dyZWdhdG9yLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSBpbmRleFxuICAgICAqL1xuICAgIGFkZEdyb3VwQnk6IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgIHRoaXMuZ3JvdXBCeXMucHVzaChpbmRleCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlQWdncmVnYXRvci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBoYXNHcm91cHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLmdyb3VwQnlzLmxlbmd0aDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VBZ2dyZWdhdG9yLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGhhc0FnZ3JlZ2F0ZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLmFnZ3JlZ2F0ZXMubGVuZ3RoO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUFnZ3JlZ2F0b3IucHJvdG90eXBlXG4gICAgICovXG4gICAgYXBwbHk6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmJ1aWxkR3JvdXBUcmVlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlQWdncmVnYXRvci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBjbGVhckdyb3VwczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZ3JvdXBCeXMubGVuZ3RoID0gMDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VBZ2dyZWdhdG9yLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGNsZWFyQWdncmVnYXRpb25zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5hZ2dyZWdhdGVzLmxlbmd0aCA9IDA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlQWdncmVnYXRvci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBidWlsZEdyb3VwVHJlZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZXZlcnNlZEdyb3VwQnlzID0gdGhpcy5ncm91cEJ5cy5zbGljZSgwKS5yZXZlcnNlKCksXG4gICAgICAgICAgICBsZWFmRGVwdGggPSB0aGlzLmdyb3VwQnlzLmxlbmd0aCAtIDEsXG4gICAgICAgICAgICBzb3VyY2UgPSB0aGlzLmRhdGFTb3VyY2UsXG4gICAgICAgICAgICByb3dDb3VudCA9IHNvdXJjZS5nZXRSb3dDb3VudCgpLFxuICAgICAgICAgICAgdHJlZSA9IHRoaXMudHJlZSA9IG5ldyBEYXRhTm9kZVRyZWUoJ1RvdGFscycpO1xuXG4gICAgICAgIC8vIGZpcnN0IHNvcnQgZGF0YVxuICAgICAgICBpZiAodGhpcy5wcmVzb3J0R3JvdXBzKSB7XG4gICAgICAgICAgICByZXZlcnNlZEdyb3VwQnlzLmZvckVhY2goZnVuY3Rpb24oZ3JvdXBCeSkge1xuICAgICAgICAgICAgICAgIHNvdXJjZSA9IG5ldyBEYXRhU291cmNlU29ydGVyKHNvdXJjZSk7XG4gICAgICAgICAgICAgICAgc291cmNlLnNvcnRPbihncm91cEJ5KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgciA9IDA7IHIgPCByb3dDb3VudDsgcisrKSB7XG4gICAgICAgICAgICB2YXIgcGF0aCA9IHRyZWU7XG5cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBCeXMuZm9yRWFjaChmdW5jdGlvbihnLCBjKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbG9vcC1mdW5jXG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IHNvdXJjZS5nZXRWYWx1ZShnLCByKSxcbiAgICAgICAgICAgICAgICAgICAgZmFjdG9yeURhdGFOb2RlID0gKGMgPT09IGxlYWZEZXB0aCkgPyBmYWN0b3J5RGF0YU5vZGVMZWFmIDogZmFjdG9yeURhdGFOb2RlR3JvdXA7XG4gICAgICAgICAgICAgICAgcGF0aCA9IHBhdGguY2hpbGRyZW4uZ2V0SWZVbmRlZmluZWQoa2V5LCBmYWN0b3J5RGF0YU5vZGUpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHBhdGguaW5kZXgucHVzaChyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc29ydGVySW5zdGFuY2UgPSBuZXcgRGF0YVNvdXJjZVNvcnRlcihzb3VyY2UpO1xuICAgICAgICB0cmVlLnRvQXJyYXkoKTtcbiAgICAgICAgdHJlZS5jb21wdXRlQWdncmVnYXRlcyh0aGlzKTtcbiAgICAgICAgdGhpcy5idWlsZFZpZXcoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VBZ2dyZWdhdG9yLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSBkYXRhTm9kZVxuICAgICAqL1xuICAgIGFkZFZpZXc6IGZ1bmN0aW9uKGRhdGFOb2RlKSB7XG4gICAgICAgIHRoaXMudmlldy5wdXNoKGRhdGFOb2RlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VBZ2dyZWdhdG9yLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGJ1aWxkVmlldzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMudmlldy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLnRyZWUuY29tcHV0ZUhlaWdodCgpO1xuICAgICAgICB0aGlzLnRyZWUuYnVpbGRWaWV3KHRoaXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUFnZ3JlZ2F0b3IucHJvdG90eXBlXG4gICAgICogQHJldHVybnMgeyp8Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB2aWV3TWFrZXNTZW5zZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhc0FnZ3JlZ2F0ZXMoKSAmJiB0aGlzLmhhc0dyb3VwcygpO1xuICAgIH0sXG5cbiAgICBnZXREYXRhSW5kZXg6IGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld01ha2VzU2Vuc2UoKSA/IHkgOiB0aGlzLmRhdGFTb3VyY2UuZ2V0RGF0YUluZGV4KHkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUFnZ3JlZ2F0b3IucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHhcbiAgICAgKiBAcGFyYW0geVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGdldFZhbHVlOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIGlmICghdGhpcy52aWV3TWFrZXNTZW5zZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhU291cmNlLmdldFZhbHVlKHgsIHkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByb3cgPSB0aGlzLnZpZXdbeV07XG4gICAgICAgIHJldHVybiByb3cgPyByb3cuZ2V0VmFsdWUoeCkgOiBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUFnZ3JlZ2F0b3IucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHhcbiAgICAgKiBAcGFyYW0geVxuICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIHNldFZhbHVlOiBmdW5jdGlvbih4LCB5LCB2YWx1ZSkge1xuICAgICAgICBpZiAoIXRoaXMudmlld01ha2VzU2Vuc2UoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVNvdXJjZS5zZXRWYWx1ZSh4LCB5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VBZ2dyZWdhdG9yLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGdldENvbHVtbkNvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZpZXdNYWtlc1NlbnNlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFTb3VyY2UuZ2V0Q29sdW1uQ291bnQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5nZXRIZWFkZXJzKCkubGVuZ3RoO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUFnZ3JlZ2F0b3IucHJvdG90eXBlXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZ2V0Um93Q291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMudmlld01ha2VzU2Vuc2UoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVNvdXJjZS5nZXRSb3dDb3VudCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXcubGVuZ3RoOyAvL2hlYWRlciBjb2x1bW5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VBZ2dyZWdhdG9yLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB5XG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZXhwYW5kXSAtIE9uZSBvZjpcbiAgICAgKiAqIGB0cnVlYCAtIEV4cGFuZCBhbGwgcm93cyB0aGF0IGFyZSBjdXJyZW50bHkgY29sbGFwc2VkLlxuICAgICAqICogYGZhbHNlYCAtIENvbGxhcHNlIGFsbCByb3dzIHRoYXQgYXJlIGN1cnJlbnRseSBleHBhbmRlZC5cbiAgICAgKiAqIGB1bmRlZmluZWRgIChvciBvbWl0dGVkKSAtIEV4cGFuZCBhbGwgY3VycmVudGx5IGNvbGxhcHNlZCByb3dzOyBjb2xsYXBzZSBhbGwgY3VycmVudGx5IGV4cGFuZGVkIHJvd3MuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtkZXB0aD1JbmZpbml0eV0gLSBPbmUgb2Y6XG4gICAgICogKiBudW1iZXIgPiAwIC0gQXBwbHkgb25seSBpZiByb3cgZGVwdGggaXMgYWJvdmUgdGhlIGdpdmVuIGRlcHRoLlxuICAgICAqICogbnVtYmVyIDw9IDAgLSBBcHBseSBvbmx5IGlmIHJvdyBkZXB0aCBpcyBiZWxvdyB0aGUgZ2l2ZW4gZGVwdGguXG4gICAgICogQHJldHVybnMge3VuZGVmaW5lZHxib29sZWFufSBPbmUgb2Y6XG4gICAgICogKiBgdW5kZWZpbmVkYCAtIHJvdyB3YXMgbm90IGV4cGFuZGFibGVcbiAgICAgKiAqIGB0cnVlYCAtIHJvdyB3YXMgZXhwYW5kYWJsZSBfYW5kXyBzdGF0ZSBjaGFuZ2VkXG4gICAgICogKiBgZmFsc2VgIC0gcm93IHdhcyBleHBhbmRhYmxlIF9idXRfIHN0YXRlIGRpZCBfbm90XyBjaGFuZ2VcbiAgICAgKi9cbiAgICBjbGljazogZnVuY3Rpb24oeSwgZXhwYW5kLCBkZXB0aCkge1xuICAgICAgICBpZiAoIXRoaXMudmlld01ha2VzU2Vuc2UoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVNvdXJjZS5jbGljay5hcHBseSh0aGlzLmRhdGFTb3VyY2UsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGdyb3VwID0gdGhpcy52aWV3W3ldLCBleHBhbmRhYmxlLCBjaGFuZ2VkO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICBncm91cCAmJiAoXG4gICAgICAgICAgICAgICAgZGVwdGggPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgICAgIGRlcHRoID4gMCAmJiBncm91cC5kZXB0aCA8IGRlcHRoIHx8XG4gICAgICAgICAgICAgICAgZGVwdGggPD0gMCAmJiBncm91cC5kZXB0aCA+PSAtZGVwdGhcbiAgICAgICAgICAgIClcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBjaGFuZ2VkID0gZ3JvdXAudG9nZ2xlRXhwYW5zaW9uU3RhdGUodGhpcywgZXhwYW5kKTtcbiAgICAgICAgICAgIGlmICgoZXhwYW5kYWJsZSA9IGdyb3VwLmNoaWxkcmVuKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYnVpbGRWaWV3KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXhwYW5kYWJsZSA/IGNoYW5nZWQgOiB1bmRlZmluZWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlQWdncmVnYXRvci5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0gaGVhZGVyc1xuICAgICAqL1xuICAgIHNldEhlYWRlcnM6IGZ1bmN0aW9uKGhlYWRlcnMpIHtcbiAgICAgICAgdGhpcy5kYXRhU291cmNlLnNldEhlYWRlcnMoaGVhZGVycyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlQWdncmVnYXRvci5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0gZmllbGRzXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgc2V0RmllbGRzOiBmdW5jdGlvbihmaWVsZHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVNvdXJjZS5zZXRGaWVsZHMoZmllbGRzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VBZ2dyZWdhdG9yLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtvYmplY3RbXX1cbiAgICAgKi9cbiAgICBnZXRHcmFuZFRvdGFsczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2aWV3ID0gdGhpcy50cmVlO1xuICAgICAgICByZXR1cm4gW3ZpZXcuZGF0YV07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlQWdncmVnYXRvci5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0geVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGdldFJvdzogZnVuY3Rpb24oeSkge1xuICAgICAgICBpZiAoIXRoaXMudmlld01ha2VzU2Vuc2UoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVNvdXJjZS5nZXRSb3coeSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcm9sbHVwcyA9IHRoaXMudmlld1t5XTtcblxuICAgICAgICByZXR1cm4gcm9sbHVwcyA/IHJvbGx1cHMgOiB0aGlzLnRyZWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlQWdncmVnYXRvci5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0gYXJyYXlPZlVuaWZvcm1PYmplY3RzXG4gICAgICovXG4gICAgc2V0RGF0YTogZnVuY3Rpb24oYXJyYXlPZlVuaWZvcm1PYmplY3RzKSB7XG4gICAgICAgIHRoaXMuZGF0YVNvdXJjZS5zZXREYXRhKGFycmF5T2ZVbmlmb3JtT2JqZWN0cyk7XG4gICAgICAgIHRoaXMuYXBwbHkoKTtcbiAgICB9LFxuXG4gICAgc29ydEdyb3VwczogZnVuY3Rpb24oZ3JvdXBTb3J0ZXIpIHtcbiAgICAgICAgdGhpcy50cmVlLmNsZWFyR3JvdXBTb3J0cygpO1xuICAgICAgICB0aGlzLnRyZWUuc29ydFdpdGgoZ3JvdXBTb3J0ZXIpO1xuICAgICAgICB0aGlzLmJ1aWxkVmlldygpO1xuICAgIH1cbn0pO1xuXG5mdW5jdGlvbiBmYWN0b3J5RGF0YU5vZGVMZWFmKGtleSkge1xuICAgIHJldHVybiBuZXcgRGF0YU5vZGVMZWFmKGtleSk7XG59XG5cbmZ1bmN0aW9uIGZhY3RvcnlEYXRhTm9kZUdyb3VwKGtleSkge1xuICAgIHJldHVybiBuZXcgRGF0YU5vZGVHcm91cChrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGFTb3VyY2VBZ2dyZWdhdG9yO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRGF0YVNvdXJjZUluZGV4ZWQgPSByZXF1aXJlKCcuL0RhdGFTb3VyY2VJbmRleGVkJyk7XG5cbi8qKlxuICogQHR5cGVkZWYge2Z1bmN0aW9ufSBmaWx0ZXJGdW5jdGlvblxuICogQHBhcmFtIGNlbGxWYWx1ZVxuICogQHBhcmFtIHtvYmplY3R9IHJvd09iamVjdCAtIFJlZmVyZW5jZSB0byBgdGhpcy5kYXRhU291cmNlLmRhdGFbcl1gLlxuICogQHBhcmFtIHtudW1iZXJ9IHIgLSBSb3cgbnVtYmVyIChpbmRleCB3aXRoaW4gYHRoaXMuZGF0YVNvdXJjZS5kYXRhYCkuXG4gKi9cblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIERhdGFTb3VyY2VJbmRleGVkXG4gKi9cbnZhciBEYXRhU291cmNlR2xvYmFsRmlsdGVyID0gRGF0YVNvdXJjZUluZGV4ZWQuZXh0ZW5kKCdEYXRhU291cmNlR2xvYmFsRmlsdGVyJywge1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUdsb2JhbEZpbHRlci5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW2ZpbHRlcl0gLSBJZiB1bmRlZmluZWQsIGRlbGV0ZXMgZmlsdGVyLlxuICAgICAqL1xuICAgIHNldDogZnVuY3Rpb24oZmlsdGVyKSB7XG4gICAgICAgIGlmIChmaWx0ZXIpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHR5cGUge2ZpbHRlckZ1bmN0aW9ufVxuICAgICAgICAgICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VHbG9iYWxGaWx0ZXIucHJvdG90eXBlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuZmlsdGVyID0gZmlsdGVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuZmlsdGVyO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGdldDogZnVuY3Rpb24oZmlsdGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbHRlcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUdsb2JhbEZpbHRlci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBhcHBseTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5maWx0ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuY2xlYXJJbmRleCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5idWlsZEluZGV4KGZ1bmN0aW9uIGFwcGx5RmlsdGVyKHIsIHJvd09iamVjdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbHRlci50ZXN0KHJvd09iamVjdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlR2xvYmFsRmlsdGVyLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0Um93Q291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXIgPyB0aGlzLmluZGV4Lmxlbmd0aCA6IHRoaXMuZGF0YVNvdXJjZS5nZXRSb3dDb3VudCgpO1xuICAgIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGFTb3VyY2VHbG9iYWxGaWx0ZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBCYXNlID0gcmVxdWlyZSgnLi9CYXNlJyk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBEYXRhU291cmNlSW5kZXhlZCA9IEJhc2UuZXh0ZW5kKCdEYXRhU291cmNlSW5kZXhlZCcsIHtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgaXNOdWxsT2JqZWN0OiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlSW5kZXhlZC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0gZGF0YVNvdXJjZVxuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKGRhdGFTb3VyY2UpIHtcbiAgICAgICAgdGhpcy5kYXRhU291cmNlID0gZGF0YVNvdXJjZTtcbiAgICAgICAgdGhpcy5pbmRleCA9IFtdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUluZGV4ZWQucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHlcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICB0cmFuc3Bvc2VZOiBmdW5jdGlvbih5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluZGV4Lmxlbmd0aCA/IHRoaXMuaW5kZXhbeV0gOiB5O1xuICAgIH0sXG5cbiAgICBnZXREYXRhSW5kZXg6IGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVNvdXJjZS5nZXREYXRhSW5kZXgodGhpcy50cmFuc3Bvc2VZKHkpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VJbmRleGVkLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB5XG4gICAgICogQHJldHVybnMge29iamVjdH1cbiAgICAgKi9cbiAgICBnZXRSb3c6IGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVNvdXJjZS5nZXRSb3codGhpcy50cmFuc3Bvc2VZKHkpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VJbmRleGVkLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB4XG4gICAgICogQHBhcmFtIHlcbiAgICAgKiBAcmV0dXJucyB7KnxNaXhlZH1cbiAgICAgKi9cbiAgICBnZXRWYWx1ZTogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhU291cmNlLmdldFZhbHVlKHgsIHRoaXMudHJhbnNwb3NlWSh5KSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlSW5kZXhlZC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqL1xuICAgIHNldFZhbHVlOiBmdW5jdGlvbih4LCB5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmRhdGFTb3VyY2Uuc2V0VmFsdWUoeCwgdGhpcy50cmFuc3Bvc2VZKHkpLCB2YWx1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlSW5kZXhlZC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfCp9XG4gICAgICovXG4gICAgZ2V0Um93Q291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbmRleC5sZW5ndGggfHwgdGhpcy5kYXRhU291cmNlLmdldFJvd0NvdW50KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZ2V0Q29sdW1uQ291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhU291cmNlLmdldENvbHVtbkNvdW50KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlSW5kZXhlZC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBnZXRGaWVsZHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhU291cmNlLmdldEZpZWxkcygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUluZGV4ZWQucHJvdG90eXBlXG4gICAgICogQHBhcmFtIGZpZWxkc1xuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIHNldEZpZWxkczogZnVuY3Rpb24oZmllbGRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFTb3VyY2Uuc2V0RmllbGRzKGZpZWxkcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlSW5kZXhlZC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBoZWFkZXJzXG4gICAgICogQHJldHVybnMge3N0cmluZ1tdfVxuICAgICAqL1xuICAgIHNldEhlYWRlcnM6IGZ1bmN0aW9uKGhlYWRlcnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVNvdXJjZS5zZXRIZWFkZXJzKGhlYWRlcnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmdbXX1cbiAgICAgKi9cbiAgICBnZXRIZWFkZXJzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVNvdXJjZS5nZXRIZWFkZXJzKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlSW5kZXhlZC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBnZXRHcmFuZFRvdGFsczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFTb3VyY2UuZ2V0R3JhbmRUb3RhbHMoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VJbmRleGVkLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0W119IGFycmF5T2ZVbmlmb3JtT2JqZWN0c1xuICAgICAqIEByZXR1cm5zIHtvYmplY3RbXX1cbiAgICAgKi9cbiAgICBzZXREYXRhOiBmdW5jdGlvbihhcnJheU9mVW5pZm9ybU9iamVjdHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVNvdXJjZS5zZXREYXRhKGFycmF5T2ZVbmlmb3JtT2JqZWN0cyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlSW5kZXhlZC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBjbGVhckluZGV4OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5pbmRleC5sZW5ndGggPSAwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUluZGV4ZWQucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtmaWx0ZXJQcmVkaWNhdGV9IHByZWRpY2F0ZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJbXX1cbiAgICAgKi9cbiAgICBidWlsZEluZGV4OiBmdW5jdGlvbihwcmVkaWNhdGUpIHtcbiAgICAgICAgdmFyIHJvd0NvdW50ID0gdGhpcy5kYXRhU291cmNlLmdldFJvd0NvdW50KCksXG4gICAgICAgICAgICBpbmRleCA9IHRoaXMuaW5kZXg7XG5cbiAgICAgICAgdGhpcy5jbGVhckluZGV4KCk7XG5cbiAgICAgICAgZm9yICh2YXIgciA9IDA7IHIgPCByb3dDb3VudDsgcisrKSB7XG4gICAgICAgICAgICBpZiAoIXByZWRpY2F0ZSB8fCBwcmVkaWNhdGUuY2FsbCh0aGlzLCByLCB0aGlzLmRhdGFTb3VyY2UuZ2V0Um93KHIpKSkge1xuICAgICAgICAgICAgICAgIGluZGV4LnB1c2gocik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxufSk7XG5cbi8qKiBAdHlwZWRlZiB7ZnVuY3Rpb259IGZpbHRlclByZWRpY2F0ZVxuICogQHN1bW1hcnkgQXBwbGllcyBmaWx0ZXIgdG8gZ2l2ZW4gcm93LlxuICogQHBhcmFtIHtudWJtZXJ9IHIgLSBSb3cgaW5kZXggb2Ygcm93IGRhdGEgd2l0aGluIHJvd3MgYXJyYXkgYHRoaXMuZGF0YVNvdXJjZS5kYXRhW11gLlxuICogQHBhcmFtIHtvYmplY3R9IHJvd09iamVjdCAtIFJvdyBkYXRhOyBlbGVtZW50IG9mIGB0aGlzLmRhdGFTb3VyY2UuZGF0YVtdYC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSb3cgcXVhbGlmaWVzIChwYXNzZXMgdGhyb3VnaCBmaWx0ZXIpLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gRGF0YVNvdXJjZUluZGV4ZWQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBEYXRhU291cmNlSW5kZXhlZCA9IHJlcXVpcmUoJy4vRGF0YVNvdXJjZUluZGV4ZWQnKTtcbnZhciBzdGFibGVTb3J0ID0gcmVxdWlyZSgnLi91dGlsL3N0YWJsZVNvcnQnKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIERhdGFTb3VyY2VJbmRleGVkXG4gKi9cbnZhciBEYXRhU291cmNlU29ydGVyID0gRGF0YVNvdXJjZUluZGV4ZWQuZXh0ZW5kKCdEYXRhU291cmNlU29ydGVyJywge1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VTb3J0ZXIucHJvdG90eXBlXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZVNvcnRlci5wcm90b3R5cGVcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRlc2NlbmRpbmdTb3J0ID0gZmFsc2U7IC8vIFRPRE86IHRoaXMgZG9lcyBub3Qgc2VlbSB0byBiZSBpbiB1c2VcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VTb3J0ZXIucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbHVtbkluZGV4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtkaXJlY3Rpb249MV1cbiAgICAgKi9cbiAgICBzb3J0T246IGZ1bmN0aW9uKGNvbHVtbkluZGV4LCBkaXJlY3Rpb24pIHtcbiAgICAgICAgdmFyIGRhdGFTb3VyY2UgPSB0aGlzLmRhdGFTb3VyY2UsXG4gICAgICAgICAgICBjb2x1bW5OYW1lID0gZGF0YVNvdXJjZS5nZXRGaWVsZHMoKVtjb2x1bW5JbmRleF07XG5cbiAgICAgICAgc3dpdGNoIChkaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFySW5kZXgoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBjYXNlIC0xOlxuICAgICAgICAgICAgICAgIHN0YWJsZVNvcnQuc29ydCh0aGlzLmJ1aWxkSW5kZXgoKSwgZ2V0VmFsdWUsIGRpcmVjdGlvbik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZXRWYWx1ZShyb3dJZHgpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWxPckZ1bmMoZGF0YVNvdXJjZS5nZXRSb3cocm93SWR4KSwgY29sdW1uTmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfGZ1bmN0aW9ufSB2YWxPckZ1bmNcbiAqIEByZXR1cm5zIHsqfVxuICovXG5mdW5jdGlvbiB2YWxPckZ1bmMoZGF0YVJvdywgY29sdW1uTmFtZSkge1xuICAgIHZhciB2ZiA9IGRhdGFSb3dbY29sdW1uTmFtZV07XG4gICAgcmV0dXJuICh0eXBlb2YgdmYpWzBdID09PSAnZicgPyB2ZihkYXRhUm93LCBjb2x1bW5OYW1lKSA6IHZmO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGFTb3VyY2VTb3J0ZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBEYXRhU291cmNlSW5kZXhlZCA9IHJlcXVpcmUoJy4vRGF0YVNvdXJjZUluZGV4ZWQnKTtcbnZhciBEYXRhU291cmNlU29ydGVyID0gcmVxdWlyZSgnLi9EYXRhU291cmNlU29ydGVyJyk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBEYXRhU291cmNlSW5kZXhlZFxuICovXG52YXIgRGF0YVNvdXJjZVNvcnRlckNvbXBvc2l0ZSA9IERhdGFTb3VyY2VJbmRleGVkLmV4dGVuZCgnRGF0YVNvdXJjZVNvcnRlckNvbXBvc2l0ZScsIHtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlU29ydGVyQ29tcG9zaXRlLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2F2ZWF0czpcbiAgICAgICAgICpcbiAgICAgICAgICogMS4gQ29sdW1ucyBzaG91bGQgYmUgdW5pcXVlbHkgcmVwcmVzZW50ZWQgKGkuZS4sIG5vIHJlcGVhdHMgd2l0aCBzYW1lIGNvbHVtbkluZGV4KVxuICAgICAgICAgKiAyLiBDb2x1bW5zIHNob3VsZCBiZSBhZGRlZCBsb3ctIHRvIGhpZ2gtb3JkZXIgKGkuZS4sIG1vc3QgZ3JvdXBlZCBjb2x1bW5zIGNvbWUgbGFzdClcbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge251bWJlcltdfVxuICAgICAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZVNvcnRlckNvbXBvc2l0ZS5wcm90b3R5cGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc29ydHMgPSBbXTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge0RhdGFTb3VyY2V9XG4gICAgICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlU29ydGVyQ29tcG9zaXRlLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5sYXN0ID0gdGhpcy5kYXRhU291cmNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZVNvcnRlckNvbXBvc2l0ZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgZ2V0Um93OiBmdW5jdGlvbih5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxhc3QuZ2V0Um93KHkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZVNvcnRlckNvbXBvc2l0ZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0gY29sdW1uSW5kZXhcbiAgICAgKiBAcGFyYW0gZGlyZWN0aW9uXG4gICAgICovXG4gICAgc29ydE9uOiBmdW5jdGlvbihjb2x1bW5JbmRleCwgZGlyZWN0aW9uKSB7XG4gICAgICAgIHRoaXMuc29ydHMucHVzaCh7IGNvbHVtbkluZGV4OiBjb2x1bW5JbmRleCwgZGlyZWN0aW9uOiBkaXJlY3Rpb24gfSk7XG4gICAgfSxcblxuICAgIHNldFNvcnRzOiBmdW5jdGlvbihzb3J0cykge1xuICAgICAgICB0aGlzLnNvcnRzID0gc29ydHMgfHwgW107XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlU29ydGVyQ29tcG9zaXRlLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGFwcGx5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGVhY2ggPSB0aGlzLmRhdGFTb3VyY2U7XG5cbiAgICAgICAgdGhpcy5zb3J0cy5mb3JFYWNoKGZ1bmN0aW9uKHNvcnRTcGVjKSB7XG4gICAgICAgICAgICBlYWNoID0gbmV3IERhdGFTb3VyY2VTb3J0ZXIoZWFjaCk7XG4gICAgICAgICAgICBlYWNoLnNvcnRPbihzb3J0U3BlYy5jb2x1bW5JbmRleCwgc29ydFNwZWMuZGlyZWN0aW9uKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5sYXN0ID0gZWFjaDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VTb3J0ZXJDb21wb3NpdGUucHJvdG90eXBlXG4gICAgICovXG4gICAgY2xlYXJTb3J0czogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc29ydHMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5sYXN0ID0gdGhpcy5kYXRhU291cmNlO1xuICAgIH0sXG5cbiAgICBnZXREYXRhSW5kZXg6IGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGFzdC5nZXREYXRhSW5kZXgoeSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlU29ydGVyQ29tcG9zaXRlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBnZXRWYWx1ZTogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5sYXN0LmdldFZhbHVlKHgsIHkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZVNvcnRlckNvbXBvc2l0ZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqL1xuICAgIHNldFZhbHVlOiBmdW5jdGlvbih4LCB5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmxhc3Quc2V0VmFsdWUoeCwgeSwgdmFsdWUpO1xuICAgIH1cbn0pO1xuXG5EYXRhU291cmNlU29ydGVyQ29tcG9zaXRlLnByb3RvdHlwZS5hcHBseVNvcnRzID0gZnVuY3Rpb24oKSB7XG4gICAgKGNvbnNvbGUud2FybiB8fCBjb25zb2xlLmxvZykuY2FsbChjb25zb2xlLCAnYXBwbHlTb3J0cyBkZXByZWNhdGVkOyB1c2UgYXBwbHknKTtcbiAgICB0aGlzLmFwcGx5KCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGFTb3VyY2VTb3J0ZXJDb21wb3NpdGU7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBEYXRhU291cmNlSW5kZXhlZCA9IHJlcXVpcmUoJy4vRGF0YVNvdXJjZUluZGV4ZWQnKTtcblxudmFyIGV4cGFuZGVkTWFwID0ge1xuICAgIHRydWU6ICdcXHUyNWJjICcsIC8vIEJMQUNLIERPV04tUE9JTlRJTkcgVFJJQU5HTEUgYWthICfilrwnXG4gICAgZmFsc2U6ICdcXHUyNWI2ICcsIC8vIEJMQUNLIFJJR0hULVBPSU5USU5HIFRSSUFOR0xFIGFrYSAn4pa2J1xuICAgIHVuZGVmaW5lZDogJyAgJyAvLyBmb3IgbGVhZiByb3dzXG59O1xuXG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBEYXRhU291cmNlSW5kZXhlZFxuICovXG52YXIgRGF0YVNvdXJjZVRyZWV2aWV3ID0gRGF0YVNvdXJjZUluZGV4ZWQuZXh0ZW5kKCdEYXRhU291cmNlVHJlZXZpZXcnLCB7XG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBUb2dnbGUgdGhlIHRyZWUtdmlldy5cbiAgICAgKiBAZGVzYyBDYWxjdWxhdGVzIG9yIHJlY2FsY3VsYXRlcyBuZXN0aW5nIGRlcHRoIG9mIGVhY2ggcm93IGFuZCBtYXJrcyBpdCBhcyBleHBhbmRhYmxlIGlmIGl0IGhhcyBjaGlsZHJlbi5cbiAgICAgKlxuICAgICAqIElmIHJlc2V0dGluZyBwcmV2aW91c2x5IHNldCBkYXRhLCB0aGUgc3RhdGUgb2YgZXhwYW5zaW9uIG9mIGFsbCByb3dzIHRoYXQgc3RpbGwgaGF2ZSBjaGlsZHJlbiBpcyByZXRhaW5lZC5cbiAgICAgKlxuICAgICAqIEFsbCB0aHJlZSBuYW1lZCBjb2x1bW5zIG11c3QgZXhpc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW58b2JqZWN0fSBbb3B0aW9uc10gLSBUdXJuIHRyZWUtdmlldyAqKk9OKiouIElmIGZhbHN5IChvciBvbWl0dGVkKSwgdHVybiBpdCAqKk9GRioqLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5pZENvbHVtbk5hbWU9J0lEJ10gLSBDb2x1bW4gbmFtZSBvZiB0aGUgcHJpbWFyeSBrZXkgY29sdW1uLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wYXJlbnRJZENvbHVtbk5hbWU9J3BhcmVudElEJ10gLSBDb2x1bW4gbmFtZSBvZiB0aGUgZm9yZWlnbiBrZXkgY29sdW1uIGZvciBncm91cGluZy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMudHJlZUNvbHVtbk5hbWU9J25hbWUnXSAtIENvbHVtbiBuYW1lIG9mIHRoZSBkcmlsbC1kb3duIGNvbHVtbiB0byBkZWNvcmF0ZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gSm9pbmVkIHN0YXRlLlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlVHJlZXZpZXcucHJvdG90eXBlXG4gICAgICovXG4gICAgc2V0UmVsYXRpb246IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGlkQ29sdW1uTmFtZSwgcGFyZW50SWRDb2x1bW5OYW1lLCB0cmVlQ29sdW1uTmFtZSwgZmllbGRzLFxuICAgICAgICAgICAgcm93Q291bnQsIHIsIHBhcmVudElELCBkZXB0aCwgbGVhZlJvdywgcm93LCBJRDtcblxuICAgICAgICB0aGlzLmpvaW5lZCA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgICBmaWVsZHMgPSB0aGlzLmdldEZpZWxkcygpO1xuICAgICAgICAgICAgaWRDb2x1bW5OYW1lID0gb3B0aW9ucy5pZENvbHVtbk5hbWUgfHwgJ0lEJztcbiAgICAgICAgICAgIHBhcmVudElkQ29sdW1uTmFtZSA9IG9wdGlvbnMucGFyZW50SWRDb2x1bW5OYW1lIHx8ICdwYXJlbnRJRCc7XG4gICAgICAgICAgICB0cmVlQ29sdW1uTmFtZSA9IG9wdGlvbnMudHJlZUNvbHVtbk5hbWUgfHwgJ25hbWUnO1xuXG4gICAgICAgICAgICBpZiAoIC8vIGFsbCB0aHJlZSBjb2x1bW5zIG11c3QgZXhpc3RcbiAgICAgICAgICAgICAgICBmaWVsZHMuaW5kZXhPZihpZENvbHVtbk5hbWUpID49IDAgJiZcbiAgICAgICAgICAgICAgICBmaWVsZHMuaW5kZXhPZihwYXJlbnRJZENvbHVtbk5hbWUpID49IDAgJiZcbiAgICAgICAgICAgICAgICBmaWVsZHMuaW5kZXhPZih0cmVlQ29sdW1uTmFtZSkgPj0gMFxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pZENvbHVtbk5hbWUgPSBpZENvbHVtbk5hbWU7XG4gICAgICAgICAgICAgICAgdGhpcy5pZENvbHVtbkluZGV4ID0gZmllbGRzLmluZGV4T2YoaWRDb2x1bW5OYW1lKTtcblxuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50SWRDb2x1bW5OYW1lID0gcGFyZW50SWRDb2x1bW5OYW1lO1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50SWRDb2x1bW5JbmRleCA9IGZpZWxkcy5pbmRleE9mKHBhcmVudElkQ29sdW1uTmFtZSk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLnRyZWVDb2x1bW5OYW1lID0gdHJlZUNvbHVtbk5hbWU7XG4gICAgICAgICAgICAgICAgdGhpcy50cmVlQ29sdW1uSW5kZXggPSBmaWVsZHMuaW5kZXhPZih0cmVlQ29sdW1uTmFtZSk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmpvaW5lZCA9IHRoaXMudHJlZUNvbHVtbkluZGV4ICE9PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmJ1aWxkSW5kZXgoKTsgLy8gbWFrZSBhbGwgcm93cyB2aXNpYmxlIHRvIGdldFJvdygpXG5cbiAgICAgICAgaWYgKHRoaXMuam9pbmVkKSB7XG4gICAgICAgICAgICAvLyBtdXRhdGUgZGF0YSByb3cgd2l0aCBfX0RFUFRIIChhbGwgcm93cykgYW5kIF9fRVhQQU5ERUQgKGFsbCBcInBhcmVudFwiIHJvd3MpXG4gICAgICAgICAgICByb3dDb3VudCA9IHRoaXMuZ2V0Um93Q291bnQoKTtcbiAgICAgICAgICAgIHIgPSByb3dDb3VudDtcbiAgICAgICAgICAgIHdoaWxlIChyLS0pIHtcbiAgICAgICAgICAgICAgICBkZXB0aCA9IDA7XG4gICAgICAgICAgICAgICAgbGVhZlJvdyA9IHRoaXMuZ2V0Um93KHIpO1xuICAgICAgICAgICAgICAgIHJvdyA9IGxlYWZSb3c7XG4gICAgICAgICAgICAgICAgSUQgPSByb3dbaWRDb2x1bW5OYW1lXTtcblxuICAgICAgICAgICAgICAgIHdoaWxlICgocGFyZW50SUQgPSByb3dbcGFyZW50SWRDb2x1bW5OYW1lXSkgIT0gdW5kZWZpbmVkKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgICAgICAgICAgICAgICAgIHJvdyA9IHRoaXMuZmluZFJvdyhpZENvbHVtbk5hbWUsIHBhcmVudElEKTtcbiAgICAgICAgICAgICAgICAgICAgKytkZXB0aDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBsZWFmUm93Ll9fREVQVEggPSBkZXB0aDtcblxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5maW5kUm93KHBhcmVudElkQ29sdW1uTmFtZSwgSUQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBsZWFmUm93Ll9fRVhQQU5ERUQ7IC8vIG5vIGxvbmdlciBleHBhbmRhYmxlXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsZWFmUm93Ll9fRVhQQU5ERUQgPT09IHVuZGVmaW5lZCkgeyAvLyByZXRhaW4gcHJldmlvdXMgc2V0dGluZyBmb3Igb2xkIHJvd3NcbiAgICAgICAgICAgICAgICAgICAgbGVhZlJvdy5fX0VYUEFOREVEID0gZmFsc2U7IC8vIGRlZmF1bHQgZm9yIG5ldyByb3cgaXMgdW5leHBhbmRlZFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmpvaW5lZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VUcmVldmlldy5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBhcHBseTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLnZpZXdNYWtlc1NlbnNlKCkpIHtcbiAgICAgICAgICAgIHRoaXMuYnVpbGRJbmRleCh0aGlzLnRyZWVDb2x1bW5JbmRleCA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogY29sbGFwc2VSb3dzKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0geFxuICAgICAqIEBwYXJhbSB5XG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VUcmVldmlldy5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBnZXRWYWx1ZTogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBEYXRhU291cmNlSW5kZXhlZC5wcm90b3R5cGUuZ2V0VmFsdWUuY2FsbCh0aGlzLCB4LCB5KTtcblxuICAgICAgICBpZiAodGhpcy52aWV3TWFrZXNTZW5zZSgpICYmIHggPT09IHRoaXMudHJlZUNvbHVtbkluZGV4KSB7XG4gICAgICAgICAgICB2YXIgcm93ID0gdGhpcy5nZXRSb3coeSksXG4gICAgICAgICAgICAgICAgcHJlZml4ID0gQXJyYXkocm93Ll9fREVQVEggKyAxKS5qb2luKCcgICAgJykgKyBleHBhbmRlZE1hcFtyb3cuX19FWFBBTkRFRF07XG4gICAgICAgICAgICB2YWx1ZSA9IHByZWZpeCArIHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG5cbiAgICB2aWV3TWFrZXNTZW5zZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmpvaW5lZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGRlc2MgT3BlcmF0ZXMgb25seSBvbiB0aGUgZm9sbG93aW5nIHJvd3M6XG4gICAgICogKiBFeHBhbmRhYmxlIHJvd3MgLSBSb3dzIHdpdGggYSBkcmlsbC1kb3duIGNvbnRyb2wuXG4gICAgICogKiBSZXZlYWxlZCByb3dzIC0gUm93cyBub3QgaGlkZGVuIGluc2lkZSBvZiBjb2xsYXBzZWQgZHJpbGwtZG93bnMuXG4gICAgICogQHBhcmFtIHkgLSBSZXZlYWxlZCByb3cgbnVtYmVyLiAoVGhpcyBpcyBub3QgdGhlIHJvdyBJRC4pXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZXhwYW5kXSAtIE9uZSBvZjpcbiAgICAgKiAqIGB0cnVlYCAtIEV4cGFuZCBhbGwgcm93cyB0aGF0IGFyZSBjdXJyZW50bHkgY29sbGFwc2VkLlxuICAgICAqICogYGZhbHNlYCAtIENvbGxhcHNlIGFsbCByb3dzIHRoYXQgYXJlIGN1cnJlbnRseSBleHBhbmRlZC5cbiAgICAgKiAqIGB1bmRlZmluZWRgIChvciBvbWl0dGVkKSAtIEV4cGFuZCBhbGwgY3VycmVudGx5IGNvbGxhcHNlZCByb3dzOyBjb2xsYXBzZSBhbGwgY3VycmVudGx5IGV4cGFuZGVkIHJvd3MuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtkZXB0aD1JbmZpbml0eV0gLSBPbmUgb2Y6XG4gICAgICogKiBudW1iZXIgPiAwIC0gQXBwbHkgb25seSBpZiByb3cgZGVwdGggaXMgYWJvdmUgdGhlIGdpdmVuIGRlcHRoLlxuICAgICAqICogbnVtYmVyIDw9IDAgLSBBcHBseSBvbmx5IGlmIHJvdyBkZXB0aCBpcyBiZWxvdyB0aGUgZ2l2ZW4gZGVwdGguXG4gICAgICogQHJldHVybnMge3VuZGVmaW5lZHxib29sZWFufSBPbmUgb2Y6XG4gICAgICogKiBgdW5kZWZpbmVkYCAtIFJvdyB3YXMgbm90IGV4cGFuZGFibGUuXG4gICAgICogKiBgdHJ1ZWAgLSBSb3cgaGFkIGRyaWxsLWRvd24gX2FuZF8gc3RhdGUgY2hhbmdlZC5cbiAgICAgKiAqIGBmYWxzZWAgLSBSb3cgaGFkIGRyaWxsLWRvd24gX2J1dF8gc3RhdGUgZGlkIF9ub3RfIGNoYW5nZS5cbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZVRyZWV2aWV3LnByb3RvdHlwZVxuICAgICAqL1xuICAgIGNsaWNrOiBmdW5jdGlvbih5LCBleHBhbmQsIGRlcHRoKSB7XG4gICAgICAgIGlmICghdGhpcy52aWV3TWFrZXNTZW5zZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhU291cmNlLmNsaWNrLmFwcGx5KHRoaXMuZGF0YVNvdXJjZSwgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2hhbmdlZCwgcm93ID0gdGhpcy5nZXRSb3coeSk7XG4gICAgICAgIGlmIChyb3cgJiYgcm93Ll9fRVhQQU5ERUQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKGRlcHRoICE9PSB1bmRlZmluZWQgJiYgKFxuICAgICAgICAgICAgICAgIGRlcHRoID4gMCAmJiByb3cuX19ERVBUSCA+PSBkZXB0aCB8fFxuICAgICAgICAgICAgICAgIGRlcHRoIDw9IDAgJiYgcm93Ll9fREVQVEggPCAtZGVwdGhcbiAgICAgICAgICAgICkpIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChleHBhbmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBleHBhbmQgPSAhcm93Ll9fRVhQQU5ERUQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNoYW5nZWQgPSByb3cuX19FWFBBTkRFRCAmJiAhZXhwYW5kIHx8ICFyb3cuX19FWFBBTkRFRCAmJiBleHBhbmQ7XG4gICAgICAgICAgICAgICAgcm93Ll9fRVhQQU5ERUQgPSBleHBhbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoYW5nZWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IEV4cGFuZCBuZXN0ZWQgZHJpbGwtZG93bnMgY29udGFpbmluZyB0aGlzIHJvdy5cbiAgICAgKiBAcGFyYW0gSUQgLSBUaGUgdW5pcXVlIHJvdyBJRC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gSWYgYW55IHJvd3MgZXhwYW5kZWQuXG4gICAgICovXG4gICAgcmV2ZWFsUm93OiBmdW5jdGlvbihJRCkge1xuICAgICAgICBpZiAoIXRoaXMudmlld01ha2VzU2Vuc2UoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVNvdXJjZS5yZXZlYWxSb3cuYXBwbHkodGhpcy5kYXRhU291cmNlLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJvdywgcGFyZW50LCBjaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgIHdoaWxlICgocm93ID0gdGhpcy5maW5kUm93KHRoaXMuaWRDb2x1bW5OYW1lLCBJRCkpKSB7XG4gICAgICAgICAgICBpZiAocGFyZW50ICYmIHJvdy5fX0VYUEFOREVEID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHJvdy5fX0VYUEFOREVEID0gY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJlbnQgPSB0cnVlO1xuICAgICAgICAgICAgSUQgPSByb3dbdGhpcy5wYXJlbnRJZENvbHVtbk5hbWVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGFuZ2VkO1xuICAgIH1cbn0pO1xuXG5mdW5jdGlvbiBjb2xsYXBzZVJvd3Mociwgcm93KSB7XG4gICAgdmFyIHBhcmVudElEO1xuICAgIHdoaWxlICgocGFyZW50SUQgPSByb3dbdGhpcy5wYXJlbnRJZENvbHVtbk5hbWVdKSAhPSB1bmRlZmluZWQpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICAgICAgcm93ID0gdGhpcy5maW5kUm93KHRoaXMuaWRDb2x1bW5OYW1lLCBwYXJlbnRJRCk7XG4gICAgICAgIGlmIChyb3cuX19FWFBBTkRFRCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBEYXRhU291cmNlVHJlZXZpZXc7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIE1hcHB5KCkge1xuICAgIHRoaXMua2V5cyA9IFtdO1xuICAgIHRoaXMuZGF0YSA9IHt9O1xuICAgIHRoaXMudmFsdWVzID0gW107XG59XG5cbk1hcHB5LnByb3RvdHlwZSA9IHtcblxuICAgIGNvbnN0cnVjdG9yOiBNYXBweS5wcm90b3R5cGUuY29uc3RydWN0b3IsIC8vIHByZXNlcnZlIGNvbnN0cnVjdG9yXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgTWFwcHkucHJvdG90eXBlXG4gICAgICogQHBhcmFtIGtleVxuICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAqL1xuICAgIHNldDogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICB2YXIgaGFzaENvZGUgPSBoYXNoKGtleSk7XG4gICAgICAgIGlmICghKGhhc2hDb2RlIGluIHRoaXMuZGF0YSkpIHtcbiAgICAgICAgICAgIHRoaXMua2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgICB0aGlzLnZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRhdGFbaGFzaENvZGVdID0gdmFsdWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBNYXBweS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ga2V5XG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgdmFyIGhhc2hDb2RlID0gaGFzaChrZXkpO1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhW2hhc2hDb2RlXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgTWFwcHkucHJvdG90eXBlXG4gICAgICogQHBhcmFtIGtleVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGlmVW5kZWZpbmVkRnVuYyAtIFZhbHVlIGdldHRlciB3aGVuIHZhbHVlIGlzIG90aGVyd2lzZSB1bmRlZmluZWQuXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZ2V0SWZVbmRlZmluZWQ6IGZ1bmN0aW9uKGtleSwgaWZVbmRlZmluZWRGdW5jKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0KGtleSk7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGlmVW5kZWZpbmVkRnVuYyhrZXkpO1xuICAgICAgICAgICAgdGhpcy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG5cbiAgICBzaXplOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMua2V5cy5sZW5ndGg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBNYXBweS5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBjbGVhcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMua2V5cy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLnZhbHVlcy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLmRhdGEgPSB7fTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIE1hcHB5LnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSBrZXlcbiAgICAgKi9cbiAgICBkZWxldGU6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICB2YXIgaGFzaENvZGUgPSBoYXNoKGtleSk7XG4gICAgICAgIGlmICh0aGlzLmRhdGFbaGFzaENvZGVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IGJldHRlckluZGV4T2YodGhpcy5rZXlzLCBrZXkpO1xuICAgICAgICAgICAgdGhpcy5rZXlzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB0aGlzLnZhbHVlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuZGF0YVtoYXNoQ29kZV07XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIE1hcHB5LnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGl0ZXJhdGVlXG4gICAgICovXG4gICAgZm9yRWFjaDogZnVuY3Rpb24oaXRlcmF0ZWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpdGVyYXRlZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFyIGtleXMgPSB0aGlzLmtleXMsXG4gICAgICAgICAgICAgICAgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gc2VsZi5nZXQoa2V5KTtcbiAgICAgICAgICAgICAgICBpdGVyYXRlZSh2YWx1ZSwga2V5LCBzZWxmKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBNYXBweS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBpdGVyYXRlZVxuICAgICAqIEByZXR1cm5zIHtNYXBweX1cbiAgICAgKi9cbiAgICBtYXA6IGZ1bmN0aW9uKGl0ZXJhdGVlKSB7XG4gICAgICAgIHZhciBrZXlzID0gdGhpcy5rZXlzLFxuICAgICAgICAgICAgbmV3TWFwID0gbmV3IE1hcHB5KCksXG4gICAgICAgICAgICBzZWxmID0gdGhpcztcblxuICAgICAgICBpZiAoISh0eXBlb2YgaXRlcmF0ZWUgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgICAgICAgICBpdGVyYXRlZSA9IHJlZmxlY3Rpb247XG4gICAgICAgIH1cblxuICAgICAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBzZWxmLmdldChrZXkpLFxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybWVkID0gaXRlcmF0ZWUodmFsdWUsIGtleSwgc2VsZik7XG4gICAgICAgICAgICBuZXdNYXAuc2V0KGtleSwgdHJhbnNmb3JtZWQpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ld01hcDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIE1hcHB5LnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtNYXBweX1cbiAgICAgKi9cbiAgICBjb3B5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGtleXMgPSB0aGlzLmtleXMsXG4gICAgICAgICAgICBuZXdNYXAgPSBuZXcgTWFwcHkoKSxcbiAgICAgICAgICAgIHNlbGYgPSB0aGlzO1xuICAgICAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBzZWxmLmdldChrZXkpO1xuICAgICAgICAgICAgbmV3TWFwLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXdNYXA7XG4gICAgfVxuXG59O1xuXG52YXIgT0lEX1BSRUZJWCA9ICcufi4jJV8nOyAvL3RoaXMgc2hvdWxkIGJlIHNvbWV0aGluZyB3ZSBuZXZlciB3aWxsIHNlZSBhdCB0aGUgYmVnaW5uaW5nIG9mIGEgc3RyaW5nXG52YXIgY291bnRlciA9IDA7XG5cbmZ1bmN0aW9uIGhhc2goa2V5KSB7XG4gICAgdmFyIHR5cGVPZiA9IHR5cGVvZiBrZXk7XG5cbiAgICBzd2l0Y2ggKHR5cGVPZikge1xuICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgY2FzZSAnc3ltYm9sJzpcbiAgICAgICAgICAgIHJldHVybiBPSURfUFJFRklYICsgdHlwZU9mICsgJ18nICsga2V5O1xuXG4gICAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgICAgICByZXR1cm4gJ1VOREVGSU5FRCc7XG5cbiAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgIGlmIChrZXkgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ05VTEwnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZmFsbCB0aHJvdWdoIHdoZW4gbm90IG51bGw6XG4gICAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgICAgICAgIHJldHVybiAoa2V5Ll9fX2Zpbmhhc2ggPSBrZXkuX19fZmluaGFzaCB8fCBPSURfUFJFRklYICsgY291bnRlcisrKTtcbiAgICB9XG59XG5cbi8vIE9iamVjdC5pcyBwb2x5ZmlsbCwgY291cnRlc3kgb2YgQFdlYlJlZmxlY3Rpb25cbnZhciBpcyA9IE9iamVjdC5pcyB8fCBmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIGEgPT09IGIgPyBhICE9PSAwIHx8IDEgLyBhID09IDEgLyBiIDogYSAhPSBhICYmIGIgIT0gYjsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbn07XG5cbmZ1bmN0aW9uIHJlZmxlY3Rpb24odmFsKSB7XG4gICAgcmV0dXJuIHZhbDtcbn1cblxuLy8gTW9yZSByZWxpYWJsZSBpbmRleE9mLCBjb3VydGVzeSBvZiBAV2ViUmVmbGVjdGlvblxuZnVuY3Rpb24gYmV0dGVySW5kZXhPZihhcnIsIHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlICE9IHZhbHVlIHx8IHZhbHVlID09PSAwKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgICAgIHZhciBpID0gYXJyLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGktLSAmJiAhaXMoYXJyW2ldLCB2YWx1ZSkpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZW1wdHlcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGkgPSBbXS5pbmRleE9mLmNhbGwoYXJyLCB2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE1hcHB5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBtb2R1bGUgYWdncmVnYXRpb25zXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb259IGFnZ3JlZ2F0aW9uRnVuY3Rpb25cbiAqIEBzdW1tYXJ5IEEgYm91bmQgZnVuY3Rpb24uXG4gKiBAZGVzYyBBbiBhZ2dyZWdhdGlvbiBmdW5jdGlvbiBib3VuZCB0byB0aGUgYGNvbHVtbkluZGV4YCB2YWx1ZSBzdXBwbGllZCB0byBvbmUgb2YgdGhlIGFib3ZlIGZhY3RvcnkgZnVuY3Rpb25zLlxuICogQHBhcmFtIHtvYmplY3R9IGdyb3VwXG4gKiBAcmV0dXJucyB7Kn0gQWdncmVnYXRlZCB2YWx1ZS5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAvKipcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sdW1uSW5kZXhcbiAgICAgKiBAcmV0dXJucyB7YWdncmVnYXRpb25GdW5jdGlvbn0gQm91bmQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgY291bnQ6IGZ1bmN0aW9uKGNvbHVtbkluZGV4KSB7XG4gICAgICAgIHJldHVybiBjb3VudDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbHVtbkluZGV4XG4gICAgICogQHJldHVybnMge2FnZ3JlZ2F0aW9uRnVuY3Rpb259IEJvdW5kIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIHN1bTogZnVuY3Rpb24oY29sdW1uSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHN1bS5iaW5kKHRoaXMsIGNvbHVtbkluZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbHVtbkluZGV4XG4gICAgICogQHJldHVybnMge2FnZ3JlZ2F0aW9uRnVuY3Rpb259IEJvdW5kIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIG1pbjogZnVuY3Rpb24oY29sdW1uSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIG1pbm1heC5iaW5kKHRoaXMsIGNvbHVtbkluZGV4LCBNYXRoLm1pbiwgSW5maW5pdHkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sdW1uSW5kZXhcbiAgICAgKiBAcmV0dXJucyB7YWdncmVnYXRpb25GdW5jdGlvbn0gQm91bmQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgbWF4OiBmdW5jdGlvbihjb2x1bW5JbmRleCkge1xuICAgICAgICByZXR1cm4gbWlubWF4LmJpbmQodGhpcywgY29sdW1uSW5kZXgsIE1hdGgubWF4LCAtSW5maW5pdHkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sdW1uSW5kZXhcbiAgICAgKiBAcmV0dXJucyB7YWdncmVnYXRpb25GdW5jdGlvbn0gQm91bmQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgYXZnOiBmdW5jdGlvbihjb2x1bW5JbmRleCkge1xuICAgICAgICByZXR1cm4gYXZnLmJpbmQodGhpcywgY29sdW1uSW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sdW1uSW5kZXhcbiAgICAgKiBAcmV0dXJucyB7YWdncmVnYXRpb25GdW5jdGlvbn0gQm91bmQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZmlyc3Q6IGZ1bmN0aW9uKGNvbHVtbkluZGV4KSB7XG4gICAgICAgIHJldHVybiBmaXJzdC5iaW5kKHRoaXMsIGNvbHVtbkluZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbHVtbkluZGV4XG4gICAgICogQHJldHVybnMge2FnZ3JlZ2F0aW9uRnVuY3Rpb259IEJvdW5kIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGxhc3Q6IGZ1bmN0aW9uKGNvbHVtbkluZGV4KSB7XG4gICAgICAgIHJldHVybiBsYXN0LmJpbmQodGhpcywgY29sdW1uSW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sdW1uSW5kZXhcbiAgICAgKiBAcmV0dXJucyB7YWdncmVnYXRpb25GdW5jdGlvbn0gQm91bmQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgc3RkZGV2OiBmdW5jdGlvbihjb2x1bW5JbmRleCkge1xuICAgICAgICByZXR1cm4gc3RkZGV2LmJpbmQodGhpcywgY29sdW1uSW5kZXgpO1xuICAgIH1cbn07XG5cbmZ1bmN0aW9uIGNvdW50KGdyb3VwKSB7XG4gICAgcmV0dXJuIGdyb3VwLmdldFJvd0NvdW50KCk7XG59XG5cbmZ1bmN0aW9uIHN1bShjb2x1bW5JbmRleCwgZ3JvdXApIHtcbiAgICB2YXIgciA9IGdyb3VwLmdldFJvd0NvdW50KCksXG4gICAgICAgIG4gPSAwO1xuXG4gICAgd2hpbGUgKHItLSkge1xuICAgICAgICBuICs9IGdyb3VwLmdldFZhbHVlKGNvbHVtbkluZGV4LCByKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbjtcbn1cblxuZnVuY3Rpb24gbWlubWF4KGNvbHVtbkluZGV4LCBtZXRob2QsIG4sIGdyb3VwKSB7XG4gICAgdmFyIHIgPSBncm91cC5nZXRSb3dDb3VudCgpO1xuXG4gICAgd2hpbGUgKHItLSkge1xuICAgICAgICBuID0gbWV0aG9kKG4sIGdyb3VwLmdldFZhbHVlKGNvbHVtbkluZGV4LCByKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG47XG59XG5cbmZ1bmN0aW9uIGF2Zyhjb2x1bW5JbmRleCwgZ3JvdXApIHtcbiAgICByZXR1cm4gc3VtKGNvbHVtbkluZGV4LCBncm91cCkgLyBncm91cC5nZXRSb3dDb3VudCgpO1xufVxuXG5mdW5jdGlvbiBmaXJzdChjb2x1bW5JbmRleCwgZ3JvdXApIHtcbiAgICByZXR1cm4gZ3JvdXAuZ2V0VmFsdWUoY29sdW1uSW5kZXgsIDApO1xufVxuXG5mdW5jdGlvbiBsYXN0KGNvbHVtbkluZGV4LCBncm91cCkge1xuICAgIHJldHVybiBncm91cC5nZXRWYWx1ZShjb2x1bW5JbmRleCwgZ3JvdXAuZ2V0Um93Q291bnQoKSAtIDEpO1xufVxuXG5mdW5jdGlvbiBzdGRkZXYoY29sdW1uSW5kZXgsIGdyb3VwKSB7XG4gICAgdmFyIHJvd3MgPSBncm91cC5nZXRSb3dDb3VudCgpLFxuICAgICAgICBtZWFuID0gYXZnKGNvbHVtbkluZGV4LCBncm91cCk7XG5cbiAgICBmb3IgKHZhciBkZXYsIHIgPSByb3dzLCB2YXJpYW5jZSA9IDA7IHItLTsgdmFyaWFuY2UgKz0gZGV2ICogZGV2KSB7XG4gICAgICAgIGRldiA9IGdyb3VwLmdldFZhbHVlKGNvbHVtbkluZGV4LCByKSAtIG1lYW47XG4gICAgfVxuXG4gICAgcmV0dXJuIE1hdGguc3FydCh2YXJpYW5jZSAvIHJvd3MpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBOT1RFOiBGb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHksIGBjYXBpdGFsaXplYCBpcyBzdGlsbCBhIGZ1bmN0aW9uLCBkb3VibGluZyBub3cgYXMgdGhlIEFQSS5cblxuZnVuY3Rpb24gY2FwaXRhbGl6ZShzdHJpbmcpIHtcbiAgICByZXR1cm4gKC9bYS16XS8udGVzdChzdHJpbmcpID8gc3RyaW5nIDogc3RyaW5nLnRvTG93ZXJDYXNlKCkpXG4gICAgICAgIC5yZXBsYWNlKC9bXFxzXFwtX10qKFteXFxzXFwtX10pKFteXFxzXFwtX10rKS9nLCByZXBsYWNlcilcbiAgICAgICAgLnJlcGxhY2UoL1tBLVpdL2csICcgJCYnKVxuICAgICAgICAudHJpbSgpO1xufVxuXG5mdW5jdGlvbiByZXBsYWNlcihhLCBiLCBjKSB7XG4gICAgcmV0dXJuIGIudG9VcHBlckNhc2UoKSArIGM7XG59XG5cbmZ1bmN0aW9uIHNldChtZXRob2ROYW1lKSB7XG4gICAgY2FwaXRhbGl6ZS50cmFuc2Zvcm0gPSBjYXBpdGFsaXplW21ldGhvZE5hbWVdO1xufVxuXG5mdW5jdGlvbiBwYXNzdGhyb3VnaChzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nO1xufVxuXG5jYXBpdGFsaXplLnRyYW5zZm9ybSA9IHBhc3N0aHJvdWdoO1xuY2FwaXRhbGl6ZS5zZXQgPSBzZXQ7XG5jYXBpdGFsaXplLnBhc3N0aHJvdWdoID0gcGFzc3Rocm91Z2g7XG5jYXBpdGFsaXplLmNhcGl0YWxpemUgPSBjYXBpdGFsaXplO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNhcGl0YWxpemU7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogTm90ZSB0aGF0IHtAbGluayBtb2R1bGU6c3RhYmxlU29ydCNzb3J0fHNvcnQoKX0gaXMgdGhlIG9ubHkgZXhwb3NlZCBtZXRob2QuXG4gKiBAbW9kdWxlIHN0YWJsZVNvcnRcbiAqL1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNvbXBhcmF0b3JcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZGVzY2VuZGluZ1xuICogQHBhcmFtIHtBcnJheX0gYXJyMVxuICogQHBhcmFtIHtBcnJheX0gYXJyMlxuICogQHJldHVybnMge2Z1bmN0aW9ufVxuICovXG5mdW5jdGlvbiBzdGFiaWxpemUoY29tcGFyYXRvciwgZGVzY2VuZGluZywgYXJyMSwgYXJyMikgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNoYWRvd1xuICAgIHZhciB4ID0gYXJyMVswXTtcbiAgICB2YXIgeSA9IGFycjJbMF07XG5cbiAgICBpZiAoeCA9PT0geSkge1xuICAgICAgICB4ID0gZGVzY2VuZGluZyA/IGFycjJbMV0gOiBhcnIxWzFdO1xuICAgICAgICB5ID0gZGVzY2VuZGluZyA/IGFycjFbMV0gOiBhcnIyWzFdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh5ID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHggPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbXBhcmF0b3IoeCwgeSk7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHhcbiAqIEBwYXJhbSB5XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBhc2NlbmRpbmdOdW1iZXJzKHgsIHkpIHtcbiAgICByZXR1cm4geCAtIHk7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHhcbiAqIEBwYXJhbSB5XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBkZXNjZW5kaW5nTnVtYmVycyh4LCB5KSB7XG4gICAgcmV0dXJuIHkgLSB4O1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB4XG4gKiBAcGFyYW0geVxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gYXNjZW5kaW5nQWxsT3RoZXJzKHgsIHkpIHtcbiAgICByZXR1cm4geCA8IHkgPyAtMSA6IDE7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHhcbiAqIEBwYXJhbSB5XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBkZXNjZW5kaW5nQWxsT3RoZXJzKHgsIHkpIHtcbiAgICByZXR1cm4geSA8IHggPyAtMSA6IDE7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHR5cGVPZkRhdGFcbiAqIEByZXR1cm5zIHtmdW5jdGlvbih0aGlzOmFzY2VuZGluZyl9XG4gKi9cbmZ1bmN0aW9uIGFzY2VuZGluZyh0eXBlT2ZEYXRhKSB7XG4gICAgcmV0dXJuIHN0YWJpbGl6ZS5iaW5kKHRoaXMsIHR5cGVPZkRhdGEgPT09ICdudW1iZXInID8gYXNjZW5kaW5nTnVtYmVycyA6IGFzY2VuZGluZ0FsbE90aGVycywgZmFsc2UpO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB0eXBlT2ZEYXRhXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb24odGhpczpkZXNjZW5kaW5nKX1cbiAqL1xuZnVuY3Rpb24gZGVzY2VuZGluZyh0eXBlT2ZEYXRhKSB7XG4gICAgcmV0dXJuIHN0YWJpbGl6ZS5iaW5kKHRoaXMsIHR5cGVPZkRhdGEgPT09ICdudW1iZXInID8gZGVzY2VuZGluZ051bWJlcnMgOiBkZXNjZW5kaW5nQWxsT3RoZXJzLCB0cnVlKTtcbn1cblxuLyoqXG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICogQHBhcmFtIHtmdW5jdGlvbn0gZ2V0VmFsdWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBbZGlyZWN0aW9uPTFdXG4gKi9cbmZ1bmN0aW9uIHNvcnQoaW5kZXgsIGdldFZhbHVlLCBkaXJlY3Rpb24pIHtcblxuICAgIHZhciBjb21wYXJlLCBpO1xuXG4gICAgLy8gYXBwbHkgZGVmYXVsdHNcbiAgICBpZiAoZGlyZWN0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGlyZWN0aW9uID0gMTtcbiAgICB9XG5cbiAgICBpZiAoaW5kZXgubGVuZ3RoKSB7IC8vIHNvbWV0aGluZyB0byBkb1xuICAgICAgICBzd2l0Y2ggKGRpcmVjdGlvbikge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHJldHVybjsgLy8gYmFpbDogbm90aGluZyB0byBzb3J0XG5cbiAgICAgICAgICAgIGNhc2UgdW5kZWZpbmVkOiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWZhbGx0aHJvdWdoXG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uID0gMTtcbiAgICAgICAgICAgIGNhc2UgMTogIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZmFsbHRocm91Z2hcbiAgICAgICAgICAgICAgICBjb21wYXJlID0gYXNjZW5kaW5nKHR5cGVvZiBnZXRWYWx1ZSgwKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgLTE6XG4gICAgICAgICAgICAgICAgY29tcGFyZSA9IGRlc2NlbmRpbmcodHlwZW9mIGdldFZhbHVlKDApKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNldCB1cCB0aGUgc29ydC4uLi4uXG4gICAgICAgIHZhciB0bXAgPSBuZXcgQXJyYXkoaW5kZXgubGVuZ3RoKTtcblxuICAgICAgICAvLyBhZGQgdGhlIGluZGV4IGZvciBcInN0YWJpbGl0eVwiXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBpbmRleC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdG1wW2ldID0gW2dldFZhbHVlKGkpLCBpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGRvIHRoZSBhY3R1YWwgc29ydFxuICAgICAgICB0bXAuc29ydChjb21wYXJlKTtcblxuICAgICAgICAvLyBjb3B5IHRoZSBzb3J0ZWQgdmFsdWVzIGludG8gb3VyIGluZGV4IHZlY3RvclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgaW5kZXgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGluZGV4W2ldID0gdG1wW2ldWzFdO1xuICAgICAgICB9XG4gICAgfVxuXG59XG5cbmV4cG9ydHMuc29ydCA9IHNvcnQ7XG4iLCIvLyBsaXN0LWRyYWdvbiBub2RlIG1vZHVsZVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2pvbmVpdC9saXN0LWRyYWdvblxuXG4vKiBlc2xpbnQtZW52IG5vZGUsIGJyb3dzZXIgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY3NzSW5qZWN0b3IgPSByZXF1aXJlKCdjc3MtaW5qZWN0b3InKTtcbnZhciBmb3JtYXQgPSByZXF1aXJlKCd0ZW1wbGV4Jyk7XG5cbnZhciBSRVZFUlRfVE9fU1RZTEVTSEVFVF9WQUxVRSA9IG51bGw7ICAvLyBudWxsIHJlbW92ZXMgdGhlIHN0eWxlXG5cbnZhciB0cmFuc2Zvcm0sIHRpbWVyLCBzY3JvbGxWZWxvY2l0eSwgY3NzTGlzdERyYWdvbjtcblxuLyogaW5qZWN0OmNzcyAqL1xuY3NzTGlzdERyYWdvbiA9ICdkaXYuZHJhZ29uLWxpc3R7cG9zaXRpb246cmVsYXRpdmU7YmFja2dyb3VuZC1jb2xvcjojZmZmfWRpdi5kcmFnb24tbGlzdD5kaXYsZGl2LmRyYWdvbi1saXN0PnVse3Bvc2l0aW9uOmFic29sdXRlO2xlZnQ6MDtyaWdodDowfWRpdi5kcmFnb24tbGlzdD5kaXZ7dGV4dC1hbGlnbjpjZW50ZXI7YmFja2dyb3VuZC1jb2xvcjojMDA3OTZiO2NvbG9yOiNmZmY7Ym94LXNoYWRvdzowIDNweCA2cHggcmdiYSgwLDAsMCwuMTYpLDAgM3B4IDZweCByZ2JhKDAsMCwwLC4yMyk7b3ZlcmZsb3c6aGlkZGVuO3doaXRlLXNwYWNlOm5vd3JhcH1kaXYuZHJhZ29uLWxpc3Q+dWx7b3ZlcmZsb3cteTphdXRvO2JvdHRvbTowO21hcmdpbjowO3BhZGRpbmc6MDtib3gtc2hhZG93OjAgMXB4IDNweCByZ2JhKDAsMCwwLC4xMiksMCAxcHggMnB4IHJnYmEoMCwwLDAsLjI0KX1kaXYuZHJhZ29uLWxpc3Q+dWw+bGksbGkuZHJhZ29uLXBvcHt3aGl0ZS1zcGFjZTpub3dyYXA7bGlzdC1zdHlsZS10eXBlOm5vbmU7Ym9yZGVyOjAgc29saWQgI2Y0ZjRmNDtib3JkZXItYm90dG9tOjFweCBzb2xpZCAjZTBlMGUwO2N1cnNvcjptb3ZlO3RyYW5zaXRpb246Ym9yZGVyLXRvcC13aWR0aCAuMnN9ZGl2LmRyYWdvbi1saXN0PnVsPmxpOmxhc3QtY2hpbGR7aGVpZ2h0OjA7Ym9yZGVyLWJvdHRvbTpub25lfWxpLmRyYWdvbi1wb3B7cG9zaXRpb246Zml4ZWQ7YmFja2dyb3VuZC1jb2xvcjojZmZmO2JvcmRlcjoxcHggc29saWQgI2UwZTBlMDtsZWZ0OjA7dG9wOjA7b3ZlcmZsb3cteDpoaWRkZW47Ym94LXNoYWRvdzpyZ2JhKDAsMCwwLC4xODgyMzUpIDAgMTBweCAyMHB4LHJnYmEoMCwwLDAsLjIyNzQ1MSkgMCA2cHggNnB4fSc7XG4vKiBlbmRpbmplY3QgKi9cblxuLyoqXG4gKiBAY29uc3RydWN0b3IgTGlzdERyYWdvblxuICpcbiAqIEBkZXNjIFRoaXMgb2JqZWN0IHNlcnZpY2VzIGEgc2V0IG9mIGl0ZW0gbGlzdHMgdGhhdCBhbGxvdyBkcmFnZ2luZyBhbmQgZHJvcHBpbmcgaXRlbXMgd2l0aGluIGFuZCBiZXR3ZWVuIGxpc3RzIGluIGEgc2V0LlxuICpcbiAqIFR3byBzdHJhdGVnaWVzIGFyZSBzdXBwb3J0ZWQ6XG4gKlxuICogMS4gU3VwcGx5IHlvdXIgb3duIEhUTUwgbWFya3VwIGFuZCBsZXQgdGhlIEFQSSBidWlsZCB0aGUgaXRlbSBtb2RlbHMgZm9yIHlvdS5cbiAqICAgIFRvIHVzZSB0aGlzIHN0cmF0ZWd5LCBzY3JpcHQgeW91ciBIVE1MIGFuZCBwcm92aWRlIG9uZSBvZiB0aGVzZTpcbiAqICAgICogYW4gYXJyYXkgb2YgYWxsIHRoZSBsaXN0IGl0ZW0gKGA8bGk+YCkgdGFnc1xuICogICAgKiBhIENTUyBzZWxlY3RvciB0aGF0IHBvaW50cyB0byBhbGwgdGhlIGxpc3QgaXRlbSB0YWdzXG4gKiAyLiBTdXBwbHkgeW91ciBvd24gaXRlbSBtb2RlbHMgYW5kIGxldCB0aGUgQVBJIGJ1aWxkIHRoZSBIVE1MIG1hcmt1cCBmb3IgeW91LlxuICogICAgVG8gdXNlIHRoaXMgc3RyYXRlZ3ksIHByb3ZpZGUgYW4gYXJyYXkgb2YgbW9kZWwgbGlzdHMuXG4gKlxuICogVGhlIG5ldyBMaXN0RHJhZ29uIG9iamVjdCdzIGBtb2RlbExpc3RzYCBwcm9wZXJ0eSByZWZlcmVuY2VzIHRoZSBhcnJheSBvZiBtb2RlbCBsaXN0cyB0aGUgQVBJIGNvbnN0cnVjdGVkIGZvciB5b3UgaW4gc3RyYXRlZ3kgIzEgb3IgdGhlIGFycmF5IG9mIG1vZGVsIGxpc3RzIHlvdSBzdXBwbGllZCBmb3Igc3RyYXRlZ3kgIzIuXG4gKlxuICogQWZ0ZXIgdGhlIHVzZXIgcGVyZm9ybXMgYSBzdWNjZXNzZnVsIGRyYWctYW5kLWRyb3Agb3BlcmF0aW9uLCB0aGUgcG9zaXRpb24gb2YgdGhlIG1vZGVsIHJlZmVyZW5jZXMgd2l0aGluIHRoZSBgbW9kZWxMaXN0c2AgYXJyYXkgaXMgcmVhcnJhbmdlZC4gKFRoZSBtb2RlbHMgdGhlbXNlbHZlcyBhcmUgdGhlIG9yaWdpbmFsIG9iamVjdHMgYXMgc3VwcGxpZWQgaW4gdGhlIG1vZGVsIGxpc3RzOyB0aGV5IGFyZSBub3QgcmVidWlsdCBvciBhbHRlcmVkIGluIGFueSB3YXkuIEp1c3QgdGhlIHJlZmVyZW5jZXMgdG8gdGhlbSBhcmUgbW92ZWQgYXJvdW5kLilcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xFbGVtZW50W118bW9kZWxMaXN0VHlwZVtdfSBzZWxlY3Rvck9yTW9kZWxMaXN0cyAtIFlvdSBtdXN0IHN1cHBseSBvbmUgb2YgdGhlIGl0ZW1zIGluICoqYm9sZCoqIGJlbG93OlxuICpcbiAqIDEuIF9Gb3Igc3RyYXRlZ3kgIzEgYWJvdmUgKEFQSSBjcmVhdGVzIG1vZGVscyBmcm9tIHN1cHBsaWVkIGVsZW1lbnRzKTpfIEFsbCB0aGUgbGlzdCBpdGVtIChgPGxpPmApIERPTSBlbGVtZW50cyBvZiBhbGwgdGhlIGxpc3RzIHlvdSB3YW50IHRoZSBuZXcgb2JqZWN0IHRvIG1hbmFnZSwgYXMgZWl0aGVyOlxuICogICAgMS4gKipBIENTUyBzZWxlY3RvcjsqKiBfb3JfXG4gKiAgICAyLiAqKkFuIGFycmF5IG9mIERPTSBlbGVtZW50cyoqXG4gKiAyLiBfRm9yIHN0cmF0ZWd5ICMyIGFib3ZlIChBUEkgY3JlYXRlcyBlbGVtZW50cyBmcm9tIHN1cHBsaWVkIG1vZGVscyk6XyAqKkFuIGFycmF5IG9mIG1vZGVsIGxpc3RzLCoqIGVhY2ggb2Ygd2hpY2ggaXMgaW4gb25lIG9mIHRoZSBmb2xsb3dpbmcgZm9ybXM6XG4gKiAgICAxLiBBbiBhcnJheSBvZiBpdGVtIG1vZGVscyAod2l0aCB2YXJpb3VzIG9wdGlvbiBwcm9wZXJ0aWVzIGhhbmdpbmcgb2ZmIG9mIGl0KTsgX2FuZC9vcl9cbiAqICAgIDIuIEEge0BsaW5rIG1vZGVsTGlzdFR5cGV9IG9iamVjdCB3aXRoIHRob3NlIHNhbWUgdmFyaW91cyBvcHRpb24gcHJvcGVydGllcyBpbmNsdWRpbmcgdGhlIHJlcXVpcmVkIGBtb2RlbHNgIHByb3BlcnR5IGNvbnRhaW5pbmcgdGhhdCBzYW1lIGFycmF5IG9mIGl0ZW0gbW9kZWxzLlxuICpcbiAqIEluIGVpdGhlciBjYXNlICgyLjEgb3IgMi4yKSwgZWFjaCBlbGVtZW50IG9mIHN1Y2ggYXJyYXlzIG9mIGl0ZW0gbW9kZWxzIG1heSB0YWtlIHRoZSBmb3JtIG9mOlxuICogKiBBIHN0cmluZyBwcmltaXRpdmU7IF9vcl9cbiAqICogQSB7QGxpbmsgaXRlbU1vZGVsVHlwZX0gb2JqZWN0IHdpdGggYSB2YXJpb3VzIG9wdGlvbiBwcm9wZXJ0aWVzIGluY2x1ZGluZyB0aGUgcmVxdWlyZWQgYGxhYmVsYCBwcm9wZXJ0eSBjb250YWluaW5nIGEgc3RyaW5nIHByaW1pdGl2ZS5cbiAqXG4gKiBSZWdhcmRpbmcgdGhlc2Ugc3RyaW5nIHByaW1pdGl2ZXMsIGVhY2ggaXMgZWl0aGVyOlxuICogKiBBIHN0cmluZyB0byBiZSBkaXNwbGF5ZWQgaW4gdGhlIGxpc3QgaXRlbTsgX29yX1xuICogKiBBIGZvcm1hdCBzdHJpbmcgd2l0aCBvdGhlciBwcm9wZXJ0eSB2YWx1ZXMgbWVyZ2VkIGluLCB0aGUgcmVzdWx0IG9mIHdoaWNoIGlzIHRvIGJlIGRpc3BsYXllZCBpbiB0aGUgbGlzdCBpdGVtLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucz17fV0gLSBZb3UgbWF5IHN1cHBseSBcImdsb2JhbFwiIHRlbXBsYXRlIHZhcmlhYmxlcyBoZXJlLCByZXByZXNlbnRpbmcgdGhlIFwib3V0ZXIgc2NvcGUsXCIgYWZ0ZXIgZmlyc3Qgc2VhcmNoaW5nIGVhY2ggbW9kZWwgYW5kIHRoZW4gZWFjaCBtb2RlbCBsaXN0LlxuICogQHBhcmFtIHt1bmRlZmluZWR8bnVsbHxFbGVtZW50fHN0cmluZ30gW2Nzc1N0eWxlc2hlZXRSZWZlcmVuY2VFbGVtZW50XSAtIERldGVybWluZXMgd2hlcmUgdG8gaW5zZXJ0IHRoZSBzdHlsZXNoZWV0LiAoVGhpcyBpcyB0aGUgb25seSBmb3JtYWwgb3B0aW9uLikgUGFzc2VkIHRvIGNzcy1pbmplY3RvciwgdGhlIG92ZXJsb2FkcyBhcmUgKGZyb20gY3NzLWluamVjdG9yIGRvY3MpOlxuICogKiBgdW5kZWZpbmVkYCB0eXBlIChvciBvbWl0dGVkKTogaW5qZWN0cyBzdHlsZXNoZWV0IGF0IHRvcCBvZiBgPGhlYWQ+Li4uPC9oZWFkPmAgZWxlbWVudFxuICogKiBgbnVsbGAgdmFsdWU6IGluamVjdHMgc3R5bGVzaGVldCBhdCBib3R0b20gb2YgYDxoZWFkPi4uLjwvaGVhZD5gIGVsZW1lbnRcbiAqICogYEVsZW1lbnRgIHR5cGU6IGluamVjdHMgc3R5bGVzaGVldCBpbW1lZGlhdGVseSBiZWZvcmUgZ2l2ZW4gZWxlbWVudCwgd2hlcmV2ZXIgaXQgaXMgZm91bmQuXG4gKiAqIGBzdHJpbmdgIHR5cGU6IGluamVjdHMgc3R5bGVzaGVldCBpbW1lZGlhdGVseSBiZWZvcmUgZ2l2ZW4gZmlyc3QgZWxlbWVudCBmb3VuZCB0aGF0IG1hdGNoZXMgdGhlIGdpdmVuIGNzcyBzZWxlY3Rvci5cbiAqL1xuZnVuY3Rpb24gTGlzdERyYWdvbihzZWxlY3Rvck9yTW9kZWxMaXN0cywgb3B0aW9ucykge1xuXG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIExpc3REcmFnb24pKSB7XG4gICAgICAgIHRocm93IGVycm9yKCdOb3QgY2FsbGVkIHdpdGggXCJuZXdcIiBrZXl3b3JkLicpO1xuICAgIH1cblxuICAgIHZhciBzZWxmID0gdGhpcywgbW9kZWxMaXN0cywgaXRlbXM7XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIGlmICh0eXBlb2Ygc2VsZWN0b3JPck1vZGVsTGlzdHMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGl0ZW1zID0gdG9BcnJheShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yT3JNb2RlbExpc3RzKSk7XG4gICAgICAgIG1vZGVsTGlzdHMgPSBjcmVhdGVNb2RlbExpc3RzRnJvbUxpc3RFbGVtZW50cyhpdGVtcyk7XG4gICAgfSBlbHNlIGlmIChzZWxlY3Rvck9yTW9kZWxMaXN0c1swXSBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICAgICAgaXRlbXMgPSB0b0FycmF5KHNlbGVjdG9yT3JNb2RlbExpc3RzKTtcbiAgICAgICAgbW9kZWxMaXN0cyA9IGNyZWF0ZU1vZGVsTGlzdHNGcm9tTGlzdEVsZW1lbnRzKGl0ZW1zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBwYXJhbSBpcyBhcnJheSBvZiBtb2RlbCBsaXN0c1xuICAgICAgICAvLyBidWlsZCBuZXcgPHVsPiBlbGVtZW50KHMpIGZvciBlYWNoIGxpc3QgYW5kIHB1dCBpbiBgLm1vZGVsTGlzdHNgO1xuICAgICAgICAvLyBmaWxsIGAuaXRlbXNgIGFycmF5IHdpdGggPGxpPiBlbGVtZW50cyBmcm9tIHRoZXNlIG5ldyA8dWw+IGVsZW1lbnRzXG4gICAgICAgIGl0ZW1zID0gW107XG4gICAgICAgIG1vZGVsTGlzdHMgPSBjcmVhdGVMaXN0RWxlbWVudHNGcm9tTW9kZWxMaXN0cyhzZWxlY3Rvck9yTW9kZWxMaXN0cywgb3B0aW9ucyk7XG4gICAgICAgIG1vZGVsTGlzdHMuZm9yRWFjaChmdW5jdGlvbiAobGlzdCkge1xuICAgICAgICAgICAgaXRlbXMgPSBpdGVtcy5jb25jYXQodG9BcnJheShsaXN0LmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnbGknKSkpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBncmFiIHdoZWVsIGV2ZW50cyBhbmQgZG9uJ3QgbGV0ICdlbSBidWJibGVcbiAgICBtb2RlbExpc3RzLmZvckVhY2goZnVuY3Rpb24gKG1vZGVsTGlzdCkge1xuICAgICAgICBtb2RlbExpc3QuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd3aGVlbCcsIGNhcHR1cmVFdmVudCk7XG4gICAgfSk7XG5cbiAgICBpdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtRWxlbWVudCwgaW5kZXgpIHtcbiAgICAgICAgdmFyIGl0ZW0gPSAoaXRlbUVsZW1lbnQgIT09IGl0ZW1FbGVtZW50LnBhcmVudEVsZW1lbnQubGFzdEVsZW1lbnRDaGlsZClcbiAgICAgICAgICAgID8gc2VsZi5hZGRFdnQoaXRlbUVsZW1lbnQsICdtb3VzZWRvd24nLCBpdGVtRWxlbWVudCwgdHJ1ZSlcbiAgICAgICAgICAgIDogeyBlbGVtZW50OiBpdGVtRWxlbWVudCB9O1xuXG4gICAgICAgIC8qIGBpdGVtLm1vZGVsYCBub3QgY3VycmVudGx5IG5lZWRlZCBzbyBjb21tZW50ZWQgb3V0IGhlcmUuXG4gICAgICAgICAqIChPcmlnaW5hbGx5IHVzZWQgZm9yIHJlYnVpbGRpbmcgbW9kZWxMaXN0cyBmb3IgZmluYWxcbiAgICAgICAgICogcmVwb3J0aW5nLCBtb2RlbExpc3RzIGFyZSBub3cgc3BsaWNlZCBvbiBldmVyeSBzdWNjZXNzZnVsXG4gICAgICAgICAqIGRyYWctYW5kLWRyb3Agb3BlcmF0aW9uIHNvIHRoZXkncmUgYWx3YXlzIHVwIHRvIGRhdGUuKVxuXG4gICAgICAgICB2YXIgb3JpZ2luID0gdGhpcy5pdGVtQ29vcmRpbmF0ZXMoaXRlbUVsZW1lbnQpO1xuICAgICAgICAgaXRlbS5tb2RlbCA9IHRoaXMubW9kZWxMaXN0c1tvcmlnaW4ubGlzdF0ubW9kZWxzW29yaWdpbi5pdGVtXTtcblxuICAgICAgICAgKi9cblxuICAgICAgICBpdGVtc1tpbmRleF0gPSBpdGVtO1xuICAgIH0pO1xuXG4gICAgdHJhbnNmb3JtID0gJ3RyYW5zZm9ybScgaW4gaXRlbXNbMF0uZWxlbWVudC5zdHlsZVxuICAgICAgICA/ICd0cmFuc2Zvcm0nIC8vIENocm9tZSA0NSBhbmQgRmlyZWZveCA0MFxuICAgICAgICA6ICctd2Via2l0LXRyYW5zZm9ybSc7IC8vIFNhZmFyaSA4XG5cbiAgICAvLyBzZXQgdXAgdGhlIG5ldyBvYmplY3RcbiAgICB0aGlzLm1vZGVsTGlzdHMgPSBtb2RlbExpc3RzO1xuICAgIHRoaXMuaXRlbXMgPSBpdGVtcztcbiAgICB0aGlzLmJpbmRpbmdzID0ge307XG4gICAgdGhpcy5jYWxsYmFjayA9IHt9O1xuXG4gICAgY3NzSW5qZWN0b3IoY3NzTGlzdERyYWdvbiwgJ2xpc3QtZHJhZ29uLWJhc2UnLCBvcHRpb25zLmNzc1N0eWxlc2hlZXRSZWZlcmVuY2VFbGVtZW50KTtcblxufVxuXG5MaXN0RHJhZ29uLnByb3RvdHlwZSA9IHtcblxuICAgIGFkZEV2dDogZnVuY3Rpb24gKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIGRvTm90QmluZCkge1xuICAgICAgICB2YXIgYmluZGluZyA9IHtcbiAgICAgICAgICAgIGhhbmRsZXI6IGhhbmRsZXJzW3R5cGVdLmJpbmQodGFyZ2V0LCB0aGlzKSxcbiAgICAgICAgICAgIGVsZW1lbnQ6IGxpc3RlbmVyIHx8IHdpbmRvd1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmICghZG9Ob3RCaW5kKSB7XG4gICAgICAgICAgICB0aGlzLmJpbmRpbmdzW3R5cGVdID0gYmluZGluZztcbiAgICAgICAgfVxuXG4gICAgICAgIGJpbmRpbmcuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGJpbmRpbmcuaGFuZGxlcik7XG5cbiAgICAgICAgcmV0dXJuIGJpbmRpbmc7XG4gICAgfSxcblxuICAgIHJlbW92ZUV2dDogZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgdmFyIGJpbmRpbmcgPSB0aGlzLmJpbmRpbmdzW3R5cGVdO1xuICAgICAgICBkZWxldGUgdGhpcy5iaW5kaW5nc1t0eXBlXTtcbiAgICAgICAgYmluZGluZy5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgYmluZGluZy5oYW5kbGVyKTtcbiAgICB9LFxuXG4gICAgcmVtb3ZlQWxsRXZlbnRMaXN0ZW5lcnM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gcmVtb3ZlIGRyYWcgJiBkcm9wIGV2ZW50cyAobW91c2Vtb3ZlLCBtb3VzZXVwLCBhbmQgdHJhbnNpdGlvbmVuZClcbiAgICAgICAgZm9yICh2YXIgdHlwZSBpbiB0aGlzLmJpbmRpbmdzKSB7XG4gICAgICAgICAgICB2YXIgYmluZGluZyA9IHRoaXMuYmluZGluZ3NbdHlwZV07XG4gICAgICAgICAgICBiaW5kaW5nLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBiaW5kaW5nLmhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlbW92ZSB0aGUgbW91c2Vkb3duIGV2ZW50cyBmcm9tIGFsbCBsaXN0IGl0ZW1zXG4gICAgICAgIHRoaXMuaXRlbXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgaWYgKGl0ZW0uaGFuZGxlcikge1xuICAgICAgICAgICAgICAgIGl0ZW0uZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBpdGVtLmhhbmRsZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gd2hlZWwgZXZlbnRzIG9uIHRoZSBsaXN0IGVsZW1lbnRzXG4gICAgICAgIHRoaXMubW9kZWxMaXN0cy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RlbExpc3QpIHtcbiAgICAgICAgICAgIG1vZGVsTGlzdC5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3doZWVsJywgY2FwdHVyZUV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIHBvaW50SW5MaXN0UmVjdHM6IGZ1bmN0aW9uIChwb2ludCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbExpc3RzLmZpbmQoZnVuY3Rpb24gKG1vZGVsTGlzdCkge1xuICAgICAgICAgICAgdmFyIHJlY3QgPSBtb2RlbExpc3QuZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgICAgICAgcmVjdCA9IHtcbiAgICAgICAgICAgICAgICBsZWZ0OiAgIHdpbmRvdy5zY3JvbGxYICsgcmVjdC5sZWZ0LFxuICAgICAgICAgICAgICAgIHRvcDogICAgd2luZG93LnNjcm9sbFkgKyByZWN0LnRvcCxcbiAgICAgICAgICAgICAgICByaWdodDogIHdpbmRvdy5zY3JvbGxYICsgcmVjdC5yaWdodCxcbiAgICAgICAgICAgICAgICBib3R0b206IHdpbmRvdy5zY3JvbGxZICsgcmVjdC5ib3R0b20sXG4gICAgICAgICAgICAgICAgd2lkdGg6ICByZWN0LndpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogcmVjdC5oZWlnaHRcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIG1vZGVsTGlzdC5yZWN0ID0gcmVjdDtcblxuICAgICAgICAgICAgaWYgKHBvaW50SW5SZWN0KHBvaW50LCByZWN0KSkge1xuICAgICAgICAgICAgICAgIG1vZGVsTGlzdC5yZWN0ID0gcmVjdDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gZm91bmRcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgcG9pbnRJbkl0ZW1SZWN0czogZnVuY3Rpb24gKHBvaW50LCBleGNlcHQxLCBleGNlcHQyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLml0ZW1zLmZpbmQoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gaXRlbS5lbGVtZW50O1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICBlbGVtZW50ICE9PSBleGNlcHQxICYmXG4gICAgICAgICAgICAgICAgZWxlbWVudCAhPT0gZXhjZXB0MiAmJlxuICAgICAgICAgICAgICAgIHBvaW50SW5SZWN0KHBvaW50LCBpdGVtLnJlY3QpXG4gICAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLy8gZ2V0IHBvc2l0aW9ucyBvZiBhbGwgbGlzdCBpdGVtcyBpbiBwYWdlIGNvb3JkcyAobm9ybWFsaXplZCBmb3Igd2luZG93IGFuZCBsaXN0IHNjcm9sbGluZylcbiAgICBnZXRBbGxJdGVtQm91bmRpbmdSZWN0czogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbW9kZWxMaXN0cyA9IHRoaXMubW9kZWxMaXN0cywgaGVpZ2h0O1xuICAgICAgICB0aGlzLml0ZW1zLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgIHZhciBpdGVtRWxlbWVudCA9IGl0ZW0uZWxlbWVudCxcbiAgICAgICAgICAgICAgICBsaXN0RWxlbWVudCA9IGl0ZW1FbGVtZW50LnBhcmVudEVsZW1lbnQsXG4gICAgICAgICAgICAgICAgbGlzdCA9IG1vZGVsTGlzdHMuZmluZChmdW5jdGlvbiAobGlzdCkgeyByZXR1cm4gbGlzdC5lbGVtZW50ID09PSBsaXN0RWxlbWVudDsgfSk7XG5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAvLyBvbWl0dGVkOiBkZWZhdWx0IHRvIHRydWVcbiAgICAgICAgICAgICAgICBsaXN0LmlzRHJvcFRhcmdldCA9PT0gdW5kZWZpbmVkIHx8XG5cbiAgICAgICAgICAgICAgICAvLyBmdW5jdGlvbjogdXNlIHJldHVybiB2YWx1ZVxuICAgICAgICAgICAgICAgIHR5cGVvZiBsaXN0LmlzRHJvcFRhcmdldCA9PT0gJ2Z1bmN0aW9uJyAmJiBsaXN0LmlzRHJvcFRhcmdldCgpIHx8XG5cbiAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2U6IHVzZSB0cnV0aGluZXNzIG9mIGdpdmVuIHZhbHVlXG4gICAgICAgICAgICAgICAgbGlzdC5pc0Ryb3BUYXJnZXRcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHZhciByZWN0ID0gaXRlbUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgICAgICAgICAgICAgIGJvdHRvbSA9IHJlY3QuYm90dG9tO1xuXG4gICAgICAgICAgICAgICAgaWYgKGl0ZW1FbGVtZW50ID09PSBsaXN0RWxlbWVudC5sYXN0RWxlbWVudENoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIGJvdHRvbSA9IGxpc3RFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmJvdHRvbTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJvdHRvbSA8IHJlY3QudG9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBib3R0b20gPSByZWN0LnRvcCArIChoZWlnaHQgfHwgNTApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmVjdCA9IHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogICB3aW5kb3cuc2Nyb2xsWCArIHJlY3QubGVmdCxcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQ6ICB3aW5kb3cuc2Nyb2xsWCArIHJlY3QucmlnaHQsXG4gICAgICAgICAgICAgICAgICAgIHRvcDogICAgd2luZG93LnNjcm9sbFkgKyByZWN0LnRvcCAgICArIGxpc3RFbGVtZW50LnNjcm9sbFRvcCxcbiAgICAgICAgICAgICAgICAgICAgYm90dG9tOiB3aW5kb3cuc2Nyb2xsWSArIGJvdHRvbSArIGxpc3RFbGVtZW50LnNjcm9sbFRvcFxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBpdGVtLnJlY3QgPSByZWN0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgcmVpbnNlcnQ6IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgdmFyIHN0eWxlID0gdGFyZ2V0LnN0eWxlO1xuICAgICAgICBzdHlsZS53aWR0aCA9IHN0eWxlW3RyYW5zZm9ybV0gPSBzdHlsZS50cmFuc2l0aW9uID0gUkVWRVJUX1RPX1NUWUxFU0hFRVRfVkFMVUU7XG5cbiAgICAgICAgdGFyZ2V0LmNsYXNzTGlzdC5yZW1vdmUoJ2RyYWdvbi1wb3AnKTtcblxuICAgICAgICB0aGlzLmRyb3Auc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gJzBzJztcbiAgICAgICAgdGhpcy5kcm9wLnN0eWxlLmJvcmRlclRvcFdpZHRoID0gUkVWRVJUX1RPX1NUWUxFU0hFRVRfVkFMVUU7XG4gICAgICAgIHRoaXMuZHJvcC5wYXJlbnRFbGVtZW50Lmluc2VydEJlZm9yZSh0YXJnZXQsIHRoaXMuZHJvcCk7XG5cbiAgICAgICAgZGVsZXRlIHRoaXMuZHJvcDtcbiAgICB9LFxuXG4gICAgLy8gcmV0dXJuIGFuIG9iamVjdCB7IGl0ZW06IDxpdGVtIGluZGV4IHdpdGhpbiBsaXN0PiwgbGlzdDogPGxpc3QgaW5kZXggd2l0aGluIGxpc3Qgb2YgbGlzdHM+IH1cbiAgICBpdGVtQ29vcmRpbmF0ZXM6IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHZhciBsaXN0RWxlbWVudCA9IGl0ZW0ucGFyZW50RWxlbWVudCxcbiAgICAgICAgICAgIGNvb3JkcyA9IHsgaXRlbTogMCB9O1xuXG4gICAgICAgIHdoaWxlICgoaXRlbSA9IGl0ZW0ucHJldmlvdXNFbGVtZW50U2libGluZykpIHtcbiAgICAgICAgICAgICsrY29vcmRzLml0ZW07XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm1vZGVsTGlzdHMuZmluZChmdW5jdGlvbiAobGlzdCwgaW5kZXgpIHtcbiAgICAgICAgICAgIGNvb3Jkcy5saXN0ID0gaW5kZXg7XG4gICAgICAgICAgICByZXR1cm4gbGlzdC5lbGVtZW50ID09PSBsaXN0RWxlbWVudDsgLy8gc3RvcCB3aGVuIHdlIGZpbmQgdGhlIG9uZSB3ZSBiZWxvbmcgdG9cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGNvb3JkcztcbiAgICB9XG5cbn07XG5cbnZhciBoYW5kbGVycyA9IHtcbiAgICBtb3VzZWRvd246IGZ1bmN0aW9uIChkcmFnb24sIGV2dCkge1xuXG4gICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7ICAvL3ByZXZlbnRzIHVzZXIgc2VsZWN0aW9uIG9mIHJlbmRlcmVkIG5vZGVzIGR1cmluZyBkcmFnXG5cbiAgICAgICAgaWYgKGRyYWdvbi5kcm9wKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVjdCA9IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgICAgZHJhZ29uLnJlY3QgPSByZWN0ID0ge1xuICAgICAgICAgICAgbGVmdDogICBNYXRoLnJvdW5kKHJlY3QubGVmdCAtIDEpLFxuICAgICAgICAgICAgdG9wOiAgICBNYXRoLnJvdW5kKHJlY3QudG9wIC0gMSksXG4gICAgICAgICAgICByaWdodDogIE1hdGgucm91bmQocmVjdC5yaWdodCksXG4gICAgICAgICAgICBib3R0b206IE1hdGgucm91bmQocmVjdC5ib3R0b20pLFxuICAgICAgICAgICAgd2lkdGg6ICBNYXRoLnJvdW5kKHJlY3Qud2lkdGgpLFxuICAgICAgICAgICAgaGVpZ2h0OiBNYXRoLnJvdW5kKHJlY3QuaGVpZ2h0KVxuICAgICAgICB9O1xuXG4gICAgICAgIGRyYWdvbi5waW4gPSB7XG4gICAgICAgICAgICB4OiB3aW5kb3cuc2Nyb2xsWCArIGV2dC5jbGllbnRYLFxuICAgICAgICAgICAgeTogd2luZG93LnNjcm9sbFkgKyBldnQuY2xpZW50WVxuICAgICAgICB9O1xuXG4gICAgICAgIGRyYWdvbi5vcmlnaW4gPSBkcmFnb24uaXRlbUNvb3JkaW5hdGVzKHRoaXMpO1xuXG4gICAgICAgIGlmIChkcmFnb24uY2FsbGJhY2suZ3JhYmJlZCkge1xuICAgICAgICAgICAgZHJhZ29uLmNhbGxiYWNrLmdyYWJiZWQuY2FsbCh0aGlzLCBkcmFnb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgZHJhZ29uLmdldEFsbEl0ZW1Cb3VuZGluZ1JlY3RzKCk7XG5cbiAgICAgICAgZHJhZ29uLmRyb3AgPSB0aGlzLm5leHRFbGVtZW50U2libGluZztcbiAgICAgICAgZHJhZ29uLmRyb3Auc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gJzBzJztcbiAgICAgICAgZHJhZ29uLmRyb3Auc3R5bGUuYm9yZGVyVG9wV2lkdGggPSByZWN0LmhlaWdodCArICdweCc7XG5cbiAgICAgICAgdGhpcy5zdHlsZS53aWR0aCA9IHJlY3Qud2lkdGggKyAncHgnO1xuICAgICAgICB0aGlzLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcwcyc7XG4gICAgICAgIHRoaXMuc3R5bGVbdHJhbnNmb3JtXSA9IHRyYW5zbGF0ZShcbiAgICAgICAgICAgIHJlY3QubGVmdCAtIHdpbmRvdy5zY3JvbGxYLFxuICAgICAgICAgICAgcmVjdC50b3AgIC0gd2luZG93LnNjcm9sbFlcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdkcmFnb24tcG9wJyk7XG4gICAgICAgIHRoaXMuc3R5bGUuekluZGV4ID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZHJhZ29uLm1vZGVsTGlzdHNbMF0uY29udGFpbmVyLnBhcmVudEVsZW1lbnQpLnpJbmRleDtcblxuICAgICAgICBpZiAoIWRyYWdvbi5jb250YWluZXIpIHtcbiAgICAgICAgICAgIC8vIHdhbGsgYmFjayB0byBjbG9zZXN0IHNoYWRvdyByb290IE9SIGJvZHkgdGFnIE9SIHJvb3QgdGFnXG4gICAgICAgICAgICB2YXIgY29udGFpbmVyID0gdGhpcztcbiAgICAgICAgICAgIHdoaWxlIChjb250YWluZXIucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lciA9IGNvbnRhaW5lci5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIFNoYWRvd1Jvb3QgIT09ICd1bmRlZmluZWQnICYmIGNvbnRhaW5lciBpbnN0YW5jZW9mIFNoYWRvd1Jvb3QgfHxcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyLnRhZ05hbWUgPT09ICdCT0RZJ1xuICAgICAgICAgICAgICAgICl7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRyYWdvbi5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgICAgIH1cblxuICAgICAgICBkcmFnb24uY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMpO1xuXG4gICAgICAgIHJlY3QubGVmdCAgICs9IHdpbmRvdy5zY3JvbGxYO1xuICAgICAgICByZWN0LnRvcCAgICArPSB3aW5kb3cuc2Nyb2xsWTtcbiAgICAgICAgcmVjdC5yaWdodCAgKz0gd2luZG93LnNjcm9sbFg7XG4gICAgICAgIHJlY3QuYm90dG9tICs9IHdpbmRvdy5zY3JvbGxZO1xuXG4gICAgICAgIGRyYWdvbi5hZGRFdnQodGhpcywgJ21vdXNlbW92ZScpO1xuICAgICAgICBkcmFnb24uYWRkRXZ0KHRoaXMsICdtb3VzZXVwJyk7XG4gICAgfSxcblxuICAgIG1vdXNlbW92ZTogZnVuY3Rpb24gKGRyYWdvbiwgZXZ0KSB7XG4gICAgICAgIGRyYWdvbi5kcm9wLnN0eWxlLnRyYW5zaXRpb24gPSBSRVZFUlRfVE9fU1RZTEVTSEVFVF9WQUxVRTtcblxuICAgICAgICB2YXIgaG92ZXJMaXN0ID0gZHJhZ29uLnBvaW50SW5MaXN0UmVjdHMoeyB4OiBldnQuY2xpZW50WCwgeTogZXZ0LmNsaWVudFkgfSkgfHwgZHJhZ29uLm1vc3RSZWNlbnRIb3Zlckxpc3Q7XG5cbiAgICAgICAgaWYgKGhvdmVyTGlzdCkge1xuICAgICAgICAgICAgdmFyIGR4ID0gZXZ0LmNsaWVudFggLSBkcmFnb24ucGluLngsXG4gICAgICAgICAgICAgICAgZHkgPSBldnQuY2xpZW50WSAtIGRyYWdvbi5waW4ueTtcblxuICAgICAgICAgICAgZHJhZ29uLm1vc3RSZWNlbnRIb3Zlckxpc3QgPSBob3Zlckxpc3Q7XG5cbiAgICAgICAgICAgIHZhciBtYXhTY3JvbGxZID0gaG92ZXJMaXN0LmVsZW1lbnQuc2Nyb2xsSGVpZ2h0IC0gaG92ZXJMaXN0LnJlY3QuaGVpZ2h0LFxuICAgICAgICAgICAgICAgIHkgPSBldnQuY2xpZW50WSArIHdpbmRvdy5zY3JvbGxZLFxuICAgICAgICAgICAgICAgIG1hZ25pdHVkZTtcblxuICAgICAgICAgICAgaWYgKG1heFNjcm9sbFkgPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gbGlzdCBpcyBzY3JvbGxhYmxlIChpcyB0YWxsZXIgdGhhbiByZWN0KVxuICAgICAgICAgICAgICAgIGlmIChob3Zlckxpc3QuZWxlbWVudC5zY3JvbGxUb3AgPiAwICYmIChtYWduaXR1ZGUgPSB5IC0gKGhvdmVyTGlzdC5yZWN0LnRvcCArIDUpKSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbW91c2UgbmVhciBvciBhYm92ZSB0b3AgYW5kIGxpc3QgaXMgbm90IHNjcm9sbGVkIHRvIHRvcCB5ZXRcbiAgICAgICAgICAgICAgICAgICAgcmVzZXRBdXRvU2Nyb2xsVGltZXIobWFnbml0dWRlLCAwLCBob3Zlckxpc3QuZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChob3Zlckxpc3QuZWxlbWVudC5zY3JvbGxUb3AgPCBtYXhTY3JvbGxZICYmIChtYWduaXR1ZGUgPSB5IC0gKGhvdmVyTGlzdC5yZWN0LmJvdHRvbSAtIDEgLSA1KSkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG1vdXNlIG5lYXIgb3IgYmVsb3cgYm90dG9tIGFuZCBsaXN0IG5vdCBzY3JvbGxlZCB0byBib3R0b20geWV0XG4gICAgICAgICAgICAgICAgICAgIHJlc2V0QXV0b1Njcm9sbFRpbWVyKG1hZ25pdHVkZSwgbWF4U2Nyb2xsWSwgaG92ZXJMaXN0LmVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG1vdXNlIGluc2lkZVxuICAgICAgICAgICAgICAgICAgICByZXNldEF1dG9TY3JvbGxUaW1lcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG90aGVyID0gZHJhZ29uLnBvaW50SW5JdGVtUmVjdHMoe1xuICAgICAgICAgICAgICAgIHg6IGV2dC5jbGllbnRYLFxuICAgICAgICAgICAgICAgIHk6IGRyYWdvbi5yZWN0LmJvdHRvbSArIHdpbmRvdy5zY3JvbGxZICsgZHkgKyBob3Zlckxpc3QuZWxlbWVudC5zY3JvbGxUb3BcbiAgICAgICAgICAgIH0sIHRoaXMsIGRyYWdvbi5kcm9wKTtcblxuICAgICAgICAgICAgdGhpcy5zdHlsZVt0cmFuc2Zvcm1dID0gdHJhbnNsYXRlKFxuICAgICAgICAgICAgICAgIGRyYWdvbi5yZWN0LmxlZnQgLSB3aW5kb3cuc2Nyb2xsWCArIGR4LFxuICAgICAgICAgICAgICAgIGRyYWdvbi5yZWN0LnRvcCAtIHdpbmRvdy5zY3JvbGxZICsgZHlcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGlmIChvdGhlcikge1xuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gb3RoZXIuZWxlbWVudDtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlLnRyYW5zaXRpb24gPSBSRVZFUlRfVE9fU1RZTEVTSEVFVF9WQUxVRTtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlLmJvcmRlclRvcFdpZHRoID0gZHJhZ29uLmRyb3Auc3R5bGUuYm9yZGVyVG9wV2lkdGg7XG4gICAgICAgICAgICAgICAgZHJhZ29uLmRyb3Auc3R5bGUuYm9yZGVyVG9wV2lkdGggPSBudWxsO1xuICAgICAgICAgICAgICAgIGRyYWdvbi5kcm9wID0gZWxlbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBtb3VzZXVwOiBmdW5jdGlvbiAoZHJhZ29uLCBldnQpIHtcbiAgICAgICAgcmVzZXRBdXRvU2Nyb2xsVGltZXIoKTtcbiAgICAgICAgZHJhZ29uLnJlbW92ZUV2dCgnbW91c2Vtb3ZlJyk7XG4gICAgICAgIGRyYWdvbi5yZW1vdmVFdnQoJ21vdXNldXAnKTtcblxuICAgICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgICAgdmFyIG5ld1JlY3QgPSB0aGlzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHdpbmRvdy5zY3JvbGxYICsgbmV3UmVjdC5sZWZ0ID09PSBkcmFnb24ucmVjdC5sZWZ0ICYmXG4gICAgICAgICAgICB3aW5kb3cuc2Nyb2xsWSArIG5ld1JlY3QudG9wID09PSBkcmFnb24ucmVjdC50b3BcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBkcmFnb24ucmVpbnNlcnQodGhpcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgZHJvcFJlY3QgPSBkcmFnb24uZHJvcC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgICAgICAgZHJhZ29uLmFkZEV2dCh0aGlzLCAndHJhbnNpdGlvbmVuZCcsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSBSRVZFUlRfVE9fU1RZTEVTSEVFVF9WQUxVRTsgLy9yZXZlcnRzIHRvIDIwMG1zXG4gICAgICAgICAgICB0aGlzLnN0eWxlLnRyYW5zaXRpb25Qcm9wZXJ0eSA9IHRyYW5zZm9ybTtcbiAgICAgICAgICAgIHRoaXMuc3R5bGVbdHJhbnNmb3JtXSA9IHRyYW5zbGF0ZShcbiAgICAgICAgICAgICAgICBkcm9wUmVjdC5sZWZ0IC0gd2luZG93LnNjcm9sbFgsXG4gICAgICAgICAgICAgICAgZHJvcFJlY3QudG9wIC0gd2luZG93LnNjcm9sbFlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgdHJhbnNpdGlvbmVuZDogZnVuY3Rpb24gKGRyYWdvbiwgZXZ0KSB7XG4gICAgICAgIGlmIChldnQucHJvcGVydHlOYW1lID09PSB0cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIGRyYWdvbi5yZW1vdmVFdnQoJ3RyYW5zaXRpb25lbmQnKTtcbiAgICAgICAgICAgIGRyYWdvbi5yZWluc2VydCh0aGlzKTtcblxuICAgICAgICAgICAgdGhpcy5zdHlsZS50cmFuc2l0aW9uUHJvcGVydHkgPSBSRVZFUlRfVE9fU1RZTEVTSEVFVF9WQUxVRTsgLy9yZXZlcnRzIHRvIGJvcmRlci10b3Atd2lkdGhcblxuICAgICAgICAgICAgdmFyIG9yaWdpbkxpc3QgPSBkcmFnb24ubW9kZWxMaXN0c1tkcmFnb24ub3JpZ2luLmxpc3RdO1xuICAgICAgICAgICAgdmFyIG1vZGVsID0gb3JpZ2luTGlzdC5zcGxpY2UoZHJhZ29uLm9yaWdpbi5pdGVtLCAxKVswXTtcbiAgICAgICAgICAgIHZhciBkZXN0aW5hdGlvbiA9IGRyYWdvbi5pdGVtQ29vcmRpbmF0ZXModGhpcyk7XG4gICAgICAgICAgICB2YXIgZGVzdGluYXRpb25MaXN0ID0gZHJhZ29uLm1vZGVsTGlzdHNbZGVzdGluYXRpb24ubGlzdF07XG4gICAgICAgICAgICB2YXIgaW50ZXJMaXN0RHJvcCA9IG9yaWdpbkxpc3QgIT09IGRlc3RpbmF0aW9uTGlzdDtcbiAgICAgICAgICAgIHZhciBsaXN0Q2hhbmdlZCA9IGludGVyTGlzdERyb3AgfHwgZHJhZ29uLm9yaWdpbi5pdGVtICE9PSBkZXN0aW5hdGlvbi5pdGVtO1xuICAgICAgICAgICAgZGVzdGluYXRpb25MaXN0LnNwbGljZShkZXN0aW5hdGlvbi5pdGVtLCAwLCBtb2RlbCk7XG5cbiAgICAgICAgICAgIGlmIChsaXN0Q2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIG9yaWdpbkxpc3QuZWxlbWVudC5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnbGlzdGNoYW5nZWQnKSk7XG4gICAgICAgICAgICAgICAgaWYgKGludGVyTGlzdERyb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgZGVzdGluYXRpb25MaXN0LmVsZW1lbnQuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ2xpc3RjaGFuZ2VkJykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRyYWdvbi5jYWxsYmFjay5kcm9wcGVkKSB7XG4gICAgICAgICAgICAgICAgZHJhZ29uLmNhbGxiYWNrLmRyb3BwZWQuY2FsbCh0aGlzLCBkcmFnb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuZnVuY3Rpb24gcmVzZXRBdXRvU2Nyb2xsVGltZXIobWFnbml0dWRlLCBsaW1pdCwgZWxlbWVudCkge1xuICAgIGlmICghbWFnbml0dWRlKSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwodGltZXIpO1xuICAgICAgICBzY3JvbGxWZWxvY2l0eSA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGNoYW5nZURpcmVjdGlvbiA9XG4gICAgICAgICAgICBzY3JvbGxWZWxvY2l0eSAgPCAgMCAmJiBtYWduaXR1ZGUgID49IDAgfHxcbiAgICAgICAgICAgIHNjcm9sbFZlbG9jaXR5ID09PSAwICYmIG1hZ25pdHVkZSAhPT0gMCB8fFxuICAgICAgICAgICAgc2Nyb2xsVmVsb2NpdHkgID4gIDAgJiYgbWFnbml0dWRlICA8PSAwO1xuICAgICAgICBzY3JvbGxWZWxvY2l0eSA9IG1hZ25pdHVkZSA+IDAgPyBNYXRoLm1pbig1MCwgbWFnbml0dWRlKSA6IE1hdGgubWF4KC01MCwgbWFnbml0dWRlKTtcbiAgICAgICAgaWYgKGNoYW5nZURpcmVjdGlvbikge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aW1lcik7XG4gICAgICAgICAgICB0aW1lciA9IHNldEludGVydmFsKGZ1bmN0aW9uIChsaW1pdCkge1xuICAgICAgICAgICAgICAgIHZhciBzY3JvbGxUb3AgPSBlbGVtZW50LnNjcm9sbFRvcCArIHNjcm9sbFZlbG9jaXR5O1xuICAgICAgICAgICAgICAgIGlmIChzY3JvbGxWZWxvY2l0eSA8IDAgJiYgc2Nyb2xsVG9wIDwgbGltaXQgfHwgc2Nyb2xsVmVsb2NpdHkgPiAwICYmIHNjcm9sbFRvcCA+IGxpbWl0KSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuc2Nyb2xsVG9wID0gbGltaXQ7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGltZXIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuc2Nyb2xsVG9wID0gc2Nyb2xsVG9wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIDEyNSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIHRvQXJyYXkoYXJyYXlMaWtlT2JqZWN0KSB7XG4gICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFycmF5TGlrZU9iamVjdCk7XG59XG5cbmZ1bmN0aW9uIHBvaW50SW5SZWN0KHBvaW50LCByZWN0KSB7XG4gICAgcmV0dXJuIHJlY3QudG9wIDw9IHBvaW50LnkgJiYgcG9pbnQueSA8PSByZWN0LmJvdHRvbVxuICAgICAgICAmJiByZWN0LmxlZnQgPD0gcG9pbnQueCAmJiBwb2ludC54IDw9IHJlY3QucmlnaHQ7XG59XG5cbmZ1bmN0aW9uIHRyYW5zbGF0ZShsZWZ0LCB0b3ApIHtcbiAgICByZXR1cm4gJ3RyYW5zbGF0ZSgnXG4gICAgICAgICsgTWF0aC5mbG9vcihsZWZ0ICsgd2luZG93LnNjcm9sbFgpICsgJ3B4LCdcbiAgICAgICAgKyBNYXRoLmZsb29yKHRvcCArIHdpbmRvdy5zY3JvbGxZKSArICdweCknO1xufVxuXG5mdW5jdGlvbiBodG1sRW5jb2RlKHN0cmluZykge1xuICAgIHZhciB0ZXh0Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHN0cmluZyk7XG5cbiAgICByZXR1cm4gZG9jdW1lbnRcbiAgICAgICAgLmNyZWF0ZUVsZW1lbnQoJ2EnKVxuICAgICAgICAuYXBwZW5kQ2hpbGQodGV4dE5vZGUpXG4gICAgICAgIC5wYXJlbnROb2RlXG4gICAgICAgIC5pbm5lckhUTUw7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBgPHVsPi4uLjwvdWw+YCBlbGVtZW50cyBhbmQgaW5zZXJ0cyB0aGVtIGludG8gYW4gYGVsZW1lbnRgIHByb3BlcnR5IG9uIGVhY2ggbW9kZWwuXG4gKiBAcGFyYW0ge29iamVjdH0gbW9kZWxMaXN0c1xuICogQHJldHVybnMgYG1vZGVsTGlzdHNgXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUxpc3RFbGVtZW50c0Zyb21Nb2RlbExpc3RzKG1vZGVsTGlzdHMsIG9wdGlvbnMpIHtcbiAgICB2YXIgdGVtcGxhdGVMYWJlbCA9IG9wdGlvbnMubGFiZWwgfHwgJ3tsYWJlbH0nO1xuXG4gICAgbW9kZWxMaXN0cy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RlbExpc3QsIGxpc3RJbmRleCkge1xuICAgICAgICB2YXIgbGlzdExhYmVsID0gbW9kZWxMaXN0LmxhYmVsIHx8IHRlbXBsYXRlTGFiZWwsXG4gICAgICAgICAgICBsaXN0SHRtbEVuY29kZSA9IG1vZGVsTGlzdC5odG1sRW5jb2RlICE9PSB1bmRlZmluZWQgJiYgbW9kZWxMaXN0Lmh0bWxFbmNvZGUgfHwgb3B0aW9ucy5odG1sRW5jb2RlLFxuICAgICAgICAgICAgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksXG4gICAgICAgICAgICBsaXN0RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3VsJyk7XG5cbiAgICAgICAgaWYgKG1vZGVsTGlzdC5tb2RlbHMpIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKG1vZGVsTGlzdCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleSAhPT0gJ21vZGVscycpIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kZWxMaXN0Lm1vZGVsc1trZXldID0gbW9kZWxMaXN0W2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBtb2RlbExpc3RzW2xpc3RJbmRleF0gPSBtb2RlbExpc3QgPSBtb2RlbExpc3QubW9kZWxzO1xuICAgICAgICB9IGVsc2UgaWYgKG1vZGVsTGlzdCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICBtb2RlbExpc3QubW9kZWxzID0gbW9kZWxMaXN0OyAvLyBwb2ludCB0byBzZWxmXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcignTGlzdCBbezF9XSBub3QgYW4gYXJyYXkgb2YgbW9kZWxzICh3aXRoIG9yIHdpdGhvdXQgYWRkaXRpb25hbCBwcm9wZXJ0aWVzKSBPUiAnICtcbiAgICAgICAgICAgICAgICAnYW4gb2JqZWN0ICh3aXRoIGEgYG1vZGVsc2AgcHJvcGVydHkgY29udGFpbmluZyBhbiBhcnJheSBvZiBtb2RlbHMpLicsIGxpc3RJbmRleCk7XG4gICAgICAgIH1cblxuICAgICAgICBtb2RlbExpc3QuZm9yRWFjaChmdW5jdGlvbiAobW9kZWwpIHtcbiAgICAgICAgICAgIHZhciBtb2RlbExhYmVsID0gbW9kZWwubGFiZWwgfHwgbGlzdExhYmVsLFxuICAgICAgICAgICAgICAgIG1vZGVsSHRtbEVuY29kZSA9IG1vZGVsLmh0bWxFbmNvZGUgIT09IHVuZGVmaW5lZCAmJiBtb2RlbC5odG1sRW5jb2RlIHx8IGxpc3RIdG1sRW5jb2RlLFxuICAgICAgICAgICAgICAgIG1vZGVsT2JqZWN0ID0gdHlwZW9mIG1vZGVsID09PSAnb2JqZWN0JyA/IG1vZGVsIDogeyBsYWJlbDogbW9kZWx9LFxuICAgICAgICAgICAgICAgIGxhYmVsID0gZm9ybWF0LmNhbGwoW21vZGVsT2JqZWN0LCBtb2RlbExpc3QsIG9wdGlvbnNdLCBtb2RlbExhYmVsKSxcbiAgICAgICAgICAgICAgICBpdGVtRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpJyk7XG5cbiAgICAgICAgICAgIGl0ZW1FbGVtZW50LmlubmVySFRNTCA9IG1vZGVsSHRtbEVuY29kZSA/IGh0bWxFbmNvZGUobGFiZWwpIDogbGFiZWw7XG5cbiAgICAgICAgICAgIGxpc3RFbGVtZW50LmFwcGVuZENoaWxkKGl0ZW1FbGVtZW50KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gYXBwZW5kIHRoZSBmaW5hbCBcImZlbmNlcG9zdFwiIGl0ZW0gLS0gZHJvcCB0YXJnZXQgYXQgYm90dG9tIG9mIGxpc3QgYWZ0ZXIgYWxsIGl0ZW1zXG4gICAgICAgIHZhciBpdGVtRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpJyk7XG4gICAgICAgIGl0ZW1FbGVtZW50LmlubmVySFRNTCA9ICcmbmJzcDsnO1xuICAgICAgICBsaXN0RWxlbWVudC5hcHBlbmRDaGlsZChpdGVtRWxlbWVudCk7XG5cbiAgICAgICAgLy8gYXBwZW5kIGhlYWRlciB0byBjb250YWluZXJcbiAgICAgICAgaWYgKG1vZGVsTGlzdC50aXRsZSkge1xuICAgICAgICAgICAgdmFyIGhlYWRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgaGVhZGVyLmlubmVySFRNTCA9IGxpc3RIdG1sRW5jb2RlID8gaHRtbEVuY29kZShtb2RlbExpc3QudGl0bGUpIDogbW9kZWxMaXN0LnRpdGxlO1xuICAgICAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGhlYWRlcik7XG4gICAgICAgIH1cblxuICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQobGlzdEVsZW1lbnQpO1xuICAgICAgICBjb250YWluZXIuY2xhc3NOYW1lID0gbW9kZWxMaXN0LmNzc0NsYXNzTmFtZXMgfHwgb3B0aW9ucy5jc3NDbGFzc05hbWVzIHx8ICdkcmFnb24tbGlzdCc7XG4gICAgICAgIG1vZGVsTGlzdC5lbGVtZW50ID0gbGlzdEVsZW1lbnQ7XG4gICAgICAgIG1vZGVsTGlzdC5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gbW9kZWxMaXN0cztcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBgLm1vZGVsTGlzdHNgIGFycmF5IHdpdGggdGhlc2UgPGxpPiBlbGVtZW50cycgcGFyZW50IDx1bD4gZWxlbWVudHNcbiAqIEBwYXJhbSB7RWxlbWVudFtdfSBsaXN0SXRlbUVsZW1lbnRzXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU1vZGVsTGlzdHNGcm9tTGlzdEVsZW1lbnRzKGxpc3RJdGVtRWxlbWVudHMpIHtcbiAgICB2YXIgbW9kZWxMaXN0cyA9IFtdO1xuXG4gICAgbGlzdEl0ZW1FbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtRWxlbWVudCkge1xuICAgICAgICB2YXIgbGlzdEVsZW1lbnQgPSBpdGVtRWxlbWVudC5wYXJlbnRFbGVtZW50LFxuICAgICAgICAgICAgY29udGFpbmVyID0gbGlzdEVsZW1lbnQucGFyZW50RWxlbWVudCxcbiAgICAgICAgICAgIG1vZGVscyA9IFtdO1xuICAgICAgICBpZiAoIW1vZGVsTGlzdHMuZmluZChmdW5jdGlvbiAobGlzdCkgeyByZXR1cm4gbGlzdC5lbGVtZW50ID09PSBsaXN0RWxlbWVudDsgfSkpIHtcbiAgICAgICAgICAgIHRvQXJyYXkobGlzdEVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnbGknKSkuZm9yRWFjaChmdW5jdGlvbiAoaXRlbUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbUVsZW1lbnQgIT09IGxpc3RFbGVtZW50Lmxhc3RFbGVtZW50Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kZWxzLnB1c2goaXRlbUVsZW1lbnQuaW5uZXJIVE1MKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG1vZGVscy5lbGVtZW50ID0gbGlzdEVsZW1lbnQ7XG4gICAgICAgICAgICBtb2RlbHMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgICAgICAgbW9kZWxMaXN0cy5wdXNoKG1vZGVscyk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBtb2RlbExpc3RzO1xufVxuXG5mdW5jdGlvbiBjYXB0dXJlRXZlbnQoZXZ0KSB7XG4gICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xufVxuXG5mdW5jdGlvbiBlcnJvcigpIHtcbiAgICByZXR1cm4gJ2xpc3QtZHJhZ29uOiAnICsgZm9ybWF0LmFwcGx5KHRoaXMsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xufVxuXG4vLyB0aGlzIGludGVyZmFjZSBjb25zaXN0cyBzb2xlbHkgb2YgdGhlIHByb3RvdHlwYWwgb2JqZWN0IGNvbnN0cnVjdG9yXG5tb2R1bGUuZXhwb3J0cyA9IExpc3REcmFnb247XG4iLCI7KGZ1bmN0aW9uICgpIHsgLy8gY2xvc3VyZSBmb3Igd2ViIGJyb3dzZXJzXG5cbmlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICBtb2R1bGUuZXhwb3J0cyA9IExSVUNhY2hlXG59IGVsc2Uge1xuICAvLyBqdXN0IHNldCB0aGUgZ2xvYmFsIGZvciBub24tbm9kZSBwbGF0Zm9ybXMuXG4gIHRoaXMuTFJVQ2FjaGUgPSBMUlVDYWNoZVxufVxuXG5mdW5jdGlvbiBoT1AgKG9iaiwga2V5KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpXG59XG5cbmZ1bmN0aW9uIG5haXZlTGVuZ3RoICgpIHsgcmV0dXJuIDEgfVxuXG5mdW5jdGlvbiBMUlVDYWNoZSAob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTFJVQ2FjaGUpKVxuICAgIHJldHVybiBuZXcgTFJVQ2FjaGUob3B0aW9ucylcblxuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdudW1iZXInKVxuICAgIG9wdGlvbnMgPSB7IG1heDogb3B0aW9ucyB9XG5cbiAgaWYgKCFvcHRpb25zKVxuICAgIG9wdGlvbnMgPSB7fVxuXG4gIHRoaXMuX21heCA9IG9wdGlvbnMubWF4XG4gIC8vIEtpbmQgb2Ygd2VpcmQgdG8gaGF2ZSBhIGRlZmF1bHQgbWF4IG9mIEluZmluaXR5LCBidXQgb2ggd2VsbC5cbiAgaWYgKCF0aGlzLl9tYXggfHwgISh0eXBlb2YgdGhpcy5fbWF4ID09PSBcIm51bWJlclwiKSB8fCB0aGlzLl9tYXggPD0gMCApXG4gICAgdGhpcy5fbWF4ID0gSW5maW5pdHlcblxuICB0aGlzLl9sZW5ndGhDYWxjdWxhdG9yID0gb3B0aW9ucy5sZW5ndGggfHwgbmFpdmVMZW5ndGhcbiAgaWYgKHR5cGVvZiB0aGlzLl9sZW5ndGhDYWxjdWxhdG9yICE9PSBcImZ1bmN0aW9uXCIpXG4gICAgdGhpcy5fbGVuZ3RoQ2FsY3VsYXRvciA9IG5haXZlTGVuZ3RoXG5cbiAgdGhpcy5fYWxsb3dTdGFsZSA9IG9wdGlvbnMuc3RhbGUgfHwgZmFsc2VcbiAgdGhpcy5fbWF4QWdlID0gb3B0aW9ucy5tYXhBZ2UgfHwgbnVsbFxuICB0aGlzLl9kaXNwb3NlID0gb3B0aW9ucy5kaXNwb3NlXG4gIHRoaXMucmVzZXQoKVxufVxuXG4vLyByZXNpemUgdGhlIGNhY2hlIHdoZW4gdGhlIG1heCBjaGFuZ2VzLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KExSVUNhY2hlLnByb3RvdHlwZSwgXCJtYXhcIixcbiAgeyBzZXQgOiBmdW5jdGlvbiAobUwpIHtcbiAgICAgIGlmICghbUwgfHwgISh0eXBlb2YgbUwgPT09IFwibnVtYmVyXCIpIHx8IG1MIDw9IDAgKSBtTCA9IEluZmluaXR5XG4gICAgICB0aGlzLl9tYXggPSBtTFxuICAgICAgaWYgKHRoaXMuX2xlbmd0aCA+IHRoaXMuX21heCkgdHJpbSh0aGlzKVxuICAgIH1cbiAgLCBnZXQgOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9tYXggfVxuICAsIGVudW1lcmFibGUgOiB0cnVlXG4gIH0pXG5cbi8vIHJlc2l6ZSB0aGUgY2FjaGUgd2hlbiB0aGUgbGVuZ3RoQ2FsY3VsYXRvciBjaGFuZ2VzLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KExSVUNhY2hlLnByb3RvdHlwZSwgXCJsZW5ndGhDYWxjdWxhdG9yXCIsXG4gIHsgc2V0IDogZnVuY3Rpb24gKGxDKSB7XG4gICAgICBpZiAodHlwZW9mIGxDICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhpcy5fbGVuZ3RoQ2FsY3VsYXRvciA9IG5haXZlTGVuZ3RoXG4gICAgICAgIHRoaXMuX2xlbmd0aCA9IHRoaXMuX2l0ZW1Db3VudFxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5fY2FjaGUpIHtcbiAgICAgICAgICB0aGlzLl9jYWNoZVtrZXldLmxlbmd0aCA9IDFcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fbGVuZ3RoQ2FsY3VsYXRvciA9IGxDXG4gICAgICAgIHRoaXMuX2xlbmd0aCA9IDBcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMuX2NhY2hlKSB7XG4gICAgICAgICAgdGhpcy5fY2FjaGVba2V5XS5sZW5ndGggPSB0aGlzLl9sZW5ndGhDYWxjdWxhdG9yKHRoaXMuX2NhY2hlW2tleV0udmFsdWUpXG4gICAgICAgICAgdGhpcy5fbGVuZ3RoICs9IHRoaXMuX2NhY2hlW2tleV0ubGVuZ3RoXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2xlbmd0aCA+IHRoaXMuX21heCkgdHJpbSh0aGlzKVxuICAgIH1cbiAgLCBnZXQgOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9sZW5ndGhDYWxjdWxhdG9yIH1cbiAgLCBlbnVtZXJhYmxlIDogdHJ1ZVxuICB9KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTFJVQ2FjaGUucHJvdG90eXBlLCBcImxlbmd0aFwiLFxuICB7IGdldCA6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2xlbmd0aCB9XG4gICwgZW51bWVyYWJsZSA6IHRydWVcbiAgfSlcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTFJVQ2FjaGUucHJvdG90eXBlLCBcIml0ZW1Db3VudFwiLFxuICB7IGdldCA6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2l0ZW1Db3VudCB9XG4gICwgZW51bWVyYWJsZSA6IHRydWVcbiAgfSlcblxuTFJVQ2FjaGUucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAoZm4sIHRoaXNwKSB7XG4gIHRoaXNwID0gdGhpc3AgfHwgdGhpc1xuICB2YXIgaSA9IDBcbiAgdmFyIGl0ZW1Db3VudCA9IHRoaXMuX2l0ZW1Db3VudFxuXG4gIGZvciAodmFyIGsgPSB0aGlzLl9tcnUgLSAxOyBrID49IDAgJiYgaSA8IGl0ZW1Db3VudDsgay0tKSBpZiAodGhpcy5fbHJ1TGlzdFtrXSkge1xuICAgIGkrK1xuICAgIHZhciBoaXQgPSB0aGlzLl9scnVMaXN0W2tdXG4gICAgaWYgKGlzU3RhbGUodGhpcywgaGl0KSkge1xuICAgICAgZGVsKHRoaXMsIGhpdClcbiAgICAgIGlmICghdGhpcy5fYWxsb3dTdGFsZSkgaGl0ID0gdW5kZWZpbmVkXG4gICAgfVxuICAgIGlmIChoaXQpIHtcbiAgICAgIGZuLmNhbGwodGhpc3AsIGhpdC52YWx1ZSwgaGl0LmtleSwgdGhpcylcbiAgICB9XG4gIH1cbn1cblxuTFJVQ2FjaGUucHJvdG90eXBlLmtleXMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBrZXlzID0gbmV3IEFycmF5KHRoaXMuX2l0ZW1Db3VudClcbiAgdmFyIGkgPSAwXG4gIGZvciAodmFyIGsgPSB0aGlzLl9tcnUgLSAxOyBrID49IDAgJiYgaSA8IHRoaXMuX2l0ZW1Db3VudDsgay0tKSBpZiAodGhpcy5fbHJ1TGlzdFtrXSkge1xuICAgIHZhciBoaXQgPSB0aGlzLl9scnVMaXN0W2tdXG4gICAga2V5c1tpKytdID0gaGl0LmtleVxuICB9XG4gIHJldHVybiBrZXlzXG59XG5cbkxSVUNhY2hlLnByb3RvdHlwZS52YWx1ZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB2YWx1ZXMgPSBuZXcgQXJyYXkodGhpcy5faXRlbUNvdW50KVxuICB2YXIgaSA9IDBcbiAgZm9yICh2YXIgayA9IHRoaXMuX21ydSAtIDE7IGsgPj0gMCAmJiBpIDwgdGhpcy5faXRlbUNvdW50OyBrLS0pIGlmICh0aGlzLl9scnVMaXN0W2tdKSB7XG4gICAgdmFyIGhpdCA9IHRoaXMuX2xydUxpc3Rba11cbiAgICB2YWx1ZXNbaSsrXSA9IGhpdC52YWx1ZVxuICB9XG4gIHJldHVybiB2YWx1ZXNcbn1cblxuTFJVQ2FjaGUucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5fZGlzcG9zZSAmJiB0aGlzLl9jYWNoZSkge1xuICAgIGZvciAodmFyIGsgaW4gdGhpcy5fY2FjaGUpIHtcbiAgICAgIHRoaXMuX2Rpc3Bvc2UoaywgdGhpcy5fY2FjaGVba10udmFsdWUpXG4gICAgfVxuICB9XG5cbiAgdGhpcy5fY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpIC8vIGhhc2ggb2YgaXRlbXMgYnkga2V5XG4gIHRoaXMuX2xydUxpc3QgPSBPYmplY3QuY3JlYXRlKG51bGwpIC8vIGxpc3Qgb2YgaXRlbXMgaW4gb3JkZXIgb2YgdXNlIHJlY2VuY3lcbiAgdGhpcy5fbXJ1ID0gMCAvLyBtb3N0IHJlY2VudGx5IHVzZWRcbiAgdGhpcy5fbHJ1ID0gMCAvLyBsZWFzdCByZWNlbnRseSB1c2VkXG4gIHRoaXMuX2xlbmd0aCA9IDAgLy8gbnVtYmVyIG9mIGl0ZW1zIGluIHRoZSBsaXN0XG4gIHRoaXMuX2l0ZW1Db3VudCA9IDBcbn1cblxuTFJVQ2FjaGUucHJvdG90eXBlLmR1bXAgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBhcnIgPSBbXVxuICB2YXIgaSA9IDBcblxuICBmb3IgKHZhciBrID0gdGhpcy5fbXJ1IC0gMTsgayA+PSAwICYmIGkgPCB0aGlzLl9pdGVtQ291bnQ7IGstLSkgaWYgKHRoaXMuX2xydUxpc3Rba10pIHtcbiAgICB2YXIgaGl0ID0gdGhpcy5fbHJ1TGlzdFtrXVxuICAgIGlmICghaXNTdGFsZSh0aGlzLCBoaXQpKSB7XG4gICAgICAvL0RvIG5vdCBzdG9yZSBzdGFsZWQgaGl0c1xuICAgICAgKytpXG4gICAgICBhcnIucHVzaCh7XG4gICAgICAgIGs6IGhpdC5rZXksXG4gICAgICAgIHY6IGhpdC52YWx1ZSxcbiAgICAgICAgZTogaGl0Lm5vdyArIChoaXQubWF4QWdlIHx8IDApXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgLy9hcnIgaGFzIHRoZSBtb3N0IHJlYWQgZmlyc3RcbiAgcmV0dXJuIGFyclxufVxuXG5MUlVDYWNoZS5wcm90b3R5cGUuZHVtcExydSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX2xydUxpc3Rcbn1cblxuTFJVQ2FjaGUucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlLCBtYXhBZ2UpIHtcbiAgbWF4QWdlID0gbWF4QWdlIHx8IHRoaXMuX21heEFnZVxuICB2YXIgbm93ID0gbWF4QWdlID8gRGF0ZS5ub3coKSA6IDBcbiAgdmFyIGxlbiA9IHRoaXMuX2xlbmd0aENhbGN1bGF0b3IodmFsdWUpXG5cbiAgaWYgKGhPUCh0aGlzLl9jYWNoZSwga2V5KSkge1xuICAgIGlmIChsZW4gPiB0aGlzLl9tYXgpIHtcbiAgICAgIGRlbCh0aGlzLCB0aGlzLl9jYWNoZVtrZXldKVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIC8vIGRpc3Bvc2Ugb2YgdGhlIG9sZCBvbmUgYmVmb3JlIG92ZXJ3cml0aW5nXG4gICAgaWYgKHRoaXMuX2Rpc3Bvc2UpXG4gICAgICB0aGlzLl9kaXNwb3NlKGtleSwgdGhpcy5fY2FjaGVba2V5XS52YWx1ZSlcblxuICAgIHRoaXMuX2NhY2hlW2tleV0ubm93ID0gbm93XG4gICAgdGhpcy5fY2FjaGVba2V5XS5tYXhBZ2UgPSBtYXhBZ2VcbiAgICB0aGlzLl9jYWNoZVtrZXldLnZhbHVlID0gdmFsdWVcbiAgICB0aGlzLl9sZW5ndGggKz0gKGxlbiAtIHRoaXMuX2NhY2hlW2tleV0ubGVuZ3RoKVxuICAgIHRoaXMuX2NhY2hlW2tleV0ubGVuZ3RoID0gbGVuXG4gICAgdGhpcy5nZXQoa2V5KVxuXG4gICAgaWYgKHRoaXMuX2xlbmd0aCA+IHRoaXMuX21heClcbiAgICAgIHRyaW0odGhpcylcblxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICB2YXIgaGl0ID0gbmV3IEVudHJ5KGtleSwgdmFsdWUsIHRoaXMuX21ydSsrLCBsZW4sIG5vdywgbWF4QWdlKVxuXG4gIC8vIG92ZXJzaXplZCBvYmplY3RzIGZhbGwgb3V0IG9mIGNhY2hlIGF1dG9tYXRpY2FsbHkuXG4gIGlmIChoaXQubGVuZ3RoID4gdGhpcy5fbWF4KSB7XG4gICAgaWYgKHRoaXMuX2Rpc3Bvc2UpIHRoaXMuX2Rpc3Bvc2Uoa2V5LCB2YWx1ZSlcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHRoaXMuX2xlbmd0aCArPSBoaXQubGVuZ3RoXG4gIHRoaXMuX2xydUxpc3RbaGl0Lmx1XSA9IHRoaXMuX2NhY2hlW2tleV0gPSBoaXRcbiAgdGhpcy5faXRlbUNvdW50ICsrXG5cbiAgaWYgKHRoaXMuX2xlbmd0aCA+IHRoaXMuX21heClcbiAgICB0cmltKHRoaXMpXG5cbiAgcmV0dXJuIHRydWVcbn1cblxuTFJVQ2FjaGUucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKCFoT1AodGhpcy5fY2FjaGUsIGtleSkpIHJldHVybiBmYWxzZVxuICB2YXIgaGl0ID0gdGhpcy5fY2FjaGVba2V5XVxuICBpZiAoaXNTdGFsZSh0aGlzLCBoaXQpKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuTFJVQ2FjaGUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuIGdldCh0aGlzLCBrZXksIHRydWUpXG59XG5cbkxSVUNhY2hlLnByb3RvdHlwZS5wZWVrID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gZ2V0KHRoaXMsIGtleSwgZmFsc2UpXG59XG5cbkxSVUNhY2hlLnByb3RvdHlwZS5wb3AgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBoaXQgPSB0aGlzLl9scnVMaXN0W3RoaXMuX2xydV1cbiAgZGVsKHRoaXMsIGhpdClcbiAgcmV0dXJuIGhpdCB8fCBudWxsXG59XG5cbkxSVUNhY2hlLnByb3RvdHlwZS5kZWwgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIGRlbCh0aGlzLCB0aGlzLl9jYWNoZVtrZXldKVxufVxuXG5MUlVDYWNoZS5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgLy9yZXNldCB0aGUgY2FjaGVcbiAgdGhpcy5yZXNldCgpO1xuXG4gIHZhciBub3cgPSBEYXRlLm5vdygpXG4gIC8vQSBwcmV2aW91cyBzZXJpYWxpemVkIGNhY2hlIGhhcyB0aGUgbW9zdCByZWNlbnQgaXRlbXMgZmlyc3RcbiAgZm9yICh2YXIgbCA9IGFyci5sZW5ndGggLSAxOyBsID49IDA7IGwtLSApIHtcbiAgICB2YXIgaGl0ID0gYXJyW2xdXG4gICAgdmFyIGV4cGlyZXNBdCA9IGhpdC5lIHx8IDBcbiAgICBpZiAoZXhwaXJlc0F0ID09PSAwKSB7XG4gICAgICAvL3RoZSBpdGVtIHdhcyBjcmVhdGVkIHdpdGhvdXQgZXhwaXJhdGlvbiBpbiBhIG5vbiBhZ2VkIGNhY2hlXG4gICAgICB0aGlzLnNldChoaXQuaywgaGl0LnYpXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBtYXhBZ2UgPSBleHBpcmVzQXQgLSBub3dcbiAgICAgIC8vZG9udCBhZGQgYWxyZWFkeSBleHBpcmVkIGl0ZW1zXG4gICAgICBpZiAobWF4QWdlID4gMCkgdGhpcy5zZXQoaGl0LmssIGhpdC52LCBtYXhBZ2UpXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldCAoc2VsZiwga2V5LCBkb1VzZSkge1xuICB2YXIgaGl0ID0gc2VsZi5fY2FjaGVba2V5XVxuICBpZiAoaGl0KSB7XG4gICAgaWYgKGlzU3RhbGUoc2VsZiwgaGl0KSkge1xuICAgICAgZGVsKHNlbGYsIGhpdClcbiAgICAgIGlmICghc2VsZi5fYWxsb3dTdGFsZSkgaGl0ID0gdW5kZWZpbmVkXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChkb1VzZSkgdXNlKHNlbGYsIGhpdClcbiAgICB9XG4gICAgaWYgKGhpdCkgaGl0ID0gaGl0LnZhbHVlXG4gIH1cbiAgcmV0dXJuIGhpdFxufVxuXG5mdW5jdGlvbiBpc1N0YWxlKHNlbGYsIGhpdCkge1xuICBpZiAoIWhpdCB8fCAoIWhpdC5tYXhBZ2UgJiYgIXNlbGYuX21heEFnZSkpIHJldHVybiBmYWxzZVxuICB2YXIgc3RhbGUgPSBmYWxzZTtcbiAgdmFyIGRpZmYgPSBEYXRlLm5vdygpIC0gaGl0Lm5vd1xuICBpZiAoaGl0Lm1heEFnZSkge1xuICAgIHN0YWxlID0gZGlmZiA+IGhpdC5tYXhBZ2VcbiAgfSBlbHNlIHtcbiAgICBzdGFsZSA9IHNlbGYuX21heEFnZSAmJiAoZGlmZiA+IHNlbGYuX21heEFnZSlcbiAgfVxuICByZXR1cm4gc3RhbGU7XG59XG5cbmZ1bmN0aW9uIHVzZSAoc2VsZiwgaGl0KSB7XG4gIHNoaWZ0TFUoc2VsZiwgaGl0KVxuICBoaXQubHUgPSBzZWxmLl9tcnUgKytcbiAgc2VsZi5fbHJ1TGlzdFtoaXQubHVdID0gaGl0XG59XG5cbmZ1bmN0aW9uIHRyaW0gKHNlbGYpIHtcbiAgd2hpbGUgKHNlbGYuX2xydSA8IHNlbGYuX21ydSAmJiBzZWxmLl9sZW5ndGggPiBzZWxmLl9tYXgpXG4gICAgZGVsKHNlbGYsIHNlbGYuX2xydUxpc3Rbc2VsZi5fbHJ1XSlcbn1cblxuZnVuY3Rpb24gc2hpZnRMVSAoc2VsZiwgaGl0KSB7XG4gIGRlbGV0ZSBzZWxmLl9scnVMaXN0WyBoaXQubHUgXVxuICB3aGlsZSAoc2VsZi5fbHJ1IDwgc2VsZi5fbXJ1ICYmICFzZWxmLl9scnVMaXN0W3NlbGYuX2xydV0pIHNlbGYuX2xydSArK1xufVxuXG5mdW5jdGlvbiBkZWwgKHNlbGYsIGhpdCkge1xuICBpZiAoaGl0KSB7XG4gICAgaWYgKHNlbGYuX2Rpc3Bvc2UpIHNlbGYuX2Rpc3Bvc2UoaGl0LmtleSwgaGl0LnZhbHVlKVxuICAgIHNlbGYuX2xlbmd0aCAtPSBoaXQubGVuZ3RoXG4gICAgc2VsZi5faXRlbUNvdW50IC0tXG4gICAgZGVsZXRlIHNlbGYuX2NhY2hlWyBoaXQua2V5IF1cbiAgICBzaGlmdExVKHNlbGYsIGhpdClcbiAgfVxufVxuXG4vLyBjbGFzc3ksIHNpbmNlIFY4IHByZWZlcnMgcHJlZGljdGFibGUgb2JqZWN0cy5cbmZ1bmN0aW9uIEVudHJ5IChrZXksIHZhbHVlLCBsdSwgbGVuZ3RoLCBub3csIG1heEFnZSkge1xuICB0aGlzLmtleSA9IGtleVxuICB0aGlzLnZhbHVlID0gdmFsdWVcbiAgdGhpcy5sdSA9IGx1XG4gIHRoaXMubGVuZ3RoID0gbGVuZ3RoXG4gIHRoaXMubm93ID0gbm93XG4gIGlmIChtYXhBZ2UpIHRoaXMubWF4QWdlID0gbWF4QWdlXG59XG5cbn0pKClcbiIsIi8qIVxuICogbXVzdGFjaGUuanMgLSBMb2dpYy1sZXNzIHt7bXVzdGFjaGV9fSB0ZW1wbGF0ZXMgd2l0aCBKYXZhU2NyaXB0XG4gKiBodHRwOi8vZ2l0aHViLmNvbS9qYW5sL211c3RhY2hlLmpzXG4gKi9cblxuLypnbG9iYWwgZGVmaW5lOiBmYWxzZSBNdXN0YWNoZTogdHJ1ZSovXG5cbihmdW5jdGlvbiBkZWZpbmVNdXN0YWNoZSAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiB0eXBlb2YgZXhwb3J0cy5ub2RlTmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICBmYWN0b3J5KGV4cG9ydHMpOyAvLyBDb21tb25KU1xuICB9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSk7IC8vIEFNRFxuICB9IGVsc2Uge1xuICAgIGdsb2JhbC5NdXN0YWNoZSA9IHt9O1xuICAgIGZhY3RvcnkoTXVzdGFjaGUpOyAvLyBzY3JpcHQsIHdzaCwgYXNwXG4gIH1cbn0odGhpcywgZnVuY3Rpb24gbXVzdGFjaGVGYWN0b3J5IChtdXN0YWNoZSkge1xuXG4gIHZhciBvYmplY3RUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG4gIHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiBpc0FycmF5UG9seWZpbGwgKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3RUb1N0cmluZy5jYWxsKG9iamVjdCkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gIH07XG5cbiAgZnVuY3Rpb24gaXNGdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdmdW5jdGlvbic7XG4gIH1cblxuICAvKipcbiAgICogTW9yZSBjb3JyZWN0IHR5cGVvZiBzdHJpbmcgaGFuZGxpbmcgYXJyYXlcbiAgICogd2hpY2ggbm9ybWFsbHkgcmV0dXJucyB0eXBlb2YgJ29iamVjdCdcbiAgICovXG4gIGZ1bmN0aW9uIHR5cGVTdHIgKG9iaikge1xuICAgIHJldHVybiBpc0FycmF5KG9iaikgPyAnYXJyYXknIDogdHlwZW9mIG9iajtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVzY2FwZVJlZ0V4cCAoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC9bXFwtXFxbXFxde30oKSorPy4sXFxcXFxcXiR8I1xcc10vZywgJ1xcXFwkJicpO1xuICB9XG5cbiAgLyoqXG4gICAqIE51bGwgc2FmZSB3YXkgb2YgY2hlY2tpbmcgd2hldGhlciBvciBub3QgYW4gb2JqZWN0LFxuICAgKiBpbmNsdWRpbmcgaXRzIHByb3RvdHlwZSwgaGFzIGEgZ2l2ZW4gcHJvcGVydHlcbiAgICovXG4gIGZ1bmN0aW9uIGhhc1Byb3BlcnR5IChvYmosIHByb3BOYW1lKSB7XG4gICAgcmV0dXJuIG9iaiAhPSBudWxsICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIChwcm9wTmFtZSBpbiBvYmopO1xuICB9XG5cbiAgLy8gV29ya2Fyb3VuZCBmb3IgaHR0cHM6Ly9pc3N1ZXMuYXBhY2hlLm9yZy9qaXJhL2Jyb3dzZS9DT1VDSERCLTU3N1xuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2phbmwvbXVzdGFjaGUuanMvaXNzdWVzLzE4OVxuICB2YXIgcmVnRXhwVGVzdCA9IFJlZ0V4cC5wcm90b3R5cGUudGVzdDtcbiAgZnVuY3Rpb24gdGVzdFJlZ0V4cCAocmUsIHN0cmluZykge1xuICAgIHJldHVybiByZWdFeHBUZXN0LmNhbGwocmUsIHN0cmluZyk7XG4gIH1cblxuICB2YXIgbm9uU3BhY2VSZSA9IC9cXFMvO1xuICBmdW5jdGlvbiBpc1doaXRlc3BhY2UgKHN0cmluZykge1xuICAgIHJldHVybiAhdGVzdFJlZ0V4cChub25TcGFjZVJlLCBzdHJpbmcpO1xuICB9XG5cbiAgdmFyIGVudGl0eU1hcCA9IHtcbiAgICAnJic6ICcmYW1wOycsXG4gICAgJzwnOiAnJmx0OycsXG4gICAgJz4nOiAnJmd0OycsXG4gICAgJ1wiJzogJyZxdW90OycsXG4gICAgXCInXCI6ICcmIzM5OycsXG4gICAgJy8nOiAnJiN4MkY7J1xuICB9O1xuXG4gIGZ1bmN0aW9uIGVzY2FwZUh0bWwgKHN0cmluZykge1xuICAgIHJldHVybiBTdHJpbmcoc3RyaW5nKS5yZXBsYWNlKC9bJjw+XCInXFwvXS9nLCBmdW5jdGlvbiBmcm9tRW50aXR5TWFwIChzKSB7XG4gICAgICByZXR1cm4gZW50aXR5TWFwW3NdO1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIHdoaXRlUmUgPSAvXFxzKi87XG4gIHZhciBzcGFjZVJlID0gL1xccysvO1xuICB2YXIgZXF1YWxzUmUgPSAvXFxzKj0vO1xuICB2YXIgY3VybHlSZSA9IC9cXHMqXFx9LztcbiAgdmFyIHRhZ1JlID0gLyN8XFxefFxcL3w+fFxce3wmfD18IS87XG5cbiAgLyoqXG4gICAqIEJyZWFrcyB1cCB0aGUgZ2l2ZW4gYHRlbXBsYXRlYCBzdHJpbmcgaW50byBhIHRyZWUgb2YgdG9rZW5zLiBJZiB0aGUgYHRhZ3NgXG4gICAqIGFyZ3VtZW50IGlzIGdpdmVuIGhlcmUgaXQgbXVzdCBiZSBhbiBhcnJheSB3aXRoIHR3byBzdHJpbmcgdmFsdWVzOiB0aGVcbiAgICogb3BlbmluZyBhbmQgY2xvc2luZyB0YWdzIHVzZWQgaW4gdGhlIHRlbXBsYXRlIChlLmcuIFsgXCI8JVwiLCBcIiU+XCIgXSkuIE9mXG4gICAqIGNvdXJzZSwgdGhlIGRlZmF1bHQgaXMgdG8gdXNlIG11c3RhY2hlcyAoaS5lLiBtdXN0YWNoZS50YWdzKS5cbiAgICpcbiAgICogQSB0b2tlbiBpcyBhbiBhcnJheSB3aXRoIGF0IGxlYXN0IDQgZWxlbWVudHMuIFRoZSBmaXJzdCBlbGVtZW50IGlzIHRoZVxuICAgKiBtdXN0YWNoZSBzeW1ib2wgdGhhdCB3YXMgdXNlZCBpbnNpZGUgdGhlIHRhZywgZS5nLiBcIiNcIiBvciBcIiZcIi4gSWYgdGhlIHRhZ1xuICAgKiBkaWQgbm90IGNvbnRhaW4gYSBzeW1ib2wgKGkuZS4ge3tteVZhbHVlfX0pIHRoaXMgZWxlbWVudCBpcyBcIm5hbWVcIi4gRm9yXG4gICAqIGFsbCB0ZXh0IHRoYXQgYXBwZWFycyBvdXRzaWRlIGEgc3ltYm9sIHRoaXMgZWxlbWVudCBpcyBcInRleHRcIi5cbiAgICpcbiAgICogVGhlIHNlY29uZCBlbGVtZW50IG9mIGEgdG9rZW4gaXMgaXRzIFwidmFsdWVcIi4gRm9yIG11c3RhY2hlIHRhZ3MgdGhpcyBpc1xuICAgKiB3aGF0ZXZlciBlbHNlIHdhcyBpbnNpZGUgdGhlIHRhZyBiZXNpZGVzIHRoZSBvcGVuaW5nIHN5bWJvbC4gRm9yIHRleHQgdG9rZW5zXG4gICAqIHRoaXMgaXMgdGhlIHRleHQgaXRzZWxmLlxuICAgKlxuICAgKiBUaGUgdGhpcmQgYW5kIGZvdXJ0aCBlbGVtZW50cyBvZiB0aGUgdG9rZW4gYXJlIHRoZSBzdGFydCBhbmQgZW5kIGluZGljZXMsXG4gICAqIHJlc3BlY3RpdmVseSwgb2YgdGhlIHRva2VuIGluIHRoZSBvcmlnaW5hbCB0ZW1wbGF0ZS5cbiAgICpcbiAgICogVG9rZW5zIHRoYXQgYXJlIHRoZSByb290IG5vZGUgb2YgYSBzdWJ0cmVlIGNvbnRhaW4gdHdvIG1vcmUgZWxlbWVudHM6IDEpIGFuXG4gICAqIGFycmF5IG9mIHRva2VucyBpbiB0aGUgc3VidHJlZSBhbmQgMikgdGhlIGluZGV4IGluIHRoZSBvcmlnaW5hbCB0ZW1wbGF0ZSBhdFxuICAgKiB3aGljaCB0aGUgY2xvc2luZyB0YWcgZm9yIHRoYXQgc2VjdGlvbiBiZWdpbnMuXG4gICAqL1xuICBmdW5jdGlvbiBwYXJzZVRlbXBsYXRlICh0ZW1wbGF0ZSwgdGFncykge1xuICAgIGlmICghdGVtcGxhdGUpXG4gICAgICByZXR1cm4gW107XG5cbiAgICB2YXIgc2VjdGlvbnMgPSBbXTsgICAgIC8vIFN0YWNrIHRvIGhvbGQgc2VjdGlvbiB0b2tlbnNcbiAgICB2YXIgdG9rZW5zID0gW107ICAgICAgIC8vIEJ1ZmZlciB0byBob2xkIHRoZSB0b2tlbnNcbiAgICB2YXIgc3BhY2VzID0gW107ICAgICAgIC8vIEluZGljZXMgb2Ygd2hpdGVzcGFjZSB0b2tlbnMgb24gdGhlIGN1cnJlbnQgbGluZVxuICAgIHZhciBoYXNUYWcgPSBmYWxzZTsgICAgLy8gSXMgdGhlcmUgYSB7e3RhZ319IG9uIHRoZSBjdXJyZW50IGxpbmU/XG4gICAgdmFyIG5vblNwYWNlID0gZmFsc2U7ICAvLyBJcyB0aGVyZSBhIG5vbi1zcGFjZSBjaGFyIG9uIHRoZSBjdXJyZW50IGxpbmU/XG5cbiAgICAvLyBTdHJpcHMgYWxsIHdoaXRlc3BhY2UgdG9rZW5zIGFycmF5IGZvciB0aGUgY3VycmVudCBsaW5lXG4gICAgLy8gaWYgdGhlcmUgd2FzIGEge3sjdGFnfX0gb24gaXQgYW5kIG90aGVyd2lzZSBvbmx5IHNwYWNlLlxuICAgIGZ1bmN0aW9uIHN0cmlwU3BhY2UgKCkge1xuICAgICAgaWYgKGhhc1RhZyAmJiAhbm9uU3BhY2UpIHtcbiAgICAgICAgd2hpbGUgKHNwYWNlcy5sZW5ndGgpXG4gICAgICAgICAgZGVsZXRlIHRva2Vuc1tzcGFjZXMucG9wKCldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3BhY2VzID0gW107XG4gICAgICB9XG5cbiAgICAgIGhhc1RhZyA9IGZhbHNlO1xuICAgICAgbm9uU3BhY2UgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgb3BlbmluZ1RhZ1JlLCBjbG9zaW5nVGFnUmUsIGNsb3NpbmdDdXJseVJlO1xuICAgIGZ1bmN0aW9uIGNvbXBpbGVUYWdzICh0YWdzVG9Db21waWxlKSB7XG4gICAgICBpZiAodHlwZW9mIHRhZ3NUb0NvbXBpbGUgPT09ICdzdHJpbmcnKVxuICAgICAgICB0YWdzVG9Db21waWxlID0gdGFnc1RvQ29tcGlsZS5zcGxpdChzcGFjZVJlLCAyKTtcblxuICAgICAgaWYgKCFpc0FycmF5KHRhZ3NUb0NvbXBpbGUpIHx8IHRhZ3NUb0NvbXBpbGUubGVuZ3RoICE9PSAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdGFnczogJyArIHRhZ3NUb0NvbXBpbGUpO1xuXG4gICAgICBvcGVuaW5nVGFnUmUgPSBuZXcgUmVnRXhwKGVzY2FwZVJlZ0V4cCh0YWdzVG9Db21waWxlWzBdKSArICdcXFxccyonKTtcbiAgICAgIGNsb3NpbmdUYWdSZSA9IG5ldyBSZWdFeHAoJ1xcXFxzKicgKyBlc2NhcGVSZWdFeHAodGFnc1RvQ29tcGlsZVsxXSkpO1xuICAgICAgY2xvc2luZ0N1cmx5UmUgPSBuZXcgUmVnRXhwKCdcXFxccyonICsgZXNjYXBlUmVnRXhwKCd9JyArIHRhZ3NUb0NvbXBpbGVbMV0pKTtcbiAgICB9XG5cbiAgICBjb21waWxlVGFncyh0YWdzIHx8IG11c3RhY2hlLnRhZ3MpO1xuXG4gICAgdmFyIHNjYW5uZXIgPSBuZXcgU2Nhbm5lcih0ZW1wbGF0ZSk7XG5cbiAgICB2YXIgc3RhcnQsIHR5cGUsIHZhbHVlLCBjaHIsIHRva2VuLCBvcGVuU2VjdGlvbjtcbiAgICB3aGlsZSAoIXNjYW5uZXIuZW9zKCkpIHtcbiAgICAgIHN0YXJ0ID0gc2Nhbm5lci5wb3M7XG5cbiAgICAgIC8vIE1hdGNoIGFueSB0ZXh0IGJldHdlZW4gdGFncy5cbiAgICAgIHZhbHVlID0gc2Nhbm5lci5zY2FuVW50aWwob3BlbmluZ1RhZ1JlKTtcblxuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCB2YWx1ZUxlbmd0aCA9IHZhbHVlLmxlbmd0aDsgaSA8IHZhbHVlTGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBjaHIgPSB2YWx1ZS5jaGFyQXQoaSk7XG5cbiAgICAgICAgICBpZiAoaXNXaGl0ZXNwYWNlKGNocikpIHtcbiAgICAgICAgICAgIHNwYWNlcy5wdXNoKHRva2Vucy5sZW5ndGgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBub25TcGFjZSA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdG9rZW5zLnB1c2goWyAndGV4dCcsIGNociwgc3RhcnQsIHN0YXJ0ICsgMSBdKTtcbiAgICAgICAgICBzdGFydCArPSAxO1xuXG4gICAgICAgICAgLy8gQ2hlY2sgZm9yIHdoaXRlc3BhY2Ugb24gdGhlIGN1cnJlbnQgbGluZS5cbiAgICAgICAgICBpZiAoY2hyID09PSAnXFxuJylcbiAgICAgICAgICAgIHN0cmlwU3BhY2UoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBNYXRjaCB0aGUgb3BlbmluZyB0YWcuXG4gICAgICBpZiAoIXNjYW5uZXIuc2NhbihvcGVuaW5nVGFnUmUpKVxuICAgICAgICBicmVhaztcblxuICAgICAgaGFzVGFnID0gdHJ1ZTtcblxuICAgICAgLy8gR2V0IHRoZSB0YWcgdHlwZS5cbiAgICAgIHR5cGUgPSBzY2FubmVyLnNjYW4odGFnUmUpIHx8ICduYW1lJztcbiAgICAgIHNjYW5uZXIuc2Nhbih3aGl0ZVJlKTtcblxuICAgICAgLy8gR2V0IHRoZSB0YWcgdmFsdWUuXG4gICAgICBpZiAodHlwZSA9PT0gJz0nKSB7XG4gICAgICAgIHZhbHVlID0gc2Nhbm5lci5zY2FuVW50aWwoZXF1YWxzUmUpO1xuICAgICAgICBzY2FubmVyLnNjYW4oZXF1YWxzUmUpO1xuICAgICAgICBzY2FubmVyLnNjYW5VbnRpbChjbG9zaW5nVGFnUmUpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAneycpIHtcbiAgICAgICAgdmFsdWUgPSBzY2FubmVyLnNjYW5VbnRpbChjbG9zaW5nQ3VybHlSZSk7XG4gICAgICAgIHNjYW5uZXIuc2NhbihjdXJseVJlKTtcbiAgICAgICAgc2Nhbm5lci5zY2FuVW50aWwoY2xvc2luZ1RhZ1JlKTtcbiAgICAgICAgdHlwZSA9ICcmJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlID0gc2Nhbm5lci5zY2FuVW50aWwoY2xvc2luZ1RhZ1JlKTtcbiAgICAgIH1cblxuICAgICAgLy8gTWF0Y2ggdGhlIGNsb3NpbmcgdGFnLlxuICAgICAgaWYgKCFzY2FubmVyLnNjYW4oY2xvc2luZ1RhZ1JlKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmNsb3NlZCB0YWcgYXQgJyArIHNjYW5uZXIucG9zKTtcblxuICAgICAgdG9rZW4gPSBbIHR5cGUsIHZhbHVlLCBzdGFydCwgc2Nhbm5lci5wb3MgXTtcbiAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcblxuICAgICAgaWYgKHR5cGUgPT09ICcjJyB8fCB0eXBlID09PSAnXicpIHtcbiAgICAgICAgc2VjdGlvbnMucHVzaCh0b2tlbik7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICcvJykge1xuICAgICAgICAvLyBDaGVjayBzZWN0aW9uIG5lc3RpbmcuXG4gICAgICAgIG9wZW5TZWN0aW9uID0gc2VjdGlvbnMucG9wKCk7XG5cbiAgICAgICAgaWYgKCFvcGVuU2VjdGlvbilcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vub3BlbmVkIHNlY3Rpb24gXCInICsgdmFsdWUgKyAnXCIgYXQgJyArIHN0YXJ0KTtcblxuICAgICAgICBpZiAob3BlblNlY3Rpb25bMV0gIT09IHZhbHVlKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5jbG9zZWQgc2VjdGlvbiBcIicgKyBvcGVuU2VjdGlvblsxXSArICdcIiBhdCAnICsgc3RhcnQpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnbmFtZScgfHwgdHlwZSA9PT0gJ3snIHx8IHR5cGUgPT09ICcmJykge1xuICAgICAgICBub25TcGFjZSA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICc9Jykge1xuICAgICAgICAvLyBTZXQgdGhlIHRhZ3MgZm9yIHRoZSBuZXh0IHRpbWUgYXJvdW5kLlxuICAgICAgICBjb21waWxlVGFncyh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gTWFrZSBzdXJlIHRoZXJlIGFyZSBubyBvcGVuIHNlY3Rpb25zIHdoZW4gd2UncmUgZG9uZS5cbiAgICBvcGVuU2VjdGlvbiA9IHNlY3Rpb25zLnBvcCgpO1xuXG4gICAgaWYgKG9wZW5TZWN0aW9uKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmNsb3NlZCBzZWN0aW9uIFwiJyArIG9wZW5TZWN0aW9uWzFdICsgJ1wiIGF0ICcgKyBzY2FubmVyLnBvcyk7XG5cbiAgICByZXR1cm4gbmVzdFRva2VucyhzcXVhc2hUb2tlbnModG9rZW5zKSk7XG4gIH1cblxuICAvKipcbiAgICogQ29tYmluZXMgdGhlIHZhbHVlcyBvZiBjb25zZWN1dGl2ZSB0ZXh0IHRva2VucyBpbiB0aGUgZ2l2ZW4gYHRva2Vuc2AgYXJyYXlcbiAgICogdG8gYSBzaW5nbGUgdG9rZW4uXG4gICAqL1xuICBmdW5jdGlvbiBzcXVhc2hUb2tlbnMgKHRva2Vucykge1xuICAgIHZhciBzcXVhc2hlZFRva2VucyA9IFtdO1xuXG4gICAgdmFyIHRva2VuLCBsYXN0VG9rZW47XG4gICAgZm9yICh2YXIgaSA9IDAsIG51bVRva2VucyA9IHRva2Vucy5sZW5ndGg7IGkgPCBudW1Ub2tlbnM7ICsraSkge1xuICAgICAgdG9rZW4gPSB0b2tlbnNbaV07XG5cbiAgICAgIGlmICh0b2tlbikge1xuICAgICAgICBpZiAodG9rZW5bMF0gPT09ICd0ZXh0JyAmJiBsYXN0VG9rZW4gJiYgbGFzdFRva2VuWzBdID09PSAndGV4dCcpIHtcbiAgICAgICAgICBsYXN0VG9rZW5bMV0gKz0gdG9rZW5bMV07XG4gICAgICAgICAgbGFzdFRva2VuWzNdID0gdG9rZW5bM107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3F1YXNoZWRUb2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgbGFzdFRva2VuID0gdG9rZW47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3F1YXNoZWRUb2tlbnM7XG4gIH1cblxuICAvKipcbiAgICogRm9ybXMgdGhlIGdpdmVuIGFycmF5IG9mIGB0b2tlbnNgIGludG8gYSBuZXN0ZWQgdHJlZSBzdHJ1Y3R1cmUgd2hlcmVcbiAgICogdG9rZW5zIHRoYXQgcmVwcmVzZW50IGEgc2VjdGlvbiBoYXZlIHR3byBhZGRpdGlvbmFsIGl0ZW1zOiAxKSBhbiBhcnJheSBvZlxuICAgKiBhbGwgdG9rZW5zIHRoYXQgYXBwZWFyIGluIHRoYXQgc2VjdGlvbiBhbmQgMikgdGhlIGluZGV4IGluIHRoZSBvcmlnaW5hbFxuICAgKiB0ZW1wbGF0ZSB0aGF0IHJlcHJlc2VudHMgdGhlIGVuZCBvZiB0aGF0IHNlY3Rpb24uXG4gICAqL1xuICBmdW5jdGlvbiBuZXN0VG9rZW5zICh0b2tlbnMpIHtcbiAgICB2YXIgbmVzdGVkVG9rZW5zID0gW107XG4gICAgdmFyIGNvbGxlY3RvciA9IG5lc3RlZFRva2VucztcbiAgICB2YXIgc2VjdGlvbnMgPSBbXTtcblxuICAgIHZhciB0b2tlbiwgc2VjdGlvbjtcbiAgICBmb3IgKHZhciBpID0gMCwgbnVtVG9rZW5zID0gdG9rZW5zLmxlbmd0aDsgaSA8IG51bVRva2VuczsgKytpKSB7XG4gICAgICB0b2tlbiA9IHRva2Vuc1tpXTtcblxuICAgICAgc3dpdGNoICh0b2tlblswXSkge1xuICAgICAgY2FzZSAnIyc6XG4gICAgICBjYXNlICdeJzpcbiAgICAgICAgY29sbGVjdG9yLnB1c2godG9rZW4pO1xuICAgICAgICBzZWN0aW9ucy5wdXNoKHRva2VuKTtcbiAgICAgICAgY29sbGVjdG9yID0gdG9rZW5bNF0gPSBbXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICcvJzpcbiAgICAgICAgc2VjdGlvbiA9IHNlY3Rpb25zLnBvcCgpO1xuICAgICAgICBzZWN0aW9uWzVdID0gdG9rZW5bMl07XG4gICAgICAgIGNvbGxlY3RvciA9IHNlY3Rpb25zLmxlbmd0aCA+IDAgPyBzZWN0aW9uc1tzZWN0aW9ucy5sZW5ndGggLSAxXVs0XSA6IG5lc3RlZFRva2VucztcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBjb2xsZWN0b3IucHVzaCh0b2tlbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5lc3RlZFRva2VucztcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNpbXBsZSBzdHJpbmcgc2Nhbm5lciB0aGF0IGlzIHVzZWQgYnkgdGhlIHRlbXBsYXRlIHBhcnNlciB0byBmaW5kXG4gICAqIHRva2VucyBpbiB0ZW1wbGF0ZSBzdHJpbmdzLlxuICAgKi9cbiAgZnVuY3Rpb24gU2Nhbm5lciAoc3RyaW5nKSB7XG4gICAgdGhpcy5zdHJpbmcgPSBzdHJpbmc7XG4gICAgdGhpcy50YWlsID0gc3RyaW5nO1xuICAgIHRoaXMucG9zID0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdGFpbCBpcyBlbXB0eSAoZW5kIG9mIHN0cmluZykuXG4gICAqL1xuICBTY2FubmVyLnByb3RvdHlwZS5lb3MgPSBmdW5jdGlvbiBlb3MgKCkge1xuICAgIHJldHVybiB0aGlzLnRhaWwgPT09ICcnO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUcmllcyB0byBtYXRjaCB0aGUgZ2l2ZW4gcmVndWxhciBleHByZXNzaW9uIGF0IHRoZSBjdXJyZW50IHBvc2l0aW9uLlxuICAgKiBSZXR1cm5zIHRoZSBtYXRjaGVkIHRleHQgaWYgaXQgY2FuIG1hdGNoLCB0aGUgZW1wdHkgc3RyaW5nIG90aGVyd2lzZS5cbiAgICovXG4gIFNjYW5uZXIucHJvdG90eXBlLnNjYW4gPSBmdW5jdGlvbiBzY2FuIChyZSkge1xuICAgIHZhciBtYXRjaCA9IHRoaXMudGFpbC5tYXRjaChyZSk7XG5cbiAgICBpZiAoIW1hdGNoIHx8IG1hdGNoLmluZGV4ICE9PSAwKVxuICAgICAgcmV0dXJuICcnO1xuXG4gICAgdmFyIHN0cmluZyA9IG1hdGNoWzBdO1xuXG4gICAgdGhpcy50YWlsID0gdGhpcy50YWlsLnN1YnN0cmluZyhzdHJpbmcubGVuZ3RoKTtcbiAgICB0aGlzLnBvcyArPSBzdHJpbmcubGVuZ3RoO1xuXG4gICAgcmV0dXJuIHN0cmluZztcbiAgfTtcblxuICAvKipcbiAgICogU2tpcHMgYWxsIHRleHQgdW50aWwgdGhlIGdpdmVuIHJlZ3VsYXIgZXhwcmVzc2lvbiBjYW4gYmUgbWF0Y2hlZC4gUmV0dXJuc1xuICAgKiB0aGUgc2tpcHBlZCBzdHJpbmcsIHdoaWNoIGlzIHRoZSBlbnRpcmUgdGFpbCBpZiBubyBtYXRjaCBjYW4gYmUgbWFkZS5cbiAgICovXG4gIFNjYW5uZXIucHJvdG90eXBlLnNjYW5VbnRpbCA9IGZ1bmN0aW9uIHNjYW5VbnRpbCAocmUpIHtcbiAgICB2YXIgaW5kZXggPSB0aGlzLnRhaWwuc2VhcmNoKHJlKSwgbWF0Y2g7XG5cbiAgICBzd2l0Y2ggKGluZGV4KSB7XG4gICAgY2FzZSAtMTpcbiAgICAgIG1hdGNoID0gdGhpcy50YWlsO1xuICAgICAgdGhpcy50YWlsID0gJyc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDA6XG4gICAgICBtYXRjaCA9ICcnO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIG1hdGNoID0gdGhpcy50YWlsLnN1YnN0cmluZygwLCBpbmRleCk7XG4gICAgICB0aGlzLnRhaWwgPSB0aGlzLnRhaWwuc3Vic3RyaW5nKGluZGV4KTtcbiAgICB9XG5cbiAgICB0aGlzLnBvcyArPSBtYXRjaC5sZW5ndGg7XG5cbiAgICByZXR1cm4gbWF0Y2g7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlcHJlc2VudHMgYSByZW5kZXJpbmcgY29udGV4dCBieSB3cmFwcGluZyBhIHZpZXcgb2JqZWN0IGFuZFxuICAgKiBtYWludGFpbmluZyBhIHJlZmVyZW5jZSB0byB0aGUgcGFyZW50IGNvbnRleHQuXG4gICAqL1xuICBmdW5jdGlvbiBDb250ZXh0ICh2aWV3LCBwYXJlbnRDb250ZXh0KSB7XG4gICAgdGhpcy52aWV3ID0gdmlldztcbiAgICB0aGlzLmNhY2hlID0geyAnLic6IHRoaXMudmlldyB9O1xuICAgIHRoaXMucGFyZW50ID0gcGFyZW50Q29udGV4dDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGNvbnRleHQgdXNpbmcgdGhlIGdpdmVuIHZpZXcgd2l0aCB0aGlzIGNvbnRleHRcbiAgICogYXMgdGhlIHBhcmVudC5cbiAgICovXG4gIENvbnRleHQucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiBwdXNoICh2aWV3KSB7XG4gICAgcmV0dXJuIG5ldyBDb250ZXh0KHZpZXcsIHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gbmFtZSBpbiB0aGlzIGNvbnRleHQsIHRyYXZlcnNpbmdcbiAgICogdXAgdGhlIGNvbnRleHQgaGllcmFyY2h5IGlmIHRoZSB2YWx1ZSBpcyBhYnNlbnQgaW4gdGhpcyBjb250ZXh0J3Mgdmlldy5cbiAgICovXG4gIENvbnRleHQucHJvdG90eXBlLmxvb2t1cCA9IGZ1bmN0aW9uIGxvb2t1cCAobmFtZSkge1xuICAgIHZhciBjYWNoZSA9IHRoaXMuY2FjaGU7XG5cbiAgICB2YXIgdmFsdWU7XG4gICAgaWYgKGNhY2hlLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICB2YWx1ZSA9IGNhY2hlW25hbWVdO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgY29udGV4dCA9IHRoaXMsIG5hbWVzLCBpbmRleCwgbG9va3VwSGl0ID0gZmFsc2U7XG5cbiAgICAgIHdoaWxlIChjb250ZXh0KSB7XG4gICAgICAgIGlmIChuYW1lLmluZGV4T2YoJy4nKSA+IDApIHtcbiAgICAgICAgICB2YWx1ZSA9IGNvbnRleHQudmlldztcbiAgICAgICAgICBuYW1lcyA9IG5hbWUuc3BsaXQoJy4nKTtcbiAgICAgICAgICBpbmRleCA9IDA7XG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBVc2luZyB0aGUgZG90IG5vdGlvbiBwYXRoIGluIGBuYW1lYCwgd2UgZGVzY2VuZCB0aHJvdWdoIHRoZVxuICAgICAgICAgICAqIG5lc3RlZCBvYmplY3RzLlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogVG8gYmUgY2VydGFpbiB0aGF0IHRoZSBsb29rdXAgaGFzIGJlZW4gc3VjY2Vzc2Z1bCwgd2UgaGF2ZSB0b1xuICAgICAgICAgICAqIGNoZWNrIGlmIHRoZSBsYXN0IG9iamVjdCBpbiB0aGUgcGF0aCBhY3R1YWxseSBoYXMgdGhlIHByb3BlcnR5XG4gICAgICAgICAgICogd2UgYXJlIGxvb2tpbmcgZm9yLiBXZSBzdG9yZSB0aGUgcmVzdWx0IGluIGBsb29rdXBIaXRgLlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogVGhpcyBpcyBzcGVjaWFsbHkgbmVjZXNzYXJ5IGZvciB3aGVuIHRoZSB2YWx1ZSBoYXMgYmVlbiBzZXQgdG9cbiAgICAgICAgICAgKiBgdW5kZWZpbmVkYCBhbmQgd2Ugd2FudCB0byBhdm9pZCBsb29raW5nIHVwIHBhcmVudCBjb250ZXh0cy5cbiAgICAgICAgICAgKiovXG4gICAgICAgICAgd2hpbGUgKHZhbHVlICE9IG51bGwgJiYgaW5kZXggPCBuYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gbmFtZXMubGVuZ3RoIC0gMSlcbiAgICAgICAgICAgICAgbG9va3VwSGl0ID0gaGFzUHJvcGVydHkodmFsdWUsIG5hbWVzW2luZGV4XSk7XG5cbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWVbbmFtZXNbaW5kZXgrK11dO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IGNvbnRleHQudmlld1tuYW1lXTtcbiAgICAgICAgICBsb29rdXBIaXQgPSBoYXNQcm9wZXJ0eShjb250ZXh0LnZpZXcsIG5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxvb2t1cEhpdClcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjb250ZXh0ID0gY29udGV4dC5wYXJlbnQ7XG4gICAgICB9XG5cbiAgICAgIGNhY2hlW25hbWVdID0gdmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKVxuICAgICAgdmFsdWUgPSB2YWx1ZS5jYWxsKHRoaXMudmlldyk7XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIEEgV3JpdGVyIGtub3dzIGhvdyB0byB0YWtlIGEgc3RyZWFtIG9mIHRva2VucyBhbmQgcmVuZGVyIHRoZW0gdG8gYVxuICAgKiBzdHJpbmcsIGdpdmVuIGEgY29udGV4dC4gSXQgYWxzbyBtYWludGFpbnMgYSBjYWNoZSBvZiB0ZW1wbGF0ZXMgdG9cbiAgICogYXZvaWQgdGhlIG5lZWQgdG8gcGFyc2UgdGhlIHNhbWUgdGVtcGxhdGUgdHdpY2UuXG4gICAqL1xuICBmdW5jdGlvbiBXcml0ZXIgKCkge1xuICAgIHRoaXMuY2FjaGUgPSB7fTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhcnMgYWxsIGNhY2hlZCB0ZW1wbGF0ZXMgaW4gdGhpcyB3cml0ZXIuXG4gICAqL1xuICBXcml0ZXIucHJvdG90eXBlLmNsZWFyQ2FjaGUgPSBmdW5jdGlvbiBjbGVhckNhY2hlICgpIHtcbiAgICB0aGlzLmNhY2hlID0ge307XG4gIH07XG5cbiAgLyoqXG4gICAqIFBhcnNlcyBhbmQgY2FjaGVzIHRoZSBnaXZlbiBgdGVtcGxhdGVgIGFuZCByZXR1cm5zIHRoZSBhcnJheSBvZiB0b2tlbnNcbiAgICogdGhhdCBpcyBnZW5lcmF0ZWQgZnJvbSB0aGUgcGFyc2UuXG4gICAqL1xuICBXcml0ZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UgKHRlbXBsYXRlLCB0YWdzKSB7XG4gICAgdmFyIGNhY2hlID0gdGhpcy5jYWNoZTtcbiAgICB2YXIgdG9rZW5zID0gY2FjaGVbdGVtcGxhdGVdO1xuXG4gICAgaWYgKHRva2VucyA9PSBudWxsKVxuICAgICAgdG9rZW5zID0gY2FjaGVbdGVtcGxhdGVdID0gcGFyc2VUZW1wbGF0ZSh0ZW1wbGF0ZSwgdGFncyk7XG5cbiAgICByZXR1cm4gdG9rZW5zO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIaWdoLWxldmVsIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gcmVuZGVyIHRoZSBnaXZlbiBgdGVtcGxhdGVgIHdpdGhcbiAgICogdGhlIGdpdmVuIGB2aWV3YC5cbiAgICpcbiAgICogVGhlIG9wdGlvbmFsIGBwYXJ0aWFsc2AgYXJndW1lbnQgbWF5IGJlIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZVxuICAgKiBuYW1lcyBhbmQgdGVtcGxhdGVzIG9mIHBhcnRpYWxzIHRoYXQgYXJlIHVzZWQgaW4gdGhlIHRlbXBsYXRlLiBJdCBtYXlcbiAgICogYWxzbyBiZSBhIGZ1bmN0aW9uIHRoYXQgaXMgdXNlZCB0byBsb2FkIHBhcnRpYWwgdGVtcGxhdGVzIG9uIHRoZSBmbHlcbiAgICogdGhhdCB0YWtlcyBhIHNpbmdsZSBhcmd1bWVudDogdGhlIG5hbWUgb2YgdGhlIHBhcnRpYWwuXG4gICAqL1xuICBXcml0ZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlciAodGVtcGxhdGUsIHZpZXcsIHBhcnRpYWxzKSB7XG4gICAgdmFyIHRva2VucyA9IHRoaXMucGFyc2UodGVtcGxhdGUpO1xuICAgIHZhciBjb250ZXh0ID0gKHZpZXcgaW5zdGFuY2VvZiBDb250ZXh0KSA/IHZpZXcgOiBuZXcgQ29udGV4dCh2aWV3KTtcbiAgICByZXR1cm4gdGhpcy5yZW5kZXJUb2tlbnModG9rZW5zLCBjb250ZXh0LCBwYXJ0aWFscywgdGVtcGxhdGUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBMb3ctbGV2ZWwgbWV0aG9kIHRoYXQgcmVuZGVycyB0aGUgZ2l2ZW4gYXJyYXkgb2YgYHRva2Vuc2AgdXNpbmdcbiAgICogdGhlIGdpdmVuIGBjb250ZXh0YCBhbmQgYHBhcnRpYWxzYC5cbiAgICpcbiAgICogTm90ZTogVGhlIGBvcmlnaW5hbFRlbXBsYXRlYCBpcyBvbmx5IGV2ZXIgdXNlZCB0byBleHRyYWN0IHRoZSBwb3J0aW9uXG4gICAqIG9mIHRoZSBvcmlnaW5hbCB0ZW1wbGF0ZSB0aGF0IHdhcyBjb250YWluZWQgaW4gYSBoaWdoZXItb3JkZXIgc2VjdGlvbi5cbiAgICogSWYgdGhlIHRlbXBsYXRlIGRvZXNuJ3QgdXNlIGhpZ2hlci1vcmRlciBzZWN0aW9ucywgdGhpcyBhcmd1bWVudCBtYXlcbiAgICogYmUgb21pdHRlZC5cbiAgICovXG4gIFdyaXRlci5wcm90b3R5cGUucmVuZGVyVG9rZW5zID0gZnVuY3Rpb24gcmVuZGVyVG9rZW5zICh0b2tlbnMsIGNvbnRleHQsIHBhcnRpYWxzLCBvcmlnaW5hbFRlbXBsYXRlKSB7XG4gICAgdmFyIGJ1ZmZlciA9ICcnO1xuXG4gICAgdmFyIHRva2VuLCBzeW1ib2wsIHZhbHVlO1xuICAgIGZvciAodmFyIGkgPSAwLCBudW1Ub2tlbnMgPSB0b2tlbnMubGVuZ3RoOyBpIDwgbnVtVG9rZW5zOyArK2kpIHtcbiAgICAgIHZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgICBzeW1ib2wgPSB0b2tlblswXTtcblxuICAgICAgaWYgKHN5bWJvbCA9PT0gJyMnKSB2YWx1ZSA9IHRoaXMucmVuZGVyU2VjdGlvbih0b2tlbiwgY29udGV4dCwgcGFydGlhbHMsIG9yaWdpbmFsVGVtcGxhdGUpO1xuICAgICAgZWxzZSBpZiAoc3ltYm9sID09PSAnXicpIHZhbHVlID0gdGhpcy5yZW5kZXJJbnZlcnRlZCh0b2tlbiwgY29udGV4dCwgcGFydGlhbHMsIG9yaWdpbmFsVGVtcGxhdGUpO1xuICAgICAgZWxzZSBpZiAoc3ltYm9sID09PSAnPicpIHZhbHVlID0gdGhpcy5yZW5kZXJQYXJ0aWFsKHRva2VuLCBjb250ZXh0LCBwYXJ0aWFscywgb3JpZ2luYWxUZW1wbGF0ZSk7XG4gICAgICBlbHNlIGlmIChzeW1ib2wgPT09ICcmJykgdmFsdWUgPSB0aGlzLnVuZXNjYXBlZFZhbHVlKHRva2VuLCBjb250ZXh0KTtcbiAgICAgIGVsc2UgaWYgKHN5bWJvbCA9PT0gJ25hbWUnKSB2YWx1ZSA9IHRoaXMuZXNjYXBlZFZhbHVlKHRva2VuLCBjb250ZXh0KTtcbiAgICAgIGVsc2UgaWYgKHN5bWJvbCA9PT0gJ3RleHQnKSB2YWx1ZSA9IHRoaXMucmF3VmFsdWUodG9rZW4pO1xuXG4gICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgYnVmZmVyICs9IHZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiBidWZmZXI7XG4gIH07XG5cbiAgV3JpdGVyLnByb3RvdHlwZS5yZW5kZXJTZWN0aW9uID0gZnVuY3Rpb24gcmVuZGVyU2VjdGlvbiAodG9rZW4sIGNvbnRleHQsIHBhcnRpYWxzLCBvcmlnaW5hbFRlbXBsYXRlKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBidWZmZXIgPSAnJztcbiAgICB2YXIgdmFsdWUgPSBjb250ZXh0Lmxvb2t1cCh0b2tlblsxXSk7XG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gcmVuZGVyIGFuIGFyYml0cmFyeSB0ZW1wbGF0ZVxuICAgIC8vIGluIHRoZSBjdXJyZW50IGNvbnRleHQgYnkgaGlnaGVyLW9yZGVyIHNlY3Rpb25zLlxuICAgIGZ1bmN0aW9uIHN1YlJlbmRlciAodGVtcGxhdGUpIHtcbiAgICAgIHJldHVybiBzZWxmLnJlbmRlcih0ZW1wbGF0ZSwgY29udGV4dCwgcGFydGlhbHMpO1xuICAgIH1cblxuICAgIGlmICghdmFsdWUpIHJldHVybjtcblxuICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgZm9yICh2YXIgaiA9IDAsIHZhbHVlTGVuZ3RoID0gdmFsdWUubGVuZ3RoOyBqIDwgdmFsdWVMZW5ndGg7ICsraikge1xuICAgICAgICBidWZmZXIgKz0gdGhpcy5yZW5kZXJUb2tlbnModG9rZW5bNF0sIGNvbnRleHQucHVzaCh2YWx1ZVtqXSksIHBhcnRpYWxzLCBvcmlnaW5hbFRlbXBsYXRlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICBidWZmZXIgKz0gdGhpcy5yZW5kZXJUb2tlbnModG9rZW5bNF0sIGNvbnRleHQucHVzaCh2YWx1ZSksIHBhcnRpYWxzLCBvcmlnaW5hbFRlbXBsYXRlKTtcbiAgICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICBpZiAodHlwZW9mIG9yaWdpbmFsVGVtcGxhdGUgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCB1c2UgaGlnaGVyLW9yZGVyIHNlY3Rpb25zIHdpdGhvdXQgdGhlIG9yaWdpbmFsIHRlbXBsYXRlJyk7XG5cbiAgICAgIC8vIEV4dHJhY3QgdGhlIHBvcnRpb24gb2YgdGhlIG9yaWdpbmFsIHRlbXBsYXRlIHRoYXQgdGhlIHNlY3Rpb24gY29udGFpbnMuXG4gICAgICB2YWx1ZSA9IHZhbHVlLmNhbGwoY29udGV4dC52aWV3LCBvcmlnaW5hbFRlbXBsYXRlLnNsaWNlKHRva2VuWzNdLCB0b2tlbls1XSksIHN1YlJlbmRlcik7XG5cbiAgICAgIGlmICh2YWx1ZSAhPSBudWxsKVxuICAgICAgICBidWZmZXIgKz0gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1ZmZlciArPSB0aGlzLnJlbmRlclRva2Vucyh0b2tlbls0XSwgY29udGV4dCwgcGFydGlhbHMsIG9yaWdpbmFsVGVtcGxhdGUpO1xuICAgIH1cbiAgICByZXR1cm4gYnVmZmVyO1xuICB9O1xuXG4gIFdyaXRlci5wcm90b3R5cGUucmVuZGVySW52ZXJ0ZWQgPSBmdW5jdGlvbiByZW5kZXJJbnZlcnRlZCAodG9rZW4sIGNvbnRleHQsIHBhcnRpYWxzLCBvcmlnaW5hbFRlbXBsYXRlKSB7XG4gICAgdmFyIHZhbHVlID0gY29udGV4dC5sb29rdXAodG9rZW5bMV0pO1xuXG4gICAgLy8gVXNlIEphdmFTY3JpcHQncyBkZWZpbml0aW9uIG9mIGZhbHN5LiBJbmNsdWRlIGVtcHR5IGFycmF5cy5cbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2phbmwvbXVzdGFjaGUuanMvaXNzdWVzLzE4NlxuICAgIGlmICghdmFsdWUgfHwgKGlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA9PT0gMCkpXG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJUb2tlbnModG9rZW5bNF0sIGNvbnRleHQsIHBhcnRpYWxzLCBvcmlnaW5hbFRlbXBsYXRlKTtcbiAgfTtcblxuICBXcml0ZXIucHJvdG90eXBlLnJlbmRlclBhcnRpYWwgPSBmdW5jdGlvbiByZW5kZXJQYXJ0aWFsICh0b2tlbiwgY29udGV4dCwgcGFydGlhbHMpIHtcbiAgICBpZiAoIXBhcnRpYWxzKSByZXR1cm47XG5cbiAgICB2YXIgdmFsdWUgPSBpc0Z1bmN0aW9uKHBhcnRpYWxzKSA/IHBhcnRpYWxzKHRva2VuWzFdKSA6IHBhcnRpYWxzW3Rva2VuWzFdXTtcbiAgICBpZiAodmFsdWUgIT0gbnVsbClcbiAgICAgIHJldHVybiB0aGlzLnJlbmRlclRva2Vucyh0aGlzLnBhcnNlKHZhbHVlKSwgY29udGV4dCwgcGFydGlhbHMsIHZhbHVlKTtcbiAgfTtcblxuICBXcml0ZXIucHJvdG90eXBlLnVuZXNjYXBlZFZhbHVlID0gZnVuY3Rpb24gdW5lc2NhcGVkVmFsdWUgKHRva2VuLCBjb250ZXh0KSB7XG4gICAgdmFyIHZhbHVlID0gY29udGV4dC5sb29rdXAodG9rZW5bMV0pO1xuICAgIGlmICh2YWx1ZSAhPSBudWxsKVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICB9O1xuXG4gIFdyaXRlci5wcm90b3R5cGUuZXNjYXBlZFZhbHVlID0gZnVuY3Rpb24gZXNjYXBlZFZhbHVlICh0b2tlbiwgY29udGV4dCkge1xuICAgIHZhciB2YWx1ZSA9IGNvbnRleHQubG9va3VwKHRva2VuWzFdKTtcbiAgICBpZiAodmFsdWUgIT0gbnVsbClcbiAgICAgIHJldHVybiBtdXN0YWNoZS5lc2NhcGUodmFsdWUpO1xuICB9O1xuXG4gIFdyaXRlci5wcm90b3R5cGUucmF3VmFsdWUgPSBmdW5jdGlvbiByYXdWYWx1ZSAodG9rZW4pIHtcbiAgICByZXR1cm4gdG9rZW5bMV07XG4gIH07XG5cbiAgbXVzdGFjaGUubmFtZSA9ICdtdXN0YWNoZS5qcyc7XG4gIG11c3RhY2hlLnZlcnNpb24gPSAnMi4yLjAnO1xuICBtdXN0YWNoZS50YWdzID0gWyAne3snLCAnfX0nIF07XG5cbiAgLy8gQWxsIGhpZ2gtbGV2ZWwgbXVzdGFjaGUuKiBmdW5jdGlvbnMgdXNlIHRoaXMgd3JpdGVyLlxuICB2YXIgZGVmYXVsdFdyaXRlciA9IG5ldyBXcml0ZXIoKTtcblxuICAvKipcbiAgICogQ2xlYXJzIGFsbCBjYWNoZWQgdGVtcGxhdGVzIGluIHRoZSBkZWZhdWx0IHdyaXRlci5cbiAgICovXG4gIG11c3RhY2hlLmNsZWFyQ2FjaGUgPSBmdW5jdGlvbiBjbGVhckNhY2hlICgpIHtcbiAgICByZXR1cm4gZGVmYXVsdFdyaXRlci5jbGVhckNhY2hlKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFBhcnNlcyBhbmQgY2FjaGVzIHRoZSBnaXZlbiB0ZW1wbGF0ZSBpbiB0aGUgZGVmYXVsdCB3cml0ZXIgYW5kIHJldHVybnMgdGhlXG4gICAqIGFycmF5IG9mIHRva2VucyBpdCBjb250YWlucy4gRG9pbmcgdGhpcyBhaGVhZCBvZiB0aW1lIGF2b2lkcyB0aGUgbmVlZCB0b1xuICAgKiBwYXJzZSB0ZW1wbGF0ZXMgb24gdGhlIGZseSBhcyB0aGV5IGFyZSByZW5kZXJlZC5cbiAgICovXG4gIG11c3RhY2hlLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UgKHRlbXBsYXRlLCB0YWdzKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRXcml0ZXIucGFyc2UodGVtcGxhdGUsIHRhZ3MpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBgdGVtcGxhdGVgIHdpdGggdGhlIGdpdmVuIGB2aWV3YCBhbmQgYHBhcnRpYWxzYCB1c2luZyB0aGVcbiAgICogZGVmYXVsdCB3cml0ZXIuXG4gICAqL1xuICBtdXN0YWNoZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIgKHRlbXBsYXRlLCB2aWV3LCBwYXJ0aWFscykge1xuICAgIGlmICh0eXBlb2YgdGVtcGxhdGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHRlbXBsYXRlISBUZW1wbGF0ZSBzaG91bGQgYmUgYSBcInN0cmluZ1wiICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnYnV0IFwiJyArIHR5cGVTdHIodGVtcGxhdGUpICsgJ1wiIHdhcyBnaXZlbiBhcyB0aGUgZmlyc3QgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdhcmd1bWVudCBmb3IgbXVzdGFjaGUjcmVuZGVyKHRlbXBsYXRlLCB2aWV3LCBwYXJ0aWFscyknKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGVmYXVsdFdyaXRlci5yZW5kZXIodGVtcGxhdGUsIHZpZXcsIHBhcnRpYWxzKTtcbiAgfTtcblxuICAvLyBUaGlzIGlzIGhlcmUgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHdpdGggMC40LnguLFxuICAvKmVzbGludC1kaXNhYmxlICovIC8vIGVzbGludCB3YW50cyBjYW1lbCBjYXNlZCBmdW5jdGlvbiBuYW1lXG4gIG11c3RhY2hlLnRvX2h0bWwgPSBmdW5jdGlvbiB0b19odG1sICh0ZW1wbGF0ZSwgdmlldywgcGFydGlhbHMsIHNlbmQpIHtcbiAgICAvKmVzbGludC1lbmFibGUqL1xuXG4gICAgdmFyIHJlc3VsdCA9IG11c3RhY2hlLnJlbmRlcih0ZW1wbGF0ZSwgdmlldywgcGFydGlhbHMpO1xuXG4gICAgaWYgKGlzRnVuY3Rpb24oc2VuZCkpIHtcbiAgICAgIHNlbmQocmVzdWx0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH07XG5cbiAgLy8gRXhwb3J0IHRoZSBlc2NhcGluZyBmdW5jdGlvbiBzbyB0aGF0IHRoZSB1c2VyIG1heSBvdmVycmlkZSBpdC5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qYW5sL211c3RhY2hlLmpzL2lzc3Vlcy8yNDRcbiAgbXVzdGFjaGUuZXNjYXBlID0gZXNjYXBlSHRtbDtcblxuICAvLyBFeHBvcnQgdGhlc2UgbWFpbmx5IGZvciB0ZXN0aW5nLCBidXQgYWxzbyBmb3IgYWR2YW5jZWQgdXNhZ2UuXG4gIG11c3RhY2hlLlNjYW5uZXIgPSBTY2FubmVyO1xuICBtdXN0YWNoZS5Db250ZXh0ID0gQ29udGV4dDtcbiAgbXVzdGFjaGUuV3JpdGVyID0gV3JpdGVyO1xuXG59KSk7XG4iLCIvKiBvYmplY3QtaXRlcmF0b3JzLmpzIC0gTWluaSBVbmRlcnNjb3JlIGxpYnJhcnlcbiAqIGJ5IEpvbmF0aGFuIEVpdGVuXG4gKlxuICogVGhlIG1ldGhvZHMgYmVsb3cgb3BlcmF0ZSBvbiBvYmplY3RzIChidXQgbm90IGFycmF5cykgc2ltaWxhcmx5XG4gKiB0byBVbmRlcnNjb3JlIChodHRwOi8vdW5kZXJzY29yZWpzLm9yZy8jY29sbGVjdGlvbnMpLlxuICpcbiAqIEZvciBtb3JlIGluZm9ybWF0aW9uOlxuICogaHR0cHM6Ly9naXRodWIuY29tL2pvbmVpdC9vYmplY3QtaXRlcmF0b3JzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQHN1bW1hcnkgV3JhcCBhbiBvYmplY3QgZm9yIG9uZSBtZXRob2QgY2FsbC5cbiAqIEBEZXNjIE5vdGUgdGhhdCB0aGUgYG5ld2Aga2V5d29yZCBpcyBub3QgbmVjZXNzYXJ5LlxuICogQHBhcmFtIHtvYmplY3R8bnVsbHx1bmRlZmluZWR9IG9iamVjdCAtIGBudWxsYCBvciBgdW5kZWZpbmVkYCBpcyB0cmVhdGVkIGFzIGFuIGVtcHR5IHBsYWluIG9iamVjdC5cbiAqIEByZXR1cm4ge1dyYXBwZXJ9IFRoZSB3cmFwcGVkIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gV3JhcHBlcihvYmplY3QpIHtcbiAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgV3JhcHBlcikge1xuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgV3JhcHBlcikpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBXcmFwcGVyKG9iamVjdCk7XG4gICAgfVxuICAgIHRoaXMub3JpZ2luYWxWYWx1ZSA9IG9iamVjdDtcbiAgICB0aGlzLm8gPSBvYmplY3QgfHwge307XG59XG5cbi8qKlxuICogQG5hbWUgV3JhcHBlci5jaGFpblxuICogQHN1bW1hcnkgV3JhcCBhbiBvYmplY3QgZm9yIGEgY2hhaW4gb2YgbWV0aG9kIGNhbGxzLlxuICogQERlc2MgQ2FsbHMgdGhlIGNvbnN0cnVjdG9yIGBXcmFwcGVyKClgIGFuZCBtb2RpZmllcyB0aGUgd3JhcHBlciBmb3IgY2hhaW5pbmcuXG4gKiBAcGFyYW0ge29iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJuIHtXcmFwcGVyfSBUaGUgd3JhcHBlZCBvYmplY3QuXG4gKi9cbldyYXBwZXIuY2hhaW4gPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgdmFyIHdyYXBwZWQgPSBXcmFwcGVyKG9iamVjdCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbmV3LWNhcFxuICAgIHdyYXBwZWQuY2hhaW5pbmcgPSB0cnVlO1xuICAgIHJldHVybiB3cmFwcGVkO1xufTtcblxuV3JhcHBlci5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogVW53cmFwIGFuIG9iamVjdCB3cmFwcGVkIHdpdGgge0BsaW5rIFdyYXBwZXIuY2hhaW58V3JhcHBlci5jaGFpbigpfS5cbiAgICAgKiBAcmV0dXJuIHtvYmplY3R8bnVsbHx1bmRlZmluZWR9IFRoZSB2YWx1ZSBvcmlnaW5hbGx5IHdyYXBwZWQgYnkgdGhlIGNvbnN0cnVjdG9yLlxuICAgICAqIEBtZW1iZXJPZiBXcmFwcGVyLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9yaWdpbmFsVmFsdWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBkZXNjIE1pbWljcyBVbmRlcnNjb3JlJ3MgW2VhY2hdKGh0dHA6Ly91bmRlcnNjb3JlanMub3JnLyNlYWNoKSBtZXRob2Q6IEl0ZXJhdGUgb3ZlciB0aGUgbWVtYmVycyBvZiB0aGUgd3JhcHBlZCBvYmplY3QsIGNhbGxpbmcgYGl0ZXJhdGVlKClgIHdpdGggZWFjaC5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBpdGVyYXRlZSAtIEZvciBlYWNoIG1lbWJlciBvZiB0aGUgd3JhcHBlZCBvYmplY3QsIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdpdGggdGhyZWUgYXJndW1lbnRzOiBgKHZhbHVlLCBrZXksIG9iamVjdClgLiBUaGUgcmV0dXJuIHZhbHVlIG9mIHRoaXMgZnVuY3Rpb24gaXMgdW5kZWZpbmVkOyBhbiBgLmVhY2hgIGxvb3AgY2Fubm90IGJlIGJyb2tlbiBvdXQgb2YgKHVzZSB7QGxpbmsgV3JhcHBlciNmaW5kfC5maW5kfSBpbnN0ZWFkKS5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW2NvbnRleHRdIC0gSWYgZ2l2ZW4sIGBpdGVyYXRlZWAgaXMgYm91bmQgdG8gdGhpcyBvYmplY3QuIEluIG90aGVyIHdvcmRzLCB0aGlzIG9iamVjdCBiZWNvbWVzIHRoZSBgdGhpc2AgdmFsdWUgaW4gdGhlIGNhbGxzIHRvIGBpdGVyYXRlZWAuIChPdGhlcndpc2UsIHRoZSBgdGhpc2AgdmFsdWUgd2lsbCBiZSB0aGUgdW53cmFwcGVkIG9iamVjdC4pXG4gICAgICogQHJldHVybiB7V3JhcHBlcn0gVGhlIHdyYXBwZWQgb2JqZWN0IGZvciBjaGFpbmluZy5cbiAgICAgKiBAbWVtYmVyT2YgV3JhcHBlci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBlYWNoOiBmdW5jdGlvbiAoaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIG8gPSB0aGlzLm87XG4gICAgICAgIE9iamVjdC5rZXlzKG8pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgaXRlcmF0ZWUuY2FsbCh0aGlzLCBvW2tleV0sIGtleSwgbyk7XG4gICAgICAgIH0sIGNvbnRleHQgfHwgbyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZGVzYyBNaW1pY3MgVW5kZXJzY29yZSdzIFtmaW5kXShodHRwOi8vdW5kZXJzY29yZWpzLm9yZy8jZmluZCkgbWV0aG9kOiBMb29rIHRocm91Z2ggZWFjaCBtZW1iZXIgb2YgdGhlIHdyYXBwZWQgb2JqZWN0LCByZXR1cm5pbmcgdGhlIGZpcnN0IG9uZSB0aGF0IHBhc3NlcyBhIHRydXRoIHRlc3QgKGBwcmVkaWNhdGVgKSwgb3IgYHVuZGVmaW5lZGAgaWYgbm8gdmFsdWUgcGFzc2VzIHRoZSB0ZXN0LiBUaGUgZnVuY3Rpb24gcmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIGZpcnN0IGFjY2VwdGFibGUgbWVtYmVyLCBhbmQgZG9lc24ndCBuZWNlc3NhcmlseSB0cmF2ZXJzZSB0aGUgZW50aXJlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBwcmVkaWNhdGUgLSBGb3IgZWFjaCBtZW1iZXIgb2YgdGhlIHdyYXBwZWQgb2JqZWN0LCB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogYCh2YWx1ZSwga2V5LCBvYmplY3QpYC4gVGhlIHJldHVybiB2YWx1ZSBvZiB0aGlzIGZ1bmN0aW9uIHNob3VsZCBiZSB0cnV0aHkgaWYgdGhlIG1lbWJlciBwYXNzZXMgdGhlIHRlc3QgYW5kIGZhbHN5IG90aGVyd2lzZS5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW2NvbnRleHRdIC0gSWYgZ2l2ZW4sIGBwcmVkaWNhdGVgIGlzIGJvdW5kIHRvIHRoaXMgb2JqZWN0LiBJbiBvdGhlciB3b3JkcywgdGhpcyBvYmplY3QgYmVjb21lcyB0aGUgYHRoaXNgIHZhbHVlIGluIHRoZSBjYWxscyB0byBgcHJlZGljYXRlYC4gKE90aGVyd2lzZSwgdGhlIGB0aGlzYCB2YWx1ZSB3aWxsIGJlIHRoZSB1bndyYXBwZWQgb2JqZWN0LilcbiAgICAgKiBAcmV0dXJuIHsqfSBUaGUgZm91bmQgcHJvcGVydHkncyB2YWx1ZSwgb3IgdW5kZWZpbmVkIGlmIG5vdCBmb3VuZC5cbiAgICAgKiBAbWVtYmVyT2YgV3JhcHBlci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBmaW5kOiBmdW5jdGlvbiAocHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBvID0gdGhpcy5vO1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICBpZiAobykge1xuICAgICAgICAgICAgcmVzdWx0ID0gT2JqZWN0LmtleXMobykuZmluZChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByZWRpY2F0ZS5jYWxsKHRoaXMsIG9ba2V5XSwga2V5LCBvKTtcbiAgICAgICAgICAgIH0sIGNvbnRleHQgfHwgbyk7XG4gICAgICAgICAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBvW3Jlc3VsdF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGRlc2MgTWltaWNzIFVuZGVyc2NvcmUncyBbZmlsdGVyXShodHRwOi8vdW5kZXJzY29yZWpzLm9yZy8jZmlsdGVyKSBtZXRob2Q6IExvb2sgdGhyb3VnaCBlYWNoIG1lbWJlciBvZiB0aGUgd3JhcHBlZCBvYmplY3QsIHJldHVybmluZyB0aGUgdmFsdWVzIG9mIGFsbCBtZW1iZXJzIHRoYXQgcGFzcyBhIHRydXRoIHRlc3QgKGBwcmVkaWNhdGVgKSwgb3IgZW1wdHkgYXJyYXkgaWYgbm8gdmFsdWUgcGFzc2VzIHRoZSB0ZXN0LiBUaGUgZnVuY3Rpb24gYWx3YXlzIHRyYXZlcnNlcyB0aGUgZW50aXJlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBwcmVkaWNhdGUgLSBGb3IgZWFjaCBtZW1iZXIgb2YgdGhlIHdyYXBwZWQgb2JqZWN0LCB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogYCh2YWx1ZSwga2V5LCBvYmplY3QpYC4gVGhlIHJldHVybiB2YWx1ZSBvZiB0aGlzIGZ1bmN0aW9uIHNob3VsZCBiZSB0cnV0aHkgaWYgdGhlIG1lbWJlciBwYXNzZXMgdGhlIHRlc3QgYW5kIGZhbHN5IG90aGVyd2lzZS5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW2NvbnRleHRdIC0gSWYgZ2l2ZW4sIGBwcmVkaWNhdGVgIGlzIGJvdW5kIHRvIHRoaXMgb2JqZWN0LiBJbiBvdGhlciB3b3JkcywgdGhpcyBvYmplY3QgYmVjb21lcyB0aGUgYHRoaXNgIHZhbHVlIGluIHRoZSBjYWxscyB0byBgcHJlZGljYXRlYC4gKE90aGVyd2lzZSwgdGhlIGB0aGlzYCB2YWx1ZSB3aWxsIGJlIHRoZSB1bndyYXBwZWQgb2JqZWN0LilcbiAgICAgKiBAcmV0dXJuIHsqfSBBbiBhcnJheSBjb250YWluaW5nIHRoZSBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICogQG1lbWJlck9mIFdyYXBwZXIucHJvdG90eXBlXG4gICAgICovXG4gICAgZmlsdGVyOiBmdW5jdGlvbiAocHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBvID0gdGhpcy5vO1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIGlmIChvKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhvKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJlZGljYXRlLmNhbGwodGhpcywgb1trZXldLCBrZXksIG8pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG9ba2V5XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgY29udGV4dCB8fCBvKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZGVzYyBNaW1pY3MgVW5kZXJzY29yZSdzIFttYXBdKGh0dHA6Ly91bmRlcnNjb3JlanMub3JnLyNtYXApIG1ldGhvZDogUHJvZHVjZXMgYSBuZXcgYXJyYXkgb2YgdmFsdWVzIGJ5IG1hcHBpbmcgZWFjaCB2YWx1ZSBpbiBsaXN0IHRocm91Z2ggYSB0cmFuc2Zvcm1hdGlvbiBmdW5jdGlvbiAoYGl0ZXJhdGVlYCkuIFRoZSBmdW5jdGlvbiBhbHdheXMgdHJhdmVyc2VzIHRoZSBlbnRpcmUgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGl0ZXJhdGVlIC0gRm9yIGVhY2ggbWVtYmVyIG9mIHRoZSB3cmFwcGVkIG9iamVjdCwgdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6IGAodmFsdWUsIGtleSwgb2JqZWN0KWAuIFRoZSByZXR1cm4gdmFsdWUgb2YgdGhpcyBmdW5jdGlvbiBpcyBjb25jYXRlbmF0ZWQgdG8gdGhlIGVuZCBvZiB0aGUgbmV3IGFycmF5LlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbY29udGV4dF0gLSBJZiBnaXZlbiwgYGl0ZXJhdGVlYCBpcyBib3VuZCB0byB0aGlzIG9iamVjdC4gSW4gb3RoZXIgd29yZHMsIHRoaXMgb2JqZWN0IGJlY29tZXMgdGhlIGB0aGlzYCB2YWx1ZSBpbiB0aGUgY2FsbHMgdG8gYHByZWRpY2F0ZWAuIChPdGhlcndpc2UsIHRoZSBgdGhpc2AgdmFsdWUgd2lsbCBiZSB0aGUgdW53cmFwcGVkIG9iamVjdC4pXG4gICAgICogQHJldHVybiB7Kn0gQW4gYXJyYXkgY29udGFpbmluZyB0aGUgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqIEBtZW1iZXJPZiBXcmFwcGVyLnByb3RvdHlwZVxuICAgICAqL1xuICAgIG1hcDogZnVuY3Rpb24gKGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBvID0gdGhpcy5vO1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIGlmIChvKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhvKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChpdGVyYXRlZS5jYWxsKHRoaXMsIG9ba2V5XSwga2V5LCBvKSk7XG4gICAgICAgICAgICB9LCBjb250ZXh0IHx8IG8pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBkZXNjIE1pbWljcyBVbmRlcnNjb3JlJ3MgW3JlZHVjZV0oaHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvI3JlZHVjZSkgbWV0aG9kOiBCb2lsIGRvd24gdGhlIHZhbHVlcyBvZiBhbGwgdGhlIG1lbWJlcnMgb2YgdGhlIHdyYXBwZWQgb2JqZWN0IGludG8gYSBzaW5nbGUgdmFsdWUuIGBtZW1vYCBpcyB0aGUgaW5pdGlhbCBzdGF0ZSBvZiB0aGUgcmVkdWN0aW9uLCBhbmQgZWFjaCBzdWNjZXNzaXZlIHN0ZXAgb2YgaXQgc2hvdWxkIGJlIHJldHVybmVkIGJ5IGBpdGVyYXRlZSgpYC5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBpdGVyYXRlZSAtIEZvciBlYWNoIG1lbWJlciBvZiB0aGUgd3JhcHBlZCBvYmplY3QsIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdpdGggZm91ciBhcmd1bWVudHM6IGAobWVtbywgdmFsdWUsIGtleSwgb2JqZWN0KWAuIFRoZSByZXR1cm4gdmFsdWUgb2YgdGhpcyBmdW5jdGlvbiBiZWNvbWVzIHRoZSBuZXcgdmFsdWUgb2YgYG1lbW9gIGZvciB0aGUgbmV4dCBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbbWVtb10gLSBJZiBubyBtZW1vIGlzIHBhc3NlZCB0byB0aGUgaW5pdGlhbCBpbnZvY2F0aW9uIG9mIHJlZHVjZSwgdGhlIGl0ZXJhdGVlIGlzIG5vdCBpbnZva2VkIG9uIHRoZSBmaXJzdCBlbGVtZW50IG9mIHRoZSBsaXN0LiBUaGUgZmlyc3QgZWxlbWVudCBpcyBpbnN0ZWFkIHBhc3NlZCBhcyB0aGUgbWVtbyBpbiB0aGUgaW52b2NhdGlvbiBvZiB0aGUgaXRlcmF0ZWUgb24gdGhlIG5leHQgZWxlbWVudCBpbiB0aGUgbGlzdC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW2NvbnRleHRdIC0gSWYgZ2l2ZW4sIGBpdGVyYXRlZWAgaXMgYm91bmQgdG8gdGhpcyBvYmplY3QuIEluIG90aGVyIHdvcmRzLCB0aGlzIG9iamVjdCBiZWNvbWVzIHRoZSBgdGhpc2AgdmFsdWUgaW4gdGhlIGNhbGxzIHRvIGBpdGVyYXRlZWAuIChPdGhlcndpc2UsIHRoZSBgdGhpc2AgdmFsdWUgd2lsbCBiZSB0aGUgdW53cmFwcGVkIG9iamVjdC4pXG4gICAgICogQHJldHVybiB7Kn0gVGhlIHZhbHVlIG9mIGBtZW1vYCBcInJlZHVjZWRcIiBhcyBwZXIgYGl0ZXJhdGVlYC5cbiAgICAgKiBAbWVtYmVyT2YgV3JhcHBlci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICByZWR1Y2U6IGZ1bmN0aW9uIChpdGVyYXRlZSwgbWVtbywgY29udGV4dCkge1xuICAgICAgICB2YXIgbyA9IHRoaXMubztcbiAgICAgICAgaWYgKG8pIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKG8pLmZvckVhY2goZnVuY3Rpb24gKGtleSwgaWR4KSB7XG4gICAgICAgICAgICAgICAgbWVtbyA9ICghaWR4ICYmIG1lbW8gPT09IHVuZGVmaW5lZCkgPyBvW2tleV0gOiBpdGVyYXRlZShtZW1vLCBvW2tleV0sIGtleSwgbyk7XG4gICAgICAgICAgICB9LCBjb250ZXh0IHx8IG8pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZW1vO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZGVzYyBNaW1pY3MgVW5kZXJzY29yZSdzIFtleHRlbmRdKGh0dHA6Ly91bmRlcnNjb3JlanMub3JnLyNleHRlbmQpIG1ldGhvZDogQ29weSBhbGwgb2YgdGhlIHByb3BlcnRpZXMgaW4gZWFjaCBvZiB0aGUgYHNvdXJjZWAgb2JqZWN0IHBhcmFtZXRlcihzKSBvdmVyIHRvIHRoZSAod3JhcHBlZCkgZGVzdGluYXRpb24gb2JqZWN0ICh0aHVzIG11dGF0aW5nIGl0KS4gSXQncyBpbi1vcmRlciwgc28gdGhlIHByb3BlcnRpZXMgb2YgdGhlIGxhc3QgYHNvdXJjZWAgb2JqZWN0IHdpbGwgb3ZlcnJpZGUgcHJvcGVydGllcyB3aXRoIHRoZSBzYW1lIG5hbWUgaW4gcHJldmlvdXMgYXJndW1lbnRzIG9yIGluIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogPiBUaGlzIG1ldGhvZCBjb3BpZXMgb3duIG1lbWJlcnMgYXMgd2VsbCBhcyBtZW1iZXJzIGluaGVyaXRlZCBmcm9tIHByb3RvdHlwZSBjaGFpbi5cbiAgICAgKiBAcGFyYW0gey4uLm9iamVjdHxudWxsfHVuZGVmaW5lZH0gc291cmNlIC0gVmFsdWVzIG9mIGBudWxsYCBvciBgdW5kZWZpbmVkYCBhcmUgdHJlYXRlZCBhcyBlbXB0eSBwbGFpbiBvYmplY3RzLlxuICAgICAqIEByZXR1cm4ge1dyYXBwZXJ8b2JqZWN0fSBUaGUgd3JhcHBlZCBkZXN0aW5hdGlvbiBvYmplY3QgaWYgY2hhaW5pbmcgaXMgaW4gZWZmZWN0OyBvdGhlcndpc2UgdGhlIHVud3JhcHBlZCBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQG1lbWJlck9mIFdyYXBwZXIucHJvdG90eXBlXG4gICAgICovXG4gICAgZXh0ZW5kOiBmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICAgIHZhciBvID0gdGhpcy5vO1xuICAgICAgICBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLmZvckVhY2goZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgICAgICAgaWYgKG9iamVjdCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgb1trZXldID0gb2JqZWN0W2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhaW5pbmcgPyB0aGlzIDogbztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGRlc2MgTWltaWNzIFVuZGVyc2NvcmUncyBbZXh0ZW5kT3duXShodHRwOi8vdW5kZXJzY29yZWpzLm9yZy8jZXh0ZW5kT3duKSBtZXRob2Q6IExpa2Uge0BsaW5rIFdyYXBwZXIjZXh0ZW5kfGV4dGVuZH0sIGJ1dCBvbmx5IGNvcGllcyBpdHMgXCJvd25cIiBwcm9wZXJ0aWVzIG92ZXIgdG8gdGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLm9iamVjdHxudWxsfHVuZGVmaW5lZH0gc291cmNlIC0gVmFsdWVzIG9mIGBudWxsYCBvciBgdW5kZWZpbmVkYCBhcmUgdHJlYXRlZCBhcyBlbXB0eSBwbGFpbiBvYmplY3RzLlxuICAgICAqIEByZXR1cm4ge1dyYXBwZXJ8b2JqZWN0fSBUaGUgd3JhcHBlZCBkZXN0aW5hdGlvbiBvYmplY3QgaWYgY2hhaW5pbmcgaXMgaW4gZWZmZWN0OyBvdGhlcndpc2UgdGhlIHVud3JhcHBlZCBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQG1lbWJlck9mIFdyYXBwZXIucHJvdG90eXBlXG4gICAgICovXG4gICAgZXh0ZW5kT3duOiBmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICAgIHZhciBvID0gdGhpcy5vO1xuICAgICAgICBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLmZvckVhY2goZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgICAgICAgV3JhcHBlcihvYmplY3QpLmVhY2goZnVuY3Rpb24gKHZhbCwga2V5KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbmV3LWNhcFxuICAgICAgICAgICAgICAgIG9ba2V5XSA9IHZhbDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhaW5pbmcgPyB0aGlzIDogbztcbiAgICB9XG59O1xuXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9maW5kXG5pZiAoIUFycmF5LnByb3RvdHlwZS5maW5kKSB7XG4gICAgQXJyYXkucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbiAocHJlZGljYXRlKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZXh0ZW5kLW5hdGl2ZVxuICAgICAgICBpZiAodGhpcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJyYXkucHJvdG90eXBlLmZpbmQgY2FsbGVkIG9uIG51bGwgb3IgdW5kZWZpbmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBwcmVkaWNhdGUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ByZWRpY2F0ZSBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGlzdCA9IE9iamVjdCh0aGlzKTtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGxpc3QubGVuZ3RoID4+PiAwO1xuICAgICAgICB2YXIgdGhpc0FyZyA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgdmFyIHZhbHVlO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhbHVlID0gbGlzdFtpXTtcbiAgICAgICAgICAgIGlmIChwcmVkaWNhdGUuY2FsbCh0aGlzQXJnLCB2YWx1ZSwgaSwgbGlzdCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFdyYXBwZXI7XG4iLCIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUkVHRVhQX0lORElSRUNUSU9OID0gL14oXFx3KylcXCgoXFx3KylcXCkkLzsgIC8vIGZpbmRzIGNvbXBsZXRlIHBhdHRlcm4gYShiKSB3aGVyZSBib3RoIGEgYW5kIGIgYXJlIHJlZ2V4IFwid29yZHNcIlxuXG4vKiogQHR5cGVkZWYge29iamVjdH0gdmFsdWVJdGVtXG4gKiBZb3Ugc2hvdWxkIHN1cHBseSBib3RoIGBuYW1lYCBhbmQgYGFsaWFzYCBidXQgeW91IGNvdWxkIG9taXQgb25lIG9yIHRoZSBvdGhlciBhbmQgd2hpY2hldmVyIHlvdSBwcm92aWRlIHdpbGwgYmUgdXNlZCBmb3IgYm90aC5cbiAqID4gSWYgeW91IG9ubHkgZ2l2ZSB0aGUgYG5hbWVgIHByb3BlcnR5LCB5b3UgbWlnaHQgYXMgd2VsbCBqdXN0IGdpdmUgYSBzdHJpbmcgZm9yIHtAbGluayBtZW51SXRlbX0gcmF0aGVyIHRoYW4gdGhpcyBvYmplY3QuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW25hbWU9YWxpYXNdIC0gVmFsdWUgb2YgYHZhbHVlYCBhdHRyaWJ1dGUgb2YgYDxvcHRpb24+Li4uPC9vcHRpb24+YCBlbGVtZW50LlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFthbGlhcz1uYW1lXSAtIFRleHQgb2YgYDxvcHRpb24+Li4uPC9vcHRpb24+YCBlbGVtZW50LlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFt0eXBlXSBPbmUgb2YgdGhlIGtleXMgb2YgYHRoaXMuY29udmVydGVyc2AuIElmIG5vdCBvbmUgb2YgdGhlc2UgKGluY2x1ZGluZyBgdW5kZWZpbmVkYCksIGZpZWxkIHZhbHVlcyB3aWxsIGJlIHRlc3RlZCB3aXRoIGEgc3RyaW5nIGNvbXBhcmlzb24uXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtoaWRkZW49ZmFsc2VdXG4gKi9cblxuLyoqIEB0eXBlZGVmIHtvYmplY3R8bWVudUl0ZW1bXX0gc3VibWVudUl0ZW1cbiAqIEBzdW1tYXJ5IEhpZXJhcmNoaWNhbCBhcnJheSBvZiBzZWxlY3QgbGlzdCBpdGVtcy5cbiAqIEBkZXNjIERhdGEgc3RydWN0dXJlIHJlcHJlc2VudGluZyB0aGUgbGlzdCBvZiBgPG9wdGlvbj4uLi48L29wdGlvbj5gIGFuZCBgPG9wdGdyb3VwPi4uLjwvb3B0Z3JvdXA+YCBlbGVtZW50cyB0aGF0IG1ha2UgdXAgYSBgPHNlbGVjdD4uLi48L3NlbGVjdD5gIGVsZW1lbnQuXG4gKlxuICogPiBBbHRlcm5hdGUgZm9ybTogSW5zdGVhZCBvZiBhbiBvYmplY3Qgd2l0aCBhIGBtZW51YCBwcm9wZXJ0eSBjb250YWluaW5nIGFuIGFycmF5LCBtYXkgaXRzZWxmIGJlIHRoYXQgYXJyYXkuIEJvdGggZm9ybXMgaGF2ZSB0aGUgb3B0aW9uYWwgYGxhYmVsYCBwcm9wZXJ0eS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbbGFiZWxdIC0gRGVmYXVsdHMgdG8gYSBnZW5lcmF0ZWQgc3RyaW5nIG9mIHRoZSBmb3JtIFwiR3JvdXAgblsubV0uLi5cIiB3aGVyZSBlYWNoIGRlY2ltYWwgcG9zaXRpb24gcmVwcmVzZW50cyBhIGxldmVsIG9mIHRoZSBvcHRncm91cCBoaWVyYXJjaHkuXG4gKiBAcHJvcGVydHkge21lbnVJdGVtW119IHN1Ym1lbnVcbiAqL1xuXG4vKiogQHR5cGVkZWYge3N0cmluZ3x2YWx1ZUl0ZW18c3VibWVudUl0ZW19IG1lbnVJdGVtXG4gKiBNYXkgYmUgb25lIG9mIHRocmVlIHBvc3NpYmxlIHR5cGVzIHRoYXQgc3BlY2lmeSBlaXRoZXIgYW4gYDxvcHRpb24+Li4uLjwvb3B0aW9uPmAgZWxlbWVudCBvciBhbiBgPG9wdGdyb3VwPi4uLi48L29wdGdyb3VwPmAgZWxlbWVudCBhcyBmb2xsb3dzOlxuICogKiBJZiBhIGBzdHJpbmdgLCBzcGVjaWZpZXMgdGhlIHRleHQgb2YgYW4gYDxvcHRpb24+Li4uLjwvb3B0aW9uPmAgZWxlbWVudCB3aXRoIG5vIGB2YWx1ZWAgYXR0cmlidXRlLiAoSW4gdGhlIGFic2VuY2Ugb2YgYSBgdmFsdWVgIGF0dHJpYnV0ZSwgdGhlIGB2YWx1ZWAgcHJvcGVydHkgb2YgdGhlIGVsZW1lbnQgZGVmYXVsdHMgdG8gdGhlIHRleHQuKVxuICogKiBJZiBzaGFwZWQgbGlrZSBhIHtAbGluayB2YWx1ZUl0ZW19IG9iamVjdCwgc3BlY2lmaWVzIGJvdGggdGhlIHRleHQgYW5kIHZhbHVlIG9mIGFuIGA8b3B0aW9uLi4uLjwvb3B0aW9uPmAgZWxlbWVudC5cbiAqICogSWYgc2hhcGVkIGxpa2UgYSB7QGxpbmsgc3VibWVudUl0ZW19IG9iamVjdCAob3IgaXRzIGFsdGVybmF0ZSBhcnJheSBmb3JtKSwgc3BlY2lmaWVzIGFuIGA8b3B0Z3JvdXA+Li4uLjwvb3B0Z3JvdXA+YCBlbGVtZW50LlxuICovXG5cbi8qKlxuICogQHN1bW1hcnkgQnVpbGRzIGEgbmV3IG1lbnUgcHJlLXBvcHVsYXRlZCB3aXRoIGl0ZW1zIGFuZCBncm91cHMuXG4gKiBAZGVzYyBUaGlzIGZ1bmN0aW9uIGNyZWF0ZXMgYSBuZXcgcG9wLXVwIG1lbnUgKGEuay5hLiBcImRyb3AtZG93blwiKS4gVGhpcyBpcyBhIGA8c2VsZWN0Pi4uLjwvc2VsZWN0PmAgZWxlbWVudCwgcHJlLXBvcHVsYXRlZCB3aXRoIGl0ZW1zIChgPG9wdGlvbj4uLi48L29wdGlvbj5gIGVsZW1lbnRzKSBhbmQgZ3JvdXBzIChgPG9wdGdyb3VwPi4uLjwvb3B0Z3JvdXA+YCBlbGVtZW50cykuXG4gKiA+IEJvbnVzOiBUaGlzIGZ1bmN0aW9uIGFsc28gYnVpbGRzIGBpbnB1dCB0eXBlPXRleHRgIGVsZW1lbnRzLlxuICogPiBOT1RFOiBUaGlzIGZ1bmN0aW9uIGdlbmVyYXRlcyBPUFRHUk9VUCBlbGVtZW50cyBmb3Igc3VidHJlZXMuIEhvd2V2ZXIsIG5vdGUgdGhhdCBIVE1MNSBzcGVjaWZpZXMgdGhhdCBPUFRHUk9VUCBlbGVtbmVudHMgbWFkZSBub3QgbmVzdCEgVGhpcyBmdW5jdGlvbiBnZW5lcmF0ZXMgdGhlIG1hcmt1cCBmb3IgdGhlbSBidXQgdGhleSBhcmUgbm90IHJlbmRlcmVkIGJ5IG1vc3QgYnJvd3NlcnMsIG9yIG5vdCBjb21wbGV0ZWx5LiBUaGVyZWZvcmUsIGZvciBub3csIGRvIG5vdCBzcGVjaWZ5IG1vcmUgdGhhbiBvbmUgbGV2ZWwgc3VidHJlZXMuIEZ1dHVyZSB2ZXJzaW9ucyBvZiBIVE1MIG1heSBzdXBwb3J0IGl0LiBJIGFsc28gcGxhbiB0byBhZGQgaGVyZSBvcHRpb25zIHRvIGF2b2lkIE9QVEdST1VQUyBlbnRpcmVseSBlaXRoZXIgYnkgaW5kZW50aW5nIG9wdGlvbiB0ZXh0LCBvciBieSBjcmVhdGluZyBhbHRlcm5hdGUgRE9NIG5vZGVzIHVzaW5nIGA8bGk+YCBpbnN0ZWFkIG9mIGA8c2VsZWN0PmAsIG9yIGJvdGguXG4gKiBAbWVtYmVyT2YgcG9wTWVudVxuICpcbiAqIEBwYXJhbSB7RWxlbWVudHxzdHJpbmd9IGVsIC0gTXVzdCBiZSBvbmUgb2YgKGNhc2Utc2Vuc2l0aXZlKTpcbiAqICogdGV4dCBib3ggLSBhbiBgSFRNTElucHV0RWxlbWVudGAgdG8gdXNlIGFuIGV4aXN0aW5nIGVsZW1lbnQgb3IgYCdJTlBVVCdgIHRvIGNyZWF0ZSBhIG5ldyBvbmVcbiAqICogZHJvcC1kb3duIC0gYW4gYEhUTUxTZWxlY3RFbGVtZW50YCB0byB1c2UgYW4gZXhpc3RpbmcgZWxlbWVudCBvciBgJ1NFTEVDVCdgIHRvIGNyZWF0ZSBhIG5ldyBvbmVcbiAqICogc3VibWVudSAtIGFuIGBIVE1MT3B0R3JvdXBFbGVtZW50YCB0byB1c2UgYW4gZXhpc3RpbmcgZWxlbWVudCBvciBgJ09QVEdST1VQJ2AgdG8gY3JlYXRlIGEgbmV3IG9uZSAobWVhbnQgZm9yIGludGVybmFsIHVzZSBvbmx5KVxuICpcbiAqIEBwYXJhbSB7bWVudUl0ZW1bXX0gW21lbnVdIC0gSGllcmFyY2hpY2FsIGxpc3Qgb2Ygc3RyaW5ncyB0byBhZGQgYXMgYDxvcHRpb24+Li4uPC9vcHRpb24+YCBvciBgPG9wdGdyb3VwPi4uLi48L29wdGdyb3VwPmAgZWxlbWVudHMuIE9taXR0aW5nIGNyZWF0ZXMgYSB0ZXh0IGJveC5cbiAqXG4gKiBAcGFyYW0ge251bGx8c3RyaW5nfSBbb3B0aW9ucy5wcm9tcHQ9JyddIC0gQWRkcyBhbiBpbml0aWFsIGA8b3B0aW9uPi4uLjwvb3B0aW9uPmAgZWxlbWVudCB0byB0aGUgZHJvcC1kb3duIHdpdGggdGhpcyB2YWx1ZSBpbiBwYXJlbnRoZXNlcyBhcyBpdHMgYHRleHRgOyBhbmQgZW1wdHkgc3RyaW5nIGFzIGl0cyBgdmFsdWVgLiBEZWZhdWx0IGlzIGVtcHR5IHN0cmluZywgd2hpY2ggY3JlYXRlcyBhIGJsYW5rIHByb21wdDsgYG51bGxgIHN1cHByZXNzZXMgcHJvbXB0IGFsdG9nZXRoZXIuXG4gKlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5zb3J0XSAtIFdoZXRoZXIgdG8gYWxwaGEgc29ydCBvciBub3QuIElmIHRydXRoeSwgc29ydHMgZWFjaCBvcHRncm91cCBvbiBpdHMgYGxhYmVsYDsgYW5kIGVhY2ggc2VsZWN0IG9wdGlvbiBvbiBpdHMgdGV4dCAoaXRzIGBhbGlhc2AgaWYgZ2l2ZW47IG9yIGl0cyBgbmFtZWAgaWYgbm90KS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBbb3B0aW9ucy5ibGFja2xpc3RdIC0gT3B0aW9uYWwgbGlzdCBvZiBtZW51IGl0ZW0gbmFtZXMgdG8gYmUgaWdub3JlZC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcltdfSBbb3B0aW9ucy5icmVhZGNydW1ic10gLSBMaXN0IG9mIG9wdGlvbiBncm91cCBzZWN0aW9uIG51bWJlcnMgKHJvb3QgaXMgc2VjdGlvbiAwKS4gKEZvciBpbnRlcm5hbCB1c2UuKVxuICpcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuYXBwZW5kPWZhbHNlXSAtIFdoZW4gYGVsYCBpcyBhbiBleGlzdGluZyBgPHNlbGVjdD5gIEVsZW1lbnQsIGdpdmluZyB0cnV0aHkgdmFsdWUgYWRkcyB0aGUgbmV3IGNoaWxkcmVuIHdpdGhvdXQgZmlyc3QgcmVtb3ZpbmcgZXhpc3RpbmcgY2hpbGRyZW4uXG4gKlxuICogQHJldHVybnMge0VsZW1lbnR9IEVpdGhlciBhIGA8c2VsZWN0PmAgb3IgYDxvcHRncm91cD5gIGVsZW1lbnQuXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkKGVsLCBtZW51LCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICB2YXIgcHJvbXB0ID0gb3B0aW9ucy5wcm9tcHQsXG4gICAgICAgIGJsYWNrbGlzdCA9IG9wdGlvbnMuYmxhY2tsaXN0LFxuICAgICAgICBzb3J0ID0gb3B0aW9ucy5zb3J0LFxuICAgICAgICBicmVhZGNydW1icyA9IG9wdGlvbnMuYnJlYWRjcnVtYnMgfHwgW10sXG4gICAgICAgIHBhdGggPSBicmVhZGNydW1icy5sZW5ndGggPyBicmVhZGNydW1icy5qb2luKCcuJykgKyAnLicgOiAnJyxcbiAgICAgICAgc3VidHJlZU5hbWUgPSBwb3BNZW51LnN1YnRyZWUsXG4gICAgICAgIGdyb3VwSW5kZXggPSAwLFxuICAgICAgICB0YWdOYW1lO1xuXG4gICAgaWYgKGVsIGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgICAgICB0YWdOYW1lID0gZWwudGFnTmFtZTtcbiAgICAgICAgaWYgKCFvcHRpb25zLmFwcGVuZCkge1xuICAgICAgICAgICAgZWwuaW5uZXJIVE1MID0gJyc7IC8vIHJlbW92ZSBhbGwgPG9wdGlvbj4gYW5kIDxvcHRncm91cD4gZWxlbWVudHNcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHRhZ05hbWUgPSBlbDtcbiAgICAgICAgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xuICAgIH1cblxuICAgIGlmIChtZW51KSB7XG4gICAgICAgIHZhciBhZGQsIG5ld09wdGlvbjtcbiAgICAgICAgaWYgKHRhZ05hbWUgPT09ICdTRUxFQ1QnKSB7XG4gICAgICAgICAgICBhZGQgPSBlbC5hZGQ7XG4gICAgICAgICAgICBpZiAocHJvbXB0KSB7XG4gICAgICAgICAgICAgICAgbmV3T3B0aW9uID0gbmV3IE9wdGlvbihwcm9tcHQsICcnKTtcbiAgICAgICAgICAgICAgICBuZXdPcHRpb24uaW5uZXJIVE1MICs9ICcmaGVsbGlwOyc7XG4gICAgICAgICAgICAgICAgZWwuYWRkKG5ld09wdGlvbik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHByb21wdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGVsLmFkZChuZXcgT3B0aW9uKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWRkID0gZWwuYXBwZW5kQ2hpbGQ7XG4gICAgICAgICAgICBlbC5sYWJlbCA9IHByb21wdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzb3J0KSB7XG4gICAgICAgICAgICBtZW51ID0gbWVudS5zbGljZSgpLnNvcnQoaXRlbUNvbXBhcmF0b3IpOyAvLyBzb3J0ZWQgY2xvbmVcbiAgICAgICAgfVxuXG4gICAgICAgIG1lbnUuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAvLyBpZiBpdGVtIGlzIG9mIGZvcm0gYShiKSBhbmQgdGhlcmUgaXMgYW4gZnVuY3Rpb24gYSBpbiBvcHRpb25zLCB0aGVuIGl0ZW0gPSBvcHRpb25zLmEoYilcbiAgICAgICAgICAgIGlmIChvcHRpb25zICYmIHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHZhciBpbmRpcmVjdGlvbiA9IGl0ZW0ubWF0Y2goUkVHRVhQX0lORElSRUNUSU9OKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5kaXJlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBpbmRpcmVjdGlvblsxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGIgPSBpbmRpcmVjdGlvblsyXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGYgPSBvcHRpb25zW2FdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0gPSBmKGIpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgJ2J1aWxkOiBFeHBlY3RlZCBvcHRpb25zLicgKyBhICsgJyB0byBiZSBhIGZ1bmN0aW9uLic7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzdWJ0cmVlID0gaXRlbVtzdWJ0cmVlTmFtZV0gfHwgaXRlbTtcbiAgICAgICAgICAgIGlmIChzdWJ0cmVlIGluc3RhbmNlb2YgQXJyYXkpIHtcblxuICAgICAgICAgICAgICAgIHZhciBncm91cE9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFkY3J1bWJzOiBicmVhZGNydW1icy5jb25jYXQoKytncm91cEluZGV4KSxcbiAgICAgICAgICAgICAgICAgICAgcHJvbXB0OiBpdGVtLmxhYmVsIHx8ICdHcm91cCAnICsgcGF0aCArIGdyb3VwSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IHNvcnQsXG4gICAgICAgICAgICAgICAgICAgIGJsYWNrbGlzdDogYmxhY2tsaXN0XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHZhciBvcHRncm91cCA9IGJ1aWxkKCdPUFRHUk9VUCcsIHN1YnRyZWUsIGdyb3VwT3B0aW9ucyk7XG5cbiAgICAgICAgICAgICAgICBpZiAob3B0Z3JvdXAuY2hpbGRFbGVtZW50Q291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgZWwuYXBwZW5kQ2hpbGQob3B0Z3JvdXApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaXRlbSAhPT0gJ29iamVjdCcpIHtcblxuICAgICAgICAgICAgICAgIGlmICghKGJsYWNrbGlzdCAmJiBibGFja2xpc3QuaW5kZXhPZihpdGVtKSA+PSAwKSkge1xuICAgICAgICAgICAgICAgICAgICBhZGQuY2FsbChlbCwgbmV3IE9wdGlvbihpdGVtKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFpdGVtLmhpZGRlbikge1xuXG4gICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBpdGVtLm5hbWUgfHwgaXRlbS5hbGlhcztcbiAgICAgICAgICAgICAgICBpZiAoIShibGFja2xpc3QgJiYgYmxhY2tsaXN0LmluZGV4T2YobmFtZSkgPj0gMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkLmNhbGwoZWwsIG5ldyBPcHRpb24oXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLmFsaWFzIHx8IGl0ZW0ubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGVsLnR5cGUgPSAndGV4dCc7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsO1xufVxuXG5mdW5jdGlvbiBpdGVtQ29tcGFyYXRvcihhLCBiKSB7XG4gICAgYSA9IGEuYWxpYXMgfHwgYS5uYW1lIHx8IGEubGFiZWwgfHwgYTtcbiAgICBiID0gYi5hbGlhcyB8fCBiLm5hbWUgfHwgYi5sYWJlbCB8fCBiO1xuICAgIHJldHVybiBhIDwgYiA/IC0xIDogYSA+IGIgPyAxIDogMDtcbn1cblxuLyoqXG4gKiBAc3VtbWFyeSBSZWN1cnNpdmVseSBzZWFyY2hlcyB0aGUgY29udGV4dCBhcnJheSBvZiBgbWVudUl0ZW1gcyBmb3IgYSBuYW1lZCBgaXRlbWAuXG4gKiBAbWVtYmVyT2YgcG9wTWVudVxuICogQHRoaXMgQXJyYXlcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5rZXlzPVtwb3BNZW51LmRlZmF1bHRLZXldXSAtIFByb3BlcnRpZXMgdG8gc2VhcmNoIGVhY2ggbWVudUl0ZW0gd2hlbiBpdCBpcyBhbiBvYmplY3QuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNhc2VTZW5zaXRpdmU9ZmFsc2VdIC0gSWdub3JlIGNhc2Ugd2hpbGUgc2VhcmNoaW5nLlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIC0gVmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHt1bmRlZmluZWR8bWVudUl0ZW19IFRoZSBmb3VuZCBpdGVtIG9yIGB1bmRlZmluZWRgIGlmIG5vdCBmb3VuZC5cbiAqL1xuZnVuY3Rpb24gbG9va3VwKG9wdGlvbnMsIHZhbHVlKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgdmFsdWUgPSBvcHRpb25zO1xuICAgICAgICBvcHRpb25zID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHZhciBzaGFsbG93LCBkZWVwLCBpdGVtLCBwcm9wLFxuICAgICAgICBrZXlzID0gb3B0aW9ucyAmJiBvcHRpb25zLmtleXMgfHwgW3BvcE1lbnUuZGVmYXVsdEtleV0sXG4gICAgICAgIGNhc2VTZW5zaXRpdmUgPSBvcHRpb25zICYmIG9wdGlvbnMuY2FzZVNlbnNpdGl2ZTtcblxuICAgIHZhbHVlID0gdG9TdHJpbmcodmFsdWUsIGNhc2VTZW5zaXRpdmUpO1xuXG4gICAgc2hhbGxvdyA9IHRoaXMuZmluZChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgIHZhciBzdWJ0cmVlID0gaXRlbVtwb3BNZW51LnN1YnRyZWVdIHx8IGl0ZW07XG5cbiAgICAgICAgaWYgKHN1YnRyZWUgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgcmV0dXJuIChkZWVwID0gbG9va3VwLmNhbGwoc3VidHJlZSwgb3B0aW9ucywgdmFsdWUpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgaXRlbSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0b1N0cmluZyhpdGVtLCBjYXNlU2Vuc2l0aXZlKSA9PT0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBwcm9wID0gaXRlbVtrZXlzW2ldXTtcbiAgICAgICAgICAgICAgICBpZiAocHJvcCAmJiB0b1N0cmluZyhwcm9wLCBjYXNlU2Vuc2l0aXZlKSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBpdGVtID0gZGVlcCB8fCBzaGFsbG93O1xuXG4gICAgcmV0dXJuIGl0ZW0gJiYgKGl0ZW0ubmFtZSA/IGl0ZW0gOiB7IG5hbWU6IGl0ZW0gfSk7XG59XG5cbmZ1bmN0aW9uIHRvU3RyaW5nKHMsIGNhc2VTZW5zaXRpdmUpIHtcbiAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgaWYgKHMpIHtcbiAgICAgICAgcmVzdWx0ICs9IHM7IC8vIGNvbnZlcnQgcyB0byBzdHJpbmdcbiAgICAgICAgaWYgKCFjYXNlU2Vuc2l0aXZlKSB7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQudG9VcHBlckNhc2UoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEBzdW1tYXJ5IFJlY3Vyc2l2ZWx5IHdhbGtzIHRoZSBjb250ZXh0IGFycmF5IG9mIGBtZW51SXRlbWBzIGFuZCBjYWxscyBgaXRlcmF0ZWVgIG9uIGVhY2ggaXRlbSB0aGVyZWluLlxuICogQGRlc2MgYGl0ZXJhdGVlYCBpcyBjYWxsZWQgd2l0aCBlYWNoIGl0ZW0gKHRlcm1pbmFsIG5vZGUpIGluIHRoZSBtZW51IHRyZWUgYW5kIGEgZmxhdCAwLWJhc2VkIGluZGV4LiBSZWN1cnNlcyBvbiBtZW1iZXIgd2l0aCBuYW1lIG9mIGBwb3BNZW51LnN1YnRyZWVgLlxuICpcbiAqIFRoZSBub2RlIHdpbGwgYWx3YXlzIGJlIGEge0BsaW5rIHZhbHVlSXRlbX0gb2JqZWN0OyB3aGVuIGEgYHN0cmluZ2AsIGl0IGlzIGJveGVkIGZvciB5b3UuXG4gKlxuICogQG1lbWJlck9mIHBvcE1lbnVcbiAqXG4gKiBAdGhpcyBBcnJheVxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGl0ZXJhdGVlIC0gRm9yIGVhY2ggaXRlbSBpbiB0aGUgbWVudSwgYGl0ZXJhdGVlYCBpcyBjYWxsZWQgd2l0aDpcbiAqICogdGhlIGB2YWx1ZUl0ZW1gIChpZiB0aGUgaXRlbSBpcyBhIHByaW1hdGl2ZSBzdHJpbmcsIGl0IGlzIHdyYXBwZWQgdXAgZm9yIHlvdSlcbiAqICogYSAwLWJhc2VkIGBvcmRpbmFsYFxuICpcbiAqIFRoZSBgaXRlcmF0ZWVgIHJldHVybiB2YWx1ZSBjYW4gYmUgdXNlZCB0byByZXBsYWNlIHRoZSBpdGVtLCBhcyBmb2xsb3dzOlxuICogKiBgdW5kZWZpbmVkYCAtIGRvIG5vdGhpbmdcbiAqICogYG51bGxgIC0gc3BsaWNlIG91dCB0aGUgaXRlbTsgcmVzdWx0aW5nIGVtcHR5IHN1Ym1lbnVzIGFyZSBhbHNvIHNwbGljZWQgb3V0IChzZWUgbm90ZSlcbiAqICogYW55dGhpbmcgZWxzZSAtIHJlcGxhY2UgdGhlIGl0ZW0gd2l0aCB0aGlzIHZhbHVlOyBpZiB2YWx1ZSBpcyBhIHN1YnRyZWUgKGkuZS4sIGFuIGFycmF5KSBgaXRlcmF0ZWVgIHdpbGwgdGhlbiBiZSBjYWxsZWQgdG8gd2FsayBpdCBhcyB3ZWxsIChzZWUgbm90ZSlcbiAqXG4gKiA+IE5vdGU6IFJldHVybmluZyBhbnl0aGluZyAob3RoZXIgdGhhbiBgdW5kZWZpbmVkYCkgZnJvbSBgaXRlcmF0ZWVgIHdpbGwgKGRlZXBseSkgbXV0YXRlIHRoZSBvcmlnaW5hbCBgbWVudWAgc28geW91IG1heSB3YW50IHRvIGNvcHkgaXQgZmlyc3QgKGRlZXBseSwgaW5jbHVkaW5nIGFsbCBsZXZlbHMgb2YgYXJyYXkgbmVzdGluZyBidXQgbm90IHRoZSB0ZXJtaW5hbCBub2RlIG9iamVjdHMpLlxuICpcbiAqIEByZXR1cm5zIHtudW1iZXJ9IE51bWJlciBvZiBpdGVtcyAodGVybWluYWwgbm9kZXMpIGluIHRoZSBtZW51IHRyZWUuXG4gKi9cbmZ1bmN0aW9uIHdhbGsoaXRlcmF0ZWUpIHtcbiAgICB2YXIgbWVudSA9IHRoaXMsXG4gICAgICAgIG9yZGluYWwgPSAwLFxuICAgICAgICBzdWJ0cmVlTmFtZSA9IHBvcE1lbnUuc3VidHJlZSxcbiAgICAgICAgaSwgaXRlbSwgc3VidHJlZSwgbmV3VmFsO1xuXG4gICAgZm9yIChpID0gbWVudS5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICBpdGVtID0gbWVudVtpXTtcbiAgICAgICAgc3VidHJlZSA9IGl0ZW1bc3VidHJlZU5hbWVdIHx8IGl0ZW07XG5cbiAgICAgICAgaWYgKCEoc3VidHJlZSBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgICAgICAgICAgc3VidHJlZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghc3VidHJlZSkge1xuICAgICAgICAgICAgbmV3VmFsID0gaXRlcmF0ZWUoaXRlbS5uYW1lID8gaXRlbSA6IHsgbmFtZTogaXRlbSB9LCBvcmRpbmFsKTtcbiAgICAgICAgICAgIG9yZGluYWwgKz0gMTtcblxuICAgICAgICAgICAgaWYgKG5ld1ZhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5ld1ZhbCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBtZW51LnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgb3JkaW5hbCAtPSAxO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1lbnVbaV0gPSBpdGVtID0gbmV3VmFsO1xuICAgICAgICAgICAgICAgICAgICBzdWJ0cmVlID0gaXRlbVtzdWJ0cmVlTmFtZV0gfHwgaXRlbTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoc3VidHJlZSBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3VidHJlZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdWJ0cmVlKSB7XG4gICAgICAgICAgICBvcmRpbmFsICs9IHdhbGsuY2FsbChzdWJ0cmVlLCBpdGVyYXRlZSk7XG4gICAgICAgICAgICBpZiAoc3VidHJlZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBtZW51LnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICBvcmRpbmFsIC09IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb3JkaW5hbDtcbn1cblxuLyoqXG4gKiBAc3VtbWFyeSBGb3JtYXQgaXRlbSBuYW1lIHdpdGggaXQncyBhbGlhcyB3aGVuIGF2YWlsYWJsZS5cbiAqIEBtZW1iZXJPZiBwb3BNZW51XG4gKiBAcGFyYW0ge3N0cmluZ3x2YWx1ZUl0ZW19IGl0ZW1cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBmb3JtYXR0ZWQgbmFtZSBhbmQgYWxpYXMuXG4gKi9cbmZ1bmN0aW9uIGZvcm1hdEl0ZW0oaXRlbSkge1xuICAgIHZhciByZXN1bHQgPSBpdGVtLm5hbWUgfHwgaXRlbTtcbiAgICBpZiAoaXRlbS5hbGlhcykge1xuICAgICAgICByZXN1bHQgPSAnXCInICsgaXRlbS5hbGlhcyArICdcIiAoJyArIHJlc3VsdCArICcpJztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuXG5mdW5jdGlvbiBpc0dyb3VwUHJveHkocykge1xuICAgIHJldHVybiBSRUdFWFBfSU5ESVJFQ1RJT04udGVzdChzKTtcbn1cblxuLyoqXG4gKiBAbmFtZXNwYWNlXG4gKi9cbnZhciBwb3BNZW51ID0ge1xuICAgIGJ1aWxkOiBidWlsZCxcbiAgICB3YWxrOiB3YWxrLFxuICAgIGxvb2t1cDogbG9va3VwLFxuICAgIGZvcm1hdEl0ZW06IGZvcm1hdEl0ZW0sXG4gICAgaXNHcm91cFByb3h5OiBpc0dyb3VwUHJveHksXG4gICAgc3VidHJlZTogJ3N1Ym1lbnUnLFxuICAgIGRlZmF1bHRLZXk6ICduYW1lJ1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBwb3BNZW51O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKiBlc2xpbnQtZW52IG5vZGUsIGJyb3dzZXIgKi9cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHJlYWQtb25seSBwcm9wZXJ0eSBhbmQgYXR0YWNoZXMgaXQgdG8gdGhlIHByb3ZpZGVkIGNvbnRleHQuXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBOYW1lIGZvciBuZXcgcHJvcGVydHkuXG4gKiBAcGFyYW0geyp9IFt2YWx1ZV0gLSBWYWx1ZSBvZiBuZXcgcHJvcGVydHkuXG4gKi9cbmZ1bmN0aW9uIGFkZFJlYWRPbmx5UHJvcGVydHkobmFtZSwgdmFsdWUpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgbmFtZSwge1xuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZVxuICAgIH0pO1xufVxuXG4vKipcbiAqIEBjb25zdHJ1Y3RvciBQb2ludFxuICpcbiAqIEBkZXNjIFRoaXMgb2JqZWN0IHJlcHJlc2VudHMgYSBzaW5nbGUgcG9pbnQgaW4gYW4gYWJzdHJhY3QgMi1kaW1lbnNpb25hbCBtYXRyaXguXG4gKlxuICogVGhlIHVuaXQgb2YgbWVhc3VyZSBpcyB0eXBpY2FsbHkgcGl4ZWxzLlxuICogKElmIHVzZWQgdG8gbW9kZWwgY29tcHV0ZXIgZ3JhcGhpY3MsIHZlcnRpY2FsIGNvb3JkaW5hdGVzIGFyZSB0eXBpY2FsbHkgbWVhc3VyZWQgZG93bndhcmRzXG4gKiBmcm9tIHRoZSB0b3Agb2YgdGhlIHdpbmRvdy4gVGhpcyBjb252ZW50aW9uIGhvd2V2ZXIgaXMgbm90IGluaGVyZW50IGluIHRoaXMgb2JqZWN0LilcbiAqXG4gKiBOb3RlOiBUaGlzIG9iamVjdCBzaG91bGQgYmUgaW5zdGFudGlhdGVkIHdpdGggdGhlIGBuZXdgIGtleXdvcmQuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHggLSB0aGUgbmV3IHBvaW50J3MgYHhgIHByb3BlcnR5XG4gKiBAcGFyYW0ge251bWJlcn0geSAtIHRoZSBuZXcgcG9pbnQncyBgeWAgcHJvcGVydHlcbiAqL1xuZnVuY3Rpb24gUG9pbnQoeCwgeSkge1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgeFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQHN1bW1hcnkgVGhpcyBwb2ludCdzIGhvcml6b250YWwgY29vcmRpbmF0ZS5cbiAgICAgKiBAZGVzYyBDcmVhdGVkIHVwb24gaW5zdGFudGlhdGlvbiBieSB0aGUge0BsaW5rIFBvaW50fGNvbnN0cnVjdG9yfS5cbiAgICAgKiBAbWVtYmVyT2YgUG9pbnQucHJvdG90eXBlXG4gICAgICogQGFic3RyYWN0XG4gICAgICovXG4gICAgYWRkUmVhZE9ubHlQcm9wZXJ0eS5jYWxsKHRoaXMsICd4JywgTnVtYmVyKHgpIHx8IDApO1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgeVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQHN1bW1hcnkgVGhpcyBwb2ludCdzIHZlcnRpY2FsIGNvb3JkaW5hdGUuXG4gICAgICogQGRlc2MgQ3JlYXRlZCB1cG9uIGluc3RhbnRpYXRpb24gYnkgdGhlIHtAbGluayBQb2ludHxjb25zdHJ1Y3Rvcn0uXG4gICAgICogQG1lbWJlck9mIFBvaW50LnByb3RvdHlwZVxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqL1xuICAgIGFkZFJlYWRPbmx5UHJvcGVydHkuY2FsbCh0aGlzLCAneScsIE51bWJlcih5KSB8fCAwKTtcblxufVxuXG5Qb2ludC5wcm90b3R5cGUgPSB7XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7UG9pbnR9IEEgbmV3IHBvaW50IHdoaWNoIGlzIHRoaXMgcG9pbnQncyBwb3NpdGlvbiBpbmNyZWFzZWQgYnkgY29vcmRpbmF0ZXMgb2YgZ2l2ZW4gYG9mZnNldGAuXG4gICAgICogQHBhcmFtIHtQb2ludH0gb2Zmc2V0IC0gSG9yaXpvbnRhbCBhbmQgdmVydGljYWwgdmFsdWVzIHRvIGFkZCB0byB0aGlzIHBvaW50J3MgY29vcmRpbmF0ZXMuXG4gICAgICogQG1lbWJlck9mIFBvaW50LnByb3RvdHlwZVxuICAgICAqL1xuICAgIHBsdXM6IGZ1bmN0aW9uKG9mZnNldCkge1xuICAgICAgICByZXR1cm4gbmV3IFBvaW50KFxuICAgICAgICAgICAgdGhpcy54ICsgb2Zmc2V0LngsXG4gICAgICAgICAgICB0aGlzLnkgKyBvZmZzZXQueVxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7UG9pbnR9IEEgbmV3IHBvaW50IHdoaWNoIGlzIHRoaXMgcG9pbnQncyBwb3NpdGlvbiBpbmNyZWFzZWQgYnkgZ2l2ZW4gb2Zmc2V0cy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29mZnNldFg9MF0gLSBWYWx1ZSB0byBhZGQgdG8gdGhpcyBwb2ludCdzIGhvcml6b250YWwgY29vcmRpbmF0ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29mZnNldFk9MF0gLSBWYWx1ZSB0byBhZGQgdG8gdGhpcyBwb2ludCdzIGhvcml6b250YWwgY29vcmRpbmF0ZS5cbiAgICAgKiBAbWVtYmVyT2YgUG9pbnQucHJvdG90eXBlXG4gICAgICovXG4gICAgcGx1c1hZOiBmdW5jdGlvbihvZmZzZXRYLCBvZmZzZXRZKSB7XG4gICAgICAgIHJldHVybiBuZXcgUG9pbnQoXG4gICAgICAgICAgICB0aGlzLnggKyAob2Zmc2V0WCB8fCAwKSxcbiAgICAgICAgICAgIHRoaXMueSArIChvZmZzZXRZIHx8IDApXG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtQb2ludH0gQSBuZXcgcG9pbnQgd2hpY2ggaXMgdGhpcyBwb2ludCdzIHBvc2l0aW9uIGRlY3JlYXNlZCBieSBjb29yZGluYXRlcyBvZiBnaXZlbiBgb2Zmc2V0YC5cbiAgICAgKiBAcGFyYW0ge1BvaW50fSBvZmZzZXQgLSBIb3Jpem9udGFsIGFuZCB2ZXJ0aWNhbCB2YWx1ZXMgdG8gc3VidHJhY3QgZnJvbSB0aGlzIHBvaW50J3MgY29vcmRpbmF0ZXMuXG4gICAgICogQG1lbWJlck9mIFBvaW50LnByb3RvdHlwZVxuICAgICAqL1xuICAgIG1pbnVzOiBmdW5jdGlvbihvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludChcbiAgICAgICAgICAgIHRoaXMueCAtIG9mZnNldC54LFxuICAgICAgICAgICAgdGhpcy55IC0gb2Zmc2V0LnlcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1BvaW50fSBBIG5ldyBgUG9pbnRgIHBvc2l0aW9uZWQgdG8gbGVhc3QgeCBhbmQgbGVhc3QgeSBvZiB0aGlzIHBvaW50IGFuZCBnaXZlbiBgb2Zmc2V0YC5cbiAgICAgKiBAcGFyYW0ge1BvaW50fSBwb2ludCAtIEEgcG9pbnQgdG8gY29tcGFyZSB0byB0aGlzIHBvaW50LlxuICAgICAqIEBtZW1iZXJPZiBQb2ludC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBtaW46IGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgICAgIHJldHVybiBuZXcgUG9pbnQoXG4gICAgICAgICAgICBNYXRoLm1pbih0aGlzLngsIHBvaW50LngpLFxuICAgICAgICAgICAgTWF0aC5taW4odGhpcy55LCBwb2ludC55KVxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7UG9pbnR9IEEgbmV3IGBQb2ludGAgcG9zaXRpb25lZCB0byBncmVhdGVzdCB4IGFuZCBncmVhdGVzdCB5IG9mIHRoaXMgcG9pbnQgYW5kIGdpdmVuIGBwb2ludGAuXG4gICAgICogQHBhcmFtIHtQb2ludH0gcG9pbnQgLSBBIHBvaW50IHRvIGNvbXBhcmUgdG8gdGhpcyBwb2ludC5cbiAgICAgKiBAbWVtYmVyT2YgUG9pbnQucHJvdG90eXBlXG4gICAgICovXG4gICAgbWF4OiBmdW5jdGlvbihwb2ludCkge1xuICAgICAgICByZXR1cm4gbmV3IFBvaW50KFxuICAgICAgICAgICAgTWF0aC5tYXgodGhpcy54LCBwb2ludC54KSxcbiAgICAgICAgICAgIE1hdGgubWF4KHRoaXMueSwgcG9pbnQueSlcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge251bWJlcn0gRGlzdGFuY2UgYmV0d2VlbiBnaXZlbiBgcG9pbnRgIGFuZCB0aGlzIHBvaW50IHVzaW5nIFB5dGhhZ29yZWFuIFRoZW9yZW0gZm9ybXVsYS5cbiAgICAgKiBAcGFyYW0ge1BvaW50fSBwb2ludCAtIEEgcG9pbnQgZnJvbSB3aGljaCB0byBjb21wdXRlIHRoZSBkaXN0YW5jZSB0byB0aGlzIHBvaW50LlxuICAgICAqIEBtZW1iZXJPZiBQb2ludC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBkaXN0YW5jZTogZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAgICAgdmFyIGRlbHRhWCA9IHBvaW50LnggLSB0aGlzLngsXG4gICAgICAgICAgICBkZWx0YVkgPSBwb2ludC55IC0gdGhpcy55O1xuXG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoXG4gICAgICAgICAgICBkZWx0YVggKiBkZWx0YVggK1xuICAgICAgICAgICAgZGVsdGFZICogZGVsdGFZXG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIF8oRm9ybWVybHk6IGBlcXVhbGAuKV9cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmZiBfYm90aF8gY29vcmRpbmF0ZXMgb2YgdGhpcyBwb2ludCBhcmUgZXhhY3RseSBlcXVhbCB0byB0aG9zZSBvZiBnaXZlbiBgcG9pbnRgLlxuICAgICAqIEBwYXJhbSB7UG9pbnR9IHBvaW50IC0gQSBwb2ludCB0byBjb21wYXJlIHRvIHRoaXMgcG9pbnQuXG4gICAgICogQG1lbWJlck9mIFBvaW50LnByb3RvdHlwZVxuICAgICAqL1xuICAgIGVxdWFsczogZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChwb2ludCkge1xuICAgICAgICAgICAgcmVzdWx0ID1cbiAgICAgICAgICAgICAgICB0aGlzLnggPT09IHBvaW50LnggJiZcbiAgICAgICAgICAgICAgICB0aGlzLnkgPT09IHBvaW50Lnk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmZiBfYm90aF8gY29vcmRpbmF0ZXMgb2YgdGhpcyBwb2ludCBhcmUgZ3JlYXRlciB0aGFuIHRob3NlIG9mIGdpdmVuIGBwb2ludGAuXG4gICAgICogQHBhcmFtIHtQb2ludH0gcG9pbnQgLSBBIHBvaW50IHRvIGNvbXBhcmUgdG8gdGhpcyBwb2ludFxuICAgICAqIEBtZW1iZXJPZiBQb2ludC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBncmVhdGVyVGhhbjogZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRoaXMueCA+IHBvaW50LnggJiZcbiAgICAgICAgICAgIHRoaXMueSA+IHBvaW50LnlcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZmYgX2JvdGhfIGNvb3JkaW5hdGVzIG9mIHRoaXMgcG9pbnQgYXJlIGxlc3MgdGhhbiB0aG9zZSBvZiBnaXZlbiBgcG9pbnRgLlxuICAgICAqIEBwYXJhbSB7UG9pbnR9IHBvaW50IC0gQSBwb2ludCB0byBjb21wYXJlIHRvIHRoaXMgcG9pbnRcbiAgICAgKiBAbWVtYmVyT2YgUG9pbnQucHJvdG90eXBlXG4gICAgICovXG4gICAgbGVzc1RoYW46IGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0aGlzLnggPCBwb2ludC54ICYmXG4gICAgICAgICAgICB0aGlzLnkgPCBwb2ludC55XG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIF8oRm9ybWVybHkgYGdyZWF0ZXJUaGFuRXF1YWxUb2AuKV9cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmZiBfYm90aF8gY29vcmRpbmF0ZXMgb2YgdGhpcyBwb2ludCBhcmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRob3NlIG9mIGdpdmVuIGBwb2ludGAuXG4gICAgICogQHBhcmFtIHtQb2ludH0gcG9pbnQgLSBBIHBvaW50IHRvIGNvbXBhcmUgdG8gdGhpcyBwb2ludFxuICAgICAqIEBtZW1iZXJPZiBQb2ludC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBncmVhdGVyVGhhbk9yRXF1YWxUbzogZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRoaXMueCA+PSBwb2ludC54ICYmXG4gICAgICAgICAgICB0aGlzLnkgPj0gcG9pbnQueVxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBfKEZvcm1lcmx5IGBsZXNzVGhhbkVxdWFsVG9gLilfXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZmYgX2JvdGhfIGNvb3JkaW5hdGVzIG9mIHRoaXMgcG9pbnQgYXJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aG9zZSBvZiBnaXZlbiBgcG9pbnRgLlxuICAgICAqIEBwYXJhbSB7UG9pbnR9IHBvaW50IC0gQSBwb2ludCB0byBjb21wYXJlIHRvIHRoaXMgcG9pbnQuXG4gICAgICogQG1lbWJlck9mIFBvaW50LnByb3RvdHlwZVxuICAgICAqL1xuICAgIGxlc3NUaGFuT3JFcXVhbFRvOiBmdW5jdGlvbihwb2ludCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdGhpcy54IDw9IHBvaW50LnggJiZcbiAgICAgICAgICAgIHRoaXMueSA8PSBwb2ludC55XG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIF8oRm9ybWVybHkgYGlzQ29udGFpbmVkV2l0aGluUmVjdGFuZ2xlYC4pX1xuICAgICAqIEBwYXJhbSByZWN0IHtSZWN0YW5nbGV9IC0gUmVjdGFuZ2xlIHRvIHRlc3QgdGhpcyBwb2ludCBhZ2FpbnN0LlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWZmIHRoaXMgcG9pbnQgaXMgd2l0aGluIGdpdmVuIGByZWN0YC5cbiAgICAgKiBAbWVtYmVyT2YgUG9pbnQucHJvdG90eXBlXG4gICAgICovXG4gICAgd2l0aGluOiBmdW5jdGlvbihyZWN0KSB7XG4gICAgICAgIHZhciBtaW5YID0gcmVjdC5vcmlnaW4ueCxcbiAgICAgICAgICAgIG1heFggPSBtaW5YICsgcmVjdC5leHRlbnQueDtcbiAgICAgICAgdmFyIG1pblkgPSByZWN0Lm9yaWdpbi55LFxuICAgICAgICAgICAgbWF4WSA9IG1pblkgKyByZWN0LmV4dGVudC55O1xuXG4gICAgICAgIGlmIChyZWN0LmV4dGVudC54IDwgMCkge1xuICAgICAgICAgICAgbWluWCA9IG1heFg7XG4gICAgICAgICAgICBtYXhYID0gcmVjdC5vcmlnaW4ueDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZWN0LmV4dGVudC55IDwgMCkge1xuICAgICAgICAgICAgbWluWSA9IG1heFk7XG4gICAgICAgICAgICBtYXhZID0gcmVjdC5vcmlnaW4ueTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBtaW5YIDw9IHRoaXMueCAmJiB0aGlzLnggPCBtYXhYICYmXG4gICAgICAgICAgICBtaW5ZIDw9IHRoaXMueSAmJiB0aGlzLnkgPCBtYXhZXG4gICAgICAgICk7XG4gICAgfVxufTtcblxuUG9pbnQucHJvdG90eXBlLkVRID0gUG9pbnQucHJvdG90eXBlLmVxdWFscztcblBvaW50LnByb3RvdHlwZS5HVCA9IFBvaW50LnByb3RvdHlwZS5ncmVhdGVyVGhhbjtcblBvaW50LnByb3RvdHlwZS5MVCA9IFBvaW50LnByb3RvdHlwZS5sZXNzVGhhbjtcblBvaW50LnByb3RvdHlwZS5HRSA9IFBvaW50LnByb3RvdHlwZS5ncmVhdGVyVGhhbk9yRXF1YWxUbztcblBvaW50LnByb3RvdHlwZS5MRSA9IFBvaW50LnByb3RvdHlwZS5sZXNzVGhhbk9yRXF1YWxUbztcblxuXG4vKipcbiAqIEBjb25zdHJ1Y3RvciBSZWN0YW5nbGVcbiAqXG4gKiBAZGVzYyBUaGlzIG9iamVjdCByZXByZXNlbnRzIGEgcmVjdGFuZ3VsYXIgYXJlYSB3aXRoaW4gYW4gYWJzdHJhY3QgMi1kaW1lbnNpb25hbCBtYXRyaXguXG4gKlxuICogVGhlIHVuaXQgb2YgbWVhc3VyZSBpcyB0eXBpY2FsbHkgcGl4ZWxzLlxuICogKElmIHVzZWQgdG8gbW9kZWwgY29tcHV0ZXIgZ3JhcGhpY3MsIHZlcnRpY2FsIGNvb3JkaW5hdGVzIGFyZSB0eXBpY2FsbHkgbWVhc3VyZWQgZG93bndhcmRzXG4gKiBmcm9tIHRoZSB0b3Agb2YgdGhlIHdpbmRvdy4gVGhpcyBjb252ZW50aW9uIGhvd2V2ZXIgaXMgbm90IGluaGVyZW50IGluIHRoaXMgb2JqZWN0LilcbiAqXG4gKiBOb3JtYWxseSwgdGhlIGB4YCBhbmQgYHlgIHBhcmFtZXRlcnMgdG8gdGhlIGNvbnN0cnVjdG9yIGRlc2NyaWJlIHRoZSB1cHBlciBsZWZ0IGNvcm5lciBvZiB0aGUgcmVjdC5cbiAqIEhvd2V2ZXIsIG5lZ2F0aXZlIHZhbHVlcyBvZiBgd2lkdGhgIGFuZCBgaGVpZ2h0YCB3aWxsIGJlIGFkZGVkIHRvIHRoZSBnaXZlbiBgeGAgYW5kIGB5YC4gVGhhdCBpcyxcbiAqIGEgbmVnYXRpdmUgdmFsdWUgb2YgdGhlIGB3aWR0aGAgcGFyYW1ldGVyIHdpbGwgZXh0ZW5kIHRoZSByZWN0IHRvIHRoZSBsZWZ0IG9mIHRoZSBnaXZlbiBgeGAgYW5kXG4gKiBhIG5lZ2F0aXZlIHZhbHVlIG9mIHRoZSBgaGVpZ2h0YCBwYXJhbWV0ZXIgd2lsbCBleHRlbmQgdGhlIHJlY3QgYWJvdmUgdGhlIGdpdmVuIGB5YC5cbiAqIEluIGFueSBjYXNlLCBhZnRlciBpbnN0YW50aWF0aW9uIHRoZSBmb2xsb3dpbmcgYXJlIGd1YXJhbnRlZWQgdG8gYWx3YXlzIGJlIHRydWU6XG4gKiAqIFRoZSBgZXh0ZW50YCwgYHdpZHRoYCwgYW5kIGBoZWlnaHRgIHByb3BlcnRpZXMgX2Fsd2F5c18gZ2l2ZSBwb3NpdGl2ZSB2YWx1ZXMuXG4gKiAqIFRoZSBgb3JpZ2luYCwgYHRvcGAsIGFuZCBgbGVmdGAgcHJvcGVydGllcyBfYWx3YXlzXyByZWZsZWN0IHRoZSB1cHBlciBsZWZ0IGNvcm5lci5cbiAqICogVGhlIGBjb3JuZXJgLCBgYm90dG9tYCwgYW5kIGByaWdodGAgcHJvcGVydGllcyBfYWx3YXlzXyByZWZsZWN0IHRoZSBsb3dlciByaWdodCBjb3JuZXIuXG4gKlxuICogTm90ZTogVGhpcyBvYmplY3Qgc2hvdWxkIGJlIGluc3RhbnRpYXRlZCB3aXRoIHRoZSBgbmV3YCBrZXl3b3JkLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBbeD0wXSAtIEhvcml6b250YWwgY29vcmRpbmF0ZSBvZiBzb21lIGNvcm5lciBvZiB0aGUgcmVjdC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbeT0wXSAtIFZlcnRpY2FsIGNvb3JkaW5hdGUgb2Ygc29tZSBjb3JuZXIgb2YgdGhlIHJlY3QuXG4gKiBAcGFyYW0ge251bWJlcn0gW3dpZHRoPTBdIC0gV2lkdGggb2YgdGhlIG5ldyByZWN0LiBNYXkgYmUgbmVnYXRpdmUgKHNlZSBhYm92ZSkuXG4gKiBAcGFyYW0ge251bWJlcn0gW2hlaWdodD0wXSAtIEhlaWdodCBvZiB0aGUgbmV3IHJlY3QuIE1heSBiZSBuZWdhdGl2ZSAoc2VlIGFib3ZlKS5cbiAqL1xuZnVuY3Rpb24gUmVjdGFuZ2xlKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcblxuICAgIHggPSBOdW1iZXIoeCkgfHwgMDtcbiAgICB5ID0gTnVtYmVyKHkpIHx8IDA7XG4gICAgd2lkdGggPSBOdW1iZXIod2lkdGgpIHx8IDA7XG4gICAgaGVpZ2h0ID0gTnVtYmVyKGhlaWdodCkgfHwgMDtcblxuICAgIGlmICh3aWR0aCA8IDApIHtcbiAgICAgICAgeCArPSB3aWR0aDtcbiAgICAgICAgd2lkdGggPSAtd2lkdGg7XG4gICAgfVxuXG4gICAgaWYgKGhlaWdodCA8IDApIHtcbiAgICAgICAgeSArPSBoZWlnaHQ7XG4gICAgICAgIGhlaWdodCA9IC1oZWlnaHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgb3JpZ2luXG4gICAgICogQHR5cGUge1BvaW50fVxuICAgICAqIEBzdW1tYXJ5IFVwcGVyIGxlZnQgY29ybmVyIG9mIHRoaXMgcmVjdC5cbiAgICAgKiBAZGVzYyBDcmVhdGVkIHVwb24gaW5zdGFudGlhdGlvbiBieSB0aGUge0BsaW5rcGxhaW4gUmVjdGFuZ2xlfGNvbnN0cnVjdG9yfS5cbiAgICAgKiBAbWVtYmVyT2YgUmVjdGFuZ2xlLnByb3RvdHlwZVxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqL1xuICAgIGFkZFJlYWRPbmx5UHJvcGVydHkuY2FsbCh0aGlzLCAnb3JpZ2luJywgbmV3IFBvaW50KHgsIHkpKTtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIGV4dGVudFxuICAgICAqIEB0eXBlIHtQb2ludH1cbiAgICAgKiBAc3VtbWFyeSB0aGlzIHJlY3QncyB3aWR0aCBhbmQgaGVpZ2h0LlxuICAgICAqIEBkZXNjIFVubGlrZSB0aGUgb3RoZXIgYFBvaW50YCBwcm9wZXJ0aWVzLCBgZXh0ZW50YCBpcyBub3QgYSBnbG9iYWwgY29vcmRpbmF0ZSBwYWlyOyByYXRoZXIgaXQgY29uc2lzdHMgb2YgYSBfd2lkdGhfIChgeGAsIGFsd2F5cyBwb3NpdGl2ZSkgYW5kIGEgX2hlaWdodF8gKGB5YCwgYWx3YXlzIHBvc2l0aXZlKS5cbiAgICAgKlxuICAgICAqIFRoaXMgb2JqZWN0IG1pZ2h0IGJlIG1vcmUgbGVnaXRpbWF0ZWx5IHR5cGVkIGFzIHNvbWV0aGluZyBsaWtlIGBBcmVhYCB3aXRoIHByb3BlcnRpZXMgYHdpZHRoYCBhbmQgYGhlaWdodGA7IGhvd2V2ZXIgd2Ugd2FudGVkIGl0IHRvIGJlIGFibGUgdG8gdXNlIGl0IGVmZmljaWVudGx5IHdpdGggYSBwb2ludCdzIGBwbHVzYCBhbmQgYG1pbnVzYCBtZXRob2RzICh0aGF0IGlzLCB3aXRob3V0IHRob3NlIG1ldGhvZHMgaGF2aW5nIHRvIGNoZWNrIGFuZCBicmFuY2ggb24gdGhlIHR5cGUgb2YgaXRzIHBhcmFtZXRlcikuXG4gICAgICpcbiAgICAgKiBDcmVhdGVkIHVwb24gaW5zdGFudGlhdGlvbiBieSB0aGUge0BsaW5rcGxhaW4gUmVjdGFuZ2xlfGNvbnN0cnVjdG9yfS5cbiAgICAgKiBAc2VlIFRoZSB7QGxpbmsgUmVjdGFuZ2xlI2Nvcm5lcnxjb3JuZXJ9IG1ldGhvZC5cbiAgICAgKiBAbWVtYmVyT2YgUmVjdGFuZ2xlLnByb3RvdHlwZVxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqL1xuICAgIGFkZFJlYWRPbmx5UHJvcGVydHkuY2FsbCh0aGlzLCAnZXh0ZW50JywgbmV3IFBvaW50KHdpZHRoLCBoZWlnaHQpKTtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIGNvcm5lclxuICAgICAqIEB0eXBlIHtQb2ludH1cbiAgICAgKiBAc3VtbWFyeSBMb3dlciByaWdodCBjb3JuZXIgb2YgdGhpcyByZWN0LlxuICAgICAqIEBkZXNjIFRoaXMgaXMgYSBjYWxjdWxhdGVkIHZhbHVlIGNyZWF0ZWQgdXBvbiBpbnN0YW50aWF0aW9uIGJ5IHRoZSB7QGxpbmtwbGFpbiBSZWN0YW5nbGV8Y29uc3RydWN0b3J9LiBJdCBpcyBgb3JpZ2luYCBvZmZzZXQgYnkgYGV4dGVudGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhlc2UgY29vcmRpbmF0ZXMgYWN0dWFsbHkgcG9pbnQgdG8gdGhlIHBpeGVsIG9uZSBiZWxvdyBhbmQgb25lIHRvIHRoZSByaWdodCBvZiB0aGUgcmVjdCdzIGFjdHVhbCBsb3dlciByaWdodCBwaXhlbC5cbiAgICAgKiBAbWVtYmVyT2YgUmVjdGFuZ2xlLnByb3RvdHlwZVxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqL1xuICAgIGFkZFJlYWRPbmx5UHJvcGVydHkuY2FsbCh0aGlzLCAnY29ybmVyJywgbmV3IFBvaW50KHggKyB3aWR0aCwgeSArIGhlaWdodCkpO1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgY2VudGVyXG4gICAgICogQHR5cGUge1BvaW50fVxuICAgICAqIEBzdW1tYXJ5IENlbnRlciBvZiB0aGlzIHJlY3QuXG4gICAgICogQGRlc2MgQ3JlYXRlZCB1cG9uIGluc3RhbnRpYXRpb24gYnkgdGhlIHtAbGlua3BsYWluIFJlY3RhbmdsZXxjb25zdHJ1Y3Rvcn0uXG4gICAgICogQG1lbWJlck9mIFJlY3RhbmdsZS5wcm90b3R5cGVcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKi9cbiAgICBhZGRSZWFkT25seVByb3BlcnR5LmNhbGwodGhpcywgJ2NlbnRlcicsIG5ldyBQb2ludCh4ICsgKHdpZHRoIC8gMiksIHkgKyAoaGVpZ2h0IC8gMikpKTtcblxufVxuXG5SZWN0YW5nbGUucHJvdG90eXBlID0ge1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAZGVzYyBfKEZvcm1lcmx5IGEgZnVuY3Rpb247IG5vdyBhIGdldHRlci4pX1xuICAgICAqIEBzdW1tYXJ5IE1pbmltdW0gdmVydGljYWwgY29vcmRpbmF0ZSBvZiB0aGlzIHJlY3QuXG4gICAgICogQG1lbWJlck9mIFJlY3RhbmdsZS5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBnZXQgdG9wKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcmlnaW4ueTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAZGVzYyBfKEZvcm1lcmx5IGEgZnVuY3Rpb247IG5vdyBhIGdldHRlci4pX1xuICAgICAqIEBzdW1tYXJ5IE1pbmltdW0gaG9yaXpvbnRhbCBjb29yZGluYXRlIG9mIHRoaXMgcmVjdC5cbiAgICAgKiBAbWVtYmVyT2YgUmVjdGFuZ2xlLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGdldCBsZWZ0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcmlnaW4ueDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAZGVzYyBfKEZvcm1lcmx5IGEgZnVuY3Rpb247IG5vdyBhIGdldHRlci4pX1xuICAgICAqIEBzdW1tYXJ5IE1heGltdW0gdmVydGljYWwgY29vcmRpbmF0ZSBvZiB0aGlzIHJlY3QgKyAxLlxuICAgICAqIEBtZW1iZXJPZiBSZWN0YW5nbGUucHJvdG90eXBlXG4gICAgICovXG4gICAgZ2V0IGJvdHRvbSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29ybmVyLnk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGRlc2MgXyhGb3JtZXJseSBhIGZ1bmN0aW9uOyBub3cgYSBnZXR0ZXIuKV9cbiAgICAgKiBAc3VtbWFyeSBNYXhpbXVtIGhvcml6b250YWwgY29vcmRpbmF0ZSBvZiB0aGlzIHJlY3QgKyAxLlxuICAgICAqIEBtZW1iZXJPZiBSZWN0YW5nbGUucHJvdG90eXBlXG4gICAgICovXG4gICAgZ2V0IHJpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb3JuZXIueDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAZGVzYyBfKEZvcm1lcmx5IGEgZnVuY3Rpb247IG5vdyBhIGdldHRlci4pX1xuICAgICAqIEBzdW1tYXJ5IFdpZHRoIG9mIHRoaXMgcmVjdCAoYWx3YXlzIHBvc2l0aXZlKS5cbiAgICAgKiBAbWVtYmVyT2YgUmVjdGFuZ2xlLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGdldCB3aWR0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXh0ZW50Lng7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGRlc2MgXyhGb3JtZXJseSBhIGZ1bmN0aW9uOyBub3cgYSBnZXR0ZXIuKV9cbiAgICAgKiBAc3VtbWFyeSBIZWlnaHQgb2YgdGhpcyByZWN0IChhbHdheXMgcG9zaXRpdmUpLlxuICAgICAqIEBtZW1iZXJPZiBSZWN0YW5nbGUucHJvdG90eXBlXG4gICAgICovXG4gICAgZ2V0IGhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXh0ZW50Lnk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGRlc2MgXyhGb3JtZXJseSBhIGZ1bmN0aW9uOyBub3cgYSBnZXR0ZXIuKV9cbiAgICAgKiBAc3VtbWFyeSBBcmVhIG9mIHRoaXMgcmVjdC5cbiAgICAgKiBAbWVtYmVyT2YgUmVjdGFuZ2xlLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGdldCBhcmVhKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53aWR0aCAqIHRoaXMuaGVpZ2h0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7UmVjdGFuZ2xlfSBBIGNvcHkgb2YgdGhpcyByZWN0IGJ1dCB3aXRoIGhvcml6b250YWwgcG9zaXRpb24gcmVzZXQgdG8gZ2l2ZW4gYHhgIGFuZCBubyB3aWR0aC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCAtIEhvcml6b250YWwgY29vcmRpbmF0ZSBvZiB0aGUgbmV3IHJlY3QuXG4gICAgICogQG1lbWJlck9mIFJlY3RhbmdsZS5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBmbGF0dGVuWEF0OiBmdW5jdGlvbih4KSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVjdGFuZ2xlKHgsIHRoaXMub3JpZ2luLnksIDAsIHRoaXMuZXh0ZW50LnkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7UmVjdGFuZ2xlfSBBIGNvcHkgb2YgdGhpcyByZWN0IGJ1dCB3aXRoIHZlcnRpY2FsIHBvc2l0aW9uIHJlc2V0IHRvIGdpdmVuIGB5YCBhbmQgbm8gaGVpZ2h0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gVmVydGljYWwgY29vcmRpbmF0ZSBvZiB0aGUgbmV3IHJlY3QuXG4gICAgICogQG1lbWJlck9mIFJlY3RhbmdsZS5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBmbGF0dGVuWUF0OiBmdW5jdGlvbih5KSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVjdGFuZ2xlKHRoaXMub3JpZ2luLngsIHksIHRoaXMuZXh0ZW50LngsIDApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmZiBnaXZlbiBgcG9pbnRgIGVudGlyZWx5IGNvbnRhaW5lZCB3aXRoaW4gdGhpcyByZWN0LlxuICAgICAqIEBwYXJhbSB7UG9pbnR9IHBvaW50T3JSZWN0IC0gVGhlIHBvaW50IG9yIHJlY3QgdG8gdGVzdCBmb3IgY29udGFpbm1lbnQuXG4gICAgICogQG1lbWJlck9mIFJlY3RhbmdsZS5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBjb250YWluczogZnVuY3Rpb24ocG9pbnRPclJlY3QpIHtcbiAgICAgICAgcmV0dXJuIHBvaW50T3JSZWN0LndpdGhpbih0aGlzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogXyhGb3JtZXJseSBgaXNDb250YWluZWRXaXRoaW5SZWN0YW5nbGVgLilfXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZmYgYHRoaXNgIHJlY3QgaXMgZW50aXJlbHkgY29udGFpbmVkIHdpdGhpbiBnaXZlbiBgcmVjdGAuXG4gICAgICogQHBhcmFtIHtSZWN0YW5nbGV9IHJlY3QgLSBSZWN0YW5nbGUgdG8gdGVzdCBhZ2FpbnN0IHRoaXMgcmVjdC5cbiAgICAgKiBAbWVtYmVyT2YgUmVjdGFuZ2xlLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHdpdGhpbjogZnVuY3Rpb24ocmVjdCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgcmVjdC5vcmlnaW4ubGVzc1RoYW5PckVxdWFsVG8odGhpcy5vcmlnaW4pICYmXG4gICAgICAgICAgICByZWN0LmNvcm5lci5ncmVhdGVyVGhhbk9yRXF1YWxUbyh0aGlzLmNvcm5lcilcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogXyhGb3JtZXJseTogYGluc2V0QnlgLilfXG4gICAgICogQHJldHVybnMge1JlY3RhbmdsZX0gVGhhdCBpcyBlbmxhcmdlZC9zaHJ1bmsgYnkgZ2l2ZW4gYHBhZGRpbmdgLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwYWRkaW5nIC0gQW1vdW50IGJ5IHdoaWNoIHRvIGluY3JlYXNlICgrKSBvciBkZWNyZWFzZSAoLSkgdGhpcyByZWN0XG4gICAgICogQHNlZSBUaGUge0BsaW5rIFJlY3RhbmdsZSNzaHJpbmtCeXxzaHJpbmtCeX0gbWV0aG9kLlxuICAgICAqIEBtZW1iZXJPZiBSZWN0YW5nbGUucHJvdG90eXBlXG4gICAgICovXG4gICAgZ3Jvd0J5OiBmdW5jdGlvbihwYWRkaW5nKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVjdGFuZ2xlKFxuICAgICAgICAgICAgdGhpcy5vcmlnaW4ueCArIHBhZGRpbmcsXG4gICAgICAgICAgICB0aGlzLm9yaWdpbi55ICsgcGFkZGluZyxcbiAgICAgICAgICAgIHRoaXMuZXh0ZW50LnggLSBwYWRkaW5nIC0gcGFkZGluZyxcbiAgICAgICAgICAgIHRoaXMuZXh0ZW50LnkgLSBwYWRkaW5nIC0gcGFkZGluZyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtSZWN0YW5nbGV9IFRoYXQgaXMgZW5sYXJnZWQvc2hydW5rIGJ5IGdpdmVuIGBwYWRkaW5nYC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFkZGluZyAtIEFtb3VudCBieSB3aGljaCB0byBkZWNyZWFzZSAoKykgb3IgaW5jcmVhc2UgKC0pIHRoaXMgcmVjdC5cbiAgICAgKiBAc2VlIFRoZSB7QGxpbmsgUmVjdGFuZ2xlI2dyb3dCeXxncm93Qnl9IG1ldGhvZC5cbiAgICAgKiBAbWVtYmVyT2YgUmVjdGFuZ2xlLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHNocmlua0J5OiBmdW5jdGlvbihwYWRkaW5nKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyb3dCeSgtcGFkZGluZyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtSZWN0YW5nbGV9IEJvdW5kaW5nIHJlY3QgdGhhdCBjb250YWlucyBib3RoIHRoaXMgcmVjdCBhbmQgdGhlIGdpdmVuIGByZWN0YC5cbiAgICAgKiBAcGFyYW0ge1JlY3RhbmdsZX0gcmVjdCAtIFRoZSByZWN0YW5nbGUgdG8gdW5pb24gd2l0aCB0aGlzIHJlY3QuXG4gICAgICogQG1lbWJlck9mIFJlY3RhbmdsZS5wcm90b3R5cGVcbiAgICAgKi9cbiAgICB1bmlvbjogZnVuY3Rpb24ocmVjdCkge1xuICAgICAgICB2YXIgb3JpZ2luID0gdGhpcy5vcmlnaW4ubWluKHJlY3Qub3JpZ2luKSxcbiAgICAgICAgICAgIGNvcm5lciA9IHRoaXMuY29ybmVyLm1heChyZWN0LmNvcm5lciksXG4gICAgICAgICAgICBleHRlbnQgPSBjb3JuZXIubWludXMob3JpZ2luKTtcblxuICAgICAgICByZXR1cm4gbmV3IFJlY3RhbmdsZShcbiAgICAgICAgICAgIG9yaWdpbi54LCBvcmlnaW4ueSxcbiAgICAgICAgICAgIGV4dGVudC54LCBleHRlbnQueVxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBpdGVyYXRlIG92ZXIgYWxsIHBvaW50cyB3aXRoaW4gdGhpcyByZWN0LCBpbnZva2luZyBgaXRlcmF0ZWVgIGZvciBlYWNoLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24obnVtYmVyLG51bWJlcil9IGl0ZXJhdGVlIC0gRnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCBwb2ludC5cbiAgICAgKiBCb3VuZCB0byBgY29udGV4dGAgd2hlbiBnaXZlbjsgb3RoZXJ3aXNlIGl0IGlzIGJvdW5kIHRvIHRoaXMgcmVjdC5cbiAgICAgKiBFYWNoIGludm9jYXRpb24gb2YgYGl0ZXJhdGVlYCBpcyBjYWxsZWQgd2l0aCB0d28gYXJndW1lbnRzOlxuICAgICAqIHRoZSBob3Jpem9udGFsIGFuZCB2ZXJ0aWNhbCBjb29yZGluYXRlcyBvZiB0aGUgcG9pbnQuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtjb250ZXh0PXRoaXNdIC0gQ29udGV4dCB0byBiaW5kIHRvIGBpdGVyYXRlZWAgKHdoZW4gbm90IGB0aGlzYCkuXG4gICAgICogQG1lbWJlck9mIFJlY3RhbmdsZS5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBmb3JFYWNoOiBmdW5jdGlvbihpdGVyYXRlZSwgY29udGV4dCkge1xuICAgICAgICBjb250ZXh0ID0gY29udGV4dCB8fCB0aGlzO1xuICAgICAgICBmb3IgKHZhciB4ID0gdGhpcy5vcmlnaW4ueCwgeDIgPSB0aGlzLmNvcm5lci54OyB4IDwgeDI7IHgrKykge1xuICAgICAgICAgICAgZm9yICh2YXIgeSA9IHRoaXMub3JpZ2luLnksIHkyID0gdGhpcy5jb3JuZXIueTsgeSA8IHkyOyB5KyspIHtcbiAgICAgICAgICAgICAgICBpdGVyYXRlZS5jYWxsKGNvbnRleHQsIHgsIHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtSZWN0YW5nbGV9IE9uZSBvZjpcbiAgICAgKiAqIF9JZiB0aGlzIHJlY3QgaW50ZXJzZWN0cyB3aXRoIHRoZSBnaXZlbiBgcmVjdGA6X1xuICAgICAqICAgICAgYSBuZXcgcmVjdCByZXByZXNlbnRpbmcgdGhhdCBpbnRlcnNlY3Rpb24uXG4gICAgICogKiBfSWYgaXQgZG9lc24ndCBpbnRlcnNlY3QgYW5kIGBpZk5vbmVBY3Rpb25gIGRlZmluZWQ6X1xuICAgICAqICAgICAgcmVzdWx0IG9mIGNhbGxpbmcgYGlmTm9uZUFjdGlvbmAuXG4gICAgICogKiBfSWYgaXQgZG9lc24ndCBpbnRlcnNlY3QgYW5kIGBpZk5vbmVBY3Rpb25gIHVuZGVmaW5lZDpfXG4gICAgICogICAgICBgbnVsbGAuXG4gICAgICogQHBhcmFtIHtSZWN0YW5nbGV9IHJlY3QgLSBUaGUgcmVjdGFuZ2xlIHRvIGludGVyc2VjdCB3aXRoIHRoaXMgcmVjdC5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKFJlY3RhbmdsZSl9IFtpZk5vbmVBY3Rpb25dIC0gV2hlbiBubyBpbnRlcnNlY3Rpb24sIGludm9rZSBhbmQgcmV0dXJuIHJlc3VsdC5cbiAgICAgKiBCb3VuZCB0byBgY29udGV4dGAgd2hlbiBnaXZlbjsgb3RoZXJ3aXNlIGJvdW5kIHRvIHRoaXMgcmVjdC5cbiAgICAgKiBJbnZva2VkIHdpdGggYHJlY3RgIGFzIHNvbGUgcGFyYW1ldGVyLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbY29udGV4dD10aGlzXSAtIENvbnRleHQgdG8gYmluZCB0byBgaWZOb25lQWN0aW9uYCAod2hlbiBub3QgYHRoaXNgKS5cbiAgICAgKiBAbWVtYmVyT2YgUmVjdGFuZ2xlLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGludGVyc2VjdDogZnVuY3Rpb24ocmVjdCwgaWZOb25lQWN0aW9uLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBudWxsLFxuICAgICAgICAgICAgb3JpZ2luID0gdGhpcy5vcmlnaW4ubWF4KHJlY3Qub3JpZ2luKSxcbiAgICAgICAgICAgIGNvcm5lciA9IHRoaXMuY29ybmVyLm1pbihyZWN0LmNvcm5lciksXG4gICAgICAgICAgICBleHRlbnQgPSBjb3JuZXIubWludXMob3JpZ2luKTtcblxuICAgICAgICBpZiAoZXh0ZW50LnggPiAwICYmIGV4dGVudC55ID4gMCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gbmV3IFJlY3RhbmdsZShcbiAgICAgICAgICAgICAgICBvcmlnaW4ueCwgb3JpZ2luLnksXG4gICAgICAgICAgICAgICAgZXh0ZW50LngsIGV4dGVudC55XG4gICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpZk5vbmVBY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGlmTm9uZUFjdGlvbi5jYWxsKGNvbnRleHQgfHwgdGhpcywgcmVjdCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmZiB0aGlzIHJlY3Qgb3ZlcmxhcHMgd2l0aCBnaXZlbiBgcmVjdGAuXG4gICAgICogQHBhcmFtIHtSZWN0YW5nbGV9IHJlY3QgLSBUaGUgcmVjdGFuZ2xlIHRvIGludGVyc2VjdCB3aXRoIHRoaXMgcmVjdC5cbiAgICAgKiBAbWVtYmVyT2YgUmVjdGFuZ2xlLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGludGVyc2VjdHM6IGZ1bmN0aW9uKHJlY3QpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHJlY3QuY29ybmVyLnggPiB0aGlzLm9yaWdpbi54ICYmXG4gICAgICAgICAgICByZWN0LmNvcm5lci55ID4gdGhpcy5vcmlnaW4ueSAmJlxuICAgICAgICAgICAgcmVjdC5vcmlnaW4ueCA8IHRoaXMuY29ybmVyLnggJiZcbiAgICAgICAgICAgIHJlY3Qub3JpZ2luLnkgPCB0aGlzLmNvcm5lci55XG4gICAgICAgICk7XG4gICAgfVxufTtcblxuLy8gSW50ZXJmYWNlXG5leHBvcnRzLlBvaW50ID0gUG9pbnQ7XG5leHBvcnRzLlJlY3RhbmdsZSA9IFJlY3RhbmdsZTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIC8vIGEgcmVnZXggc2VhcmNoIHBhdHRlcm4gdGhhdCBtYXRjaGVzIGFsbCB0aGUgcmVzZXJ2ZWQgY2hhcnMgb2YgYSByZWdleCBzZWFyY2ggcGF0dGVyblxuICAgIHJlc2VydmVkID0gLyhbXFwuXFxcXFxcK1xcKlxcP1xcXlxcJFxcKFxcKVxce1xcfVxcPVxcIVxcPFxcPlxcfFxcOlxcW1xcXV0pL2csXG5cbiAgICAvLyByZWdleCB3aWxkY2FyZCBzZWFyY2ggcGF0dGVybnNcbiAgICBSRUdFWFBfV0lMRENBUkQgPSAnLionLFxuICAgIFJFR0VYUF9XSUxEQ0hBUiA9ICcuJyxcbiAgICBSRUdFWFBfV0lMRENBUkRfTUFUQ0hFUiA9ICcoJyArIFJFR0VYUF9XSUxEQ0FSRCArICcpJyxcblxuICAgIC8vIExJS0Ugc2VhcmNoIHBhdHRlcm5zXG4gICAgTElLRV9XSUxEQ0hBUiA9ICdfJyxcbiAgICBMSUtFX1dJTERDQVJEID0gJyUnLFxuXG4gICAgLy8gcmVnZXggc2VhcmNoIHBhdHRlcm5zIHRoYXQgbWF0Y2ggTElLRSBzZWFyY2ggcGF0dGVybnNcbiAgICBSRUdFWFBfTElLRV9QQVRURVJOX01BVENIRVIgPSBuZXcgUmVnRXhwKCcoJyArIFtcbiAgICAgICAgTElLRV9XSUxEQ0hBUixcbiAgICAgICAgTElLRV9XSUxEQ0FSRCxcbiAgICAgICAgJ1xcXFxbXFxcXF4/W14tXFxcXF1dK10nLCAvLyBtYXRjaGVzIGEgTElLRSBzZXQgKHNhbWUgc3ludGF4IGFzIGEgUmVnRXhwIHNldClcbiAgICAgICAgJ1xcXFxbXFxcXF4/W14tXFxcXF1dXFxcXC1bXlxcXFxdXV0nIC8vIG1hdGNoZXMgYSBMSUtFIHJhbmdlIChzYW1lIHN5bnRheCBhcyBhIFJlZ0V4cCByYW5nZSlcbiAgICBdLmpvaW4oJ3wnKSArICcpJywgJ2cnKTtcblxuZnVuY3Rpb24gcmVnRXhwTElLRShwYXR0ZXJuLCBpZ25vcmVDYXNlKSB7XG4gICAgdmFyIGksIHBhcnRzO1xuXG4gICAgLy8gRmluZCBhbGwgTElLRSBwYXR0ZXJuc1xuICAgIHBhcnRzID0gcGF0dGVybi5tYXRjaChSRUdFWFBfTElLRV9QQVRURVJOX01BVENIRVIpO1xuXG4gICAgaWYgKHBhcnRzKSB7XG4gICAgICAgIC8vIFRyYW5zbGF0ZSBmb3VuZCBMSUtFIHBhdHRlcm5zIHRvIHJlZ2V4IHBhdHRlcm5zLCBlc2NhcGVkIGludGVydmVuaW5nIG5vbi1wYXR0ZXJucywgYW5kIGludGVybGVhdmUgdGhlIHR3b1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgLy8gRXNjYXBlIGxlZnQgYnJhY2tldHMgKHVucGFpcmVkIHJpZ2h0IGJyYWNrZXRzIGFyZSBPSylcbiAgICAgICAgICAgIGlmIChwYXJ0c1tpXVswXSA9PT0gJ1snKSB7XG4gICAgICAgICAgICAgICAgcGFydHNbaV0gPSByZWdFeHBMSUtFLnJlc2VydmUocGFydHNbaV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBNYWtlIGVhY2ggZm91bmQgcGF0dGVybiBtYXRjaGFibGUgYnkgZW5jbG9zaW5nIGluIHBhcmVudGhlc2VzXG4gICAgICAgICAgICBwYXJ0c1tpXSA9ICcoJyArIHBhcnRzW2ldICsgJyknO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTWF0Y2ggdGhlc2UgcHJlY2lzZSBwYXR0ZXJucyBhZ2FpbiB3aXRoIHRoZWlyIGludGVydmVuaW5nIG5vbi1wYXR0ZXJucyAoaS5lLiwgdGV4dClcbiAgICAgICAgcGFydHMgPSBwYXR0ZXJuLm1hdGNoKG5ldyBSZWdFeHAoXG4gICAgICAgICAgICBSRUdFWFBfV0lMRENBUkRfTUFUQ0hFUiArXG4gICAgICAgICAgICBwYXJ0cy5qb2luKFJFR0VYUF9XSUxEQ0FSRF9NQVRDSEVSKSAgK1xuICAgICAgICAgICAgUkVHRVhQX1dJTERDQVJEX01BVENIRVJcbiAgICAgICAgKSk7XG5cbiAgICAgICAgLy8gRGlzY2FyZCBmaXJzdCBtYXRjaCBvZiBub24tZ2xvYmFsIHNlYXJjaCAod2hpY2ggaXMgdGhlIHdob2xlIHN0cmluZylcbiAgICAgICAgcGFydHMuc2hpZnQoKTtcblxuICAgICAgICAvLyBGb3IgZWFjaCByZS1mb3VuZCBwYXR0ZXJuIHBhcnQsIHRyYW5zbGF0ZSAlIGFuZCBfIHRvIHJlZ2V4IGVxdWl2YWxlbnRcbiAgICAgICAgZm9yIChpID0gMTsgaSA8IHBhcnRzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICB2YXIgcGFydCA9IHBhcnRzW2ldO1xuICAgICAgICAgICAgc3dpdGNoIChwYXJ0KSB7XG4gICAgICAgICAgICAgICAgY2FzZSBMSUtFX1dJTERDQVJEOiBwYXJ0ID0gUkVHRVhQX1dJTERDQVJEOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIExJS0VfV0lMRENIQVI6IHBhcnQgPSBSRUdFWFBfV0lMRENIQVI7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHZhciBqID0gcGFydFsxXSA9PT0gJ14nID8gMiA6IDE7XG4gICAgICAgICAgICAgICAgICAgIHBhcnQgPSAnWycgKyByZWdFeHBMSUtFLnJlc2VydmUocGFydC5zdWJzdHIoaiwgcGFydC5sZW5ndGggLSAoaiArIDEpKSkgKyAnXSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJ0c1tpXSA9IHBhcnQ7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBwYXJ0cyA9IFtwYXR0ZXJuXTtcbiAgICB9XG5cbiAgICAvLyBGb3IgZWFjaCBzdXJyb3VuZGluZyB0ZXh0IHBhcnQsIGVzY2FwZSByZXNlcnZlZCByZWdleCBjaGFyc1xuICAgIGZvciAoaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICBwYXJ0c1tpXSA9IHJlZ0V4cExJS0UucmVzZXJ2ZShwYXJ0c1tpXSk7XG4gICAgfVxuXG4gICAgLy8gSm9pbiBhbGwgdGhlIGludGVybGVhdmVkIHBhcnRzXG4gICAgcGFydHMgPSBwYXJ0cy5qb2luKCcnKTtcblxuICAgIC8vIE9wdGltaXplIG9yIGFuY2hvciB0aGUgcGF0dGVybiBhdCBlYWNoIGVuZCBhcyBuZWVkZWRcbiAgICBpZiAocGFydHMuc3Vic3RyKDAsIDIpID09PSBSRUdFWFBfV0lMRENBUkQpIHsgcGFydHMgPSBwYXJ0cy5zdWJzdHIoMik7IH0gZWxzZSB7IHBhcnRzID0gJ14nICsgcGFydHM7IH1cbiAgICBpZiAocGFydHMuc3Vic3RyKC0yLCAyKSA9PT0gUkVHRVhQX1dJTERDQVJEKSB7IHBhcnRzID0gcGFydHMuc3Vic3RyKDAsIHBhcnRzLmxlbmd0aCAtIDIpOyB9IGVsc2UgeyBwYXJ0cyArPSAnJCc7IH1cblxuICAgIC8vIFJldHVybiB0aGUgbmV3IHJlZ2V4XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAocGFydHMsIGlnbm9yZUNhc2UgPyAnaScgOiB1bmRlZmluZWQpO1xufVxuXG5yZWdFeHBMSUtFLnJlc2VydmUgPSBmdW5jdGlvbiAocykge1xuICAgIHJldHVybiBzLnJlcGxhY2UocmVzZXJ2ZWQsICdcXFxcJDEnKTtcbn07XG5cbnZhciBjYWNoZSwgc2l6ZTtcblxuLyoqXG4gKiBAc3VtbWFyeSBEZWxldGUgYSBwYXR0ZXJuIGZyb20gdGhlIGNhY2hlOyBvciBjbGVhciB0aGUgd2hvbGUgY2FjaGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gW3BhdHRlcm5dIC0gVGhlIExJS0UgcGF0dGVybiB0byByZW1vdmUgZnJvbSB0aGUgY2FjaGUuIEZhaWxzIHNpbGVudGx5IGlmIG5vdCBmb3VuZCBpbiB0aGUgY2FjaGUuIElmIHBhdHRlcm4gb21pdHRlZCwgY2xlYXJzIHdob2xlIGNhY2hlLlxuICovXG4ocmVnRXhwTElLRS5jbGVhckNhY2hlID0gZnVuY3Rpb24gKHBhdHRlcm4pIHtcbiAgICBpZiAoIXBhdHRlcm4pIHtcbiAgICAgICAgY2FjaGUgPSB7fTtcbiAgICAgICAgc2l6ZSA9IDA7XG4gICAgfSBlbHNlIGlmIChjYWNoZVtwYXR0ZXJuXSkge1xuICAgICAgICBkZWxldGUgY2FjaGVbcGF0dGVybl07XG4gICAgICAgIHNpemUtLTtcbiAgICB9XG4gICAgcmV0dXJuIHNpemU7XG59KSgpOyAvLyBpbml0IHRoZSBjYWNoZVxuXG5yZWdFeHBMSUtFLmdldENhY2hlU2l6ZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNpemU7IH07XG5cbi8qKlxuICogQHN1bW1hcnkgQ2FjaGVkIHZlcnNpb24gb2YgYHJlZ0V4cExJS0UoKWAuXG4gKiBAZGVzYyBDYWNoZWQgZW50cmllcyBhcmUgc3ViamVjdCB0byBnYXJiYWdlIGNvbGxlY3Rpb24gaWYgYGtlZXBgIGlzIGB1bmRlZmluZWRgIG9yIGBmYWxzZWAgb24gaW5zZXJ0aW9uIG9yIGBmYWxzZWAgb24gbW9zdCByZWNlbnQgcmVmZXJlbmNlLiBHYXJiYWdlIGNvbGxlY3Rpb24gd2lsbCBvY2N1ciBpZmYgYHJlZ0V4cExJS0UuY2FjaGVNYXhgIGlzIGRlZmluZWQgYW5kIGl0IGVxdWFscyB0aGUgbnVtYmVyIG9mIGNhY2hlZCBwYXR0ZXJucy4gVGhlIGdhcmJhZ2UgY29sbGVjdG9yIHNvcnRzIHRoZSBwYXR0ZXJucyBiYXNlZCBvbiBtb3N0IHJlY2VudCByZWZlcmVuY2U7IHRoZSBvbGRlc3QgMTAlIG9mIHRoZSBlbnRyaWVzIGFyZSBkZWxldGVkLiBBbHRlcm5hdGl2ZWx5LCB5b3UgY2FuIG1hbmFnZSB0aGUgY2FjaGUgeW91cnNlbGYgdG8gYSBsaW1pdGVkIGV4dGVudCAoc2VlIHtAbGluayByZWdlRXhwTElLRS5jbGVhckNhY2hlfGNsZWFyQ2FjaGV9KS5cbiAqIEBwYXJhbSBwYXR0ZXJuIC0gdGhlIExJS0UgcGF0dGVybiAodG8gYmUpIGNvbnZlcnRlZCB0byBhIFJlZ0V4cFxuICogQHBhcmFtIFtrZWVwXSAtIElmIGdpdmVuLCBjaGFuZ2VzIHRoZSBrZWVwIHN0YXR1cyBmb3IgdGhpcyBwYXR0ZXJuIGFzIGZvbGxvd3M6XG4gKiAqIGB0cnVlYCBwZXJtYW5lbnRseSBjYWNoZXMgdGhlIHBhdHRlcm4gKG5vdCBzdWJqZWN0IHRvIGdhcmJhZ2UgY29sbGVjdGlvbikgdW50aWwgYGZhbHNlYCBpcyBnaXZlbiBvbiBhIHN1YnNlcXVlbnQgY2FsbFxuICogKiBgZmFsc2VgIGFsbG93cyBnYXJiYWdlIGNvbGxlY3Rpb24gb24gdGhlIGNhY2hlZCBwYXR0ZXJuXG4gKiAqIGB1bmRlZmluZWRgIG5vIGNoYW5nZSB0byBrZWVwIHN0YXR1c1xuICogQHJldHVybnMge1JlZ0V4cH1cbiAqL1xucmVnRXhwTElLRS5jYWNoZWQgPSBmdW5jdGlvbiAoa2VlcCwgcGF0dGVybiwgaWdub3JlQ2FzZSkge1xuICAgIGlmICh0eXBlb2Yga2VlcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWdub3JlQ2FzZSA9IHBhdHRlcm47XG4gICAgICAgIHBhdHRlcm4gPSBrZWVwO1xuICAgICAgICBrZWVwID0gZmFsc2U7XG4gICAgfVxuICAgIHZhciBwYXR0ZXJuQW5kQ2FzZSA9IHBhdHRlcm4gKyAoaWdub3JlQ2FzZSA/ICdpJyA6ICdjJyksXG4gICAgICAgIGl0ZW0gPSBjYWNoZVtwYXR0ZXJuQW5kQ2FzZV07XG4gICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgaXRlbS53aGVuID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgIGlmIChrZWVwICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGl0ZW0ua2VlcCA9IGtlZXA7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoc2l6ZSA9PT0gcmVnRXhwTElLRS5jYWNoZU1heCkge1xuICAgICAgICAgICAgdmFyIGFnZSA9IFtdLCBhZ2VzID0gMCwga2V5LCBpO1xuICAgICAgICAgICAgZm9yIChrZXkgaW4gY2FjaGUpIHtcbiAgICAgICAgICAgICAgICBpdGVtID0gY2FjaGVba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoIWl0ZW0ua2VlcCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYWdlczsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS53aGVuIDwgYWdlW2ldLml0ZW0ud2hlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGFnZS5zcGxpY2UoaSwgMCwgeyBrZXk6IGtleSwgaXRlbTogaXRlbSB9KTtcbiAgICAgICAgICAgICAgICAgICAgYWdlcysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghYWdlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWdFeHBMSUtFKHBhdHRlcm4sIGlnbm9yZUNhc2UpOyAvLyBjYWNoZSBpcyBmdWxsIVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSA9IE1hdGguY2VpbChhZ2UubGVuZ3RoIC8gMTApOyAvLyB3aWxsIGFsd2F5cyBiZSBhdCBsZWFzdCAxXG4gICAgICAgICAgICBzaXplIC09IGk7XG4gICAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGNhY2hlW2FnZVtpXS5rZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGl0ZW0gPSBjYWNoZVtwYXR0ZXJuQW5kQ2FzZV0gPSB7XG4gICAgICAgICAgICByZWdleDogcmVnRXhwTElLRShwYXR0ZXJuLCBpZ25vcmVDYXNlKSxcbiAgICAgICAgICAgIGtlZXA6IGtlZXAsXG4gICAgICAgICAgICB3aGVuOiBuZXcgRGF0ZSgpLmdldFRpbWUoKVxuICAgICAgICB9O1xuICAgICAgICBzaXplKys7XG4gICAgfVxuICAgIHJldHVybiBpdGVtLnJlZ2V4O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSByZWdFeHBMSUtFO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKiBlc2xpbnQtZW52IG5vZGUsIGJyb3dzZXIgKi9cblxuKGZ1bmN0aW9uIChtb2R1bGUpIHsgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zXG5cbiAgICAvLyBUaGlzIGNsb3N1cmUgc3VwcG9ydHMgTm9kZUpTLWxlc3MgY2xpZW50IHNpZGUgaW5jbHVkZXMgd2l0aCA8c2NyaXB0PiB0YWdzLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2pvbmVpdC9tbm0uXG5cbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3IgUmFuZ2VTZWxlY3Rpb25Nb2RlbFxuICAgICAqXG4gICAgICogQGRlc2MgVGhpcyBvYmplY3QgbW9kZWxzIHNlbGVjdGlvbiBvZiBcImNlbGxzXCIgd2l0aGluIGFuIGFic3RyYWN0IHNpbmdsZS1kaW1lbnNpb25hbCBtYXRyaXguXG4gICAgICpcbiAgICAgKiBEaXNqb2ludCBzZWxlY3Rpb25zIGNhbiBiZSBidWlsdCB3aXRoIGNhbGxzIHRvIHRoZSBmb2xsb3dpbmcgbWV0aG9kczpcbiAgICAgKiAqIHtAbGluayBSYW5nZVNlbGVjdGlvbk1vZGVsI3NlbGVjdHxzZWxlY3Qoc3RhcnQsIHN0b3ApfSAtIEFkZCBhIHJhbmdlIHRvIHRoZSBtYXRyaXguXG4gICAgICogKiB7QGxpbmsgUmFuZ2VTZWxlY3Rpb25Nb2RlbCNkZXNlbGVjdHxkZXNlbGVjdChzdGFydCwgc3RvcCl9IC0gUmVtb3ZlIGEgcmFuZ2UgZnJvbSB0aGUgbWF0cml4LlxuICAgICAqXG4gICAgICogVHdvIG1vcmUgbWV0aG9kcyBhcmUgYXZhaWxhYmxlOlxuICAgICAqICogVGVzdCBhIGNlbGwgdG8gc2VlIGlmIGl0IHtAbGluayBSYW5nZVNlbGVjdGlvbk1vZGVsI2lzU2VsZWN0ZWR8aXNTZWxlY3RlZChjZWxsKX1cbiAgICAgKiAqIHtAbGluayBSYW5nZVNlbGVjdGlvbk1vZGVsI2NsZWFyfGNsZWFyKCl9IHRoZSBtYXRyaXhcbiAgICAgKlxuICAgICAqIEludGVybmFsbHksIHRoZSBzZWxlY3Rpb24gaXMgcnVuLWxlbmd0aC1lbmNvZGVkLiBJdCBpcyB0aGVyZWZvcmUgYSBcInNwYXJzZVwiIG1hdHJpeFxuICAgICAqIHdpdGggdW5kZWZpbmVkIGJvdW5kcy4gQSBzaW5nbGUgZGF0YSBwcm9wZXJ0eSBjYWxsZWQgYHNlbGVjdGlvbmAgaXMgYW4gYXJyYXkgdGhhdFxuICAgICAqIGNvbnRhaW5zIGFsbCB0aGUgXCJydW5zXCIgKHJhbmdlcykgb2Ygc2VsZWN0ZWQgY2VsbHMgYWxiZWl0IGluIG5vIHBhcnRpY3VsYXIgb3JkZXIuXG4gICAgICogVGhpcyBwcm9wZXJ0eSBzaG91bGQgbm90IG5vcm1hbGx5IG5lZWQgdG8gYmUgYWNjZXNzZWQgZGlyZWN0bHkuXG4gICAgICpcbiAgICAgKiBOb3RlOiBUaGlzIG9iamVjdCBzaG91bGQgYmUgaW5zdGFudGlhdGVkIHdpdGggdGhlIGBuZXdgIGtleXdvcmQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UmFuZ2VTZWxlY3Rpb25Nb2RlbH0gU2VsZiAoaS5lLiwgYHRoaXNgIG9iamVjdCkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gUmFuZ2VTZWxlY3Rpb25Nb2RlbCgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBuYW1lIHNlbGVjdGlvblxuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuQXJyYXkubnVtYmVyfVxuICAgICAgICAgKiBAc3VtbWFyeSBVbm9yZGVyZWQgbGlzdCBvZiBydW5zLlxuICAgICAgICAgKiBAZGVzYyBBIFwicnVuXCIgaXMgZGVmaW5lZCBhcyBhbiBBcnJheSgyKSB3aGVyZTpcbiAgICAgICAgICogKiBlbGVtZW50IFswXSBpcyB0aGUgYmVnaW5uaW5nIG9mIHRoZSBydW5cbiAgICAgICAgICogKiBlbGVtZW50IFsxXSBpcyB0aGUgZW5kIG9mIHRoZSBydW4gKGluY2x1c2l2ZSkgYW5kIGlzIGFsd2F5cyA+PSBlbGVtZW50IFswXVxuICAgICAgICAgKiBUaGUgb3JkZXIgb2YgdGhlIHJ1bnMgd2l0aGluIGlzIHVuZGVmaW5lZC5cbiAgICAgICAgICogQG1lbWJlck9mIFJhbmdlU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICAgICAqIEBhYnN0cmFjdFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZWxlY3Rpb24gPSBbXTtcblxuICAgICAgICAvL3dlIG5lZWQgdG8gYmUgYWJsZSB0byBnbyBiYWNrIGluIHRpbWVcbiAgICAgICAgLy90aGUgc3RhdGVzIGZpZWxkXG4gICAgICAgIHRoaXMuc3RhdGVzID0gW107XG5cbiAgICAgICAgLy9jbG9uZSBhbmQgc3RvcmUgbXkgY3VycmVudCBzdGF0ZVxuICAgICAgICAvL3NvIHdlIGNhbiB1bndpbmQgY2hhbmdlcyBpZiBuZWVkIGJlXG4gICAgICAgIHRoaXMuc3RvcmVTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzZWxzID0gdGhpcy5zZWxlY3Rpb247XG4gICAgICAgICAgICB2YXIgc3RhdGUgPSBbXTtcbiAgICAgICAgICAgIHZhciBjb3B5O1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29weSA9IFtdLmNvbmNhdChzZWxzW2ldKTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5wdXNoKGNvcHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zdGF0ZXMucHVzaChzdGF0ZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgUmFuZ2VTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBzdW1tYXJ5IEFkZCBhIGNvbnRpZ3VvdXMgcnVuIG9mIHBvaW50cyB0byB0aGUgc2VsZWN0aW9uLlxuICAgICAgICAgKiBAZGVzYyBJbnNlcnQgYSBuZXcgcnVuIGludG8gYHRoaXMuc2VsZWN0aW9uYC5cbiAgICAgICAgICogVGhlIG5ldyBydW4gd2lsbCBiZSBtZXJnZWQgd2l0aCBvdmVybGFwcGluZyBhbmQgYWRqYWNlbnQgcnVucy5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIHR3byBwYXJhbWV0ZXJzIG1heSBiZSBnaXZlbiBpbiBlaXRoZXIgb3JkZXIuXG4gICAgICAgICAqIFRoZSBzdGFydCBhbmQgc3RvcCBlbGVtZW50cyBpbiB0aGUgcmVzdWx0aW5nIHJ1biB3aWxsIGhvd2V2ZXIgYWx3YXlzIGJlIG9yZGVyZWQuXG4gICAgICAgICAqIChIb3dldmVyLCBub3RlIHRoYXQgdGhlIG9yZGVyIG9mIHRoZSBydW5zIHdpdGhpbiBgdGhpcy5zZWxlY3Rpb25gIGlzIGl0c2VsZiBhbHdheXMgdW5vcmRlcmVkLilcbiAgICAgICAgICpcbiAgICAgICAgICogTm90ZSB0aGF0IGB0aGlzLnNlbGVjdGlvbmAgaXMgdXBkYXRlZCBpbiBwbGFjZSwgcHJlc2VydmluZyB2YWxpZGl0eSBvZiBhbnkgZXh0ZXJuYWwgcmVmZXJlbmNlcy5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IC0gU3RhcnQgb2YgcnVuLiBNYXkgYmUgZ3JlYXRlciB0aGFuIGBzdG9wYC5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdG9wPXN0b3BdIC0gRW5kIG9mIHJ1biAoaW5jbHVzaXZlKS4gTWF5IGJlIGxlc3MgdGhhbiBgc3RhcnRgLlxuICAgICAgICAgKiBAcmV0dXJucyB7UmFuZ2VTZWxlY3Rpb25Nb2RlbH0gU2VsZiAoaS5lLiwgYHRoaXNgKSwgZm9yIGNoYWluaW5nLlxuICAgICAgICAgKiBAbWVtYmVyT2YgUmFuZ2VTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgICAgICovXG4gICAgICAgIHNlbGVjdDogZnVuY3Rpb24gKHN0YXJ0LCBzdG9wKSB7XG4gICAgICAgICAgICB0aGlzLnN0b3JlU3RhdGUoKTtcbiAgICAgICAgICAgIHZhciBydW4gPSBtYWtlUnVuKHN0YXJ0LCBzdG9wKTtcbiAgICAgICAgICAgIHZhciBzcGxpY2VyID0gWzAsIDFdO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24uZm9yRWFjaChmdW5jdGlvbiAoZWFjaCkge1xuICAgICAgICAgICAgICAgIGlmIChvdmVybGFwcyhlYWNoLCBydW4pIHx8IGFidXRzKGVhY2gsIHJ1bikpIHtcbiAgICAgICAgICAgICAgICAgICAgcnVuID0gbWVyZ2UoZWFjaCwgcnVuKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzcGxpY2VyLnB1c2goZWFjaCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzcGxpY2VyLnB1c2gocnVuKTtcbiAgICAgICAgICAgIHNwbGljZXJbMV0gPSB0aGlzLnNlbGVjdGlvbi5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5zcGxpY2UuYXBwbHkodGhpcy5zZWxlY3Rpb24sIHNwbGljZXIpOyAvLyB1cGRhdGUgaW4gcGxhY2UgdG8gcHJlc2VydmUgZXh0ZXJuYWwgcmVmZXJlbmNlc1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBzdW1tYXJ5IFJlbW92ZSBhIGNvbnRpZ3VvdXMgcnVuIG9mIHBvaW50cyBmcm9tIHRoZSBzZWxlY3Rpb24uXG4gICAgICAgICAqIEBkZXNjIFRydW5jYXRlIGFuZC9vciByZW1vdmUgcnVuKHMpIGZyb20gYHRoaXMuc2VsZWN0aW9uYC5cbiAgICAgICAgICogUmVtb3ZpbmcgcGFydCBvZiBleGlzdGluZyBydW5zIHdpbGwgKGNvcnJlY3RseSkgc2hvcnRlbiB0aGVtIG9yIGJyZWFrIHRoZW0gaW50byB0d28gZnJhZ21lbnRzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgdHdvIHBhcmFtZXRlcnMgbWF5IGJlIGdpdmVuIGluIGVpdGhlciBvcmRlci5cbiAgICAgICAgICpcbiAgICAgICAgICogTm90ZSB0aGF0IGB0aGlzLnNlbGVjdGlvbmAgaXMgdXBkYXRlZCBpbiBwbGFjZSwgcHJlc2VydmluZyB2YWxpZGl0eSBvZiBhbnkgZXh0ZXJuYWwgcmVmZXJlbmNlcy5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IC0gU3RhcnQgb2YgcnVuLiBNYXkgYmUgZ3JlYXRlciB0aGFuIGBzdG9wYC5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdG9wPXN0b3BdIC0gRW5kIG9mIHJ1biAoaW5jbHVzaXZlKS4gTWF5IGJlIGxlc3MgdGhhbiBgc3RhcnRgLlxuICAgICAgICAgKiBAcmV0dXJucyB7UmFuZ2VTZWxlY3Rpb25Nb2RlbH0gU2VsZiAoaS5lLiwgYHRoaXNgKSwgZm9yIGNoYWluaW5nLlxuICAgICAgICAgKiBAbWVtYmVyT2YgUmFuZ2VTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgICAgICovXG4gICAgICAgIGRlc2VsZWN0OiBmdW5jdGlvbiAoc3RhcnQsIHN0b3ApIHtcbiAgICAgICAgICAgIHZhciBydW4gPSBtYWtlUnVuKHN0YXJ0LCBzdG9wKTtcbiAgICAgICAgICAgIHZhciBzcGxpY2VyID0gWzAsIDBdO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24uZm9yRWFjaChmdW5jdGlvbiAoZWFjaCkge1xuICAgICAgICAgICAgICAgIGlmIChvdmVybGFwcyhlYWNoLCBydW4pKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwaWVjZXMgPSBzdWJ0cmFjdChlYWNoLCBydW4pO1xuICAgICAgICAgICAgICAgICAgICBzcGxpY2VyID0gc3BsaWNlci5jb25jYXQocGllY2VzKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzcGxpY2VyLnB1c2goZWFjaCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzcGxpY2VyWzFdID0gdGhpcy5zZWxlY3Rpb24ubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24uc3BsaWNlLmFwcGx5KHRoaXMuc2VsZWN0aW9uLCBzcGxpY2VyKTsgLy8gdXBkYXRlIGluIHBsYWNlIHRvIHByZXNlcnZlIGV4dGVybmFsIHJlZmVyZW5jZXNcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAc3VtbWFyeSBFbXB0aWVzIGB0aGlzLnNlbGVjdGlvbmAsIGVmZmVjdGl2ZWx5IHJlbW92aW5nIGFsbCBydW5zLlxuICAgICAgICAgKiBAcmV0dXJucyB7UmFuZ2VTZWxlY3Rpb25Nb2RlbH0gU2VsZiAoaS5lLiwgYHRoaXNgKSwgZm9yIGNoYWluaW5nLlxuICAgICAgICAgKiBAbWVtYmVyT2YgUmFuZ2VTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgICAgICovXG4gICAgICAgIGNsZWFyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlcy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24ubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNsZWFyTW9zdFJlY2VudFNlbGVjdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uID0gdGhpcy5zdGF0ZXMucG9wKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBzdW1tYXJ5IERldGVybWluZXMgaWYgdGhlIGdpdmVuIGBjZWxsYCBpcyBzZWxlY3RlZC5cbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZmYgZ2l2ZW4gYGNlbGxgIGlzIHdpdGhpbiBhbnkgb2YgdGhlIHJ1bnMgaW4gYHRoaXMuc2VsZWN0aW9uYC5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGNlbGwgLSBUaGUgY2VsbCB0byB0ZXN0IGZvciBpbmNsdXNpb24gaW4gdGhlIHNlbGVjdGlvbi5cbiAgICAgICAgICogQG1lbWJlck9mIFJhbmdlU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICAgICAqL1xuICAgICAgICBpc1NlbGVjdGVkOiBmdW5jdGlvbiAoY2VsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uLnNvbWUoZnVuY3Rpb24gKGVhY2gpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWFjaFswXSA8PSBjZWxsICYmIGNlbGwgPD0gZWFjaFsxXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIGlzRW1wdHk6IGZ1bmN0aW9uICgpe1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uLmxlbmd0aCA9PT0gMDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHN1bW1hcnkgUmV0dXJuIHRoZSBpbmRleGVzIHRoYXQgYXJlIHNlbGVjdGVkLlxuICAgICAgICAgKiBAZGVzYyBSZXR1cm4gdGhlIGluZGV4ZXMgdGhhdCBhcmUgc2VsZWN0ZWQuXG4gICAgICAgICAqIEByZXR1cm5zIHtBcnJheS5BcnJheS5udW1iZXJ9XG4gICAgICAgICAqIEBtZW1iZXJPZiBSYW5nZVNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0U2VsZWN0aW9uczogZnVuY3Rpb24gKCl7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5mb3JFYWNoKGZ1bmN0aW9uIChlYWNoKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IGVhY2hbMF07IGkgPD0gZWFjaFsxXTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVzdWx0LnNvcnQoZnVuY3Rpb24gKGEsIGIpe1xuICAgICAgICAgICAgICAgIHJldHVybiBhIC0gYjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHN1bW1hcnkgUHJlcHMgYHN0YXJ0YCBhbmQgYHN0b3BgIHBhcmFtcyBpbnRvIG9yZGVyIGFycmF5XG4gICAgICogQGZ1bmN0aW9uIG1ha2VSdW5cbiAgICAgKiBAZGVzYyBVdGlsaXR5IGZ1bmN0aW9uIGNhbGxlZCBieSBib3RoIGBzZWxlY3QoKWAgYW5kIGBkZXNlbGVjdCgpYC5cbiAgICAgKiBAcGFyYW0ge251bWJlcnxudW1iZXJbXX0gc3RhcnQgLSBTdGFydCBvZiBydW4uIGlmIGFycmF5LCBgc3RhcnRgIGFuZCBgc3RvcGAgYXJlIHRha2VuIGZyb20gZmlyc3QgdHdvIGVsZW1lbnRzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RvcD1zdGFydF0gLSBFbmQgb2YgcnVuIChpbmNsdXNpdmUpLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1ha2VSdW4oc3RhcnQsIHN0b3ApIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHN0YXJ0IGluc3RhbmNlb2YgQXJyYXlcbiAgICAgICAgICAgICAgICA/IG1ha2VSdW4uYXBwbHkodGhpcywgc3RhcnQpIC8vIGV4dHJhY3QgcGFyYW1zIGZyb20gZ2l2ZW4gYXJyYXlcbiAgICAgICAgICAgICAgICA6IHN0b3AgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gWyBzdGFydCwgc3RhcnQgXSAvLyBzaW5nbGUgcGFyYW0gaXMgYSBydW4gdGhhdCBzdG9wcyB3aGVyZSBpdCBzdGFydHNcbiAgICAgICAgICAgICAgICA6IHN0YXJ0IDw9IHN0b3BcbiAgICAgICAgICAgICAgICA/IFsgc3RhcnQsIHN0b3AgXVxuICAgICAgICAgICAgICAgIDogWyBzdG9wLCBzdGFydCBdIC8vIHJldmVyc2UgZGVzY2VuZGluZyBwYXJhbXMgaW50byBhc2NlbmRpbmcgb3JkZXJcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBmdW5jdGlvbiBvdmVybGFwc1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWZmIGBydW4xYCBvdmVybGFwcyBgcnVuMmBcbiAgICAgKiBAc3VtbWFyeSBDb21wYXJpc29uIG9wZXJhdG9yIHRoYXQgZGV0ZXJtaW5lcyBpZiBnaXZlbiBydW5zIG92ZXJsYXAgd2l0aCBvbmUgYW5vdGhlci5cbiAgICAgKiBAZGVzYyBCb3RoIHBhcmFtZXRlcnMgYXJlIGFzc3VtZWQgdG8gYmUgX29yZGVyZWRfIGFycmF5cy5cbiAgICAgKlxuICAgICAqIE92ZXJsYXAgaXMgZGVmaW5lZCB0byBpbmNsdWRlIHRoZSBjYXNlIHdoZXJlIG9uZSBydW4gY29tcGxldGVseSBjb250YWlucyB0aGUgb3RoZXIuXG4gICAgICpcbiAgICAgKiBOb3RlOiBUaGlzIG9wZXJhdG9yIGlzIGNvbW11dGF0aXZlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IHJ1bjEgLSBmaXJzdCBydW5cbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBydW4yIC0gc2Vjb25kIHJ1blxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG92ZXJsYXBzKHJ1bjEsIHJ1bjIpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHJ1bjFbMF0gPD0gcnVuMlswXSAmJiBydW4yWzBdIDw9IHJ1bjFbMV0gfHwgLy8gcnVuMidzIHN0YXJ0IGlzIHdpdGhpbiBydW4xIE9SLi4uXG4gICAgICAgICAgICBydW4xWzBdIDw9IHJ1bjJbMV0gJiYgcnVuMlsxXSA8PSBydW4xWzFdIHx8IC8vIHJ1bjIncyBzdG9wIGlzIHdpdGhpbiBydW4xIE9SLi4uXG4gICAgICAgICAgICBydW4yWzBdIDwgIHJ1bjFbMF0gJiYgcnVuMVsxXSA8ICBydW4yWzFdICAgIC8vIHJ1bjIgY29tcGxldGVseSBjb250YWlucyBydW4xXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAZnVuY3Rpb24gYWJ1dHNcbiAgICAgKiBAc3VtbWFyeSBDb21wYXJpc29uIG9wZXJhdG9yIHRoYXQgZGV0ZXJtaW5lcyBpZiBnaXZlbiBydW5zIGFyZSBjb25zZWN1dGl2ZSB3aXRoIG9uZSBhbm90aGVyLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWZmIGBydW4xYCBpcyBjb25zZWN1dGl2ZSB3aXRoIGBydW4yYFxuICAgICAqIEBkZXNjIEJvdGggcGFyYW1ldGVycyBhcmUgYXNzdW1lZCB0byBiZSBfb3JkZXJlZF8gYXJyYXlzLlxuICAgICAqXG4gICAgICogTm90ZTogVGhpcyBvcGVyYXRvciBpcyBjb21tdXRhdGl2ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBydW4xIC0gZmlyc3QgcnVuXG4gICAgICogQHBhcmFtIHtudW1iZXJbXX0gcnVuMiAtIHNlY29uZCBydW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhYnV0cyhydW4xLCBydW4yKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBydW4xWzFdID09PSBydW4yWzBdIC0gMSB8fCAvLyBydW4xJ3MgdG9wIGltbWVkaWF0ZWx5IHByZWNlZGVzIHJ1bjIncyBzdGFydCBPUi4uLlxuICAgICAgICAgICAgcnVuMlsxXSA9PT0gcnVuMVswXSAtIDEgICAgLy8gcnVuMidzIHRvcCBpbW1lZGlhdGVseSBwcmVjZWRlcyBydW4xJ3Mgc3RhcnRcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBmdW5jdGlvbiBzdWJ0cmFjdFxuICAgICAqIEBzdW1tYXJ5IE9wZXJhdG9yIHRoYXQgc3VidHJhY3RzIG9uZSBydW4gZnJvbSBhbm90aGVyLlxuICAgICAqIEByZXR1cm5zIHtBcnJheS5BcnJheS5udW1iZXJ9IFRoZSByZW1haW5pbmcgcGllY2VzIG9mIGBtaW51ZW5kYCBhZnRlciByZW1vdmluZyBgc3VidHJhaGVuZGAuXG4gICAgICogQGRlc2MgQm90aCBwYXJhbWV0ZXJzIGFyZSBhc3N1bWVkIHRvIGJlIF9vcmRlcmVkXyBhcnJheXMuXG4gICAgICpcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIF9kb2VzIG5vdCBhc3N1bWVzXyB0aGF0IGBvdmVybGFwKClgIGhhcyBhbHJlYWR5IGJlZW4gY2FsbGVkIHdpdGggdGhlIHNhbWUgcnVucyBhbmQgaGFzIHJldHVybmVkIGB0cnVlYC5cbiAgICAgKlxuICAgICAqIFJldHVybmVkIGFycmF5IGNvbnRhaW5zIDAsIDEsIG9yIDIgcnVucyB3aGljaCBhcmUgdGhlIHBvcnRpb24ocykgb2YgYG1pbnVlbmRgIHRoYXQgZG8gX25vdF8gaW5jbHVkZSBgc3VidHJhaGVuZGAuXG4gICAgICpcbiAgICAgKiBDYXZlYXQ6IFRoaXMgb3BlcmF0b3IgaXMgKm5vdCogY29tbXV0YXRpdmUuXG4gICAgICogQHBhcmFtIHtudW1iZXJbXX0gbWludWVuZCAtIGEgcnVuIGZyb20gd2hpY2ggdG8gXCJzdWJ0cmFjdFwiIGBzdWJ0cmFoZW5kYFxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IHN1YnRyYWhlbmQgLSBhIHJ1biB0byBcInN1YnRyYWN0ZWRcIiBmcm9tIGBtaW51ZW5kYFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN1YnRyYWN0KG1pbnVlbmQsIHN1YnRyYWhlbmQpIHtcbiAgICAgICAgdmFyIG0wID0gbWludWVuZFswXTtcbiAgICAgICAgdmFyIG0xID0gbWludWVuZFsxXTtcbiAgICAgICAgdmFyIHMwID0gc3VidHJhaGVuZFswXTtcbiAgICAgICAgdmFyIHMxID0gc3VidHJhaGVuZFsxXTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICAgIGlmIChzMCA8PSBtMCAmJiBzMSA8IG0xKSB7XG4gICAgICAgICAgICAvL3N1YnRyYWhlbmQgZXh0ZW5kcyBiZWZvcmUgbWludWVuZDogcmV0dXJuIHJlbWFpbmluZyBwaWVjZSBvZiBgbWludWVuZGBcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKFtzMSArIDEsIG0xXSk7XG4gICAgICAgIH0gZWxzZSBpZiAoczAgPiBtMCAmJiBzMSA+PSBtMSkge1xuICAgICAgICAgICAgLy9zdWJ0cmFoZW5kIGV4dGVuZHMgYWZ0ZXIgbWludWVuZDogcmV0dXJuIHJlbWFpbmluZyBwaWVjZSBvZiBgbWludWVuZGBcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKFttMCwgczAgLSAxXSk7XG4gICAgICAgIH0gZWxzZSBpZiAobTAgPCBzMCAmJiBzMSA8IG0xKSB7XG4gICAgICAgICAgICAvL2NvbXBsZXRlbHkgaW5zaWRlOiByZXR1cm4gMiBzbWFsbGVyIHBpZWNlcyByZXN1bHRpbmcgZnJvbSB0aGUgaG9sZVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goW20wLCBzMCAtIDFdKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKFtzMSArIDEsIG0xXSk7XG4gICAgICAgIH0gZWxzZSBpZiAoczEgPCBtMCB8fCBzMCA+IG0xKSB7XG4gICAgICAgICAgICAvLyBjb21wbGV0ZWx5IG91dHNpZGU6IHJldHVybiBgbWludWVuZGAgdW50b3VjaGVkXG4gICAgICAgICAgICByZXN1bHQucHVzaChtaW51ZW5kKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vZWxzZSBzdWJ0cmFoZW5kIG11c3QgY29tcGxldGVseSBvdmVybGFwIG1pbnVlbmQgc28gcmV0dXJuIG5vIHBpZWNlc1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG5cbiAgICAvLyBMb2NhbCB1dGlsaXR5IGZ1bmN0aW9uc1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAZnVuY3Rpb24gbWVyZ2VcbiAgICAgKiBAc3VtbWFyeSBPcGVyYXRvciB0aGF0IG1lcmdlcyBnaXZlbiBydW5zLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJbXX0gQSBzaW5nbGUgbWVyZ2VkIHJ1bi5cbiAgICAgKiBAZGVzYyBCb3RoIHBhcmFtZXRlcnMgYXJlIGFzc3VtZWQgdG8gYmUgX29yZGVyZWRfIGFycmF5cy5cbiAgICAgKlxuICAgICAqIFRoZSBydW5zIGFyZSBhc3N1bWVkIHRvIGJlIG92ZXJsYXBwaW5nIG9yIGFkamFjZW50IHRvIG9uZSBhbm90aGVyLlxuICAgICAqXG4gICAgICogTm90ZTogVGhpcyBvcGVyYXRvciBpcyBjb21tdXRhdGl2ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBydW4xIC0gYSBydW4gdG8gbWVyZ2Ugd2l0aCBgcnVuMmBcbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBydW4yIC0gYSBydW4gdG8gbWVyZ2Ugd2l0aCBgcnVuMWBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtZXJnZShydW4xLCBydW4yKSB7XG4gICAgICAgIHZhciBtaW4gPSBNYXRoLm1pbihNYXRoLm1pbi5hcHBseShNYXRoLCBydW4xKSwgTWF0aC5taW4uYXBwbHkoTWF0aCwgcnVuMikpO1xuICAgICAgICB2YXIgbWF4ID0gTWF0aC5tYXgoTWF0aC5tYXguYXBwbHkoTWF0aCwgcnVuMSksIE1hdGgubWF4LmFwcGx5KE1hdGgsIHJ1bjIpKTtcbiAgICAgICAgcmV0dXJuIFttaW4sIG1heF07XG4gICAgfVxuXG4gICAgLy8gSW50ZXJmYWNlXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBSYW5nZVNlbGVjdGlvbk1vZGVsO1xufSkoXG4gICAgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlIHx8ICh3aW5kb3cuUmFuZ2VTZWxlY3Rpb25Nb2RlbCA9IHt9KSxcbiAgICB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cyB8fCAod2luZG93LlJhbmdlU2VsZWN0aW9uTW9kZWwuZXhwb3J0cyA9IHt9KVxuKSB8fCAoXG4gICAgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgfHwgKHdpbmRvdy5SYW5nZVNlbGVjdGlvbk1vZGVsID0gd2luZG93LlJhbmdlU2VsZWN0aW9uTW9kZWwuZXhwb3J0cylcbik7XG5cbi8qIEFib3V0IHRoZSBhYm92ZSBJSUZFOlxuICogVGhpcyBmaWxlIGlzIGEgXCJtb2RpZmllZCBub2RlIG1vZHVsZS5cIiBJdCBmdW5jdGlvbnMgYXMgdXN1YWwgaW4gTm9kZS5qcyAqYW5kKiBpcyBhbHNvIHVzYWJsZSBkaXJlY3RseSBpbiB0aGUgYnJvd3Nlci5cbiAqIDEuIE5vZGUuanM6IFRoZSBJSUZFIGlzIHN1cGVyZmx1b3VzIGJ1dCBpbm5vY3VvdXMuXG4gKiAyLiBJbiB0aGUgYnJvd3NlcjogVGhlIElJRkUgY2xvc3VyZSBzZXJ2ZXMgdG8ga2VlcCBpbnRlcm5hbCBkZWNsYXJhdGlvbnMgcHJpdmF0ZS5cbiAqIDIuYS4gSW4gdGhlIGJyb3dzZXIgYXMgYSBnbG9iYWw6IFRoZSBsb2dpYyBpbiB0aGUgYWN0dWFsIHBhcmFtZXRlciBleHByZXNzaW9ucyArIHRoZSBwb3N0LWludm9jYXRpb24gZXhwcmVzc2lvblxuICogd2lsbCBwdXQgeW91ciBBUEkgaW4gYHdpbmRvdy5SYW5nZVNlbGVjdGlvbk1vZGVsYC5cbiAqIDIuYi4gSW4gdGhlIGJyb3dzZXIgYXMgYSBtb2R1bGU6IElmIHlvdSBwcmVkZWZpbmUgYSBgd2luZG93Lm1vZHVsZWAgb2JqZWN0LCB0aGUgcmVzdWx0cyB3aWxsIGJlIGluIGBtb2R1bGUuZXhwb3J0c2AuXG4gKiBUaGUgYm93ZXIgY29tcG9uZW50IGBtbm1gIG1ha2VzIHRoaXMgZWFzeSBhbmQgYWxzbyBwcm92aWRlcyBhIGdsb2JhbCBgcmVxdWlyZSgpYCBmdW5jdGlvbiBmb3IgcmVmZXJlbmNpbmcgeW91ciBtb2R1bGVcbiAqIGZyb20gb3RoZXIgY2xvc3VyZXMuIEluIGVpdGhlciBjYXNlLCB0aGlzIHdvcmtzIHdpdGggYm90aCBOb2RlSnMtc3R5bGUgZXhwb3J0IG1lY2hhbmlzbXMgLS0gYSBzaW5nbGUgQVBJIGFzc2lnbm1lbnQsXG4gKiBgbW9kdWxlLmV4cG9ydHMgPSB5b3VyQVBJYCAqb3IqIGEgc2VyaWVzIG9mIGluZGl2aWR1YWwgcHJvcGVydHkgYXNzaWdubWVudHMsIGBtb2R1bGUuZXhwb3J0cy5wcm9wZXJ0eSA9IHByb3BlcnR5YC5cbiAqXG4gKiBCZWZvcmUgdGhlIElJRkUgcnVucywgdGhlIGFjdHVhbCBwYXJhbWV0ZXIgZXhwcmVzc2lvbnMgYXJlIGV4ZWN1dGVkOlxuICogMS4gSWYgYHdpbmRvd2Agb2JqZWN0IHVuZGVmaW5lZCwgd2UncmUgaW4gTm9kZUpzIHNvIGFzc3VtZSB0aGVyZSBpcyBhIGBtb2R1bGVgIG9iamVjdCB3aXRoIGFuIGBleHBvcnRzYCBwcm9wZXJ0eVxuICogMi4gSWYgYHdpbmRvd2Agb2JqZWN0IGRlZmluZWQsIHdlJ3JlIGluIGJyb3dzZXJcbiAqIDIuYS4gSWYgYG1vZHVsZWAgb2JqZWN0IHByZWRlZmluZWQsIHVzZSBpdFxuICogMi5iLiBJZiBgbW9kdWxlYCBvYmplY3QgdW5kZWZpbmVkLCBjcmVhdGUgYSBgUmFuZ2VTZWxlY3Rpb25Nb2RlbGAgb2JqZWN0XG4gKlxuICogQWZ0ZXIgdGhlIElJRkUgcmV0dXJuczpcbiAqIEJlY2F1c2UgaXQgYWx3YXlzIHJldHVybnMgdW5kZWZpbmVkLCB0aGUgZXhwcmVzc2lvbiBhZnRlciB0aGUgfHwgd2lsbCBleGVjdXRlOlxuICogMS4gSWYgYHdpbmRvd2Agb2JqZWN0IHVuZGVmaW5lZCwgdGhlbiB3ZSdyZSBpbiBOb2RlSnMgc28gd2UncmUgZG9uZVxuICogMi4gSWYgYHdpbmRvd2Agb2JqZWN0IGRlZmluZWQsIHRoZW4gd2UncmUgaW4gYnJvd3NlclxuICogMi5hLiBJZiBgbW9kdWxlYCBvYmplY3QgcHJlZGVmaW5lZCwgd2UncmUgZG9uZTsgcmVzdWx0cyBhcmUgaW4gYG1vdWR1bGUuZXhwb3J0c2BcbiAqIDIuYi4gSWYgYG1vZHVsZWAgb2JqZWN0IHVuZGVmaW5lZCwgcmVkZWZpbmVgUmFuZ2VTZWxlY3Rpb25Nb2RlbGAgdG8gYmUgdGhlIGBSYW5nZVNlbGVjdGlvbk1vZGVsLmV4cG9ydHNgIG9iamVjdFxuICovXG4iLCIvLyB0YWJ6IG5vZGUgbW9kdWxlXG4vLyBodHRwczovL2dpdGh1Yi5jb20vam9uZWl0L3RhYnpcblxuLyogZXNsaW50LWVudiBub2RlLCBicm93c2VyICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNzc0luamVjdG9yID0gcmVxdWlyZSgnY3NzLWluamVjdG9yJyk7XG5cbi8qKlxuICogUmVnaXN0ZXIvZGVyZWdpc3RlciBjbGljayBoYW5kbGVyIG9uIGFsbCB0YWIgY29sbGVjdGlvbnMuXG4gKiBAcGFyYW0ge0VsZW1lbnR9IFtvcHRpb25zLnJvb3Q9ZG9jdW1lbnRdIC0gV2hlcmUgdG8gbG9vayBmb3IgdGFiIHBhbmVscyAoYC50YWJ6YCBlbGVtZW50cykgY29udGFpbmluZyB0YWJzIGFuZCBmb2xkZXJzLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy51bmhvb2s9ZmFsc2VdIC0gUmVtb3ZlIGV2ZW50IGxpc3RlbmVyIGZyb20gdGFiIHBhbmVscyAoYC50YWJ6YCBlbGVtZW50cykuXG4gKiBAcGFyYW0ge0VsZW1lbnR9IFtvcHRpb25zLnJlZmVyZW5jZUVsZW1lbnRdIC0gUGFzc2VkIHRvIGNzc0luamVjdG9yJ3MgaW5zZXJ0QmVmb3JlKCkgY2FsbC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5kZWZhdWx0VGFiU2VsZWN0b3I9Jy5kZWZhdWx0LXRhYiddIC0gLmNsYXNzbmFtZSBvciAjaWQgb2YgdGhlIHRhYiB0byBzZWxlY3QgYnkgZGVmYXVsdFxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zLm9uRW5hYmxlXSAtIEhhbmRsZXIgaW1wbGVtZW50YXRpb24uIFNlZSB7QGxpbmsgVGFieiNvbkVuYWJsZXxvbkVuYWJsZX0uXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMub25EaXNhYmxlXSAtIEhhbmRsZXIgaW1wbGVtZW50YXRpb24uIFNlZSB7QGxpbmsgVGFieiNvbkRpc2FibGV8b25FbmFibGV9LlxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zLm9uRW5hYmxlZF0gLSBIYW5kbGVyIGltcGxlbWVudGF0aW9uLiBTZWUge0BsaW5rIFRhYnojb25FbmFibGVkfG9uRW5hYmxlfS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucy5vbkRpc2FibGVkXSAtIEhhbmRsZXIgaW1wbGVtZW50YXRpb24uIFNlZSB7QGxpbmsgVGFieiNvbkRpc2FibGVkfG9uRW5hYmxlfS5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBUYWJ6KG9wdGlvbnMpIHtcbiAgICB2YXIgaSwgZWw7XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgcm9vdCA9IG9wdGlvbnMucm9vdCB8fCBkb2N1bWVudCxcbiAgICAgICAgdW5ob29rID0gb3B0aW9ucy51bmhvb2ssXG4gICAgICAgIHJlZmVyZW5jZUVsZW1lbnQgPSBvcHRpb25zLnJlZmVyZW5jZUVsZW1lbnQsXG4gICAgICAgIGRlZmF1bHRUYWJTZWxlY3RvciA9IG9wdGlvbnMuZGVmYXVsdFRhYlNlbGVjdG9yIHx8ICcuZGVmYXVsdC10YWInO1xuXG4gICAgaWYgKCF1bmhvb2spIHtcbiAgICAgICAgdmFyIGNzcztcbiAgICAgICAgLyogaW5qZWN0OmNzcyAqL1xuICAgICAgICBjc3MgPSAnLnRhYnp7cG9zaXRpb246cmVsYXRpdmU7dmlzaWJpbGl0eTpoaWRkZW47aGVpZ2h0OjEwMCV9LnRhYno+aGVhZGVye3Bvc2l0aW9uOnJlbGF0aXZlO2Rpc3BsYXk6aW5saW5lLWJsb2NrO2JhY2tncm91bmQtY29sb3I6I2ZmZjttYXJnaW4tbGVmdDoxZW07cGFkZGluZzo1cHggLjZlbTtib3JkZXI6MXB4IHNvbGlkICM2NjY7Ym9yZGVyLWJvdHRvbS1jb2xvcjp0cmFuc3BhcmVudDtib3JkZXItcmFkaXVzOjZweCA2cHggMCAwO2N1cnNvcjpkZWZhdWx0O3VzZXItc2VsZWN0Om5vbmU7LXdlYmtpdC11c2VyLXNlbGVjdDpub25lOy1tb3otdXNlci1zZWxlY3Q6bm9uZTstbXMtdXNlci1zZWxlY3Q6bm9uZX0udGFiej5oZWFkZXIrc2VjdGlvbntwb3NpdGlvbjphYnNvbHV0ZTtkaXNwbGF5Om5vbmU7YmFja2dyb3VuZC1jb2xvcjojZmZmO21hcmdpbi10b3A6LTFweDtwYWRkaW5nOjhweDtib3JkZXI6MXB4IHNvbGlkICM2NjY7Ym9yZGVyLXJhZGl1czo2cHg7bGVmdDowO3JpZ2h0OjA7Ym90dG9tOjA7dG9wOjA7ei1pbmRleDowfS50YWJ6PmhlYWRlcitzZWN0aW9uLnRhYnotZW5hYmxle3otaW5kZXg6MX0udGFiej5oZWFkZXIudGFiei1lbmFibGV7ei1pbmRleDoyfS50YWJ6LWJnMHtiYWNrZ3JvdW5kLWNvbG9yOiNlZWUhaW1wb3J0YW50fS50YWJ6LWJnMXtiYWNrZ3JvdW5kLWNvbG9yOiNlZWYhaW1wb3J0YW50fS50YWJ6LWJnMntiYWNrZ3JvdW5kLWNvbG9yOiNlZmUhaW1wb3J0YW50fS50YWJ6LWJnM3tiYWNrZ3JvdW5kLWNvbG9yOiNlZmYhaW1wb3J0YW50fS50YWJ6LWJnNHtiYWNrZ3JvdW5kLWNvbG9yOiNmZWUhaW1wb3J0YW50fS50YWJ6LWJnNXtiYWNrZ3JvdW5kLWNvbG9yOiNmZWYhaW1wb3J0YW50fS50YWJ6LWJnNntiYWNrZ3JvdW5kLWNvbG9yOiNmZmUhaW1wb3J0YW50fSc7XG4gICAgICAgIC8qIGVuZGluamVjdCAqL1xuXG4gICAgICAgIGlmICghcmVmZXJlbmNlRWxlbWVudCkge1xuICAgICAgICAgICAgLy8gZmluZCBmaXJzdCA8bGluaz4gb3IgPHN0eWxlPiBpbiA8aGVhZD5cbiAgICAgICAgICAgIHZhciBoZWFkU3R1ZmYgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdoZWFkJykuY2hpbGRyZW47XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyAhcmVmZXJlbmNlRWxlbWVudCAmJiBpIDwgaGVhZFN0dWZmLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgZWwgPSBoZWFkU3R1ZmZbaV07XG4gICAgICAgICAgICAgICAgaWYgKGVsLnRhZ05hbWUgPT09ICdTVFlMRScgfHwgZWwudGFnTmFtZSA9PT0gJ0xJTksnICYmIGVsLnJlbCA9PT0gJ3N0eWxlc2hlZXQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZmVyZW5jZUVsZW1lbnQgPSBlbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY3NzSW5qZWN0b3IoY3NzLCAndGFiei1jc3MtYmFzZScsIHJlZmVyZW5jZUVsZW1lbnQpO1xuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAodGhpc1trZXldID09PSBub29wKSB7XG4gICAgICAgICAgICAgICAgdGhpc1trZXldID0gb3B0aW9uc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBzdW1tYXJ5IFRoZSBjb250ZXh0IG9mIHRoaXMgdGFiIG9iamVjdC5cbiAgICAgICAgICogQGRlc2MgVGhlIGNvbnRleHQgbWF5IGVuY29tcGFzcyBhbnkgbnVtYmVyIG9mIHRhYiBwYW5lbHMgKGAudGFiemAgZWxlbWVudHMpLlxuICAgICAgICAgKiBAdHlwZSB7SFRNTERvY3VtZW58SFRNTEVsZW1lbnR9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJvb3QgPSByb290O1xuXG4gICAgICAgIC8vIGVuYWJsZSBmaXJzdCB0YWIgb24gZWFjaCB0YWIgcGFuZWwgKGAudGFiemAgZWxlbWVudClcbiAgICAgICAgZm9yRWFjaEVsKCcudGFiej5oZWFkZXI6Zmlyc3Qtb2YtdHlwZSwudGFiej5zZWN0aW9uOmZpcnN0LW9mLXR5cGUnLCBmdW5jdGlvbihlbCkge1xuICAgICAgICAgICAgZWwuY2xhc3NMaXN0LmFkZCgndGFiei1lbmFibGUnKTtcbiAgICAgICAgfSwgcm9vdCk7XG5cbiAgICAgICAgLy8gZW5hYmxlIGRlZmF1bHQgdGFiIGFuZCBhbGwgaXRzIHBhcmVudHMgKG11c3QgYmUgYSB0YWIpXG4gICAgICAgIHRoaXMudGFiVG8ocm9vdC5xdWVyeVNlbGVjdG9yKCcudGFieiA+IGhlYWRlcicgKyBkZWZhdWx0VGFiU2VsZWN0b3IpKTtcblxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZm9yRWFjaEVsKCcudGFieiA+IHNlY3Rpb24nLCBmdW5jdGlvbihlbCkge1xuXG4gICAgICAgICAgICAgICAgLy8gU3RlcCAxOiBBIGJ1ZyBpbiBvbGRlciB2ZXJzaW9ucyBvZiBDaHJvbWUgKGxpa2UgdjQwKSB0aGF0IGluc2VydGVkIGEgYnJlYWsgYXQgbWFyay11cCBsb2NhdGlvbiBvZiBhbiBhYnNvbHV0ZSBwb3NpdGlvbmVkIGJsb2NrLiBUaGUgd29yay1hcm91bmQgaXMgdG8gaGlkZSB0aG9zZSBibG9ja3MgdW50aWwgYWZ0ZXIgZmlyc3QgcmVuZGVyOyB0aGVuIHNob3cgdGhlbS4gSSBkb24ndCBrbm93IHdoeSB0aGlzIHdvcmtzIGJ1dCBpdCBkb2VzLiBTZWVtcyB0byBiZSBkdXJhYmxlLlxuICAgICAgICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuXG4gICAgICAgICAgICAgICAgLy8gU3RlcCAyOiBBZGp1c3QgYWJzb2x1dGUgdG9wIG9mIGVhY2ggcmVuZGVyZWQgZm9sZGVyIHRvIHRoZSBib3R0b20gb2YgaXRzIHRhYlxuICAgICAgICAgICAgICAgIGVsLnN0eWxlLnRvcCA9IGVsLnByZXZpb3VzRWxlbWVudFNpYmxpbmcuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuYm90dG9tIC0gZWwucGFyZW50RWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgKyAncHgnO1xuXG4gICAgICAgICAgICB9LCByb290KTtcbiAgICAgICAgfSwgMCk7XG4gICAgfVxuXG4gICAgdmFyIG1ldGhvZCA9IHVuaG9vayA/ICdyZW1vdmVFdmVudExpc3RlbmVyJyA6ICdhZGRFdmVudExpc3RlbmVyJztcbiAgICB2YXIgYm91bmRDbGlja0hhbmRsZXIgPSBvbmNsaWNrLmJpbmQodGhpcyk7XG4gICAgZm9yRWFjaEVsKCcudGFieicsIGZ1bmN0aW9uKHRhYkJhcikge1xuICAgICAgICB0YWJCYXIuc3R5bGUudmlzaWJpbGl0eSA9ICd2aXNpYmxlJztcbiAgICAgICAgdGFiQmFyW21ldGhvZF0oJ2NsaWNrJywgYm91bmRDbGlja0hhbmRsZXIpO1xuICAgIH0sIHJvb3QpO1xufVxuXG5mdW5jdGlvbiBvbmNsaWNrKGV2dCkge1xuICAgIGNsaWNrLmNhbGwodGhpcywgZXZ0LmN1cnJlbnRUYXJnZXQsIGV2dC50YXJnZXQpO1xufVxuXG4vKipcbiAqIEBzdW1tYXJ5IFNlbGVjdHMgdGhlIGdpdmVuIHRhYi5cbiAqIEBkZXNjIElmIGl0IGlzIGEgbmVzdGVkIHRhYiwgYWxzbyByZXZlYWxzIGFsbCBpdHMgYW5jZXN0b3IgdGFicy5cbiAqIEBwYXJhbSB7c3RyaW5nfEhUTUxFbGVtZW50fSBbZWxdIC0gTWF5IGJlIG9uZSBvZjpcbiAqICogYEhUTUxFbGVtZW50YFxuICogICAqIGA8aGVhZGVyPmAgLSB0YWIgZWxlbWVudFxuICogICAqIGA8c2VjdGlvbj5gIC0gZm9sZGVyIGVsZW1lbnRcbiAqICogYHN0cmluZ2AgLSBDU1Mgc2VsZWN0b3IgdG8gb25lIG9mIHRoZSBhYm92ZVxuICogKiBmYWxzeSAtIGZhaWxzIHNpbGVudGx5XG4gKiBAbWVtYmVyT2YgVGFiei5wcm90b3R5cGVcbiAqL1xuVGFiei5wcm90b3R5cGUudGFiVG8gPSBmdW5jdGlvbihlbCkge1xuICAgIHdoaWxlICgoZWwgPSB0aGlzLnRhYihlbCkpKSB7XG4gICAgICAgIGNsaWNrLmNhbGwodGhpcywgZWwucGFyZW50RWxlbWVudCwgZWwpO1xuICAgICAgICBlbCA9IGVsLnBhcmVudEVsZW1lbnQucGFyZW50RWxlbWVudDsgLy8gbG9vcCB0byBjbGljayBvbiBlYWNoIGNvbnRhaW5pbmcgdGFiLi4uXG4gICAgfVxufTtcblxuLyoqXG4gKiBDdXJyZW50IHNlbGVjdGVkIHRhYi5cbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR8bnVtYmVyfSBlbCAtIEFuIGVsZW1lbnQgdGhhdCBpcyAob3IgaXMgd2l0aGluKSB0aGUgdGFiIHBhbmVsIChgLnRhYnpgIGVsZW1lbnQpIHRvIGxvb2sgaW4uXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfEhUTUxFbGVtZW50fSBSZXR1cm5zIHRhYiAoYDxoZWFkZXI+YCkgZWxlbWVudC4gIFJldHVybnMgYHVuZGVmaW5lZGAgaWYgYGVsYCBpcyBuZWl0aGVyIG9mIHRoZSBhYm92ZSBvciBhbiBvdXQgb2YgcmFuZ2UgaW5kZXguXG4gKi9cblRhYnoucHJvdG90eXBlLmVuYWJsZWRUYWIgPSBmdW5jdGlvbihlbCkge1xuICAgIGVsID0gdGhpcy5wYW5lbChlbCk7XG4gICAgcmV0dXJuIGVsICYmIGVsLnF1ZXJ5U2VsZWN0b3IoJzpzY29wZT5oZWFkZXIudGFiei1lbmFibGUnKTtcbn07XG5cbi8qKlxuICogQHN1bW1hcnkgR2V0IHRhYiBlbGVtZW50LlxuICogQGRlc2MgR2V0IHRhYiBlbGVtZW50IGlmIGdpdmVuIHRhYiBvciBmb2xkZXIgZWxlbWVudDsgb3IgYW4gZWxlbWVudCB3aXRoaW4gc3VjaDsgb3IgZmluZCB0YWIuXG4gKiBAcGFyYW0ge3N0cmluZ3xFbGVtZW50fSBbZWxdIC0gTWF5IGJlIG9uZSBvZjpcbiAqICogYSB0YWIgKGEgYDxoZWFkZXI+YCBlbGVtZW50KVxuICogKiBhIGZvbGRlciAoYSBgPHNlY3Rpb24+YCBlbGVtZW50KVxuICogKiBhbiBlbGVtZW50IHdpdGhpbiBvbmUgb2YgdGhlIGFib3ZlXG4gKiAqIGBzdHJpbmdgIC0gQ1NTIHNlbGVjdG9yIHRvIG9uZSBvZiB0aGUgYWJvdmUsIHNlYXJjaGluZyB3aXRoaW4gdGhlIHJvb3Qgb3IgZG9jdW1lbnRcbiAqIEByZXR1cm5zIHtudWxsfEVsZW1lbnR9IHRhYiAoYDxoZWFkZXI+Li4uPC9oZWFkZXI+YCkgZWxlbWVudCBvciBgbnVsbGAgaWYgbm90IGZvdW5kXG4gKiBAbWVtYmVyT2YgVGFiei5wcm90b3R5cGVcbiAqL1xuVGFiei5wcm90b3R5cGUudGFiID0gZnVuY3Rpb24oZWwpIHtcbiAgICBlbCA9IGxvb2tGb3JFbC5jYWxsKHRoaXMsIGVsKTtcbiAgICByZXR1cm4gIShlbCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSA/IG51bGwgOiBlbC50YWdOYW1lID09PSAnSEVBREVSJyA/IGVsIDogZWwudGFnTmFtZSA9PT0gJ1NFQ1RJT04nID8gZWwucHJldmlvdXNFbGVtZW50U2libGluZyA6IG51bGw7XG59O1xuXG4vKipcbiAqIEBzdW1tYXJ5IEdldCBmb2xkZXIgZWxlbWVudC5cbiAqIEBkZXNjIEdldCBmb2xkZXIgZWxlbWVudCBpZiBnaXZlbiB0YWIgb3IgZm9sZGVyIGVsZW1lbnQ7IG9yIGFuIGVsZW1lbnQgd2l0aGluIHN1Y2g7IG9yIGZpbmQgZm9sZGVyLlxuICogQHBhcmFtIHtzdHJpbmd8RWxlbWVudH0gW2VsXSAtIE1heSBiZSBvbmUgb2Y6XG4gKiAqIGEgdGFiIChhIGA8aGVhZGVyPmAgZWxlbWVudClcbiAqICogYSBmb2xkZXIgKGEgYDxzZWN0aW9uPmAgZWxlbWVudClcbiAqICogYW4gZWxlbWVudCB3aXRoaW4gb25lIG9mIHRoZSBhYm92ZVxuICogKiBgc3RyaW5nYCAtIENTUyBzZWxlY3RvciB0byBvbmUgb2YgdGhlIGFib3ZlLCBzZWFyY2hpbmcgd2l0aGluIHRoZSByb290IG9yIGRvY3VtZW50XG4gKiBAcmV0dXJucyB7bnVsbHxFbGVtZW50fSB0YWIgKGA8aGVhZGVyPi4uLjwvaGVhZGVyPmApIGVsZW1lbnQgb3IgYG51bGxgIGlmIG5vdCBmb3VuZFxuICogQG1lbWJlck9mIFRhYnoucHJvdG90eXBlXG4gKi9cblRhYnoucHJvdG90eXBlLmZvbGRlciA9IGZ1bmN0aW9uKGVsKSB7XG4gICAgZWwgPSBsb29rRm9yRWwuY2FsbCh0aGlzLCBlbCk7XG4gICAgcmV0dXJuICEoZWwgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkgPyBudWxsIDogZWwudGFnTmFtZSA9PT0gJ1NFQ1RJT04nID8gZWwgOiBlbC50YWdOYW1lID09PSAnSEVBREVSJyA/IGVsLm5leHRFbGVtZW50U2libGluZyA6IG51bGw7XG59O1xuXG4vKipcbiAqIEBzdW1tYXJ5IEdldCB0YWIgcGFuZWwgZWxlbWVudC5cbiAqIEBkZXNjIEdldCBwYW5lbCBlbGVtZW50IGlmIGdpdmVuIHRhYiBwYW5lbCBlbGVtZW50OyBvciBhbiBlbGVtZW50IHdpdGhpbiBhIHRhYiBwYW5lbDsgb3IgZmluZCB0YWIgcGFuZWwuXG4gKiBAcGFyYW0ge3N0cmluZ3xFbGVtZW50fSBbZWxdIC0gTWF5IGJlIG9uZSBvZjpcbiAqICogYSB0YWIgcGFuZWwgKGFuIGBIVE1MRWxlbWVudGAgd2l0aCBjbGFzcyBgdGFiemApXG4gKiAqIGFuIGVsZW1lbnQgd2l0aGluIGEgdGFiIHBhbmVsXG4gKiAqIGBzdHJpbmdgIC0gQ1NTIHNlbGVjdG9yIHRvIG9uZSBhIHRhYiBwYW5lbCwgc2VhcmNoaW5nIHdpdGhpbiB0aGUgcm9vdCBvciBkb2N1bWVudFxuICogQHJldHVybnMge251bGx8RWxlbWVudH0gdGFiIHBhbmVsIGVsZW1lbnQgb3IgYG51bGxgIGlmIG5vdCBmb3VuZFxuICogQG1lbWJlck9mIFRhYnoucHJvdG90eXBlXG4gKi9cblRhYnoucHJvdG90eXBlLnBhbmVsID0gZnVuY3Rpb24oZWwpIHtcbiAgICB3aGlsZSAoZWwgJiYgIWVsLmNsYXNzTGlzdC5jb250YWlucygndGFieicpKSB7XG4gICAgICAgIGVsID0gZWwucGFyZW50RWxlbWVudDtcbiAgICB9XG4gICAgcmV0dXJuICEoZWwgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkgPyBudWxsIDogZWwuY2xhc3NMaXN0LmNvbnRhaW5zKCd0YWJ6JykgPyBlbCA6IG51bGw7XG59O1xuXG5mdW5jdGlvbiBsb29rRm9yRWwoZWwpIHtcbiAgICBpZiAoZWwgaW5zdGFuY2VvZiBFbGVtZW50KSB7XG4gICAgICAgIHdoaWxlIChlbCAmJiBlbC50YWdOYW1lICE9PSAnSEVBREVSJyAmJiBlbC50YWdOYW1lICE9PSAnU0VDVElPTicpIHtcbiAgICAgICAgICAgIGVsID0gZWwucGFyZW50RWxlbWVudDtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGVsID0gdGhpcy5yb290LnF1ZXJ5U2VsZWN0b3IoZWwpO1xuICAgIH1cbiAgICByZXR1cm4gZWw7XG59XG5cbi8qKiBFbmFibGVzIHRoZSB0YWIvZm9sZGVyIHBhaXIgb2YgdGhlIGNsaWNrZWQgdGFiLlxuICogRGlzYWJsZXMgYWxsIHRoZSBvdGhlciBwYWlycyBpbiB0aGlzIHNjb3BlIHdoaWNoIHdpbGwgaW5jbHVkZSB0aGUgcHJldmlvdXNseSBlbmFibGVkIHBhaXIuXG4gKiBAcHJpdmF0ZVxuICogQHRoaXMgVGFielxuICogQHBhcmFtIHtFbGVtZW50fSBkaXYgLSBUaGUgdGFiIHBhbmVsIChgLnRhYnpgIGVsZW1lbnQpIHRoYXQncyBoYW5kbGluZyB0aGUgY2xpY2sgZXZlbnQuXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldCAtIFRoZSBlbGVtZW50IHRoYXQgcmVjZWl2ZWQgdGhlIGNsaWNrLlxuICogQHJldHVybnMge3VuZGVmaW5lZHxFbGVtZW50fSBUaGUgYDxoZWFkZXI+YCBlbGVtZW50ICh0YWIpIHRoZSB3YXMgY2xpY2tlZDsgb3IgYHVuZGVmaW5lZGAgd2hlbiBjbGljayB3YXMgbm90IHdpdGhpbiBhIHRhYi5cbiAqL1xuZnVuY3Rpb24gY2xpY2soZGl2LCB0YXJnZXQpIHtcbiAgICB2YXIgbmV3VGFiLCBvbGRUYWI7XG5cbiAgICBmb3JFYWNoRWwoJzpzY29wZT5oZWFkZXI6bm90KC50YWJ6LWVuYWJsZSknLCBmdW5jdGlvbih0YWIpIHsgLy8gdG9kbzogdXNlIGEgLmZpbmQoKSBwb2x5ZmlsbCBoZXJlXG4gICAgICAgIGlmICh0YWIuY29udGFpbnModGFyZ2V0KSkge1xuICAgICAgICAgICAgbmV3VGFiID0gdGFiO1xuICAgICAgICB9XG4gICAgfSwgZGl2KTtcblxuICAgIGlmIChuZXdUYWIpIHtcbiAgICAgICAgb2xkVGFiID0gdGhpcy5lbmFibGVkVGFiKGRpdik7XG4gICAgICAgIHRvZ2dsZVRhYi5jYWxsKHRoaXMsIG9sZFRhYiwgZmFsc2UpO1xuICAgICAgICB0b2dnbGVUYWIuY2FsbCh0aGlzLCBuZXdUYWIsIHRydWUpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXdUYWI7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEB0aGlzIFRhYnpcbiAqIEBwYXJhbSB7RWxlbWVudH0gdGFiIC0gVGhlIGA8aGVhZGVyPmAgZWxlbWVudCBvZiB0aGUgdGFiIHRvIGVuYWJsZSBvciBkaXNhYmxlLlxuICogQHBhcmFtIHtib29sZWFufSBlbmFibGUgLSBFbmFibGUgKHZzLiBkaXNhYmxlKSB0aGUgdGFiLlxuICovXG5mdW5jdGlvbiB0b2dnbGVUYWIodGFiLCBlbmFibGUpIHtcbiAgICBpZiAodGFiKSB7XG4gICAgICAgIHZhciBmb2xkZXIgPSB0aGlzLmZvbGRlcih0YWIpLFxuICAgICAgICAgICAgbWV0aG9kID0gZW5hYmxlID8gJ29uRW5hYmxlJyA6ICdvbkRpc2FibGUnO1xuXG4gICAgICAgIHRoaXNbbWV0aG9kXS5jYWxsKHRoaXMsIHRhYiwgZm9sZGVyKTtcblxuICAgICAgICB0YWIuY2xhc3NMaXN0LnRvZ2dsZSgndGFiei1lbmFibGUnLCBlbmFibGUpO1xuICAgICAgICBmb2xkZXIuY2xhc3NMaXN0LnRvZ2dsZSgndGFiei1lbmFibGUnLCBlbmFibGUpO1xuXG4gICAgICAgIG1ldGhvZCArPSAnZCc7XG4gICAgICAgIHRoaXNbbWV0aG9kXS5jYWxsKHRoaXMsIHRhYiwgZm9sZGVyKTtcbiAgICB9XG59XG5cbi8qKlxuICogQHR5cGVkZWYgdGFiRXZlbnRcbiAqIEB0eXBlIHtmdW5jdGlvbn1cbiAqIEBwYXJhbSB7dGFiRXZlbnRPYmplY3R9XG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB0YWJFdmVudE9iamVjdFxuICogQHByb3BlcnR5IHtUYWJ6fSB0YWJ6IC0gVGhlIHRhYiBvYmplY3QgaXNzdWluZyB0aGUgY2FsbGJhY2suXG4gKiBAcHJvcGVydHkge0VsZW1lbnR9IHRhcmdldCAtIFRoZSB0YWIgKGA8aGVhZGVyPmAgZWxlbWVudCkuXG4gKi9cblxuLyoqXG4gKiBDYWxsZWQgYmVmb3JlIGEgcHJldmlvdXNseSBkaXNhYmxlZCB0YWIgaXMgZW5hYmxlZC5cbiAqIEB0eXBlIHt0YWJFdmVudH1cbiAqIEBhYnN0cmFjdFxuICogQG1lbWJlck9mIFRhYnoucHJvdG90eXBlXG4gKi9cblRhYnoucHJvdG90eXBlLm9uRW5hYmxlID0gbm9vcDtcblxuLyoqXG4gKiBDYWxsZWQgYmVmb3JlIGEgcHJldmlvdXNseSBlbmFibGVkIHRhYiBpcyBkaXNhYmxlZCBieSBhbm90aGVyIHRhYiBiZWluZyBlbmFibGVkLlxuICogQHR5cGUge3RhYkV2ZW50fVxuICogQGFic3RyYWN0XG4gKiBAbWVtYmVyT2YgVGFiei5wcm90b3R5cGVcbiAqL1xuVGFiei5wcm90b3R5cGUub25EaXNhYmxlID0gbm9vcDtcblxuLyoqXG4gKiBDYWxsZWQgYWZ0ZXIgYSBwcmV2aW91c2x5IGRpc2FibGVkIHRhYiBpcyBlbmFibGVkLlxuICogQHR5cGUge3RhYkV2ZW50fVxuICogQGFic3RyYWN0XG4gKiBAbWVtYmVyT2YgVGFiei5wcm90b3R5cGVcbiAqL1xuVGFiei5wcm90b3R5cGUub25FbmFibGVkID0gbm9vcDtcblxuLyoqXG4gKiBDYWxsZWQgYWZ0ZXIgYSBwcmV2aW91c2x5IGVuYWJsZWQgdGFiIGlzIGRpc2FibGVkIGJ5IGFub3RoZXIgdGFiIGJlaW5nIGVuYWJsZWQuXG4gKiBAdHlwZSB7dGFiRXZlbnR9XG4gKiBAYWJzdHJhY3RcbiAqIEBtZW1iZXJPZiBUYWJ6LnByb3RvdHlwZVxuICovXG5UYWJ6LnByb3RvdHlwZS5vbkRpc2FibGVkID0gbm9vcDtcblxuZnVuY3Rpb24gbm9vcCgpIHt9IC8vIG51bGwgcGF0dGVyblxuXG5mdW5jdGlvbiBmb3JFYWNoRWwoc2VsZWN0b3IsIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwoKGNvbnRleHQgfHwgZG9jdW1lbnQpLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpLCBpdGVyYXRlZSk7XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSBUYWJ6O1xuIiwiLy8gdGVtcGxleCBub2RlIG1vZHVsZVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2pvbmVpdC90ZW1wbGV4XG5cbi8qIGVzbGludC1lbnYgbm9kZSAqL1xuXG4vKipcbiAqIE1lcmdlcyB2YWx1ZXMgb2YgZXhlY3V0aW9uIGNvbnRleHQgcHJvcGVydGllcyBuYW1lZCBpbiB0ZW1wbGF0ZSBieSB7cHJvcDF9LFxuICoge3Byb3AyfSwgZXRjLiwgb3IgYW55IGphdmFzY3JpcHQgZXhwcmVzc2lvbiBpbmNvcnBvcmF0aW5nIHN1Y2ggcHJvcCBuYW1lcy5cbiAqIFRoZSBjb250ZXh0IGFsd2F5cyBpbmNsdWRlcyB0aGUgZ2xvYmFsIG9iamVjdC4gSW4gYWRkaXRpb24geW91IGNhbiBzcGVjaWZ5IGEgc2luZ2xlXG4gKiBjb250ZXh0IG9yIGFuIGFycmF5IG9mIGNvbnRleHRzIHRvIHNlYXJjaCAoaW4gdGhlIG9yZGVyIGdpdmVuKSBiZWZvcmUgZmluYWxseVxuICogc2VhcmNoaW5nIHRoZSBnbG9iYWwgY29udGV4dC5cbiAqXG4gKiBNZXJnZSBleHByZXNzaW9ucyBjb25zaXN0aW5nIG9mIHNpbXBsZSBudW1lcmljIHRlcm1zLCBzdWNoIGFzIHswfSwgezF9LCBldGMuLCBkZXJlZlxuICogdGhlIGZpcnN0IGNvbnRleHQgZ2l2ZW4sIHdoaWNoIGlzIGFzc3VtZWQgdG8gYmUgYW4gYXJyYXkuIEFzIGEgY29udmVuaWVuY2UgZmVhdHVyZSxcbiAqIGlmIGFkZGl0aW9uYWwgYXJncyBhcmUgZ2l2ZW4gYWZ0ZXIgYHRlbXBsYXRlYCwgYGFyZ3VtZW50c2AgaXMgdW5zaGlmdGVkIG9udG8gdGhlIGNvbnRleHRcbiAqIGFycmF5LCB0aHVzIG1ha2luZyBmaXJzdCBhZGRpdGlvbmFsIGFyZyBhdmFpbGFibGUgYXMgezF9LCBzZWNvbmQgYXMgezJ9LCBldGMuLCBhcyBpblxuICogYHRlbXBsZXgoJ0hlbGxvLCB7MX0hJywgJ1dvcmxkJylgLiAoezB9IGlzIHRoZSB0ZW1wbGF0ZSBzbyBjb25zaWRlciB0aGlzIHRvIGJlIDEtYmFzZWQuKVxuICpcbiAqIElmIHlvdSBwcmVmZXIgc29tZXRoaW5nIG90aGVyIHRoYW4gYnJhY2VzLCByZWRlZmluZSBgdGVtcGxleC5yZWdleHBgLlxuICpcbiAqIFNlZSB0ZXN0cyBmb3IgZXhhbXBsZXMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRlbXBsYXRlXG4gKiBAcGFyYW0gey4uLnN0cmluZ30gW2FyZ3NdXG4gKi9cbmZ1bmN0aW9uIHRlbXBsZXgodGVtcGxhdGUpIHtcbiAgICB2YXIgY29udGV4dHMgPSB0aGlzIGluc3RhbmNlb2YgQXJyYXkgPyB0aGlzIDogW3RoaXNdO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkgeyBjb250ZXh0cy51bnNoaWZ0KGFyZ3VtZW50cyk7IH1cbiAgICByZXR1cm4gdGVtcGxhdGUucmVwbGFjZSh0ZW1wbGV4LnJlZ2V4cCwgdGVtcGxleC5tZXJnZXIuYmluZChjb250ZXh0cykpO1xufVxuXG50ZW1wbGV4LnJlZ2V4cCA9IC9cXHsoLio/KVxcfS9nO1xuXG50ZW1wbGV4LndpdGggPSBmdW5jdGlvbiAoaSwgcykge1xuICAgIHJldHVybiAnd2l0aCh0aGlzWycgKyBpICsgJ10peycgKyBzICsgJ30nO1xufTtcblxudGVtcGxleC5jYWNoZSA9IFtdO1xuXG50ZW1wbGV4LmRlcmVmID0gZnVuY3Rpb24gKGtleSkge1xuICAgIGlmICghKHRoaXMubGVuZ3RoIGluIHRlbXBsZXguY2FjaGUpKSB7XG4gICAgICAgIHZhciBjb2RlID0gJ3JldHVybiBldmFsKGV4cHIpJztcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvZGUgPSB0ZW1wbGV4LndpdGgoaSwgY29kZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0ZW1wbGV4LmNhY2hlW3RoaXMubGVuZ3RoXSA9IGV2YWwoJyhmdW5jdGlvbihleHByKXsnICsgY29kZSArICd9KScpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWV2YWxcbiAgICB9XG4gICAgcmV0dXJuIHRlbXBsZXguY2FjaGVbdGhpcy5sZW5ndGhdLmNhbGwodGhpcywga2V5KTtcbn07XG5cbnRlbXBsZXgubWVyZ2VyID0gZnVuY3Rpb24gKG1hdGNoLCBrZXkpIHtcbiAgICAvLyBBZHZhbmNlZCBmZWF0dXJlczogQ29udGV4dCBjYW4gYmUgYSBsaXN0IG9mIGNvbnRleHRzIHdoaWNoIGFyZSBzZWFyY2hlZCBpbiBvcmRlci5cbiAgICB2YXIgcmVwbGFjZW1lbnQ7XG5cbiAgICB0cnkge1xuICAgICAgICByZXBsYWNlbWVudCA9IGlzTmFOKGtleSkgPyB0ZW1wbGV4LmRlcmVmLmNhbGwodGhpcywga2V5KSA6IHRoaXNbMF1ba2V5XTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlcGxhY2VtZW50ID0gJ3snICsga2V5ICsgJ30nO1xuICAgIH1cblxuICAgIHJldHVybiByZXBsYWNlbWVudDtcbn07XG5cbi8vIHRoaXMgaW50ZXJmYWNlIGNvbnNpc3RzIHNvbGVseSBvZiB0aGUgdGVtcGxleCBmdW5jdGlvbiAoYW5kIGl0J3MgcHJvcGVydGllcylcbm1vZHVsZS5leHBvcnRzID0gdGVtcGxleDtcbiIsIi8vIENyZWF0ZWQgYnkgSm9uYXRoYW4gRWl0ZW4gb24gMS83LzE2LlxuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVmVyeSBmYXN0IGFycmF5IHRlc3QuXG4gKiBGb3IgY3Jvc3MtZnJhbWUgc2NyaXB0aW5nOyB1c2UgYGNyb3NzRnJhbWVzSXNBcnJheWAgaW5zdGVhZC5cbiAqIEBwYXJhbSB7Kn0gYXJyIC0gVGhlIG9iamVjdCB0byB0ZXN0LlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbnVuc3RydW5naWZ5LmlzQXJyYXkgPSBmdW5jdGlvbihhcnIpIHsgcmV0dXJuIGFyci5jb25zdHJ1Y3RvciA9PT0gQXJyYXk7IH07XG5cbi8qKlxuICogQHN1bW1hcnkgV2FsayBhIGhpZXJhcmNoaWNhbCBvYmplY3QgYXMgSlNPTi5zdHJpbmdpZnkgZG9lcyBidXQgd2l0aG91dCBzZXJpYWxpemluZy5cbiAqXG4gKiBAZGVzYyBVc2FnZTpcbiAqICogdmFyIG15RGlzdGlsbGVkT2JqZWN0ID0gdW5zdHJ1bmdpZnkuY2FsbChteU9iamVjdCk7XG4gKiAqIHZhciBteURpc3RpbGxlZE9iamVjdCA9IG15QXBpLmdldFN0YXRlKCk7IC8vIHdoZXJlIG15QXBpLnByb3RvdHlwZS5nZXRTdGF0ZSA9IHVuc3RydW5naWZ5XG4gKlxuICogUmVzdWx0IGVxdWl2YWxlbnQgdG8gYEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodGhpcykpYC5cbiAqXG4gKiA+IERvIG5vdCB1c2UgdGhpcyBmdW5jdGlvbiB0byBnZXQgYSBKU09OIHN0cmluZzsgdXNlIGBKU09OLnN0cmluZ2lmeSh0aGlzKWAgaW5zdGVhZC5cbiAqXG4gKiBAdGhpcyB7KnxvYmplY3R8KltdfSAtIE9iamVjdCB0byB3YWxrOyB0eXBpY2FsbHkgYW4gb2JqZWN0IG9yIGFycmF5LlxuICpcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubnVsbEVsZW1lbnRzPT1mYWxzZV0gLSBQcmVzZXJ2ZSB1bmRlZmluZWQgYXJyYXkgZWxlbWVudHMgYXMgYG51bGxgcy5cbiAqIFVzZSB0aGlzIHdoZW4gcHJlY2lzZSBpbmRleCBtYXR0ZXJzIChub3QgbWVyZWx5IHRoZSBvcmRlciBvZiB0aGUgZWxlbWVudHMpLlxuICpcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubnVsbFByb3BlcnRpZXM9PWZhbHNlXSAtIFByZXNlcnZlIHVuZGVmaW5lZCBvYmplY3QgcHJvcGVydGllcyBhcyBgbnVsbGBzLlxuICpcbiAqIEByZXR1cm5zIHtvYmplY3R9IC0gRGlzdGlsbGVkIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gdW5zdHJ1bmdpZnkob3B0aW9ucykge1xuICAgIHZhciBjbG9uZSwgcHJlc2VydmUsXG4gICAgICAgIG9iamVjdCA9ICh0eXBlb2YgdGhpcy50b0pTT04gPT09ICdmdW5jdGlvbicpID8gdGhpcy50b0pTT04oKSA6IHRoaXM7XG5cbiAgICBpZiAodW5zdHJ1bmdpZnkuaXNBcnJheShvYmplY3QpKSB7XG4gICAgICAgIGNsb25lID0gW107XG4gICAgICAgIHByZXNlcnZlID0gb3B0aW9ucyAmJiBvcHRpb25zLm51bGxFbGVtZW50cztcbiAgICAgICAgb2JqZWN0LmZvckVhY2goZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB1bnN0cnVuZ2lmeS5jYWxsKG9iaik7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNsb25lLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwcmVzZXJ2ZSkge1xuICAgICAgICAgICAgICAgIGNsb25lLnB1c2gobnVsbCk7IC8vIHVuZGVmaW5lZCBub3QgYSB2YWxpZCBKU09OIHZhbHVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSAgaWYgKHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGNsb25lID0ge307XG4gICAgICAgIHByZXNlcnZlID0gb3B0aW9ucyAmJiBvcHRpb25zLm51bGxQcm9wZXJ0aWVzO1xuICAgICAgICBPYmplY3Qua2V5cyhvYmplY3QpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBvYmplY3Rba2V5XTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB1bnN0cnVuZ2lmeS5jYWxsKG9iamVjdFtrZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY2xvbmVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwcmVzZXJ2ZSkge1xuICAgICAgICAgICAgICAgIGNsb25lW2tleV0gPSBudWxsOyAvLyB1bmRlZmluZWQgbm90IGEgdmFsaWQgSlNPTiB2YWx1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjbG9uZSA9IG9iamVjdDtcbiAgICB9XG5cbiAgICByZXR1cm4gY2xvbmU7XG59XG5cbi8qKlxuICogVmVyeSBzbG93IGFycmF5IHRlc3QuIFN1aXRhYmxlIGZvciBjcm9zcy1mcmFtZSBzY3JpcHRpbmcuXG4gKlxuICogU3VnZ2VzdGlvbjogSWYgeW91IG5lZWQgdGhpcyBhbmQgaGF2ZSBqUXVlcnkgbG9hZGVkLCB1c2UgYGpRdWVyeS5pc0FycmF5YCBpbnN0ZWFkIHdoaWNoIGlzIHJlYXNvbmFibHkgZmFzdC5cbiAqXG4gKiBAcGFyYW0geyp9IGFyciAtIFRoZSBvYmplY3QgdG8gdGVzdC5cbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG51bnN0cnVuZ2lmeS5jcm9zc0ZyYW1lc0lzQXJyYXkgPSBmdW5jdGlvbihhcnIpIHsgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJyKSA9PT0gYXJyU3RyaW5nOyB9OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcsIGFyclN0cmluZyA9ICdbb2JqZWN0IEFycmF5XSc7XG5cbm1vZHVsZS5leHBvcnRzID0gdW5zdHJ1bmdpZnk7XG4iLCIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5yZXF1aXJlKCcuL2xpYi9wb2x5ZmlsbHMnKTsgLy8gSW5zdGFsbHMgbWlzYy4gcG9seWZpbGxzIGludG8gZ2xvYmFsIG9iamVjdHMsIGFzIG5lZWRlZFxuXG52YXIgRmluQmFyID0gcmVxdWlyZSgnZmluYmFycycpO1xudmFyIENhbnZhcyA9IHJlcXVpcmUoJ2ZpbmNhbnZhcycpO1xudmFyIFBvaW50ID0gcmVxdWlyZSgncmVjdGFuZ3VsYXInKS5Qb2ludDtcbnZhciBSZWN0YW5nbGUgPSByZXF1aXJlKCdyZWN0YW5ndWxhcicpLlJlY3RhbmdsZTtcbnZhciBfID0gcmVxdWlyZSgnb2JqZWN0LWl0ZXJhdG9ycycpOyAvLyBmeWk6IGluc3RhbGxzIHRoZSBBcnJheS5wcm90b3R5cGUuZmluZCBwb2x5ZmlsbCwgYXMgbmVlZGVkXG5cbnZhciBkZXByZWNhdGVkID0gcmVxdWlyZSgnLi9saWIvZGVwcmVjYXRlZCcpO1xudmFyIGRlZmF1bHRzID0gcmVxdWlyZSgnLi9kZWZhdWx0cycpO1xudmFyIFJlbmRlcmVyID0gcmVxdWlyZSgnLi9saWIvUmVuZGVyZXInKTtcbnZhciBTZWxlY3Rpb25Nb2RlbCA9IHJlcXVpcmUoJy4vbGliL1NlbGVjdGlvbk1vZGVsJyk7XG52YXIgc3R5bGVzaGVldCA9IHJlcXVpcmUoJy4vbGliL3N0eWxlc2hlZXQnKTtcbnZhciBMb2NhbGl6YXRpb24gPSByZXF1aXJlKCcuL2xpYi9Mb2NhbGl6YXRpb24nKTtcbnZhciBiZWhhdmlvcnMgPSByZXF1aXJlKCcuL2JlaGF2aW9ycycpO1xudmFyIENlbGxSZW5kZXJlcnMgPSByZXF1aXJlKCcuL2NlbGxSZW5kZXJlcnMnKTtcbnZhciBDZWxsRWRpdG9ycyA9IHJlcXVpcmUoJy4vY2VsbEVkaXRvcnMnKTtcblxudmFyIHRoZW1lSW5pdGlhbGl6ZWQgPSBmYWxzZSxcbiAgICBwb2x5bWVyVGhlbWUgPSBPYmplY3QuY3JlYXRlKGRlZmF1bHRzKSxcbiAgICBnbG9iYWxQcm9wZXJ0aWVzID0gT2JqZWN0LmNyZWF0ZShwb2x5bWVyVGhlbWUpO1xuXG4vKipzXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7c3RyaW5nfEVsZW1lbnR9IGRpdiAtIENTUyBzZWxlY3RvciBvciBFbGVtZW50XG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbb3B0aW9ucy5CZWhhdmlvcj1iZWhhdmlvcnMuSlNPTl0gLSBBIGJlaGF2aW9yIGNvbnN0cnVjdG9yLlxuICogQHBhcmFtIHtmdW5jdGlvbnxvYmplY3RbXX0gW29wdGlvbnMuZGF0YV0gLSBQYXNzZWQgdG8gYmVoYXZpb3IgY29uc3RydWN0b3IuIE1heSBiZTpcbiAqICogQW4gYXJyYXkgb2YgY29uZ3J1ZW50IHJhdyBkYXRhIG9iamVjdHNcbiAqICogQSBmdW5jdGlvbiByZXR1cm5pbmcgc2FtZVxuICogQHBhcmFtIHtmdW5jdGlvbnxtZW51SXRlbVtdfSBbb3B0aW9ucy5zY2hlbWE9ZGVyaXZlZFNjaGVtYV0gLSBQYXNzZWQgdG8gYmVoYXZpb3IgY29uc3RydWN0b3IuIE1heSBiZTpcbiAqICogQSBzY2hlbWEgYXJyYXlcbiAqICogQSBmdW5jdGlvbiByZXR1cm5pbmcgYSBzY2hlbWEgYXJyYXkuIENhbGxlZCBhdCBmaWx0ZXIgcmVzZXQgdGltZSB3aXRoIGJlaGF2aW9yIGFzIGNvbnRleHQuXG4gKiAqIE9taXQgdG8gZ2VuZXJhdGUgYSBiYXNpYyBzY2hlbWEgZnJvbSBgdGhpcy5iZWhhdmlvci5jb2x1bW5zYC5cbiAqIEBwYXJhbSB7QmVoYXZpb3J9IFtvcHRpb25zLkJlaGF2aW9yPUpTT05dIC0gQSBncmlkIGJlaGF2aW9yIChkZXNjZW5kYW50IG9mIEJlaGF2aW9yIFwiY2xhc3NcIikuIFdpbGwgYmUgdXNlZCBpZiBgZ2V0QmVoYXZpb3JgIG9taXR0ZWQsIGluIHdoaWNoIGNhc2UgYG9wdGlvbnMuZGF0YWAgKHdoaWNoIGhhcyBubyBkZWZhdWx0KSAqbXVzdCogYWxzbyBiZSBwcm92aWRlZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5sb2NhbGl6YXRpb249SHlwZXJncmlkLmxvY2FsaXphdGlvbl1cbiAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBbb3B0aW9ucy5sb2NhbGl6YXRpb24ubG9jYWxlPUh5cGVyZ3JpZC5sb2NhbGl6YXRpb24ubG9jYWxlXSAtIFRoZSBkZWZhdWx0IGxvY2FsZSB0byB1c2Ugd2hlbiBhbiBleHBsaWNpdCBgbG9jYWxlYCBpcyBvbWl0dGVkIGZyb20gbG9jYWxpemVyIGNvbnN0cnVjdG9yIGNhbGxzLiBQYXNzZWQgdG8gSW50bC5OdW1iZXJGb21yYXRgIGFuZCBgSW50bC5EYXRlRm9tcmF0YC4gU2VlIHtAIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0ludGwjTG9jYWxlX2lkZW50aWZpY2F0aW9uX2FuZF9uZWdvdGlhdGlvbnxMb2NhbGUgaWRlbnRpZmljYXRpb24gYW5kIG5lZ290aWF0aW9ufSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5sb2NhbGl6YXRpb24ubnVtYmVyT3B0aW9ucz1IeXBlcmdyaWQubG9jYWxpemF0aW9uLm51bWJlck9wdGlvbnNdIC0gT3B0aW9ucyBwYXNzZWQgdG8gYEludGwuTnVtYmVyRm9tcmF0YCBmb3IgY3JlYXRpbmcgdGhlIGJhc2ljIFwibnVtYmVyXCIgbG9jYWxpemVyLlxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmxvY2FsaXphdGlvbi5kYXRlT3B0aW9ucz1IeXBlcmdyaWQubG9jYWxpemF0aW9uLmRhdGVPcHRpb25zXSAtIE9wdGlvbnMgcGFzc2VkIHRvIGBJbnRsLkRhdGVGb21yYXRgIGZvciBjcmVhdGluZyB0aGUgYmFzaWMgXCJkYXRlXCIgbG9jYWxpemVyLlxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zLm1hcmdpbl0gLSBvcHRpb25hbCBjYW52YXMgbWFyZ2luc1xuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLm1hcmdpbi50b3A9MF1cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5tYXJnaW4ucmlnaHQ9Jy0yMDBweCddXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubWFyZ2luLmJvdHRvbT0wXVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLm1hcmdpbi5sZWZ0PTBdXG4gKi9cbmZ1bmN0aW9uIEh5cGVyZ3JpZChkaXYsIG9wdGlvbnMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB0aGlzLmRpdiA9ICh0eXBlb2YgZGl2ID09PSAnc3RyaW5nJykgPyBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGRpdikgOiBkaXY7XG5cbiAgICBzdHlsZXNoZWV0LmluamVjdCgnZ3JpZCcpO1xuXG4gICAgdGhpcy5sYXN0RWRnZVNlbGVjdGlvbiA9IFswLCAwXTtcblxuICAgIHRoaXMubG5mUHJvcGVydGllcyA9IE9iamVjdC5jcmVhdGUoZ2xvYmFsUHJvcGVydGllcyk7XG5cbiAgICB0aGlzLmlzV2Via2l0ID0gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ3dlYmtpdCcpID4gLTE7XG4gICAgdGhpcy5zZWxlY3Rpb25Nb2RlbCA9IG5ldyBTZWxlY3Rpb25Nb2RlbCh0aGlzKTtcbiAgICB0aGlzLnJlbmRlck92ZXJyaWRlc0NhY2hlID0ge307XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgZGF0YSA9IHR5cGVvZiBvcHRpb25zLmRhdGEgPT09ICdmdW5jdGlvbicgPyBvcHRpb25zLmRhdGEoKSA6IG9wdGlvbnMuZGF0YTtcbiAgICB2YXIgQmVoYXZpb3IgPSBvcHRpb25zLkJlaGF2aW9yIHx8IGJlaGF2aW9ycy5KU09OO1xuICAgIHRoaXMuYmVoYXZpb3IgPSBuZXcgQmVoYXZpb3IodGhpcywgb3B0aW9ucy5zY2hlbWEsIGRhdGEpO1xuXG4gICAgdmFyIGxvYyA9IG9wdGlvbnMubG9jYWxpemF0aW9uIHx8IHt9O1xuICAgIHRoaXMubG9jYWxpemF0aW9uID0gbmV3IExvY2FsaXphdGlvbihcbiAgICAgICAgbG9jLmxvY2FsZSB8fCBIeXBlcmdyaWQubG9jYWxpemF0aW9uLmxvY2FsZSxcbiAgICAgICAgbG9jLm51bWJlck9wdGlvbnMgfHwgSHlwZXJncmlkLmxvY2FsaXphdGlvbi5udW1iZXJPcHRpb25zLFxuICAgICAgICBsb2MuZGF0ZU9wdGlvbnMgfHwgSHlwZXJncmlkLmxvY2FsaXphdGlvbi5kYXRlT3B0aW9uc1xuICAgICk7XG5cbiAgICAvL3ByZXZlbnQgdGhlIGRlZmF1bHQgY29udGV4dCBtZW51IGZvciBhcHBlYXJpbmdcbiAgICB0aGlzLmRpdi5vbmNvbnRleHRtZW51ID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICB0aGlzLmNsZWFyTW91c2VEb3duKCk7XG4gICAgdGhpcy5kcmFnRXh0ZW50ID0gbmV3IFBvaW50KDAsIDApO1xuICAgIHRoaXMubnVtUm93cyA9IDA7XG4gICAgdGhpcy5udW1Db2x1bW5zID0gMDtcblxuICAgIC8vaW5zdGFsbCBhbnkgcGx1Z2luc1xuICAgIHRoaXMucGx1Z2luc0RvKGZ1bmN0aW9uKGVhY2gpIHtcbiAgICAgICAgaWYgKGVhY2guaW5zdGFsbE9uKSB7XG4gICAgICAgICAgICBlYWNoLmluc3RhbGxPbihzZWxmKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIG1hcmdpbiA9IG9wdGlvbnMubWFyZ2luIHx8IHt9O1xuICAgIG1hcmdpbi50b3AgPSBtYXJnaW4udG9wIHx8IDA7XG4gICAgbWFyZ2luLnJpZ2h0ID0gbWFyZ2luLnJpZ2h0IHx8ICctMjAwcHgnO1xuICAgIG1hcmdpbi5ib3R0b20gPSBtYXJnaW4uYm90dG9tIHx8IDA7XG4gICAgbWFyZ2luLmxlZnQgPSBtYXJnaW4ubGVmdCB8fCAwO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0NlbGxSZW5kZXJlcnN9XG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICB0aGlzLmNlbGxSZW5kZXJlcnMgPSBuZXcgQ2VsbFJlbmRlcmVycygpO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0NlbGxFZGl0b3JzfVxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICovXG4gICAgdGhpcy5jZWxsRWRpdG9ycyA9IG5ldyBDZWxsRWRpdG9ycyh0aGlzKTtcblxuICAgIHRoaXMuYWxsb3dFdmVudEhhbmRsZXJzID0gdHJ1ZTtcblxuICAgIC8vaW5pdGlhbGl6ZSBvdXIgdmFyaW91cyBwaWVjZXNcbiAgICBpZiAoIXRoZW1lSW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgdGhlbWVJbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgIGJ1aWxkUG9seW1lclRoZW1lKCk7XG4gICAgfVxuICAgIHRoaXMuaW5pdFJlbmRlcmVyKCk7XG4gICAgdGhpcy5pbml0Q2FudmFzKG1hcmdpbik7XG4gICAgdGhpcy5pbml0U2Nyb2xsYmFycygpO1xuXG4gICAgLy9SZWdpc3RlciBhIGxpc3RlbmVyIGZvciB0aGUgY29weSBldmVudCBzbyB3ZSBjYW4gY29weSBvdXIgc2VsZWN0ZWQgcmVnaW9uIHRvIHRoZSBwYXN0ZWJ1ZmZlciBpZiBjb25kaXRpb25zIGFyZSByaWdodC5cbiAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ2NvcHknLCBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgc2VsZi5jaGVja0NsaXBib2FyZENvcHkoZXZ0KTtcbiAgICB9KTtcbiAgICB0aGlzLmdldENhbnZhcygpLnJlc2l6ZSgpO1xufVxuXG5IeXBlcmdyaWQucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBIeXBlcmdyaWQucHJvdG90eXBlLmNvbnN0cnVjdG9yLFxuXG4gICAgZGVwcmVjYXRlZDogZGVwcmVjYXRlZCxcbiAgICByZWdpc3RlckNlbGxFZGl0b3I6IGZ1bmN0aW9uKENvbnN0cnVjdG9yLCBuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlcHJlY2F0ZWQoJ3JlZ2lzdGVyQ2VsbEVkaXRvcihDb25zdHJ1Y3RvciwgbmFtZSknLCAnY2VsbEVkaXRvcnMuYWRkKG5hbWUsIENvbnN0cnVjdG9yKScsICcxLjAuNicsIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBjcmVhdGVDZWxsRWRpdG9yOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlcHJlY2F0ZWQoJ2NyZWF0ZUNlbGxFZGl0b3IobmFtZSknLCAnY2VsbEVkaXRvcnMuY3JlYXRlKG5hbWUpJywgJzEuMC42JywgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIGdldENlbGxQcm92aWRlcjogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZXByZWNhdGVkKCdnZXRDZWxsUHJvdmlkZXIoKScsICdjZWxsUmVuZGVyZXJzJywgJzEuMC42JywgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIHJlZ2lzdGVyTG9jYWxpemVyOiBmdW5jdGlvbihuYW1lLCBsb2NhbGl6ZXIsIGJhc2VDbGFzc05hbWUsIG5ld0NsYXNzTmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZXByZWNhdGVkKCdyZWdpc3RlckxvY2FsaXplcihuYW1lLCBsb2NhbGl6ZXIsIGJhc2VDbGFzc05hbWUsIG5ld0NsYXNzTmFtZSknLCAnbG9jYWxpemF0aW9uLmFkZChuYW1lLCBsb2NhbGl6ZXIpJywgJzEuMC42JywgYXJndW1lbnRzLFxuICAgICAgICAgICAgJ1NUUlVDVFVSQUwgQ0hBTkdFOiBObyBsb25nZXIgc3VwcG9ydHMgZGVyaXZpbmcgYW5kIHJlZ2lzdGVyaW5nIGEgbmV3IGNlbGwgZWRpdG9yIGNsYXNzLiBVc2UgLmNlbGxFZGl0b3JzLmdldChiYXNlQ2xhc3NOYW1lKS5leHRlbmQobmV3Q2xhc3NOYW1lIHx8IG5hbWUsIHsuLi59KSBmb3IgdGhhdC4nKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBBIG51bGwgb2JqZWN0IGJlaGF2aW9yIHNlcnZlcyBhcyBhIHBsYWNlIGhvbGRlci5cbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICovXG4gICAgYmVoYXZpb3I6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBDYWNoZWQgcmVzdWxhbn1cbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGlzV2Via2l0OiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogVGhlIHBpeGVsIGxvY2F0aW9uIG9mIGFuIGluaXRpYWwgbW91c2Vkb3duIGNsaWNrLCBlaXRoZXIgZm9yIGVkaXRpbmcgYSBjZWxsIG9yIGZvciBkcmFnZ2luZyBhIHNlbGVjdGlvbi5cbiAgICAgKiBAdHlwZSB7UG9pbnR9XG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBtb3VzZURvd246IFtdLFxuXG4gICAgLyoqXG4gICAgICogVGhlIGV4dGVudCBmcm9tIHRoZSBtb3VzZWRvd24gcG9pbnQgZHVyaW5nIGEgZHJhZyBvcGVyYXRpb24uXG4gICAgICogQHR5cGUge1BvaW50fVxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICovXG5cbiAgICBkcmFnRXh0ZW50OiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogQSBmbG9hdCB2YWx1ZSBiZXR3ZWVuIDAuMCAtIDEuMCBvZiB0aGUgdmVydGljYWwgc2Nyb2xsIHBvc2l0aW9uLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICB2U2Nyb2xsVmFsdWU6IDAsXG5cbiAgICAvKipcbiAgICAgKiBBIGZsb2F0IHZhbHVlIGJldHdlZW4gMC4wIC0gMS4wIG9mIHRoZSBob3Jpem9udGFsIHNjcm9sbCBwb3NpdGlvbi5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICovXG4gICAgaFNjcm9sbFZhbHVlOiAwLFxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtmaW4taHlwZXJncmlkLXNlbGVjdGlvbi1tb2RlbH0gc2VsZWN0aW9uTW9kZWwgLSBBIFtmaW4taHlwZXJncmlkLXNlbGVjdGlvbi1tb2RlbF0obW9kdWxlLS5fc2VsZWN0aW9uLW1vZGVsLmh0bWwpIGluc3RhbmNlLlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICovXG4gICAgc2VsZWN0aW9uTW9kZWw6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge2Zpbi1oeXBlcmdyaWQtY2VsbC1lZGl0b3J9IGNlbGxFZGl0b3IgLSBUaGUgY3VycmVudCBpbnN0YW5jZSBvZiBbZmluLWh5cGVyZ3JpZC1jZWxsLWVkaXRvcl0obW9kdWxlLWNlbGwtZWRpdG9yc19iYXNlLmh0bWwpLlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICovXG4gICAgY2VsbEVkaXRvcjogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7ZmluLXZhbXBpcmUtYmFyfSBzYkhTY3JvbGxlciAtIEFuIGluc3RhbmNlIG9mIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vb3BlbmZpbi9maW5iYXJzfEZpbkJhcn0uXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBzYkhTY3JvbGxlcjogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7ZmluLXZhbXBpcmUtYmFyfSBzYlZTY3JvbGxlciAtIEFuIGluc3RhbmNlIG9mIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vb3BlbmZpbi9maW5iYXJzfEZpbkJhcn0uXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBzYlZTY3JvbGxlcjogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFRoZSBwcmV2aW91cyB2YWx1ZSBvZiBzYlZTY3JvbGxWYWwuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHNiUHJldlZTY3JvbGxWYWx1ZTogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFRoZSBwcmV2aW91cyB2YWx1ZSBvZiBzYkhTY3JvbGxWYWx1ZS5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICovXG4gICAgc2JQcmV2SFNjcm9sbFZhbHVlOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogaXMgdGhlIHNob3J0IHRlcm0gbWVtb3J5IG9mIHdoYXQgY29sdW1uIEkgbWlnaHQgYmUgZHJhZ2dpbmcgYXJvdW5kXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqL1xuXG4gICAgcmVuZGVyT3ZlcnJpZGVzQ2FjaGU6IHt9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIHBpeGVsIGxvY2F0aW9uIG9mIHRoZSBjdXJyZW50IGhvdmVyZWQgY2VsbC5cbiAgICAgKiBAdHlwZSB7UG9pbnR9XG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBob3ZlckNlbGw6IG51bGwsXG5cbiAgICBzY3JvbGxpbmdOb3c6IGZhbHNlLFxuXG4gICAgbGFzdEVkZ2VTZWxlY3Rpb246IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgIGNsZWFyIG91dCB0aGUgTFJVIGNhY2hlIG9mIHRleHQgd2lkdGhzXG4gICAgICovXG4gICAgc2V0QXR0cmlidXRlOiBmdW5jdGlvbihhdHRyaWJ1dGUsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZGl2LnNldEF0dHJpYnV0ZShhdHRyaWJ1dGUsIHZhbHVlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICBjbGVhciBvdXQgYWxsIHN0YXRlIGFuZCBkYXRhIG9mIHRoZSBncmlkXG4gICAgICovXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmxhc3RFZGdlU2VsZWN0aW9uID0gWzAsIDBdO1xuICAgICAgICB0aGlzLmxuZlByb3BlcnRpZXMgPSBPYmplY3QuY3JlYXRlKGdsb2JhbFByb3BlcnRpZXMpO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbk1vZGVsID0gbmV3IFNlbGVjdGlvbk1vZGVsKHRoaXMpO1xuICAgICAgICB0aGlzLnJlbmRlck92ZXJyaWRlc0NhY2hlID0ge307XG4gICAgICAgIHRoaXMuY2xlYXJNb3VzZURvd24oKTtcbiAgICAgICAgdGhpcy5kcmFnRXh0ZW50ID0gbmV3IFBvaW50KDAsIDApO1xuXG4gICAgICAgIHRoaXMubnVtUm93cyA9IDA7XG4gICAgICAgIHRoaXMubnVtQ29sdW1ucyA9IDA7XG5cbiAgICAgICAgdGhpcy52U2Nyb2xsVmFsdWUgPSAwO1xuICAgICAgICB0aGlzLmhTY3JvbGxWYWx1ZSA9IDA7XG5cbiAgICAgICAgdGhpcy5jZWxsRWRpdG9yID0gbnVsbDtcblxuICAgICAgICB0aGlzLnNiUHJldlZTY3JvbGxWYWx1ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuc2JQcmV2SFNjcm9sbFZhbHVlID0gbnVsbDtcblxuICAgICAgICB0aGlzLmhvdmVyQ2VsbCA9IG51bGw7XG4gICAgICAgIHRoaXMuc2Nyb2xsaW5nTm93ID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGFzdEVkZ2VTZWxlY3Rpb24gPSBbMCwgMF07XG5cbiAgICAgICAgdGhpcy5iZWhhdmlvci5yZXNldCgpO1xuICAgICAgICB0aGlzLmdldFJlbmRlcmVyKCkucmVzZXQoKTtcbiAgICAgICAgdGhpcy5nZXRDYW52YXMoKS5yZXNpemUoKTtcbiAgICAgICAgdGhpcy5iZWhhdmlvckNoYW5nZWQoKTtcbiAgICB9LFxuXG4gICAgLy9yZXNldFRleHRXaWR0aENhY2hlOiBmdW5jdGlvbigpIHtcbiAgICAvLyAgICB0ZXh0V2lkdGhDYWNoZSA9IG5ldyBMUlVDYWNoZSgyMDAwKTtcbiAgICAvL30sXG5cbiAgICBnZXRQcm9wZXJ0aWVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UHJpdmF0ZVN0YXRlKCk7XG4gICAgfSxcblxuICAgIF9nZXRQcm9wZXJ0aWVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG5mUHJvcGVydGllcztcbiAgICB9LFxuXG4gICAgY29tcHV0ZUNlbGxzQm91bmRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJlbmRlcmVyID0gdGhpcy5nZXRSZW5kZXJlcigpO1xuICAgICAgICBpZiAocmVuZGVyZXIpIHtcbiAgICAgICAgICAgIHJlbmRlcmVyLmNvbXB1dGVDZWxsc0JvdW5kcygpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFRoZSBwb2ludGVyIGlzIG92ZXIgdGhlIGdpdmVuIGNlbGwuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgeCBjZWxsIGNvb3JkaW5hdGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSBUaGUgeSBjZWxsIGNvb3JkaW5hdGUuXG4gICAgICovXG4gICAgaXNIb3ZlcmVkOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHZhciBwID0gdGhpcy5nZXRIb3ZlckNlbGwoKTtcbiAgICAgICAgcmV0dXJuIHAgJiYgcC54ID09PSB4ICYmIHAueSA9PT0geTtcbiAgICB9LFxuXG4gICAgZ2V0Rm9ybWF0dGVyOiBmdW5jdGlvbihsb2NhbGl6ZXJOYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsaXphdGlvbi5nZXQobG9jYWxpemVyTmFtZSkuZm9ybWF0O1xuICAgIH0sXG5cbiAgICBmb3JtYXRWYWx1ZTogZnVuY3Rpb24obG9jYWxpemVyTmFtZSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGZvcm1hdHRlciA9IHRoaXMuZ2V0Rm9ybWF0dGVyKGxvY2FsaXplck5hbWUpO1xuICAgICAgICByZXR1cm4gZm9ybWF0dGVyKHZhbHVlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyBib29sZWFufSBUaGUgcG9pbnRlciBpcyBob3ZlcmluZyBvdmVyIHRoZSBnaXZlbiBjb2x1bW4uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgaG9yaXpvbnRhbCBjZWxsIGNvb3JkaW5hdGUuXG4gICAgICovXG4gICAgaXNDb2x1bW5Ib3ZlcmVkOiBmdW5jdGlvbih4KSB7XG4gICAgICAgIHZhciBwID0gdGhpcy5nZXRIb3ZlckNlbGwoKTtcbiAgICAgICAgcmV0dXJuIHAgJiYgcC54ID09PSB4O1xuICAgIH0sXG5cbiAgICBpc1Jvd1Jlc2l6ZWFibGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNvbHZlUHJvcGVydHkoJ3Jvd1Jlc2l6ZScpO1xuICAgIH0sXG5cbiAgICBpc0NoZWNrYm94T25seVJvd1NlbGVjdGlvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNvbHZlUHJvcGVydHkoJ2NoZWNrYm94T25seVJvd1NlbGVjdGlvbnMnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUaGUgcG9pbnRlciBpcyBob3ZlcmluZyBvdmVyIHRoZSByb3cgYHlgLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gVGhlIHZlcnRpY2FsIGNlbGwgY29vcmRpbmF0ZS5cbiAgICAgKi9cbiAgICBpc1Jvd0hvdmVyZWQ6IGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgdmFyIHAgPSB0aGlzLmdldEhvdmVyQ2VsbCgpO1xuICAgICAgICByZXR1cm4gcCAmJiBwLnkgPT09IHk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge1BvaW50fSBUaGUgY2VsbCBvdmVyIHdoaWNoIHRoZSBjdXJzb3IgaXMgaG92ZXJpbmcuXG4gICAgICovXG4gICAgZ2V0SG92ZXJDZWxsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaG92ZXJDZWxsO1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgU2V0IHRoZSBjZWxsIHVuZGVyIHRoZSBjdXJzb3IuXG4gICAgICogQHBhcmFtIHtQb2ludH0gcG9pbnRcbiAgICAgKi9cbiAgICBzZXRIb3ZlckNlbGw6IGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXMuaG92ZXJDZWxsO1xuICAgICAgICB2YXIgbmV3UG9pbnQgPSBuZXcgUG9pbnQocG9pbnQueCwgcG9pbnQueSk7XG4gICAgICAgIGlmIChtZSAmJiBtZS5lcXVhbHMobmV3UG9pbnQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ob3ZlckNlbGwgPSBuZXdQb2ludDtcbiAgICAgICAgdGhpcy5maXJlU3ludGhldGljT25DZWxsRW50ZXJFdmVudChuZXdQb2ludCk7XG4gICAgICAgIHRoaXMucmVwYWludCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIEFtbWVuZCBwcm9wZXJ0aWVzIGZvciBhbGwgaHlwZXJncmlkcyBpbiB0aGlzIHByb2Nlc3MuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHByb3BlcnRpZXMgLSBBIHNpbXBsZSBwcm9wZXJ0aWVzIGhhc2guXG4gICAgICovXG4gICAgYWRkR2xvYmFsUHJvcGVydGllczogZnVuY3Rpb24ocHJvcGVydGllcykge1xuICAgICAgICAvL3dlIGNoZWNrIGZvciBleGlzdGVuY2UgdG8gYXZvaWQgcmFjZSBjb25kaXRpb24gaW4gaW5pdGlhbGl6YXRpb25cbiAgICAgICAgaWYgKCFnbG9iYWxQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHNlbGYuYWRkR2xvYmFsUHJvcGVydGllcyhwcm9wZXJ0aWVzKTtcbiAgICAgICAgICAgIH0sIDEwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2FkZEdsb2JhbFByb3BlcnRpZXMocHJvcGVydGllcyk7XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIEFtbWVuZCBwcm9wZXJ0aWVzIGZvciBhbGwgaHlwZXJncmlkcyBpbiB0aGlzIHByb2Nlc3MuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHByb3BlcnRpZXMgLSBBIHNpbXBsZSBwcm9wZXJ0aWVzIGhhc2guXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYWRkR2xvYmFsUHJvcGVydGllczogZnVuY3Rpb24ocHJvcGVydGllcykge1xuICAgICAgICBfKHByb3BlcnRpZXMpLmVhY2goZnVuY3Rpb24ocHJvcGVydHksIGtleSkge1xuICAgICAgICAgICAgZ2xvYmFsUHJvcGVydGllc1trZXldID0gcHJvcGVydHk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFV0aWxpdHkgZnVuY3Rpb24gdG8gcHVzaCBvdXQgcHJvcGVydGllcyBpZiB3ZSBjaGFuZ2UgdGhlbS5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcHJvcGVydGllcyAtIEFuIG9iamVjdCBvZiB2YXJpb3VzIGtleSB2YWx1ZSBwYWlycy5cbiAgICAgKi9cblxuICAgIHJlZnJlc2hQcm9wZXJ0aWVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gdGhpcy5jYW52YXMgPSB0aGlzLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcignZmluLWNhbnZhcycpO1xuICAgICAgICAvL3RoaXMuY2FudmFzID0gbmV3IENhbnZhcyh0aGlzLmRpdkNhbnZhcywgdGhpcy5yZW5kZXJlcik7IC8vVE9ETzogRG8gd2UgcmVhbGx5IG5lZWQgdG8gYmUgcmVjcmVhdGluZyBpdCBoZXJlP1xuICAgICAgICB0aGlzLnJlbmRlcmVyLmNvbXB1dGVDZWxsc0JvdW5kcygpO1xuICAgICAgICB0aGlzLmNoZWNrU2Nyb2xsYmFyVmlzaWJpbGl0eSgpO1xuICAgICAgICB0aGlzLmJlaGF2aW9yLmRlZmF1bHRSb3dIZWlnaHQgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5pc0NvbHVtbkF1dG9zaXppbmcoKSkge1xuICAgICAgICAgICAgdGhpcy5iZWhhdmlvci5hdXRvc2l6ZUFsbENvbHVtbnMoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIEFtbWVuZCBwcm9wZXJ0aWVzIGZvciB0aGlzIGh5cGVyZ3JpZCBvbmx5LlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBtb3JlUHJvcGVydGllcyAtIEEgc2ltcGxlIHByb3BlcnRpZXMgaGFzaC5cbiAgICAgKi9cbiAgICBhZGRQcm9wZXJ0aWVzOiBmdW5jdGlvbihtb3JlUHJvcGVydGllcykge1xuICAgICAgICB2YXIgcHJvcGVydGllcyA9IHRoaXMuZ2V0UHJvcGVydGllcygpO1xuICAgICAgICBhZGREZWVwUHJvcGVydGllcyhwcm9wZXJ0aWVzLCBtb3JlUHJvcGVydGllcyk7XG4gICAgICAgIHRoaXMucmVmcmVzaFByb3BlcnRpZXMoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBUaGUgc3RhdGUgb2JqZWN0IGZvciByZW1lbWJlcmluZyBvdXIgc3RhdGUuXG4gICAgICogQHNlZSBbTWVtZW50byBwYXR0ZXJuXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01lbWVudG9fcGF0dGVybilcbiAgICAgKi9cbiAgICBnZXRQcml2YXRlU3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWhhdmlvci5nZXRQcml2YXRlU3RhdGUoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBTZXQgdGhlIHN0YXRlIG9iamVjdCB0byByZXR1cm4gdG8gdGhlIGdpdmVuIHVzZXIgY29uZmlndXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc3RhdGUgLSBBIG1lbWVudG8gb2JqZWN0LlxuICAgICAqIEBzZWUgW01lbWVudG8gcGF0dGVybl0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9NZW1lbnRvX3BhdHRlcm4pXG4gICAgICovXG4gICAgc2V0U3RhdGU6IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdGhpcy5iZWhhdmlvci5zZXRTdGF0ZShzdGF0ZSk7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzZWxmLmJlaGF2aW9yQ2hhbmdlZCgpO1xuICAgICAgICAgICAgc2VsZi5zeW5jaHJvbml6ZVNjcm9sbGluZ0JvdW5kcmllcygpO1xuICAgICAgICB9LCAxMDApO1xuICAgIH0sXG5cbiAgICBnZXRTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlaGF2aW9yLmdldFN0YXRlKCk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IFRoZSBpbml0aWFsIG1vdXNlIHBvc2l0aW9uIG9uIGEgbW91c2UgZG93biBldmVudCBmb3IgY2VsbCBlZGl0aW5nIG9yIGEgZHJhZyBvcGVyYXRpb24uXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBnZXRNb3VzZURvd246IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbGFzdCA9IHRoaXMubW91c2VEb3duLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmIChsYXN0IDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubW91c2VEb3duW2xhc3RdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFJlbW92ZSB0aGUgbGFzdCBpdGVtIGZyb20gdGhlIG1vdXNlIGRvd24gc3RhY2suXG4gICAgICovXG4gICAgcG9wTW91c2VEb3duOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMubW91c2VEb3duLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgdGhpcy5tb3VzZURvd24ubGVuZ3RoID0gdGhpcy5tb3VzZURvd24ubGVuZ3RoIC0gMTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIEVtcHR5IG91dCB0aGUgbW91c2UgZG93biBzdGFjay5cbiAgICAgKi9cbiAgICBjbGVhck1vdXNlRG93bjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMubW91c2VEb3duID0gW25ldyBQb2ludCgtMSwgLTEpXTtcbiAgICAgICAgdGhpcy5kcmFnRXh0ZW50ID0gbnVsbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBtb3VzZSBwb2ludCB0aGF0IGluaXRpYXRlZCBhIGNlbGwgZWRpdCBvciBkcmFnIG9wZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge1BvaW50fSBwb2ludFxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICovXG4gICAgc2V0TW91c2VEb3duOiBmdW5jdGlvbihwb2ludCkge1xuICAgICAgICB0aGlzLm1vdXNlRG93bi5wdXNoKHBvaW50KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7UG9pbnR9IFRoZSBleHRlbnQgcG9pbnQgb2YgdGhlIGN1cnJlbnQgZHJhZyBzZWxlY3Rpb24gcmVjdGFuZ2xlLlxuICAgICAqL1xuICAgIGdldERyYWdFeHRlbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kcmFnRXh0ZW50O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBzdW1tYXJ5IFNldCB0aGUgZXh0ZW50IHBvaW50IG9mIHRoZSBjdXJyZW50IGRyYWcgc2VsZWN0aW9uIG9wZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge1BvaW50fSBwb2ludFxuICAgICAqL1xuICAgIHNldERyYWdFeHRlbnQ6IGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgICAgIHRoaXMuZHJhZ0V4dGVudCA9IHBvaW50O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBzdW1tYXJ5IEl0ZXJhdGUgb3ZlciB0aGUgcGx1Z2lucyBpbnZva2luZyB0aGUgZ2l2ZW4gZnVuY3Rpb24gd2l0aCBlYWNoLlxuICAgICAqIEB0b2RvIFdlIG5lZWQgYSBuZXcgcGx1Z2luIG1lY2hhbmlzbSFcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmdW5jIC0gVGhlIGZ1bmN0aW9uIHRvIGludm9rZSBvbiBhbGwgdGhlIHBsdWdpbnMuXG4gICAgICovXG4gICAgcGx1Z2luc0RvOiBmdW5jdGlvbihmdW5jKSB7XG4gICAgICAgIC8vVE9ETzogV2UgbmVlZCBhIG5ldyBwbHVnaW4gbWVjaGFuaXNtIVxuICAgICAgICAvL3ZhciB1c2VyUGx1Z2lucyA9IHRoaXMuY2hpbGRyZW4uYXJyYXkoKTtcbiAgICAgICAgLy92YXIgcGx1Z2luc1RhZyA9IHRoaXMuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCdmaW4tcGx1Z2lucycpO1xuICAgICAgICAvL1xuICAgICAgICAvL3ZhciBwbHVnaW5zID0gdXNlclBsdWdpbnM7XG4gICAgICAgIC8vaWYgKHBsdWdpbnNUYWcpIHtcbiAgICAgICAgLy8gICAgdmFyIHN5c3RlbVBsdWdpbnMgPSBwbHVnaW5zVGFnLmNoaWxkcmVuLmFycmF5KCk7XG4gICAgICAgIC8vICAgIHBsdWdpbnMgPSBzeXN0ZW1QbHVnaW5zLmNvbmNhdChwbHVnaW5zKTtcbiAgICAgICAgLy99XG4gICAgICAgIC8vXG4gICAgICAgIC8vcGx1Z2lucy5mb3JFYWNoKGZ1bmN0aW9uKHBsdWdpbikge1xuICAgICAgICAvLyAgICBmdW5jKHBsdWdpbik7XG4gICAgICAgIC8vfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgVGhpcyBmdW5jdGlvbiBpcyBhIGNhbGxiYWNrIGZyb20gdGhlIEh5cGVyZ3JpZFJlbmRlcmVyIHN1Yi1jb21wb25lbnQuIEl0IGlzIGNhbGxlZCBhZnRlciBlYWNoIHBhaW50IG9mIHRoZSBjYW52YXMuXG4gICAgICovXG4gICAgZ3JpZFJlbmRlcmVkTm90aWZpY2F0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy51cGRhdGVSZW5kZXJlZFNpemVzKCk7XG4gICAgICAgIGlmICh0aGlzLmNlbGxFZGl0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuY2VsbEVkaXRvci5ncmlkUmVuZGVyZWROb3RpZmljYXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNoZWNrQ29sdW1uQXV0b3NpemluZygpO1xuICAgICAgICB0aGlzLmZpcmVTeW50aGV0aWNHcmlkUmVuZGVyZWRFdmVudCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFRoZSBncmlkIGhhcyBqdXN0IGJlZW4gcmVuZGVyZWQsIG1ha2Ugc3VyZSB0aGUgY29sdW1uIHdpZHRocyBhcmUgb3B0aW1hbC5cbiAgICAgKi9cbiAgICBjaGVja0NvbHVtbkF1dG9zaXppbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYmVoYXZpb3IgPSB0aGlzLmJlaGF2aW9yO1xuICAgICAgICBiZWhhdmlvci5hdXRvU2l6ZVJvd051bWJlckNvbHVtbigpO1xuICAgICAgICBpZiAodGhpcy5pc0NvbHVtbkF1dG9zaXppbmcoKSkge1xuICAgICAgICAgICAgYmVoYXZpb3IuY2hlY2tDb2x1bW5BdXRvc2l6aW5nKGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBOb3RpZnkgdGhlIEdyaWRCZWhhdmlvciBob3cgbWFueSByb3dzIGFuZCBjb2x1bW5zIHdlIGp1c3QgcmVuZGVyZWQuXG4gICAgICovXG4gICAgdXBkYXRlUmVuZGVyZWRTaXplczogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vYWRkIG9uZSB0byBlYWNoIG9mIHRoZXNlIHZhbHVlcyBhcyB3ZSB3YW50IGFsc28gdG8gaW5jbHVkZVxuICAgICAgICAvL3RoZSBjb2x1bW5zIGFuZCByb3dzIHRoYXQgYXJlIHBhcnRpYWxseSB2aXNpYmxlXG4gICAgICAgIHRoaXMuYmVoYXZpb3Iuc2V0UmVuZGVyZWRDb2x1bW5Db3VudCh0aGlzLmdldFZpc2libGVDb2x1bW5zKCkgKyAxKTtcbiAgICAgICAgdGhpcy5iZWhhdmlvci5zZXRSZW5kZXJlZFJvd0NvdW50KHRoaXMuZ2V0VmlzaWJsZVJvd3MoKSArIDEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBzdW1tYXJ5IENvbmRpdGlvbmFsbHkgY29weSB0byBjbGlwYm9hcmQuXG4gICAgICogQGRlc2MgSWYgd2UgaGF2ZSBmb2N1cywgY29weSBvdXIgY3VycmVudCBzZWxlY3Rpb24gZGF0YSB0byB0aGUgc3lzdGVtIGNsaXBib2FyZC5cbiAgICAgKiBAcGFyYW0ge2V2ZW50fSBldmVudCAtIFRoZSBjb3B5IHN5c3RlbSBldmVudC5cbiAgICAgKi9cbiAgICBjaGVja0NsaXBib2FyZENvcHk6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmhhc0ZvY3VzKCkpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB2YXIgY3N2RGF0YSA9IHRoaXMuZ2V0U2VsZWN0aW9uQXNUU1YoKTtcbiAgICAgICAgICAgIGV2ZW50LmNsaXBib2FyZERhdGEuc2V0RGF0YSgndGV4dC9wbGFpbicsIGNzdkRhdGEpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFdlIGhhdmUgYW55IHNlbGVjdGlvbnMuXG4gICAgICovXG4gICAgaGFzU2VsZWN0aW9uczogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5nZXRTZWxlY3Rpb25Nb2RlbCkge1xuICAgICAgICAgICAgcmV0dXJuOyAvLyB3ZXJlIG5vdCBmdWxseSBpbml0aWFsaXplZCB5ZXRcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb25Nb2RlbC5oYXNTZWxlY3Rpb25zKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge3N0cmluZ30gVGFiIHNlcGFyYXRlZCB2YWx1ZSBzdHJpbmcgZnJvbSB0aGUgc2VsZWN0aW9uIGFuZCBvdXIgZGF0YS5cbiAgICAgKi9cbiAgICBnZXRTZWxlY3Rpb25Bc1RTVjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzbSA9IHRoaXMuc2VsZWN0aW9uTW9kZWw7XG4gICAgICAgIGlmIChzbS5oYXNTZWxlY3Rpb25zKCkpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb25zID0gdGhpcy5nZXRTZWxlY3Rpb25NYXRyaXgoKTtcbiAgICAgICAgICAgIHNlbGVjdGlvbnMgPSBzZWxlY3Rpb25zW3NlbGVjdGlvbnMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRNYXRyaXhTZWxlY3Rpb25Bc1RTVihzZWxlY3Rpb25zKTtcbiAgICAgICAgfSBlbHNlIGlmIChzbS5oYXNSb3dTZWxlY3Rpb25zKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldE1hdHJpeFNlbGVjdGlvbkFzVFNWKHRoaXMuZ2V0Um93U2VsZWN0aW9uTWF0cml4KCkpO1xuICAgICAgICB9IGVsc2UgaWYgKHNtLmhhc0NvbHVtblNlbGVjdGlvbnMoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TWF0cml4U2VsZWN0aW9uQXNUU1YodGhpcy5nZXRDb2x1bW5TZWxlY3Rpb25NYXRyaXgoKSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0TWF0cml4U2VsZWN0aW9uQXNUU1Y6IGZ1bmN0aW9uKHNlbGVjdGlvbnMpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9ICcnO1xuXG4gICAgICAgIC8vb25seSB1c2UgdGhlIGRhdGEgZnJvbSB0aGUgbGFzdCBzZWxlY3Rpb25cbiAgICAgICAgaWYgKHNlbGVjdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSBzZWxlY3Rpb25zLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSBzZWxlY3Rpb25zWzBdLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBhcmVhID0gd2lkdGggKiBoZWlnaHQsXG4gICAgICAgICAgICAgICAgbGFzdENvbCA9IHdpZHRoIC0gMSxcbiAgICAgICAgICAgICAgICAvL1doaXRlc3BhY2Ugd2lsbCBvbmx5IGJlIGFkZGVkIG9uIG5vbi1zaW5ndWxhciByb3dzLCBzZWxlY3Rpb25zXG4gICAgICAgICAgICAgICAgd2hpdGVTcGFjZURlbGltaXRlckZvclJvdyA9IChoZWlnaHQgPiAxID8gJ1xcbicgOiAnJyk7XG5cbiAgICAgICAgICAgIC8vZGlzYWxsb3cgaWYgc2VsZWN0aW9uIGlzIHRvbyBiaWdcbiAgICAgICAgICAgIGlmIChhcmVhID4gMjAwMDApIHtcbiAgICAgICAgICAgICAgICBhbGVydCgnc2VsZWN0aW9uIHNpemUgaXMgdG9vIGJpZyB0byBjb3B5IHRvIHRoZSBwYXN0ZSBidWZmZXInKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1hbGVydFxuICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICh2YXIgaCA9IDA7IGggPCBoZWlnaHQ7IGgrKykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHcgPSAwOyB3IDwgd2lkdGg7IHcrKykge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gc2VsZWN0aW9uc1t3XVtoXSArICh3IDwgbGFzdENvbCA/ICdcXHQnIDogd2hpdGVTcGFjZURlbGltaXRlckZvclJvdyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gV2UgaGF2ZSBmb2N1cy5cbiAgICAgKi9cbiAgICBoYXNGb2N1czogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldENhbnZhcygpLmhhc0ZvY3VzKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgQ2xlYXIgYWxsIHRoZSBzZWxlY3Rpb25zLlxuICAgICAqL1xuICAgIGNsZWFyU2VsZWN0aW9uczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBkb250Q2xlYXJSb3dzID0gdGhpcy5pc0NoZWNrYm94T25seVJvd1NlbGVjdGlvbnMoKTtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25Nb2RlbC5jbGVhcihkb250Q2xlYXJSb3dzKTtcbiAgICAgICAgdGhpcy5jbGVhck1vdXNlRG93bigpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIENsZWFyIHRoZSBtb3N0IHJlY2VudCBzZWxlY3Rpb24uXG4gICAgICovXG4gICAgY2xlYXJNb3N0UmVjZW50U2VsZWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRvbnRDbGVhclJvd3MgPSB0aGlzLmlzQ2hlY2tib3hPbmx5Um93U2VsZWN0aW9ucygpO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbk1vZGVsLmNsZWFyTW9zdFJlY2VudFNlbGVjdGlvbihkb250Q2xlYXJSb3dzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBDbGVhciB0aGUgbW9zdCByZWNlbnQgY29sdW1uIHNlbGVjdGlvbi5cbiAgICAgKi9cbiAgICBjbGVhck1vc3RSZWNlbnRDb2x1bW5TZWxlY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnNlbGVjdGlvbk1vZGVsLmNsZWFyTW9zdFJlY2VudENvbHVtblNlbGVjdGlvbigpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIENsZWFyIHRoZSBtb3N0IHJlY2VudCByb3cgc2VsZWN0aW9uLlxuICAgICAqL1xuICAgIGNsZWFyTW9zdFJlY2VudFJvd1NlbGVjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vdGhpcy5zZWxlY3Rpb25Nb2RlbC5jbGVhck1vc3RSZWNlbnRSb3dTZWxlY3Rpb24oKTsgLy8gY29tbWVudGVkIG9mZiBhcyBwZXIgR1JJRC0xMTJcbiAgICB9LFxuXG4gICAgY2xlYXJSb3dTZWxlY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnNlbGVjdGlvbk1vZGVsLmNsZWFyUm93U2VsZWN0aW9uKCk7XG4gICAgICAgIHRoaXMuYmVoYXZpb3IuZGF0YU1vZGVsLmNsZWFyU2VsZWN0ZWREYXRhKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHN1bW1hcnkgU2VsZWN0IGdpdmVuIHJlZ2lvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb3ggLSBvcmlnaW4geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBveSAtIG9yaWdpbiB5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGV4IC0gZXh0ZW50IHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZXggLSBleHRlbnQgeVxuICAgICAqL1xuICAgIHNlbGVjdDogZnVuY3Rpb24ob3gsIG95LCBleCwgZXkpIHtcbiAgICAgICAgaWYgKG94IDwgMCB8fCBveSA8IDApIHtcbiAgICAgICAgICAgIC8vd2UgZG9uJ3Qgc2VsZWN0IG5lZ2F0aXZlIGFyZWFcbiAgICAgICAgICAgIC8vYWxzbyB0aGlzIG1lYW5zIHRoZXJlIGlzIG5vIG9yaWdpbiBtb3VzZSBkb3duIGZvciBhIHNlbGVjdGlvbiByZWN0XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZWxlY3Rpb25Nb2RlbC5zZWxlY3Qob3gsIG95LCBleCwgZXkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBHaXZlbiBwb2ludCBpcyBzZWxlY3RlZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCAtIFRoZSBob3Jpem9udGFsIGNvb3JkaW5hdGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSBUaGUgdmVydGljYWwgY29vcmRpbmF0ZS5cbiAgICAgKi9cbiAgICBpc1NlbGVjdGVkOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGlvbk1vZGVsLmlzU2VsZWN0ZWQoeCwgeSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFRoZSBnaXZlbiBjb2x1bW4gaXMgc2VsZWN0ZWQgYW55d2hlcmUgaW4gdGhlIGVudGlyZSB0YWJsZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sIC0gVGhlIGNvbHVtbiBpbmRleC5cbiAgICAgKi9cbiAgICBpc0NlbGxTZWxlY3RlZEluUm93OiBmdW5jdGlvbihjb2wpIHtcbiAgICAgICAgdmFyIHNlbGVjdGlvbk1vZGVsID0gdGhpcy5zZWxlY3Rpb25Nb2RlbDtcbiAgICAgICAgdmFyIGlzU2VsZWN0ZWQgPSBzZWxlY3Rpb25Nb2RlbC5pc0NlbGxTZWxlY3RlZEluUm93KGNvbCk7XG4gICAgICAgIHJldHVybiBpc1NlbGVjdGVkO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUaGUgZ2l2ZW4gcm93IGlzIHNlbGVjdGVkIGFueXdoZXJlIGluIHRoZSBlbnRpcmUgdGFibGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJvdyAtIFRoZSByb3cgaW5kZXguXG4gICAgICovXG4gICAgaXNDZWxsU2VsZWN0ZWRJbkNvbHVtbjogZnVuY3Rpb24ocm93KSB7XG4gICAgICAgIHZhciBzZWxlY3Rpb25Nb2RlbCA9IHRoaXMuc2VsZWN0aW9uTW9kZWw7XG4gICAgICAgIHZhciBpc1NlbGVjdGVkID0gc2VsZWN0aW9uTW9kZWwuaXNDZWxsU2VsZWN0ZWRJbkNvbHVtbihyb3cpO1xuICAgICAgICByZXR1cm4gaXNTZWxlY3RlZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAc3VtbWFyeSBTZXQgdGhlIEJlaGF2aW9yIChtb2RlbCkgb2JqZWN0IGZvciB0aGlzIGdyaWQgY29udHJvbC5cbiAgICAgKiBAZGVzYyBUaGlzIGNhbiBiZSBkb25lIGR5bmFtaWNhbGx5LlxuICAgICAqIEBwYXJhbSB7QmVoYXZpb3J9IGJlaGF2aW9yIC0gVGhlIGJlaGF2aW9yIChtb2RlbCkuXG4gICAgICovXG4gICAgc2V0QmVoYXZpb3I6IGZ1bmN0aW9uKGJlaGF2aW9yKSB7XG4gICAgICAgIGJlaGF2aW9yLmNoYW5nZWQgPSB0aGlzLmJlaGF2aW9yQ2hhbmdlZC5iaW5kKHRoaXMpO1xuICAgICAgICBiZWhhdmlvci5zaGFwZUNoYW5nZWQgPSB0aGlzLmJlaGF2aW9yU2hhcGVDaGFuZ2VkLmJpbmQodGhpcyk7XG4gICAgICAgIGJlaGF2aW9yLnN0YXRlQ2hhbmdlZCA9IHRoaXMuYmVoYXZpb3JTdGF0ZUNoYW5nZWQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5iZWhhdmlvciA9IGJlaGF2aW9yO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIEkndmUgYmVlbiBub3RpZmllZCB0aGF0IHRoZSBiZWhhdmlvciBoYXMgY2hhbmdlZC5cbiAgICAgKi9cbiAgICBiZWhhdmlvckNoYW5nZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5udW1Db2x1bW5zICE9PSB0aGlzLmdldENvbHVtbkNvdW50KCkgfHwgdGhpcy5udW1Sb3dzICE9PSB0aGlzLmdldFJvd0NvdW50KCkpIHtcbiAgICAgICAgICAgIHRoaXMubnVtQ29sdW1ucyA9IHRoaXMuZ2V0Q29sdW1uQ291bnQoKTtcbiAgICAgICAgICAgIHRoaXMubnVtUm93cyA9IHRoaXMuZ2V0Um93Q291bnQoKTtcbiAgICAgICAgICAgIHRoaXMuYmVoYXZpb3JTaGFwZUNoYW5nZWQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbXB1dGVDZWxsc0JvdW5kcygpO1xuICAgICAgICB0aGlzLnJlcGFpbnQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7UmVjdGFuZ2xlfSBNeSBib3VuZHMuXG4gICAgICovXG4gICAgZ2V0Qm91bmRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJlbmRlcmVyID0gdGhpcy5nZXRSZW5kZXJlcigpO1xuICAgICAgICByZXR1cm4gcmVuZGVyZXIgJiYgcmVuZGVyZXIuZ2V0Qm91bmRzKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIHZhbHVlIG9mIGEgbG5mIHByb3BlcnR5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBBIGxvb2stYW5kLWZlZWwga2V5LlxuICAgICAqL1xuICAgIHJlc29sdmVQcm9wZXJ0eTogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHZhciBrZXlzID0ga2V5LnNwbGl0KCcuJyk7XG4gICAgICAgIHZhciBwcm9wID0gdGhpcy5nZXRQcm9wZXJ0aWVzKCk7XG4gICAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCkgeyBwcm9wID0gcHJvcFtrZXlzLnNoaWZ0KCldOyB9XG4gICAgICAgIHJldHVybiBwcm9wO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFRoZSBkaW1lbnNpb25zIG9mIHRoZSBncmlkIGRhdGEgaGF2ZSBjaGFuZ2VkLiBZb3UndmUgYmVlbiBub3RpZmllZC5cbiAgICAgKi9cbiAgICBiZWhhdmlvclNoYXBlQ2hhbmdlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc3luY2hyb25pemVTY3JvbGxpbmdCb3VuZHJpZXMoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBUaGUgZGltZW5zaW9ucyBvZiB0aGUgZ3JpZCBkYXRhIGhhdmUgY2hhbmdlZC4gWW91J3ZlIGJlZW4gbm90aWZpZWQuXG4gICAgICovXG4gICAgYmVoYXZpb3JTdGF0ZUNoYW5nZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmdldFJlbmRlcmVyKCkuY29tcHV0ZUNlbGxzQm91bmRzKCk7XG4gICAgICAgIHRoaXMucmVwYWludCgpO1xuICAgIH0sXG5cbiAgICByZXBhaW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG5vdyA9IHRoaXMucmVzb2x2ZVByb3BlcnR5KCdyZXBhaW50SW1tZWRpYXRlbHknKTtcbiAgICAgICAgdmFyIGNhbnZhcyA9IHRoaXMuZ2V0Q2FudmFzKCk7XG4gICAgICAgIGlmIChjYW52YXMpIHtcbiAgICAgICAgICAgIGlmIChub3cgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBjYW52YXMucGFpbnROb3coKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2FudmFzLnJlcGFpbnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFBhaW50IGltbWVkaWF0ZWx5IGluIHRoaXMgbWljcm90YXNrLlxuICAgICAqL1xuICAgIHBhaW50Tm93OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNhbnZhcyA9IHRoaXMuZ2V0Q2FudmFzKCk7XG4gICAgICAgIGNhbnZhcy5wYWludE5vdygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBJbiBIaURQSSBtb2RlIChoYXMgYW4gYXR0cmlidXRlIGFzIHN1Y2gpLlxuICAgICAqL1xuICAgIHVzZUhpRFBJOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzb2x2ZVByb3BlcnR5KCd1c2VIaURQSScpICE9PSBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAc3VtbWFyeSBJbml0aWFsaXplIGRyYXdpbmcgc3VyZmFjZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGluaXRDYW52YXM6IGZ1bmN0aW9uKG1hcmdpbikge1xuXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICB2YXIgZGl2Q2FudmFzID0gdGhpcy5kaXZDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy5kaXYuYXBwZW5kQ2hpbGQoZGl2Q2FudmFzKTtcbiAgICAgICAgdGhpcy5jYW52YXMgPSBuZXcgQ2FudmFzKGRpdkNhbnZhcywgdGhpcy5yZW5kZXJlcik7XG4gICAgICAgIHRoaXMuY2FudmFzLmNhbnZhcy5jbGFzc0xpc3QuYWRkKCdoeXBlcmdyaWQnKTtcblxuICAgICAgICB2YXIgc3R5bGUgPSBkaXZDYW52YXMuc3R5bGU7XG4gICAgICAgIHN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgc3R5bGUudG9wID0gbWFyZ2luLnRvcDtcbiAgICAgICAgc3R5bGUucmlnaHQgPSBtYXJnaW4ucmlnaHQ7XG4gICAgICAgIHN0eWxlLmJvdHRvbSA9IG1hcmdpbi5ib3R0b207XG4gICAgICAgIHN0eWxlLmxlZnQgPSBtYXJnaW4ubGVmdDtcblxuICAgICAgICB0aGlzLmNhbnZhcy5yZXNpemVOb3RpZmljYXRpb24gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNlbGYucmVzaXplZCgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignZmluLWNhbnZhcy1tb3VzZW1vdmUnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5yZXNvbHZlUHJvcGVydHkoJ3JlYWRPbmx5JykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbW91c2UgPSBlLmRldGFpbC5tb3VzZTtcbiAgICAgICAgICAgIHZhciBtb3VzZUV2ZW50ID0gc2VsZi5nZXRHcmlkQ2VsbEZyb21Nb3VzZVBvaW50KG1vdXNlKTtcbiAgICAgICAgICAgIG1vdXNlRXZlbnQucHJpbWl0aXZlRXZlbnQgPSBlO1xuICAgICAgICAgICAgc2VsZi5kZWxlZ2F0ZU1vdXNlTW92ZShtb3VzZUV2ZW50KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdmaW4tY2FudmFzLW1vdXNlZG93bicsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLnJlc29sdmVQcm9wZXJ0eSgncmVhZE9ubHknKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vc2VsZi5zdG9wRWRpdGluZygpO1xuICAgICAgICAgICAgdmFyIG1vdXNlID0gZS5kZXRhaWwubW91c2U7XG4gICAgICAgICAgICB2YXIgbW91c2VFdmVudCA9IHNlbGYuZ2V0R3JpZENlbGxGcm9tTW91c2VQb2ludChtb3VzZSk7XG4gICAgICAgICAgICBtb3VzZUV2ZW50LmtleXMgPSBlLmRldGFpbC5rZXlzO1xuICAgICAgICAgICAgbW91c2VFdmVudC5wcmltaXRpdmVFdmVudCA9IGU7XG4gICAgICAgICAgICBzZWxmLm1vdXNlRG93blN0YXRlID0gbW91c2VFdmVudDtcbiAgICAgICAgICAgIHNlbGYuZGVsZWdhdGVNb3VzZURvd24obW91c2VFdmVudCk7XG4gICAgICAgICAgICBzZWxmLmZpcmVTeW50aGV0aWNNb3VzZURvd25FdmVudChtb3VzZUV2ZW50KTtcbiAgICAgICAgICAgIHNlbGYucmVwYWludCgpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2Zpbi1jYW52YXMtY2xpY2snLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5yZXNvbHZlUHJvcGVydHkoJ3JlYWRPbmx5JykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL3NlbGYuc3RvcEVkaXRpbmcoKTtcbiAgICAgICAgICAgIHZhciBtb3VzZSA9IGUuZGV0YWlsLm1vdXNlO1xuICAgICAgICAgICAgdmFyIG1vdXNlRXZlbnQgPSBzZWxmLmdldEdyaWRDZWxsRnJvbU1vdXNlUG9pbnQobW91c2UpO1xuICAgICAgICAgICAgbW91c2VFdmVudC5wcmltaXRpdmVFdmVudCA9IGU7XG4gICAgICAgICAgICBtb3VzZUV2ZW50LmtleXMgPSBlLmRldGFpbC5rZXlzOyAvLyB0b2RvOiB0aGlzIHdhcyBpbiBmaW4tdGFwIGJ1dCB3YXNuJ3QgaGVyZVxuICAgICAgICAgICAgc2VsZi5maXJlU3ludGhldGljQ2xpY2tFdmVudChtb3VzZUV2ZW50KTtcbiAgICAgICAgICAgIHNlbGYuZGVsZWdhdGVDbGljayhtb3VzZUV2ZW50KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdmaW4tY2FudmFzLW1vdXNldXAnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5yZXNvbHZlUHJvcGVydHkoJ3JlYWRPbmx5JykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLmRyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoc2VsZi5pc1Njcm9sbGluZ05vdygpKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5zZXRTY3JvbGxpbmdOb3coZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGYuY29sdW1uRHJhZ0F1dG9TY3JvbGxpbmcpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmNvbHVtbkRyYWdBdXRvU2Nyb2xsaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL3NlbGYuc3RvcEVkaXRpbmcoKTtcbiAgICAgICAgICAgIHZhciBtb3VzZSA9IGUuZGV0YWlsLm1vdXNlO1xuICAgICAgICAgICAgdmFyIG1vdXNlRXZlbnQgPSBzZWxmLmdldEdyaWRDZWxsRnJvbU1vdXNlUG9pbnQobW91c2UpO1xuICAgICAgICAgICAgbW91c2VFdmVudC5wcmltaXRpdmVFdmVudCA9IGU7XG4gICAgICAgICAgICBzZWxmLmRlbGVnYXRlTW91c2VVcChtb3VzZUV2ZW50KTtcbiAgICAgICAgICAgIGlmIChzZWxmLm1vdXNlRG93blN0YXRlKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5maXJlU3ludGhldGljQnV0dG9uUHJlc3NlZEV2ZW50KHNlbGYubW91c2VEb3duU3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5tb3VzZURvd25TdGF0ZSA9IG51bGw7XG4gICAgICAgICAgICBzZWxmLmZpcmVTeW50aGV0aWNNb3VzZVVwRXZlbnQobW91c2VFdmVudCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignZmluLWNhbnZhcy1kYmxjbGljaycsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLnJlc29sdmVQcm9wZXJ0eSgncmVhZE9ubHknKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBtb3VzZSA9IGUuZGV0YWlsLm1vdXNlO1xuICAgICAgICAgICAgdmFyIG1vdXNlRXZlbnQgPSBzZWxmLmdldEdyaWRDZWxsRnJvbU1vdXNlUG9pbnQobW91c2UpO1xuICAgICAgICAgICAgbW91c2VFdmVudC5wcmltaXRpdmVFdmVudCA9IGU7XG4gICAgICAgICAgICBzZWxmLmZpcmVTeW50aGV0aWNEb3VibGVDbGlja0V2ZW50KG1vdXNlRXZlbnQsIGUpO1xuICAgICAgICAgICAgc2VsZi5kZWxlZ2F0ZURvdWJsZUNsaWNrKG1vdXNlRXZlbnQpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2Zpbi1jYW52YXMtZHJhZycsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLnJlc29sdmVQcm9wZXJ0eSgncmVhZE9ubHknKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYuZHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIG1vdXNlID0gZS5kZXRhaWwubW91c2U7XG4gICAgICAgICAgICB2YXIgbW91c2VFdmVudCA9IHNlbGYuZ2V0R3JpZENlbGxGcm9tTW91c2VQb2ludChtb3VzZSk7XG4gICAgICAgICAgICBtb3VzZUV2ZW50LnByaW1pdGl2ZUV2ZW50ID0gZTtcbiAgICAgICAgICAgIHNlbGYuZGVsZWdhdGVNb3VzZURyYWcobW91c2VFdmVudCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignZmluLWNhbnZhcy1rZXlkb3duJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgaWYgKHNlbGYucmVzb2x2ZVByb3BlcnR5KCdyZWFkT25seScpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5maXJlU3ludGhldGljS2V5ZG93bkV2ZW50KGUpO1xuICAgICAgICAgICAgc2VsZi5kZWxlZ2F0ZUtleURvd24oZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignZmluLWNhbnZhcy1rZXl1cCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLnJlc29sdmVQcm9wZXJ0eSgncmVhZE9ubHknKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYuZmlyZVN5bnRoZXRpY0tleXVwRXZlbnQoZSk7XG4gICAgICAgICAgICBzZWxmLmRlbGVnYXRlS2V5VXAoZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignZmluLWNhbnZhcy13aGVlbG1vdmVkJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgdmFyIG1vdXNlID0gZS5kZXRhaWwubW91c2U7XG4gICAgICAgICAgICB2YXIgbW91c2VFdmVudCA9IHNlbGYuZ2V0R3JpZENlbGxGcm9tTW91c2VQb2ludChtb3VzZSk7XG4gICAgICAgICAgICBtb3VzZUV2ZW50LnByaW1pdGl2ZUV2ZW50ID0gZS5kZXRhaWwucHJpbWl0aXZlRXZlbnQ7XG4gICAgICAgICAgICBzZWxmLmRlbGVnYXRlV2hlZWxNb3ZlZChtb3VzZUV2ZW50KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdmaW4tY2FudmFzLW1vdXNlb3V0JywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgaWYgKHNlbGYucmVzb2x2ZVByb3BlcnR5KCdyZWFkT25seScpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG1vdXNlID0gZS5kZXRhaWwubW91c2U7XG4gICAgICAgICAgICB2YXIgbW91c2VFdmVudCA9IHNlbGYuZ2V0R3JpZENlbGxGcm9tTW91c2VQb2ludChtb3VzZSk7XG4gICAgICAgICAgICBtb3VzZUV2ZW50LnByaW1pdGl2ZUV2ZW50ID0gZS5kZXRhaWwucHJpbWl0aXZlRXZlbnQ7XG4gICAgICAgICAgICBzZWxmLmRlbGVnYXRlTW91c2VFeGl0KG1vdXNlRXZlbnQpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2Zpbi1jYW52YXMtY29udGV4dC1tZW51JywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgdmFyIG1vdXNlID0gZS5kZXRhaWwubW91c2U7XG4gICAgICAgICAgICB2YXIgbW91c2VFdmVudCA9IHNlbGYuZ2V0R3JpZENlbGxGcm9tTW91c2VQb2ludChtb3VzZSk7XG4gICAgICAgICAgICBtb3VzZUV2ZW50LnByaW1pdGl2ZUV2ZW50ID0gZS5kZXRhaWwucHJpbWl0aXZlRXZlbnQ7XG4gICAgICAgICAgICBzZWxmLmRlbGVnYXRlQ29udGV4dE1lbnUobW91c2VFdmVudCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuZGl2LnJlbW92ZUF0dHJpYnV0ZSgndGFiaW5kZXgnKTtcblxuICAgIH0sXG5cbiAgICBjb252ZXJ0Vmlld1BvaW50VG9EYXRhUG9pbnQ6IGZ1bmN0aW9uKHZpZXdQb2ludCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWhhdmlvci5jb252ZXJ0Vmlld1BvaW50VG9EYXRhUG9pbnQodmlld1BvaW50KTtcbiAgICB9LFxuXG4gICAgY29udmVydERhdGFQb2ludFRvVmlld1BvaW50OiBmdW5jdGlvbihkYXRhUG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVoYXZpb3IuY29udmVydERhdGFQb2ludFRvVmlld1BvaW50KGRhdGFQb2ludCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHN1bW1hcnkgQWRkIGFuIGV2ZW50IGxpc3RlbmVyIHRvIG1lLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgLSBUaGUgdHlwZSBvZiBldmVudCB3ZSBhcmUgaW50ZXJlc3RlZCBpbi5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAtIFRoZSBldmVudCBoYW5kbGVyLlxuICAgICAqL1xuICAgIGFkZEV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uKGV2ZW50TmFtZSwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgZGVjb3JhdG9yID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgaWYgKHNlbGYuYWxsb3dFdmVudEhhbmRsZXJzKXtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGRlY29yYXRvcik7XG4gICAgfSxcblxuICAgIGFsbG93RXZlbnRzOiBmdW5jdGlvbihhbGxvdyl7XG4gICAgICAgIGlmICgodGhpcy5hbGxvd0V2ZW50SGFuZGxlcnMgPSAhIWFsbG93KSl7XG4gICAgICAgICAgICB0aGlzLmJlaGF2aW9yLmZlYXR1cmVDaGFpbi5hdHRhY2hDaGFpbigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5iZWhhdmlvci5mZWF0dXJlQ2hhaW4uZGV0YWNoQ2hhaW4oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYmVoYXZpb3IuY2hhbmdlZCgpO1xuICAgIH0sXG5cbiAgICBhZGRGaW5FdmVudExpc3RlbmVyOiBmdW5jdGlvbihldmVudE5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignLmFkZEZpbkV2ZW50TGlzdGVuZXIoKSBtZXRob2QgaXMgZGVwcmVjYXRlZCBhcyBvZiB2MC4yLiBVc2UgLmFkZEV2ZW50TGlzdGVuZXIoKSBpbnN0ZWFkLiAoV2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHJlbGVhc2UuKScpO1xuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBjYWxsYmFjayk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHN1bW1hcnkgU2V0IGZvciBgc2Nyb2xsaW5nTm93YCBmaWVsZC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzSXROb3cgLSBUaGUgdHlwZSBvZiBldmVudCB3ZSBhcmUgaW50ZXJlc3RlZCBpbi5cbiAgICAgKi9cbiAgICBzZXRTY3JvbGxpbmdOb3c6IGZ1bmN0aW9uKGlzSXROb3cpIHtcbiAgICAgICAgdGhpcy5zY3JvbGxpbmdOb3cgPSBpc0l0Tm93O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUaGUgYHNjcm9sbGluZ05vd2AgZmllbGQuXG4gICAgICovXG4gICAgaXNTY3JvbGxpbmdOb3c6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY3JvbGxpbmdOb3c7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge251bWJlcn0gVGhlIGluZGV4IG9mIHRoZSBjb2x1bW4gZGl2aWRlciB1bmRlciB0aGUgbW91c2UgY29vcmRpbmF0ZXMuXG4gICAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBtb3VzZUV2ZW50IC0gVGhlIGV2ZW50IHRvIGludGVyb2dhdGUuXG4gICAgICovXG4gICAgb3ZlckNvbHVtbkRpdmlkZXI6IGZ1bmN0aW9uKG1vdXNlRXZlbnQpIHtcbiAgICAgICAgdmFyIHggPSBtb3VzZUV2ZW50LnByaW1pdGl2ZUV2ZW50LmRldGFpbC5tb3VzZS54O1xuICAgICAgICB2YXIgd2hpY2hDb2wgPSB0aGlzLmdldFJlbmRlcmVyKCkub3ZlckNvbHVtbkRpdmlkZXIoeCk7XG4gICAgICAgIHJldHVybiB3aGljaENvbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgaW5kZXggb2YgdGhlIHJvdyBkaXZpZGVyIHVuZGVyIHRoZSBtb3VzZSBjb29yZGluYXRlcy5cbiAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IG1vdXNlRXZlbnQgLSBUaGUgZXZlbnQgdG8gaW50ZXJvZ2F0ZS5cbiAgICAgKi9cbiAgICBvdmVyUm93RGl2aWRlcjogZnVuY3Rpb24obW91c2VFdmVudCkge1xuICAgICAgICB2YXIgeSA9IG1vdXNlRXZlbnQucHJpbWl0aXZlRXZlbnQuZGV0YWlsLm1vdXNlLnk7XG4gICAgICAgIHZhciB3aGljaCA9IHRoaXMuZ2V0UmVuZGVyZXIoKS5vdmVyUm93RGl2aWRlcih5KTtcbiAgICAgICAgcmV0dXJuIHdoaWNoO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFN3aXRjaCB0aGUgY3Vyc29yIGZvciB0aGUgZ3JpZC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY3Vyc29yTmFtZSAtIEEgd2VsbCBrbm93IGN1cnNvciBuYW1lLlxuICAgICAqIEBzZWUgW2N1cnNvciBuYW1lc10oaHR0cDovL3d3dy5qYXZhc2NyaXB0ZXIubmV0L2ZhcS9zdHlsZXNjLmh0bSlcbiAgICAgKi9cbiAgICBiZUN1cnNvcjogZnVuY3Rpb24oY3Vyc29yTmFtZSkge1xuICAgICAgICBpZiAoIWN1cnNvck5hbWUpIHtcbiAgICAgICAgICAgIGN1cnNvck5hbWUgPSAnZGVmYXVsdCc7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kaXYuc3R5bGUuY3Vyc29yID0gY3Vyc29yTmFtZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBEZWxlZ2F0ZSB0aGUgd2hlZWwgbW92ZWQgZXZlbnQgdG8gdGhlIGJlaGF2aW9yLlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gVGhlIHBlcnRpbmVudCBldmVudC5cbiAgICAgKi9cbiAgICBkZWxlZ2F0ZVdoZWVsTW92ZWQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuYmVoYXZpb3Iub25XaGVlbE1vdmVkKHRoaXMsIGV2ZW50KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBEZWxlZ2F0ZSBNb3VzZUV4aXQgdG8gdGhlIGJlaGF2aW9yIChtb2RlbCkuXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBUaGUgcGVydGluZW50IGV2ZW50LlxuICAgICAqL1xuICAgIGRlbGVnYXRlTW91c2VFeGl0OiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICB0aGlzLmJlaGF2aW9yLmhhbmRsZU1vdXNlRXhpdCh0aGlzLCBldmVudCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgRGVsZWdhdGUgTW91c2VFeGl0IHRvIHRoZSBiZWhhdmlvciAobW9kZWwpLlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gVGhlIHBlcnRpbmVudCBldmVudC5cbiAgICAgKi9cbiAgICBkZWxlZ2F0ZUNvbnRleHRNZW51OiBmdW5jdGlvbihldmVudCkge1xuICAgICAgIHRoaXMuIGJlaGF2aW9yLm9uQ29udGV4dE1lbnUodGhpcywgZXZlbnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIERlbGVnYXRlIE1vdXNlTW92ZSB0byB0aGUgYmVoYXZpb3IgKG1vZGVsKS5cbiAgICAgKiBAcGFyYW0ge21vdXNlRGV0YWlsc30gbW91c2VEZXRhaWxzIC0gQW4gZW5yaWNoZWQgbW91c2UgZXZlbnQgZnJvbSBmaW4tY2FudmFzLlxuICAgICAqL1xuICAgIGRlbGVnYXRlTW91c2VNb3ZlOiBmdW5jdGlvbihtb3VzZURldGFpbHMpIHtcbiAgICAgICAgdGhpcy5iZWhhdmlvci5vbk1vdXNlTW92ZSh0aGlzLCBtb3VzZURldGFpbHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIERlbGVnYXRlIG1vdXNlZG93biB0byB0aGUgYmVoYXZpb3IgKG1vZGVsKS5cbiAgICAgKiBAcGFyYW0ge21vdXNlRGV0YWlsc30gbW91c2VEZXRhaWxzIC0gQW4gZW5yaWNoZWQgbW91c2UgZXZlbnQgZnJvbSBmaW4tY2FudmFzLlxuICAgICAqL1xuICAgIGRlbGVnYXRlTW91c2VEb3duOiBmdW5jdGlvbihtb3VzZURldGFpbHMpIHtcbiAgICAgICAgdGhpcy5iZWhhdmlvci5oYW5kbGVNb3VzZURvd24odGhpcywgbW91c2VEZXRhaWxzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBEZWxlZ2F0ZSBtb3VzZXVwIHRvIHRoZSBiZWhhdmlvciAobW9kZWwpLlxuICAgICAqIEBwYXJhbSB7bW91c2VEZXRhaWxzfSBtb3VzZURldGFpbHMgLSBBbiBlbnJpY2hlZCBtb3VzZSBldmVudCBmcm9tIGZpbi1jYW52YXMuXG4gICAgICovXG4gICAgZGVsZWdhdGVNb3VzZVVwOiBmdW5jdGlvbihtb3VzZURldGFpbHMpIHtcbiAgICAgICAgdGhpcy5iZWhhdmlvci5vbk1vdXNlVXAodGhpcywgbW91c2VEZXRhaWxzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBEZWxlZ2F0ZSBjbGljayB0byB0aGUgYmVoYXZpb3IgKG1vZGVsKS5cbiAgICAgKiBAcGFyYW0ge21vdXNlRGV0YWlsc30gbW91c2VEZXRhaWxzIC0gQW4gZW5yaWNoZWQgbW91c2UgZXZlbnQgZnJvbSBmaW4tY2FudmFzLlxuICAgICAqL1xuICAgIGRlbGVnYXRlQ2xpY2s6IGZ1bmN0aW9uKG1vdXNlRGV0YWlscykge1xuICAgICAgICB0aGlzLmJlaGF2aW9yLm9uQ2xpY2sodGhpcywgbW91c2VEZXRhaWxzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBEZWxlZ2F0ZSBtb3VzZURyYWcgdG8gdGhlIGJlaGF2aW9yIChtb2RlbCkuXG4gICAgICogQHBhcmFtIHttb3VzZURldGFpbHN9IG1vdXNlRGV0YWlscyAtIEFuIGVucmljaGVkIG1vdXNlIGV2ZW50IGZyb20gZmluLWNhbnZhcy5cbiAgICAgKi9cbiAgICBkZWxlZ2F0ZU1vdXNlRHJhZzogZnVuY3Rpb24obW91c2VEZXRhaWxzKSB7XG4gICAgICAgIHRoaXMuYmVoYXZpb3Iub25Nb3VzZURyYWcodGhpcywgbW91c2VEZXRhaWxzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBXZSd2ZSBiZWVuIGRvdWJsZWNsaWNrZWQgb24uIERlbGVnYXRlIHRocm91Z2ggdGhlIGJlaGF2aW9yIChtb2RlbCkuXG4gICAgICogQHBhcmFtIHttb3VzZURldGFpbHN9IG1vdXNlRGV0YWlscyAtIEFuIGVucmljaGVkIG1vdXNlIGV2ZW50IGZyb20gZmluLWNhbnZhcy5cbiAgICAgKi9cbiAgICBkZWxlZ2F0ZURvdWJsZUNsaWNrOiBmdW5jdGlvbihtb3VzZURldGFpbHMpIHtcbiAgICAgICAgdGhpcy5iZWhhdmlvci5vbkRvdWJsZUNsaWNrKHRoaXMsIG1vdXNlRGV0YWlscyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHN1bW1hcnkgR2VuZXJhdGUgYSBmdW5jdGlvbiBuYW1lIGFuZCBjYWxsIGl0IG9uIHNlbGYuXG4gICAgICogQGRlc2MgVGhpcyBzaG91bGQgYWxzbyBiZSBkZWxlZ2F0ZWQgdGhyb3VnaCBCZWhhdmlvciBrZWVwaW5nIHRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIGhlcmUgdGhvdWdoLlxuICAgICAqIEBwYXJhbSB7ZXZlbnR9IGV2ZW50IC0gVGhlIHBlcnRpbmVudCBldmVudC5cbiAgICAgKi9cbiAgICBkZWxlZ2F0ZUtleURvd246IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuYmVoYXZpb3Iub25LZXlEb3duKHRoaXMsIGV2ZW50KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAc3VtbWFyeSBHZW5lcmF0ZSBhIGZ1bmN0aW9uIG5hbWUgYW5kIGNhbGwgaXQgb24gc2VsZi5cbiAgICAgKiBAZGVzYyBUaGlzIHNob3VsZCBhbHNvIGJlIGRlbGVnYXRlZCB0aHJvdWdoIEJlaGF2aW9yIGtlZXBpbmcgdGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gaGVyZSB0aG91Z2guXG4gICAgICogQHBhcmFtIHtldmVudH0gZXZlbnQgLSBUaGUgcGVydGluZW50IGV2ZW50LlxuICAgICAqL1xuICAgIGRlbGVnYXRlS2V5VXA6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuYmVoYXZpb3Iub25LZXlVcCh0aGlzLCBldmVudCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHN1bW1hcnkgU2h1dCBkb3duIHRoZSBjdXJyZW50IGNlbGwgZWRpdG9yIGFuZCBzYXZlIHRoZSBlZGl0ZWQgdmFsdWUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiB3ZSB3ZXJlIGVkaXRpbmc7IGBmYWxzZWAgaWYgd2Ugd2VyZSBub3QuXG4gICAgICovXG4gICAgc3RvcEVkaXRpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgd2FzRWRpdGluZyA9ICEhdGhpcy5jZWxsRWRpdG9yO1xuICAgICAgICBpZiAod2FzRWRpdGluZykge1xuICAgICAgICAgICAgdGhpcy5jZWxsRWRpdG9yLnN0b3BFZGl0aW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdhc0VkaXRpbmc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHN1bW1hcnkgU2h1dCBkb3duIHRoZSBjdXJyZW50IGNlbGwgZWRpdG9yIHdpdGhvdXQgc2F2aW5nIHRoZSBlZGl0ZWQgdmFsdWUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiB3ZSB3ZXJlIGVkaXRpbmc7IGBmYWxzZWAgaWYgd2Ugd2VyZSBub3QuXG4gICAgICovXG4gICAgY2FuY2VsRWRpdGluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB3YXNFZGl0aW5nID0gISF0aGlzLmNlbGxFZGl0b3I7XG4gICAgICAgIGlmICh3YXNFZGl0aW5nKSB7XG4gICAgICAgICAgICB0aGlzLmNlbGxFZGl0b3IuY2FuY2VsRWRpdGluZygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3YXNFZGl0aW5nO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtSZWN0YW5nbGV9IFRoZSBwaXhlbCBjb29yZGluYXRlcyBvZiBqdXN0IHRoZSBjZW50ZXIgJ21haW5cIiBkYXRhIGFyZWEuXG4gICAgICovXG4gICAgZ2V0RGF0YUJvdW5kczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjb2xETkRIYWNrV2lkdGggPSAyMDA7IC8vdGhpcyB3YXMgYSBoYWNrIHRvIGhlbHAgd2l0aCBjb2x1bW4gZG5kLCBuZWVkIHRvIGZhY3RvciB0aGlzIGludG8gYSBzaGFyZWQgdmFyaWFibGVcbiAgICAgICAgdmFyIGIgPSB0aGlzLmNhbnZhcy5ib3VuZHM7XG5cbiAgICAgICAgLy92YXIgeCA9IHRoaXMuZ2V0Um93TnVtYmVyc1dpZHRoKCk7XG4gICAgICAgIC8vIHZhciB5ID0gYmVoYXZpb3IuZ2V0Rml4ZWRSb3dzSGVpZ2h0KCkgKyAyO1xuXG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgUmVjdGFuZ2xlKDAsIDAsIGIub3JpZ2luLnggKyBiLmV4dGVudC54IC0gY29sRE5ESGFja1dpZHRoLCBiLm9yaWdpbi55ICsgYi5leHRlbnQueSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIGdldFJvd051bWJlcnNXaWR0aDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmlzU2hvd1Jvd051bWJlcnMoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UmVuZGVyZXIoKS5nZXRSb3dOdW1iZXJzV2lkdGgoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge0NhbnZhc30gT3VyIGZpbi1jYW52YXMgaW5zdGFuY2UuXG4gICAgICovXG4gICAgZ2V0Q2FudmFzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FudmFzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBzdW1tYXJ5IE9wZW4gdGhlIGNlbGwtZWRpdG9yIGF0IHRoZSBwcm92aWRlZCBtb2RlbCBjb29yZGluYXRlcy5cbiAgICAgKiBAcGFyYW0ge1BvaW50fSBlZGl0UG9pbnQgLSBUaGUgbW9kZWwgY29vcmRpbmF0ZXMgb2YgdGhlIGNlbGwgdG8gZWRpdC4gVGhpcyBpcyB0aGUgZ3JpZCBjb29yZGluYXRlcyByZWdhcmRsZXNzIG9mIHNjcm9sbCBwb3NpdGlvbi5cbiAgICAgKiBAcmV0dXJuIHt1bmRlZmluZWR8Q2VsbEVkaXRvcn0gVGhlIGNlbGxFZGl0b3IgZGV0ZXJtaW5lZCBmcm9tIHRoZSBjZWxsJ3MgcmVuZGVyIHByb3BlcnRpZXMsIHdoaWNoIG1heSBiZSBtb2RpZmllZCBieSBsb2dpYyBhZGRlZCBieSBvdmVycmlkaW5nIHtAbGluayBEYXRhTW9kZWwjZ2V0Q2VsbEVkaXRvckF0fGdldENlbGxFZGl0b3JBdH0uXG4gICAgICovXG4gICAgZWRpdEF0OiBmdW5jdGlvbihlZGl0UG9pbnQpIHtcbiAgICAgICAgdmFyIGNlbGxFZGl0b3I7XG5cbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlcHJlY2F0ZWQoJ2VkaXRBdChjZWxsRWRpdG9yLCBlZGl0UG9pbnQpJywgJ2VkaXRBdChlZGl0UG9pbnQpJywgJzEuMC42JywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc3RvcEVkaXRpbmcoKTsgLy9vdGhlciBlZGl0b3IgaXMgb3BlbiwgY2xvc2UgaXQgZmlyc3RcblxuICAgICAgICBpZiAoZWRpdFBvaW50LnggPj0gMCAmJiBlZGl0UG9pbnQueSA+PSAwKSB7XG4gICAgICAgICAgICB2YXIgZWRpdGFibGUgPSB0aGlzLmJlaGF2aW9yLmdldEFjdGl2ZUNvbHVtbihlZGl0UG9pbnQueCkuZ2V0UHJvcGVydGllcygpLmVkaXRhYmxlO1xuICAgICAgICAgICAgaWYgKGVkaXRhYmxlIHx8IHRoaXMuaXNGaWx0ZXJSb3coZWRpdFBvaW50LnkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRNb3VzZURvd24oZWRpdFBvaW50KTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldERyYWdFeHRlbnQobmV3IFBvaW50KDAsIDApKTtcbiAgICAgICAgICAgICAgICBjZWxsRWRpdG9yID0gdGhpcy5nZXRDZWxsRWRpdG9yQXQoZWRpdFBvaW50KTtcbiAgICAgICAgICAgICAgICBpZiAoY2VsbEVkaXRvcikge1xuICAgICAgICAgICAgICAgICAgICBjZWxsRWRpdG9yLmJlZ2luRWRpdGluZygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjZWxsRWRpdG9yO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUaGUgZ2l2ZW4gY29sdW1uIGlzIGZ1bGx5IHZpc2libGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbHVtbkluZGV4IC0gVGhlIGNvbHVtbiBpbmRleCBpbiBxdWVzdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtib29sYW59IFZpc2libGUuXG4gICAgICovXG4gICAgaXNDb2x1bW5WaXNpYmxlOiBmdW5jdGlvbihjb2x1bW5JbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRSZW5kZXJlcigpLmlzQ29sdW1uVmlzaWJsZShjb2x1bW5JbmRleCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFRoZSBnaXZlbiByb3cgaXMgZnVsbHkgdmlzaWJsZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcm93SW5kZXggLSBUaGUgcm93IGluZGV4IGluIHF1ZXN0aW9uLlxuICAgICAqIEByZXR1cm4ge2Jvb2xhbn0gVmlzaWJsZS5cbiAgICAgKi9cbiAgICBpc0RhdGFSb3dWaXNpYmxlOiBmdW5jdGlvbihyb3dJbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRSZW5kZXJlcigpLmlzUm93VmlzaWJsZShyb3dJbmRleCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFRoZSBnaXZlbiBjZWxsIGlzIGZ1bGx5IGlzIHZpc2libGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbHVtbkluZGV4IC0gVGhlIGNvbHVtbiBpbmRleCBpbiBxdWVzdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcm93SW5kZXggLSBUaGUgcm93IGluZGV4IGluIHF1ZXN0aW9uLlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IERhdGEgaXMgdmlzaWJsZS5cbiAgICAgKi9cbiAgICBpc0RhdGFWaXNpYmxlOiBmdW5jdGlvbihjb2x1bW5JbmRleCwgcm93SW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNEYXRhUm93VmlzaWJsZShyb3dJbmRleCkgJiYgdGhpcy5pc0NvbHVtblZpc2libGUoY29sdW1uSW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBzdW1tYXJ5IFNjcm9sbCBpbiB0aGUgYG9mZnNldFhgIGRpcmVjdGlvbiBpZiBjb2x1bW4gaW5kZXggYGNvbEluZGV4YCBpcyBub3QgdmlzaWJsZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sSW5kZXggLSBUaGUgY29sdW1uIGluZGV4IGluIHF1ZXN0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRYIC0gVGhlIGRpcmVjdGlvbiBhbmQgbWFnbml0dWRlIHRvIHNjcm9sbCBpZiB3ZSBuZWVkIHRvLlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IENvbHVtbiBpcyB2aXNpYmxlLlxuICAgICAqL1xuICAgIGluc3VyZU1vZGVsQ29sSXNWaXNpYmxlOiBmdW5jdGlvbihjb2xJbmRleCwgb2Zmc2V0WCkge1xuICAgICAgICB2YXIgbWF4Q29scyA9IHRoaXMuZ2V0Q29sdW1uQ291bnQoKSAtIDEsIC8vIC0xIGV4Y2x1ZGVzIHBhcnRpYWxseSB2aXNpYmxlIGNvbHVtbnNcbiAgICAgICAgICAgIGluZGV4VG9DaGVjayA9IGNvbEluZGV4ICsgKG9mZnNldFggPiAwKSxcbiAgICAgICAgICAgIHZpc2libGUgPSAhdGhpcy5pc0NvbHVtblZpc2libGUoaW5kZXhUb0NoZWNrKSB8fCBjb2xJbmRleCA9PT0gbWF4Q29scztcblxuICAgICAgICBpZiAodmlzaWJsZSkge1xuICAgICAgICAgICAgLy90aGUgc2Nyb2xsIHBvc2l0aW9uIGlzIHRoZSBsZWZ0bW9zdCBjb2x1bW5cbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsQnkob2Zmc2V0WCwgMCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmlzaWJsZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAc3VtbWFyeSBTY3JvbGwgaW4gdGhlIGBvZmZzZXRZYCBkaXJlY3Rpb24gaWYgY29sdW1uIGluZGV4IGMgaXMgbm90IHZpc2libGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJvd0luZGV4IC0gVGhlIGNvbHVtbiBpbmRleCBpbiBxdWVzdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0WCAtIFRoZSBkaXJlY3Rpb24gYW5kIG1hZ25pdHVkZSB0byBzY3JvbGwgaWYgd2UgbmVlZCB0by5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBSb3cgaXMgdmlzaWJsZS5cbiAgICAgKi9cbiAgICBpbnN1cmVNb2RlbFJvd0lzVmlzaWJsZTogZnVuY3Rpb24ocm93SW5kZXgsIG9mZnNldFkpIHtcbiAgICAgICAgdmFyIG1heFJvd3MgPSB0aGlzLmdldFJvd0NvdW50KCkgLSAxLCAvLyAtMSBleGNsdWRlcyBwYXJ0aWFsbHkgdmlzaWJsZSByb3dzXG4gICAgICAgICAgICBpbmRleFRvQ2hlY2sgPSByb3dJbmRleCArIChvZmZzZXRZID4gMCksXG4gICAgICAgICAgICB2aXNpYmxlID0gIXRoaXMuaXNEYXRhUm93VmlzaWJsZShpbmRleFRvQ2hlY2spIHx8IHJvd0luZGV4ID09PSBtYXhSb3dzO1xuXG4gICAgICAgIGlmICh2aXNpYmxlKSB7XG4gICAgICAgICAgICAvL3RoZSBzY3JvbGwgcG9zaXRpb24gaXMgdGhlIHRvcG1vc3Qgcm93XG4gICAgICAgICAgICB0aGlzLnNjcm9sbEJ5KDAsIG9mZnNldFkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZpc2libGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHN1bW1hcnkgU2Nyb2xsIGhvcml6b250YWwgYW5kIHZlcnRpY2FsbHkgYnkgdGhlIHByb3ZpZGVkIG9mZnNldHMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFggLSBTY3JvbGwgaW4gdGhlIHggZGlyZWN0aW9uIHRoaXMgbXVjaC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0WSAtIFNjcm9sbCBpbiB0aGUgeSBkaXJlY3Rpb24gdGhpcyBtdWNoLlxuICAgICAqL1xuICAgIHNjcm9sbEJ5OiBmdW5jdGlvbihvZmZzZXRYLCBvZmZzZXRZKSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsSEJ5KG9mZnNldFgpO1xuICAgICAgICB0aGlzLnNjcm9sbFZCeShvZmZzZXRZKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAc3VtbWFyeSBTY3JvbGwgdmVydGljYWxseSBieSB0aGUgcHJvdmlkZWQgb2Zmc2V0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRZIC0gU2Nyb2xsIGluIHRoZSB5IGRpcmVjdGlvbiB0aGlzIG11Y2guXG4gICAgICovXG4gICAgc2Nyb2xsVkJ5OiBmdW5jdGlvbihvZmZzZXRZKSB7XG4gICAgICAgIHZhciBtYXggPSB0aGlzLnNiVlNjcm9sbGVyLnJhbmdlLm1heDtcbiAgICAgICAgdmFyIG9sZFZhbHVlID0gdGhpcy5nZXRWU2Nyb2xsVmFsdWUoKTtcbiAgICAgICAgdmFyIG5ld1ZhbHVlID0gTWF0aC5taW4obWF4LCBNYXRoLm1heCgwLCBvbGRWYWx1ZSArIG9mZnNldFkpKTtcbiAgICAgICAgaWYgKG5ld1ZhbHVlICE9PSBvbGRWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5zZXRWU2Nyb2xsVmFsdWUobmV3VmFsdWUpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHN1bW1hcnkgU2Nyb2xsIGhvcml6b250YWxseSBieSB0aGUgcHJvdmlkZWQgb2Zmc2V0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRYIC0gU2Nyb2xsIGluIHRoZSB4IGRpcmVjdGlvbiB0aGlzIG11Y2guXG4gICAgICovXG4gICAgc2Nyb2xsSEJ5OiBmdW5jdGlvbihvZmZzZXRYKSB7XG4gICAgICAgIHZhciBtYXggPSB0aGlzLnNiSFNjcm9sbGVyLnJhbmdlLm1heDtcbiAgICAgICAgdmFyIG9sZFZhbHVlID0gdGhpcy5nZXRIU2Nyb2xsVmFsdWUoKTtcbiAgICAgICAgdmFyIG5ld1ZhbHVlID0gTWF0aC5taW4obWF4LCBNYXRoLm1heCgwLCBvbGRWYWx1ZSArIG9mZnNldFgpKTtcbiAgICAgICAgaWYgKG5ld1ZhbHVlICE9PSBvbGRWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5zZXRIU2Nyb2xsVmFsdWUobmV3VmFsdWUpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHNjcm9sbFRvTWFrZVZpc2libGU6IGZ1bmN0aW9uKGMsIHIpIHtcbiAgICAgICAgdmFyIGxlZnRDb2x1bW4gPSB0aGlzLnJlbmRlcmVyLmdldFNjcm9sbExlZnQoKSxcbiAgICAgICAgICAgIHRvcFJvdyA9IHRoaXMucmVuZGVyZXIuZ2V0U2Nyb2xsVG9wKCksXG4gICAgICAgICAgICBkZWx0YSxcbiAgICAgICAgICAgIG51bU9mR3JpZEN0cmxDb2xzID0gMiwgLy9UT0RPOiBHZXQgcmlkIG9mIEFMTCBtYWdpYyBhbmQgaGFyZGNvZGVkIG51bWJlcnMuXG4gICAgICAgICAgICBudW1vZkdyaWRDdHJsUm93cyA9IDMsXG4gICAgICAgICAgICBhZGp1c3RtZW50Rm9yUGFydGlhbGx5VmlzQ29scyA9IC0xO1xuXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIC8vIHRhcmdldCBpcyBvZmYgdG8gbGVmdDsgbmVnYXRpdmUgZGVsdGEgc2Nyb2xscyBsZWZ0XG4gICAgICAgICAgICAoZGVsdGEgPSBjIC0gKGxlZnRDb2x1bW4gKyB0aGlzLnJlbmRlcmVyLmdldEZpeGVkQ29sdW1uQ291bnQoKSkpIDwgMCB8fFxuXG4gICAgICAgICAgICAvLyB0YXJnZXQgaXMgb2ZmIHRvIHJpZ2h0OyBwb3NpdGl2ZSBkZWx0YSBzY3JvbGxzIHJpZ2h0XG4gICAgICAgICAgICAoZGVsdGEgPSBjIC0gKGxlZnRDb2x1bW4gKyB0aGlzLmdldFZpc2libGVDb2x1bW5zQ291bnQoKSAtIG51bU9mR3JpZEN0cmxDb2xzICsgYWRqdXN0bWVudEZvclBhcnRpYWxseVZpc0NvbHMpKSA+IDBcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB0aGlzLnNiSFNjcm9sbGVyLmluZGV4ICs9IGRlbHRhO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgLy8gdGFyZ2V0IGlzIGFib3ZlIHRvcDsgbmVnYXRpdmUgZGVsdGEgc2Nyb2xscyB1cFxuICAgICAgICAgICAgKGRlbHRhID0gciAtICh0b3BSb3cgKyB0aGlzLnJlbmRlcmVyLmdldEZpeGVkUm93Q291bnQoKSkpIDwgMCB8fFxuXG4gICAgICAgICAgICAvLyB0YXJnZXQgaXMgYmVsb3cgYm90dG9tOyBwb3NpdGl2ZSBkZWx0YSBzY3JvbGxzIGRvd25cbiAgICAgICAgICAgIChkZWx0YSA9IHIgLSAodG9wUm93ICsgdGhpcy5yZW5kZXJlci5yb3dFZGdlcy5sZW5ndGggLSBudW1vZkdyaWRDdHJsUm93cykpID4gMFxuICAgICAgICApIHtcbiAgICAgICAgICAgIHRoaXMuc2JWU2Nyb2xsZXIuaW5kZXggKz0gZGVsdGE7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgc2VsZWN0Q2VsbEFuZFNjcm9sbFRvTWFrZVZpc2libGU6IGZ1bmN0aW9uKGMsIHIpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RDZWxsKGMsIHIsIHRydWUpO1xuICAgICAgICB0aGlzLnNjcm9sbFRvTWFrZVZpc2libGUoYywgcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHN1bW1hcnkgQW5zd2VyIHdoaWNoIGRhdGEgY2VsbCBpcyB1bmRlciBhIHBpeGVsIHZhbHVlIG1vdXNlIHBvaW50LlxuICAgICAqIEBwYXJhbSB7bW91c2VQb2ludH0gbW91c2UgLSBUaGUgbW91c2UgcG9pbnQgdG8gaW50ZXJyb2dhdGUuXG4gICAgICovXG5cbiAgICBnZXRHcmlkQ2VsbEZyb21Nb3VzZVBvaW50OiBmdW5jdGlvbihtb3VzZSkge1xuICAgICAgICB2YXIgY2VsbCA9IHRoaXMuZ2V0UmVuZGVyZXIoKS5nZXRHcmlkQ2VsbEZyb21Nb3VzZVBvaW50KG1vdXNlKTtcbiAgICAgICAgcmV0dXJuIGNlbGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtSZWN0YW5nbGV9IFRoZSBwaXhlbCBiYXNlZCBib3VuZHMgcmVjdGFuZ2xlIGdpdmVuIGEgZGF0YSBjZWxsIHBvaW50LlxuICAgICAqIEBwYXJhbSB7UG9pbnR9IGNlbGwgLSBUaGUgcGl4ZWwgbG9jYXRpb24gb2YgdGhlIG1vdXNlLlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICovXG4gICAgZ2V0Qm91bmRzT2ZDZWxsOiBmdW5jdGlvbihjZWxsKSB7XG4gICAgICAgIHZhciBiID0gdGhpcy5nZXRSZW5kZXJlcigpLmdldEJvdW5kc09mQ2VsbChjZWxsKTtcblxuICAgICAgICAvL3dlIG5lZWQgdG8gY29udmVydCB0aGlzIHRvIGEgcHJvcGVyIHJlY3RhbmdsZVxuICAgICAgICB2YXIgbmV3Qm91bmRzID0gbmV3IFJlY3RhbmdsZShiLngsIGIueSwgYi53aWR0aCwgYi5oZWlnaHQpO1xuICAgICAgICByZXR1cm4gbmV3Qm91bmRzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFRoaXMgaXMgY2FsbGVkIGJ5IHRoZSBmaW4tY2FudmFzIHdoZW4gYSByZXNpemUgb2NjdXJzLlxuICAgICAqL1xuICAgIHJlc2l6ZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnN5bmNocm9uaXplU2Nyb2xsaW5nQm91bmRyaWVzKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHN1bW1hcnkgQSBjbGljayBldmVudCBvY2N1cnJlZC5cbiAgICAgKiBAZGVzYyBEZXRlcm1pbmUgdGhlIGNlbGwgYW5kIGRlbGVnYXRlIHRvIHRoZSBiZWhhdmlvciAobW9kZWwpLlxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZXZlbnQgLSBUaGUgbW91c2UgZXZlbnQgdG8gaW50ZXJyb2dhdGUuXG4gICAgICovXG4gICAgY2VsbENsaWNrZWQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIHZhciBjZWxsID0gZXZlbnQuZ3JpZENlbGw7XG5cbiAgICAgICAgLy9jbGljayBvY2N1cnJlZCBpbiBiYWNrZ3JvdW5kIGFyZWFcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgY2VsbC54IDw9IHRoaXMuZ2V0Q29sdW1uQ291bnQoKSAmJlxuICAgICAgICAgICAgY2VsbC55IDw9IHRoaXMuZ2V0Um93Q291bnQoKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHZhciBob3ZlcmVkID0gdGhpcy5nZXRIb3ZlckNlbGwoKSxcbiAgICAgICAgICAgICAgICB4ID0gaG92ZXJlZC54LFxuICAgICAgICAgICAgICAgIHkgPSBob3ZlcmVkLnk7XG5cbiAgICAgICAgICAgIC8vIGlmICh4ID49IDApIHtcbiAgICAgICAgICAgIC8vICAgICB4ID0gYmVoYXZpb3IudHJhbnNsYXRlQ29sdW1uSW5kZXgoeCArIHRoaXMuZ2V0SFNjcm9sbFZhbHVlKCkpO1xuICAgICAgICAgICAgLy8gfVxuXG4gICAgICAgICAgICBpZiAoeSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgeSArPSB0aGlzLmdldFZTY3JvbGxWYWx1ZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmJlaGF2aW9yLmNlbGxDbGlja2VkKG5ldyBQb2ludCh4LCB5KSwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSBjb2x1bW4gaW5kZXhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAtIHRvdGFscyByb3cgaW5kZXggbG9jYWwgdG8gdGhlIHRvdGFscyBhcmVhXG4gICAgICogQHBhcmFtIHZhbHVlXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gW2FyZWFzPVsndG9wJywgJ2JvdHRvbSddXSAtIG1heSBpbmNsdWRlIGAndG9wJ2AgYW5kL29yIGAnYm90dG9tJ2BcbiAgICAgKi9cbiAgICBzZXRUb3RhbHNWYWx1ZU5vdGlmaWNhdGlvbjogZnVuY3Rpb24oeCwgeSwgdmFsdWUsIGFyZWFzKSB7XG4gICAgICAgIHRoaXMuZmlyZVN5bnRoZXRpY1NldFRvdGFsc1ZhbHVlKHgsIHksIHZhbHVlLCBhcmVhcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSBjb2x1bW4gaW5kZXhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAtIHRvdGFscyByb3cgaW5kZXggbG9jYWwgdG8gdGhlIHRvdGFscyBhcmVhXG4gICAgICogQHBhcmFtIHZhbHVlXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gW2FyZWFzPVsndG9wJywgJ2JvdHRvbSddXSAtIG1heSBpbmNsdWRlIGAndG9wJ2AgYW5kL29yIGAnYm90dG9tJ2BcbiAgICAgKi9cbiAgICBmaXJlU3ludGhldGljU2V0VG90YWxzVmFsdWU6IGZ1bmN0aW9uKHgsIHksIHZhbHVlLCBhcmVhcykge1xuICAgICAgICB2YXIgY2xpY2tFdmVudCA9IG5ldyBDdXN0b21FdmVudCgnZmluLXNldC10b3RhbHMtdmFsdWUnLCB7XG4gICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgICAgIHk6IHksXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICAgIGFyZWFzOiBhcmVhc1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jYW52YXMuZGlzcGF0Y2hFdmVudChjbGlja0V2ZW50KTtcbiAgICB9LFxuXG4gICAgZmlyZVN5bnRoZXRpY0VkaXRvcktleVVwRXZlbnQ6IGZ1bmN0aW9uKGlucHV0Q29udHJvbCwga2V5RXZlbnQpIHtcbiAgICAgICAgdmFyIGNsaWNrRXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ2Zpbi1lZGl0b3Ita2V5dXAnLCB7XG4gICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgICBpbnB1dDogaW5wdXRDb250cm9sLFxuICAgICAgICAgICAgICAgIGtleUV2ZW50OiBrZXlFdmVudCxcbiAgICAgICAgICAgICAgICBjaGFyOiB0aGlzLmNhbnZhcy5nZXRDaGFyTWFwKClba2V5RXZlbnQua2V5Q29kZV1ba2V5RXZlbnQuc2hpZnRLZXkgPyAxIDogMF1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2FudmFzLmRpc3BhdGNoRXZlbnQoY2xpY2tFdmVudCk7XG4gICAgfSxcblxuICAgIGZpcmVTeW50aGV0aWNFZGl0b3JLZXlEb3duRXZlbnQ6IGZ1bmN0aW9uKGlucHV0Q29udHJvbCwga2V5RXZlbnQpIHtcbiAgICAgICAgdmFyIGNsaWNrRXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ2Zpbi1lZGl0b3Ita2V5ZG93bicsIHtcbiAgICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgICAgIGlucHV0OiBpbnB1dENvbnRyb2wsXG4gICAgICAgICAgICAgICAga2V5RXZlbnQ6IGtleUV2ZW50LFxuICAgICAgICAgICAgICAgIGNoYXI6IHRoaXMuY2FudmFzLmdldENoYXJNYXAoKVtrZXlFdmVudC5rZXlDb2RlXVtrZXlFdmVudC5zaGlmdEtleSA/IDEgOiAwXVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jYW52YXMuZGlzcGF0Y2hFdmVudChjbGlja0V2ZW50KTtcbiAgICB9LFxuXG4gICAgZmlyZVN5bnRoZXRpY0VkaXRvcktleVByZXNzRXZlbnQ6IGZ1bmN0aW9uKGlucHV0Q29udHJvbCwga2V5RXZlbnQpIHtcbiAgICAgICAgdmFyIGNsaWNrRXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ2Zpbi1lZGl0b3Ita2V5cHJlc3MnLCB7XG4gICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgICBpbnB1dDogaW5wdXRDb250cm9sLFxuICAgICAgICAgICAgICAgIGtleUV2ZW50OiBrZXlFdmVudCxcbiAgICAgICAgICAgICAgICBjaGFyOiB0aGlzLmNhbnZhcy5nZXRDaGFyTWFwKClba2V5RXZlbnQua2V5Q29kZV1ba2V5RXZlbnQuc2hpZnRLZXkgPyAxIDogMF1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2FudmFzLmRpc3BhdGNoRXZlbnQoY2xpY2tFdmVudCk7XG4gICAgfSxcblxuICAgIGZpcmVTeW50aGV0aWNFZGl0b3JEYXRhQ2hhbmdlRXZlbnQ6IGZ1bmN0aW9uKGlucHV0Q29udHJvbCwgb2xkVmFsdWUsIG5ld1ZhbHVlKSB7XG4gICAgICAgIHZhciBjbGlja0V2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdmaW4tZWRpdG9yLWRhdGEtY2hhbmdlJywge1xuICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgaW5wdXQ6IGlucHV0Q29udHJvbCxcbiAgICAgICAgICAgICAgICBvbGRWYWx1ZTogb2xkVmFsdWUsXG4gICAgICAgICAgICAgICAgbmV3VmFsdWU6IG5ld1ZhbHVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FudmFzLmRpc3BhdGNoRXZlbnQoY2xpY2tFdmVudCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgU3ludGhlc2l6ZSBhbmQgZmlyZSBhIGBmaW4tcm93LXNlbGVjdGlvbi1jaGFuZ2VkYCBldmVudC5cbiAgICAgKi9cbiAgICBmaXJlU3ludGhldGljUm93U2VsZWN0aW9uQ2hhbmdlZEV2ZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGVjdGlvbkV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdmaW4tcm93LXNlbGVjdGlvbi1jaGFuZ2VkJywge1xuICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgcm93czogdGhpcy5nZXRTZWxlY3RlZFJvd3MoKSxcbiAgICAgICAgICAgICAgICBjb2x1bW5zOiB0aGlzLmdldFNlbGVjdGVkQ29sdW1ucygpLFxuICAgICAgICAgICAgICAgIHNlbGVjdGlvbnM6IHRoaXMuc2VsZWN0aW9uTW9kZWwuZ2V0U2VsZWN0aW9ucygpLFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jYW52YXMuZGlzcGF0Y2hFdmVudChzZWxlY3Rpb25FdmVudCk7XG4gICAgfSxcblxuICAgIGZpcmVTeW50aGV0aWNDb2x1bW5TZWxlY3Rpb25DaGFuZ2VkRXZlbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZWN0aW9uRXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ2Zpbi1jb2x1bW4tc2VsZWN0aW9uLWNoYW5nZWQnLCB7XG4gICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgICByb3dzOiB0aGlzLmdldFNlbGVjdGVkUm93cygpLFxuICAgICAgICAgICAgICAgIGNvbHVtbnM6IHRoaXMuZ2V0U2VsZWN0ZWRDb2x1bW5zKCksXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uczogdGhpcy5zZWxlY3Rpb25Nb2RlbC5nZXRTZWxlY3Rpb25zKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2FudmFzLmRpc3BhdGNoRXZlbnQoc2VsZWN0aW9uRXZlbnQpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBTeW50aGVzaXplIGFuZCBkaXNwYXRjaCBhIGBmaW4tc2VsZWN0aW9uLWNoYW5nZWRgIGV2ZW50LlxuICAgICAqL1xuICAgIHNlbGVjdGlvbkNoYW5nZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZWN0ZWRSb3dzID0gdGhpcy5nZXRTZWxlY3RlZFJvd3MoKTtcbiAgICAgICAgdmFyIHNlbGVjdGlvbkV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdmaW4tc2VsZWN0aW9uLWNoYW5nZWQnLCB7XG4gICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgICByb3dzOiBzZWxlY3RlZFJvd3MsXG4gICAgICAgICAgICAgICAgY29sdW1uczogdGhpcy5nZXRTZWxlY3RlZENvbHVtbnMoKSxcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25zOiB0aGlzLnNlbGVjdGlvbk1vZGVsLmdldFNlbGVjdGlvbnMoKSxcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2FudmFzLmRpc3BhdGNoRXZlbnQoc2VsZWN0aW9uRXZlbnQpO1xuICAgIH0sXG5cbiAgICBnZXRSb3dTZWxlY3Rpb246IGZ1bmN0aW9uKGluY2x1ZGVIaWRkZW5Db2x1bW5zKSB7XG4gICAgICAgIHZhciBjb2x1bW4sIHJvd3MsIGdldENvbHVtbixcbiAgICAgICAgICAgIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgc2VsZWN0ZWRSb3dJbmRleGVzID0gdGhpcy5zZWxlY3Rpb25Nb2RlbC5nZXRTZWxlY3RlZFJvd3MoKSxcbiAgICAgICAgICAgIG51bUNvbHVtbnMgPSB0aGlzLmdldENvbHVtbkNvdW50KCksXG4gICAgICAgICAgICByZXN1bHQgPSB7fTtcblxuICAgICAgICBpZiAoaW5jbHVkZUhpZGRlbkNvbHVtbnMpIHtcbiAgICAgICAgICAgIG51bUNvbHVtbnMgKz0gdGhpcy5nZXRIaWRkZW5Db2x1bW5zKCkubGVuZ3RoO1xuICAgICAgICAgICAgZ2V0Q29sdW1uID0gdGhpcy5iZWhhdmlvci5nZXRDb2x1bW47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnZXRDb2x1bW4gPSB0aGlzLmJlaGF2aW9yLmdldEFjdGl2ZUNvbHVtbjtcbiAgICAgICAgfVxuICAgICAgICBnZXRDb2x1bW4gPSBnZXRDb2x1bW4uYmluZCh0aGlzLmJlaGF2aW9yKTtcblxuICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IG51bUNvbHVtbnM7IGMrKykge1xuICAgICAgICAgICAgY29sdW1uID0gZ2V0Q29sdW1uKGMpO1xuICAgICAgICAgICAgcm93cyA9IHJlc3VsdFtjb2x1bW4ubmFtZV0gPSBuZXcgQXJyYXkoc2VsZWN0ZWRSb3dJbmRleGVzLmxlbmd0aCk7XG4gICAgICAgICAgICBzZWxlY3RlZFJvd0luZGV4ZXMuZm9yRWFjaChnZXRWYWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZXRWYWx1ZShzZWxlY3RlZFJvd0luZGV4LCBqKSB7XG4gICAgICAgICAgICB2YXIgZGF0YVJvdyA9IHNlbGYuZ2V0Um93KHNlbGVjdGVkUm93SW5kZXgpO1xuICAgICAgICAgICAgcm93c1tqXSA9IHZhbE9yRnVuYyhkYXRhUm93LCBjb2x1bW4ubmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBnZXRIaWRkZW5Db2x1bW5zOiBmdW5jdGlvbigpe1xuICAgICAgICAvL0Egbm9uIGluLW1lbW9yeSBiZWhhdmlvciB3aWxsIGJlIG1vcmUgdHJvdWJsZXNvbWVcbiAgICAgIHJldHVybiB0aGlzLmJlaGF2aW9yLmdldEhpZGRlbkNvbHVtbnMoKTtcbiAgICB9LFxuXG4gICAgZ2V0Um93U2VsZWN0aW9uTWF0cml4OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgc2VsZWN0ZWRSb3dJbmRleGVzID0gdGhpcy5zZWxlY3Rpb25Nb2RlbC5nZXRTZWxlY3RlZFJvd3MoKSxcbiAgICAgICAgICAgIG51bUNvbHMgPSB0aGlzLmdldENvbHVtbkNvdW50KCksXG4gICAgICAgICAgICByZXN1bHQgPSBuZXcgQXJyYXkobnVtQ29scyk7XG5cbiAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCBudW1Db2xzOyBjKyspIHtcbiAgICAgICAgICAgIHZhciBjb2x1bW4gPSB0aGlzLmJlaGF2aW9yLmdldEFjdGl2ZUNvbHVtbihjKTtcbiAgICAgICAgICAgIHJlc3VsdFtjXSA9IG5ldyBBcnJheShzZWxlY3RlZFJvd0luZGV4ZXMubGVuZ3RoKTtcbiAgICAgICAgICAgIHNlbGVjdGVkUm93SW5kZXhlcy5mb3JFYWNoKGdldFZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldFZhbHVlKHNlbGVjdGVkUm93SW5kZXgsIHIpIHtcbiAgICAgICAgICAgIHZhciBkYXRhUm93ID0gc2VsZi5nZXRSb3coc2VsZWN0ZWRSb3dJbmRleCk7XG4gICAgICAgICAgICByZXN1bHRbY11bcl0gPSB2YWxPckZ1bmMoZGF0YVJvdywgY29sdW1uLm5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgZ2V0Q29sdW1uU2VsZWN0aW9uTWF0cml4OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRhdGFSb3csXG4gICAgICAgICAgICBzZWxmID0gdGhpcyxcbiAgICAgICAgICAgIGhlYWRlclJvd0NvdW50ID0gdGhpcy5nZXRIZWFkZXJSb3dDb3VudCgpLFxuICAgICAgICAgICAgc2VsZWN0ZWRDb2x1bW5JbmRleGVzID0gdGhpcy5nZXRTZWxlY3RlZENvbHVtbnMoKSxcbiAgICAgICAgICAgIG51bVJvd3MgPSB0aGlzLmdldFJvd0NvdW50KCksXG4gICAgICAgICAgICByZXN1bHQgPSBuZXcgQXJyYXkoc2VsZWN0ZWRDb2x1bW5JbmRleGVzLmxlbmd0aCk7XG5cbiAgICAgICAgc2VsZWN0ZWRDb2x1bW5JbmRleGVzLmZvckVhY2goZnVuY3Rpb24oc2VsZWN0ZWRDb2x1bW5JbmRleCwgYykge1xuICAgICAgICAgICAgdmFyIGNvbHVtbiA9IHNlbGYuYmVoYXZpb3IuZ2V0QWN0aXZlQ29sdW1uKHNlbGVjdGVkQ29sdW1uSW5kZXgpLFxuICAgICAgICAgICAgICAgIHZhbHVlcyA9IHJlc3VsdFtjXSA9IG5ldyBBcnJheShudW1Sb3dzKTtcblxuICAgICAgICAgICAgZm9yICh2YXIgciA9IGhlYWRlclJvd0NvdW50OyByIDwgbnVtUm93czsgcisrKSB7XG4gICAgICAgICAgICAgICAgZGF0YVJvdyA9IHNlbGYuZ2V0Um93KHIpO1xuICAgICAgICAgICAgICAgIHZhbHVlc1tyXSA9IHZhbE9yRnVuYyhkYXRhUm93LCBjb2x1bW4ubmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIGdldENvbHVtblNlbGVjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBkYXRhUm93LFxuICAgICAgICAgICAgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICBoZWFkZXJSb3dDb3VudCA9IHRoaXMuZ2V0SGVhZGVyUm93Q291bnQoKSxcbiAgICAgICAgICAgIHNlbGVjdGVkQ29sdW1uSW5kZXhlcyA9IHRoaXMuZ2V0U2VsZWN0ZWRDb2x1bW5zKCksXG4gICAgICAgICAgICByZXN1bHQgPSB7fSxcbiAgICAgICAgICAgIHJvd0NvdW50ID0gdGhpcy5nZXRSb3dDb3VudCgpO1xuXG4gICAgICAgIHNlbGVjdGVkQ29sdW1uSW5kZXhlcy5mb3JFYWNoKGZ1bmN0aW9uKHNlbGVjdGVkQ29sdW1uSW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBjb2x1bW4gPSBzZWxmLmJlaGF2aW9yLmdldEFjdGl2ZUNvbHVtbihzZWxlY3RlZENvbHVtbkluZGV4KSxcbiAgICAgICAgICAgICAgICB2YWx1ZXMgPSByZXN1bHRbY29sdW1uLm5hbWVdID0gbmV3IEFycmF5KHJvd0NvdW50KTtcblxuICAgICAgICAgICAgZm9yICh2YXIgciA9IGhlYWRlclJvd0NvdW50OyByIDwgcm93Q291bnQ7IHIrKykge1xuICAgICAgICAgICAgICAgIGRhdGFSb3cgPSBzZWxmLmdldFJvdyhyKTtcbiAgICAgICAgICAgICAgICB2YWx1ZXNbcl0gPSB2YWxPckZ1bmMoZGF0YVJvdywgY29sdW1uLm5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBnZXRTZWxlY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZGF0YVJvdyxcbiAgICAgICAgICAgIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgc2VsZWN0aW9ucyA9IHRoaXMuZ2V0U2VsZWN0aW9ucygpLFxuICAgICAgICAgICAgcmVjdHMgPSBuZXcgQXJyYXkoc2VsZWN0aW9ucy5sZW5ndGgpO1xuXG4gICAgICAgIHNlbGVjdGlvbnMuZm9yRWFjaChnZXRSZWN0KTtcblxuICAgICAgICBmdW5jdGlvbiBnZXRSZWN0KHNlbGVjdGlvblJlY3QsIGkpIHtcbiAgICAgICAgICAgIHZhciByZWN0ID0gbm9ybWFsaXplUmVjdChzZWxlY3Rpb25SZWN0KSxcbiAgICAgICAgICAgICAgICBjb2xDb3VudCA9IHJlY3QuZXh0ZW50LnggKyAxLFxuICAgICAgICAgICAgICAgIHJvd0NvdW50ID0gcmVjdC5leHRlbnQueSArIDEsXG4gICAgICAgICAgICAgICAgY29sdW1ucyA9IHt9O1xuXG4gICAgICAgICAgICBmb3IgKHZhciBjID0gMCwgeCA9IHJlY3Qub3JpZ2luLng7IGMgPCBjb2xDb3VudDsgYysrLCB4KyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY29sdW1uID0gc2VsZi5iZWhhdmlvci5nZXRBY3RpdmVDb2x1bW4oeCksXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlcyA9IGNvbHVtbnNbY29sdW1uLm5hbWVdID0gbmV3IEFycmF5KHJvd0NvdW50KTtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIHIgPSAwLCB5ID0gcmVjdC5vcmlnaW4ueTsgciA8IHJvd0NvdW50OyByKyssIHkrKykge1xuICAgICAgICAgICAgICAgICAgICBkYXRhUm93ID0gc2VsZi5nZXRSb3coeSk7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlc1tyXSA9IHZhbE9yRnVuYyhkYXRhUm93LCBjb2x1bW4ubmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZWN0c1tpXSA9IGNvbHVtbnM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVjdHM7XG4gICAgfSxcblxuICAgIGdldFNlbGVjdGlvbk1hdHJpeDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBkYXRhUm93LFxuICAgICAgICAgICAgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICBzZWxlY3Rpb25zID0gdGhpcy5nZXRTZWxlY3Rpb25zKCksXG4gICAgICAgICAgICByZWN0cyA9IG5ldyBBcnJheShzZWxlY3Rpb25zLmxlbmd0aCk7XG5cbiAgICAgICAgc2VsZWN0aW9ucy5mb3JFYWNoKGdldFJlY3QpO1xuXG4gICAgICAgIGZ1bmN0aW9uIGdldFJlY3Qoc2VsZWN0aW9uUmVjdCwgaSkge1xuICAgICAgICAgICAgdmFyIHJlY3QgPSBub3JtYWxpemVSZWN0KHNlbGVjdGlvblJlY3QpLFxuICAgICAgICAgICAgICAgIGNvbENvdW50ID0gcmVjdC5leHRlbnQueCArIDEsXG4gICAgICAgICAgICAgICAgcm93Q291bnQgPSByZWN0LmV4dGVudC55ICsgMSxcbiAgICAgICAgICAgICAgICByb3dzID0gW107XG5cbiAgICAgICAgICAgIGZvciAodmFyIGMgPSAwLCB4ID0gcmVjdC5vcmlnaW4ueDsgYyA8IGNvbENvdW50OyBjKyssIHgrKykge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZXMgPSByb3dzW2NdID0gbmV3IEFycmF5KHJvd0NvdW50KSxcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uID0gc2VsZi5iZWhhdmlvci5nZXRBY3RpdmVDb2x1bW4oeCk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciByID0gMCwgeSA9IHJlY3Qub3JpZ2luLnk7IHIgPCByb3dDb3VudDsgcisrLCB5KyspIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVJvdyA9IHNlbGYuZ2V0Um93KHkpO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZXNbcl0gPSB2YWxPckZ1bmMoZGF0YVJvdywgY29sdW1uLm5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVjdHNbaV0gPSByb3dzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlY3RzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFN5bnRoZXNpemUgYW5kIGZpcmUgYSBgZmluLWNvbnRleHQtbWVudWAgZXZlbnRcbiAgICAgKiBAcGFyYW0ge2tleUV2ZW50fSBldmVudCAtIFRoZSBjYW52YXMgZXZlbnQuXG4gICAgICovXG4gICAgZmlyZVN5bnRoZXRpY0NvbnRleHRNZW51RXZlbnQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZS5ncmlkQ2VsbCA9IHRoaXMuY29udmVydFZpZXdQb2ludFRvRGF0YVBvaW50KGUuZ3JpZENlbGwpO1xuICAgICAgICB2YXIgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ2Zpbi1jb250ZXh0LW1lbnUnLCB7XG4gICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgICBncmlkQ2VsbDogZS5ncmlkQ2VsbCxcbiAgICAgICAgICAgICAgICBtb3VzZVBvaW50OiBlLm1vdXNlUG9pbnQsXG4gICAgICAgICAgICAgICAgdmlld1BvaW50OiBlLnZpZXdQb2ludCxcbiAgICAgICAgICAgICAgICBwcmltaXRpdmVFdmVudDogZS5wcmltaXRpdmVFdmVudCxcbiAgICAgICAgICAgICAgICByb3dzOiB0aGlzLmdldFNlbGVjdGVkUm93cygpLFxuICAgICAgICAgICAgICAgIGNvbHVtbnM6IHRoaXMuZ2V0U2VsZWN0ZWRDb2x1bW5zKCksXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uczogdGhpcy5zZWxlY3Rpb25Nb2RlbC5nZXRTZWxlY3Rpb25zKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2FudmFzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgIH0sXG5cbiAgICBmaXJlU3ludGhldGljTW91c2VVcEV2ZW50OiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciBldmVudCA9IG5ldyBDdXN0b21FdmVudCgnZmluLW1vdXNldXAnLCB7XG4gICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgICBncmlkQ2VsbDogZS5ncmlkQ2VsbCxcbiAgICAgICAgICAgICAgICBtb3VzZVBvaW50OiBlLm1vdXNlUG9pbnQsXG4gICAgICAgICAgICAgICAgdmlld1BvaW50OiBlLnZpZXdQb2ludCxcbiAgICAgICAgICAgICAgICBwcmltaXRpdmVFdmVudDogZS5wcmltaXRpdmVFdmVudCxcbiAgICAgICAgICAgICAgICByb3dzOiB0aGlzLmdldFNlbGVjdGVkUm93cygpLFxuICAgICAgICAgICAgICAgIGNvbHVtbnM6IHRoaXMuZ2V0U2VsZWN0ZWRDb2x1bW5zKCksXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uczogdGhpcy5zZWxlY3Rpb25Nb2RlbC5nZXRTZWxlY3Rpb25zKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2FudmFzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgIH0sXG5cbiAgICBmaXJlU3ludGhldGljTW91c2VEb3duRXZlbnQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdGhpcy5zdG9wRWRpdGluZygpO1xuICAgICAgICB2YXIgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ2Zpbi1tb3VzZWRvd24nLCB7XG4gICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgICBncmlkQ2VsbDogZS5ncmlkQ2VsbCxcbiAgICAgICAgICAgICAgICBtb3VzZVBvaW50OiBlLm1vdXNlUG9pbnQsXG4gICAgICAgICAgICAgICAgdmlld1BvaW50OiBlLnZpZXdQb2ludCxcbiAgICAgICAgICAgICAgICBwcmltaXRpdmVFdmVudDogZS5wcmltaXRpdmVFdmVudCxcbiAgICAgICAgICAgICAgICByb3dzOiB0aGlzLmdldFNlbGVjdGVkUm93cygpLFxuICAgICAgICAgICAgICAgIGNvbHVtbnM6IHRoaXMuZ2V0U2VsZWN0ZWRDb2x1bW5zKCksXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uczogdGhpcy5zZWxlY3Rpb25Nb2RlbC5nZXRTZWxlY3Rpb25zKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2FudmFzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgIH0sXG5cbiAgICBpc1ZpZXdhYmxlQnV0dG9uOiBmdW5jdGlvbihjLCByKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFJlbmRlcmVyKCkuaXNWaWV3YWJsZUJ1dHRvbihjLCByKTtcbiAgICB9LFxuXG4gICAgZmlyZVN5bnRoZXRpY0J1dHRvblByZXNzZWRFdmVudDogZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIHZhciBkYXRhQ2VsbCA9IGV2dC5kYXRhQ2VsbDtcbiAgICAgICAgdmFyIGdyaWRDZWxsID0gZXZ0LmdyaWRDZWxsO1xuICAgICAgICBpZiAodGhpcy5pc1ZpZXdhYmxlQnV0dG9uKGRhdGFDZWxsLngsIGRhdGFDZWxsLnkpKSB7XG4gICAgICAgICAgICB2YXIgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ2Zpbi1idXR0b24tcHJlc3NlZCcsIHtcbiAgICAgICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgICAgICAgZ3JpZENlbGw6IGdyaWRDZWxsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmNhbnZhcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBTeW50aGVzaXplIGFuZCBmaXJlIGEgYGZpbi1jb2x1bW4tZHJhZy1zdGFydGAgZXZlbnQuXG4gICAgICovXG4gICAgZmlyZVN5bnRoZXRpY09uQ29sdW1uc0NoYW5nZWRFdmVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBkZXRhaWwgPSB7XG4gICAgICAgICAgICB0aW1lOiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgZ3JpZDogdGhpc1xuICAgICAgICB9O1xuICAgICAgICB2YXIgY0V2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdmaW4tY29sdW1uLWNoYW5nZWQtZXZlbnQnLCB7XG4gICAgICAgICAgICBkZXRhaWw6IGRldGFpbFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc29sZS5sb2coJ2NvbHVtbiBjaGFuZ2VkJyk7XG4gICAgICAgIHRoaXMuY2FudmFzLmRpc3BhdGNoRXZlbnQoY0V2ZW50KTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgU3ludGhlc2l6ZSBhbmQgZmlyZSBhIGBmaW4ta2V5ZG93bmAgZXZlbnQuXG4gICAgICogQHBhcmFtIHtrZXlFdmVudH0gZXZlbnQgLSBUaGUgY2FudmFzIGV2ZW50LlxuICAgICAqL1xuICAgIGZpcmVTeW50aGV0aWNLZXlkb3duRXZlbnQ6IGZ1bmN0aW9uKGtleUV2ZW50KSB7XG4gICAgICAgIHZhciBjbGlja0V2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdmaW4ta2V5ZG93bicsIHtcbiAgICAgICAgICAgIGRldGFpbDoga2V5RXZlbnQuZGV0YWlsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNhbnZhcy5kaXNwYXRjaEV2ZW50KGNsaWNrRXZlbnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFN5bnRoZXNpemUgYW5kIGZpcmUgYSBgZmluLWtleXVwYCBldmVudC5cbiAgICAgKiBAcGFyYW0ge2tleUV2ZW50fSBldmVudCAtIFRoZSBjYW52YXMgZXZlbnQuXG4gICAgICovXG4gICAgZmlyZVN5bnRoZXRpY0tleXVwRXZlbnQ6IGZ1bmN0aW9uKGtleUV2ZW50KSB7XG4gICAgICAgIHZhciBjbGlja0V2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdmaW4ta2V5dXAnLCB7XG4gICAgICAgICAgICBkZXRhaWw6IGtleUV2ZW50LmRldGFpbFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jYW52YXMuZGlzcGF0Y2hFdmVudChjbGlja0V2ZW50KTtcbiAgICB9LFxuXG4gICAgZmlyZVN5bnRoZXRpY0ZpbHRlckFwcGxpZWRFdmVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBmaWx0ZXJFdmVudCA9IG5ldyBDdXN0b21FdmVudCgnZmluLWZpbHRlci1hcHBsaWVkJyk7XG4gICAgICAgIHRoaXMuY2FudmFzLmRpc3BhdGNoRXZlbnQoZmlsdGVyRXZlbnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFN5bnRoZXNpemUgYW5kIGZpcmUgYSBgZmluLWNlbGwtZW50ZXJgIGV2ZW50XG4gICAgICogQHBhcmFtIHtQb2ludH0gY2VsbCAtIFRoZSBwaXhlbCBsb2NhdGlvbiBvZiB0aGUgY2VsbCBpbiB3aGljaCB0aGUgY2xpY2sgZXZlbnQgb2NjdXJyZWQuXG4gICAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBldmVudCAtIFRoZSBzeXN0ZW0gbW91c2UgZXZlbnQuXG4gICAgICovXG4gICAgZmlyZVN5bnRoZXRpY09uQ2VsbEVudGVyRXZlbnQ6IGZ1bmN0aW9uKGNlbGwpIHtcbiAgICAgICAgdmFyIGRldGFpbCA9IHtcbiAgICAgICAgICAgIGdyaWRDZWxsOiBjZWxsLFxuICAgICAgICAgICAgdGltZTogRGF0ZS5ub3coKSxcbiAgICAgICAgICAgIGdyaWQ6IHRoaXNcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGNsaWNrRXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ2Zpbi1jZWxsLWVudGVyJywge1xuICAgICAgICAgICAgZGV0YWlsOiBkZXRhaWxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2FudmFzLmRpc3BhdGNoRXZlbnQoY2xpY2tFdmVudCk7XG4gICAgfSxcblxuICAgIGZpcmVTeW50aGV0aWNHcm91cHNDaGFuZ2VkRXZlbnQ6IGZ1bmN0aW9uKGdyb3Vwcykge1xuICAgICAgICB2YXIgZGV0YWlsID0ge1xuICAgICAgICAgICAgZ3JvdXBzOiBncm91cHMsXG4gICAgICAgICAgICB0aW1lOiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgZ3JpZDogdGhpc1xuICAgICAgICB9O1xuICAgICAgICB2YXIgY2xpY2tFdmVudCA9IG5ldyBDdXN0b21FdmVudCgnZmluLWdyb3Vwcy1jaGFuZ2VkJywge1xuICAgICAgICAgICAgZGV0YWlsOiBkZXRhaWxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2FudmFzLmRpc3BhdGNoRXZlbnQoY2xpY2tFdmVudCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgU3ludGhlc2l6ZSBhbmQgZmlyZSBhIGBmaW4tY2VsbC1leGl0YCBldmVudC5cbiAgICAgKiBAcGFyYW0ge1BvaW50fSBjZWxsIC0gVGhlIHBpeGVsIGxvY2F0aW9uIG9mIHRoZSBjZWxsIGluIHdoaWNoIHRoZSBjbGljayBldmVudCBvY2N1cmVkLlxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZXZlbnQgLSBUaGUgc3lzdGVtIG1vdXNlIGV2ZW50LlxuICAgICAqL1xuICAgIGZpcmVTeW50aGV0aWNPbkNlbGxFeGl0RXZlbnQ6IGZ1bmN0aW9uKGNlbGwpIHtcbiAgICAgICAgdmFyIGRldGFpbCA9IHtcbiAgICAgICAgICAgIGdyaWRDZWxsOiBjZWxsLFxuICAgICAgICAgICAgdGltZTogRGF0ZS5ub3coKSxcbiAgICAgICAgICAgIGdyaWQ6IHRoaXNcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGNsaWNrRXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ2Zpbi1jZWxsLWV4aXQnLCB7XG4gICAgICAgICAgICBkZXRhaWw6IGRldGFpbFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jYW52YXMuZGlzcGF0Y2hFdmVudChjbGlja0V2ZW50KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBTeW50aGVzaXplIGFuZCBmaXJlIGEgYGZpbi1jZWxsLWNsaWNrYCBldmVudC5cbiAgICAgKiBAcGFyYW0ge1BvaW50fSBjZWxsIC0gVGhlIHBpeGVsIGxvY2F0aW9uIG9mIHRoZSBjZWxsIGluIHdoaWNoIHRoZSBjbGljayBldmVudCBvY2N1cmVkLlxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZXZlbnQgLSBUaGUgc3lzdGVtIG1vdXNlIGV2ZW50LlxuICAgICAqL1xuICAgIGZpcmVTeW50aGV0aWNDbGlja0V2ZW50OiBmdW5jdGlvbihtb3VzZUV2ZW50KSB7XG4gICAgICAgIHZhciBjZWxsID0gbW91c2VFdmVudC5ncmlkQ2VsbDtcbiAgICAgICAgdmFyIGRldGFpbCA9IHtcbiAgICAgICAgICAgIGdyaWRDZWxsOiBjZWxsLFxuICAgICAgICAgICAgbW91c2VQb2ludDogbW91c2VFdmVudC5tb3VzZVBvaW50LFxuICAgICAgICAgICAga2V5czogbW91c2VFdmVudC5rZXlzLFxuICAgICAgICAgICAgcHJpbWl0aXZlRXZlbnQ6IG1vdXNlRXZlbnQsXG4gICAgICAgICAgICB0aW1lOiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgZ3JpZDogdGhpc1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmJlaGF2aW9yLmVuaGFuY2VEb3VibGVDbGlja0V2ZW50KGRldGFpbCk7XG4gICAgICAgIHZhciBjbGlja0V2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdmaW4tY2xpY2snLCB7XG4gICAgICAgICAgICBkZXRhaWw6IGRldGFpbFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jYW52YXMuZGlzcGF0Y2hFdmVudChjbGlja0V2ZW50KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBTeW50aGVzaXplIGFuZCBmaXJlIGEgYGZpbi1kb3VibGUtY2xpY2tgIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZXZlbnQgLSBUaGUgc3lzdGVtIG1vdXNlIGV2ZW50LlxuICAgICAqL1xuICAgIGZpcmVTeW50aGV0aWNEb3VibGVDbGlja0V2ZW50OiBmdW5jdGlvbihtb3VzZUV2ZW50KSB7XG4gICAgICAgIHRoaXMuc3RvcEVkaXRpbmcoKTtcbiAgICAgICAgdmFyIGNlbGwgPSBtb3VzZUV2ZW50LmdyaWRDZWxsO1xuICAgICAgICB2YXIgZGV0YWlsID0ge1xuICAgICAgICAgICAgZ3JpZENlbGw6IGNlbGwsXG4gICAgICAgICAgICBtb3VzZVBvaW50OiBtb3VzZUV2ZW50Lm1vdXNlUG9pbnQsXG4gICAgICAgICAgICB0aW1lOiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgZ3JpZDogdGhpc1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmJlaGF2aW9yLmVuaGFuY2VEb3VibGVDbGlja0V2ZW50KG1vdXNlRXZlbnQpO1xuICAgICAgICB2YXIgY2xpY2tFdmVudCA9IG5ldyBDdXN0b21FdmVudCgnZmluLWRvdWJsZS1jbGljaycsIHtcbiAgICAgICAgICAgIGRldGFpbDogZGV0YWlsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmJlaGF2aW9yLmNlbGxEb3VibGVDbGlja2VkKGNlbGwsIG1vdXNlRXZlbnQpO1xuICAgICAgICB0aGlzLmNhbnZhcy5kaXNwYXRjaEV2ZW50KGNsaWNrRXZlbnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFN5bnRoZXNpemUgYW5kIGZpcmUgYSByZW5kZXJlZCBldmVudC5cbiAgICAgKi9cbiAgICBmaXJlU3ludGhldGljR3JpZFJlbmRlcmVkRXZlbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ2Zpbi1ncmlkLXJlbmRlcmVkJywge1xuICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgICAgICAgICAgIHRpbWU6IERhdGUubm93KClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLmNhbnZhcykge1xuICAgICAgICAgICAgdGhpcy5jYW52YXMuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBTeW50aGVzaXplIGFuZCBmaXJlIGEgc2Nyb2xsIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gU2hvdWxkIGJlIGVpdGhlciBgZmluLXNjcm9sbC14YCBvciBgZmluLXNjcm9sbC15YC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb2xkVmFsdWUgLSBUaGUgb2xkIHNjcm9sbCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbmV3VmFsdWUgLSBUaGUgbmV3IHNjcm9sbCB2YWx1ZS5cbiAgICAgKi9cbiAgICBmaXJlU2Nyb2xsRXZlbnQ6IGZ1bmN0aW9uKHR5cGUsIG9sZFZhbHVlLCBuZXdWYWx1ZSkge1xuICAgICAgICB2YXIgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQodHlwZSwge1xuICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgb2xkVmFsdWU6IG9sZFZhbHVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBuZXdWYWx1ZSxcbiAgICAgICAgICAgICAgICB0aW1lOiBEYXRlLm5vdygpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNhbnZhcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFNldCB0aGUgdmVydGljYWwgc2Nyb2xsIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuZXdWYWx1ZSAtIFRoZSBuZXcgc2Nyb2xsIHZhbHVlLlxuICAgICAqL1xuICAgIHNldFZTY3JvbGxWYWx1ZTogZnVuY3Rpb24oeSkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHkgPSBNYXRoLm1pbih0aGlzLnNiVlNjcm9sbGVyLnJhbmdlLm1heCwgTWF0aC5tYXgoMCwgTWF0aC5yb3VuZCh5KSkpO1xuICAgICAgICBpZiAoeSAhPT0gdGhpcy52U2Nyb2xsVmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuYmVoYXZpb3IuX3NldFNjcm9sbFBvc2l0aW9uWSh5KTtcbiAgICAgICAgICAgIHZhciBvbGRZID0gdGhpcy52U2Nyb2xsVmFsdWU7XG4gICAgICAgICAgICB0aGlzLnZTY3JvbGxWYWx1ZSA9IHk7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbFZhbHVlQ2hhbmdlZE5vdGlmaWNhdGlvbigpO1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvLyBzZWxmLnNiVlJhbmdlQWRhcHRlci5zdWJqZWN0Q2hhbmdlZCgpO1xuICAgICAgICAgICAgICAgIHNlbGYuZmlyZVNjcm9sbEV2ZW50KCdmaW4tc2Nyb2xsLXknLCBvbGRZLCB5KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgdmVydGljYWwgc2Nyb2xsIHZhbHVlLlxuICAgICAqL1xuICAgIGdldFZTY3JvbGxWYWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZTY3JvbGxWYWx1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBTZXQgdGhlIGhvcml6b250YWwgc2Nyb2xsIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuZXdWYWx1ZSAtIFRoZSBuZXcgc2Nyb2xsIHZhbHVlLlxuICAgICAqL1xuICAgIHNldEhTY3JvbGxWYWx1ZTogZnVuY3Rpb24oeCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHggPSBNYXRoLm1pbih0aGlzLnNiSFNjcm9sbGVyLnJhbmdlLm1heCwgTWF0aC5tYXgoMCwgTWF0aC5yb3VuZCh4KSkpO1xuICAgICAgICBpZiAoeCAhPT0gdGhpcy5oU2Nyb2xsVmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuYmVoYXZpb3IuX3NldFNjcm9sbFBvc2l0aW9uWCh4KTtcbiAgICAgICAgICAgIHZhciBvbGRYID0gdGhpcy5oU2Nyb2xsVmFsdWU7XG4gICAgICAgICAgICB0aGlzLmhTY3JvbGxWYWx1ZSA9IHg7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbFZhbHVlQ2hhbmdlZE5vdGlmaWNhdGlvbigpO1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvL3NlbGYuc2JIUmFuZ2VBZGFwdGVyLnN1YmplY3RDaGFuZ2VkKCk7XG4gICAgICAgICAgICAgICAgc2VsZi5maXJlU2Nyb2xsRXZlbnQoJ2Zpbi1zY3JvbGwteCcsIG9sZFgsIHgpO1xuICAgICAgICAgICAgICAgIC8vc2VsZi5zeW5jaHJvbml6ZVNjcm9sbGluZ0JvdW5kcmllcygpOyAvLyB0b2RvOiBDb21tZW50ZWQgb2ZmIHRvIHByZXZlbnQgdGhlIGdyaWQgZnJvbSBib3VuY2luZyBiYWNrLCBidXQgdGhlcmUgbWF5IGJlIHJlcHVyY3Vzc2lvbnMuLi5cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMgVGhlIHZlcnRpY2FsIHNjcm9sbCB2YWx1ZS5cbiAgICAgKi9cbiAgICBnZXRIU2Nyb2xsVmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oU2Nyb2xsVmFsdWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgUmVxdWVzdCBpbnB1dCBmb2N1cy5cbiAgICAgKi9cbiAgICB0YWtlRm9jdXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuc3RvcEVkaXRpbmcoKSkge1xuICAgICAgICAgICAgdGhpcy5nZXRDYW52YXMoKS50YWtlRm9jdXMoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFJlcXVlc3QgZm9jdXMgZm9yIG91ciBjZWxsIGVkaXRvci5cbiAgICAgKi9cbiAgICBlZGl0b3JUYWtlRm9jdXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5jZWxsRWRpdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jZWxsRWRpdG9yLnRha2VGb2N1cygpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgSW5pdGlhbGl6ZSB0aGUgc2Nyb2xsIGJhcnMuXG4gICAgICovXG4gICAgaW5pdFNjcm9sbGJhcnM6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICB2YXIgaG9yekJhciA9IG5ldyBGaW5CYXIoe1xuICAgICAgICAgICAgb3JpZW50YXRpb246ICdob3Jpem9udGFsJyxcbiAgICAgICAgICAgIG9uY2hhbmdlOiBzZWxmLnNldEhTY3JvbGxWYWx1ZS5iaW5kKHNlbGYpLFxuICAgICAgICAgICAgY3NzU3R5bGVzaGVldFJlZmVyZW5jZUVsZW1lbnQ6IHRoaXMuZGl2XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciB2ZXJ0QmFyID0gbmV3IEZpbkJhcih7XG4gICAgICAgICAgICBvcmllbnRhdGlvbjogJ3ZlcnRpY2FsJyxcbiAgICAgICAgICAgIG9uY2hhbmdlOiBzZWxmLnNldFZTY3JvbGxWYWx1ZS5iaW5kKHNlbGYpLFxuICAgICAgICAgICAgcGFnaW5nOiB7XG4gICAgICAgICAgICAgICAgdXA6IHNlbGYucGFnZVVwLmJpbmQoc2VsZiksXG4gICAgICAgICAgICAgICAgZG93bjogc2VsZi5wYWdlRG93bi5iaW5kKHNlbGYpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuc2JIU2Nyb2xsZXIgPSBob3J6QmFyO1xuICAgICAgICB0aGlzLnNiVlNjcm9sbGVyID0gdmVydEJhcjtcblxuICAgICAgICB2YXIgaFByZWZpeCA9IHRoaXMucmVzb2x2ZVByb3BlcnR5KCdoU2Nyb2xsYmFyQ2xhc3NQcmVmaXgnKTtcbiAgICAgICAgdmFyIHZQcmVmaXggPSB0aGlzLnJlc29sdmVQcm9wZXJ0eSgndlNjcm9sbGJhckNsYXNzUHJlZml4Jyk7XG5cbiAgICAgICAgaWYgKGhQcmVmaXggJiYgaFByZWZpeCAhPT0gJycpIHtcbiAgICAgICAgICAgIHRoaXMuc2JIU2Nyb2xsZXIuY2xhc3NQcmVmaXggPSBoUHJlZml4O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZQcmVmaXggJiYgdlByZWZpeCAhPT0gJycpIHtcbiAgICAgICAgICAgIHRoaXMuc2JWU2Nyb2xsZXIuY2xhc3NQcmVmaXggPSB2UHJlZml4O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5kaXYuYXBwZW5kQ2hpbGQoaG9yekJhci5iYXIpO1xuICAgICAgICB0aGlzLmRpdi5hcHBlbmRDaGlsZCh2ZXJ0QmFyLmJhcik7XG5cbiAgICAgICAgdGhpcy5yZXNpemVTY3JvbGxiYXJzKCk7XG5cbiAgICB9LFxuXG4gICAgcmVzaXplU2Nyb2xsYmFyczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc2JIU2Nyb2xsZXIuc2hvcnRlbkJ5KHRoaXMuc2JWU2Nyb2xsZXIpLnJlc2l6ZSgpO1xuICAgICAgICAvL3RoaXMuc2JWU2Nyb2xsZXIuc2hvcnRlbkJ5KHRoaXMuc2JIU2Nyb2xsZXIpO1xuICAgICAgICB0aGlzLnNiVlNjcm9sbGVyLnJlc2l6ZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFNjcm9sbCB2YWx1ZXMgaGF2ZSBjaGFuZ2VkLCB3ZSd2ZSBiZWVuIG5vdGlmaWVkLlxuICAgICAqL1xuICAgIHNldFZTY3JvbGxiYXJWYWx1ZXM6IGZ1bmN0aW9uKG1heCkge1xuICAgICAgICB0aGlzLnNiVlNjcm9sbGVyLnJhbmdlID0ge1xuICAgICAgICAgICAgbWluOiAwLFxuICAgICAgICAgICAgbWF4OiBtYXhcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgc2V0SFNjcm9sbGJhclZhbHVlczogZnVuY3Rpb24obWF4KSB7XG4gICAgICAgIHRoaXMuc2JIU2Nyb2xsZXIucmFuZ2UgPSB7XG4gICAgICAgICAgICBtaW46IDAsXG4gICAgICAgICAgICBtYXg6IG1heFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBzY3JvbGxWYWx1ZUNoYW5nZWROb3RpZmljYXRpb246IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGlmICh0aGlzLmhTY3JvbGxWYWx1ZSA9PT0gdGhpcy5zYlByZXZIU2Nyb2xsVmFsdWUgJiYgdGhpcy52U2Nyb2xsVmFsdWUgPT09IHRoaXMuc2JQcmV2VlNjcm9sbFZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNiUHJldkhTY3JvbGxWYWx1ZSA9IHRoaXMuaFNjcm9sbFZhbHVlO1xuICAgICAgICB0aGlzLnNiUHJldlZTY3JvbGxWYWx1ZSA9IHRoaXMudlNjcm9sbFZhbHVlO1xuXG4gICAgICAgIGlmICh0aGlzLmNlbGxFZGl0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuY2VsbEVkaXRvci5zY3JvbGxWYWx1ZUNoYW5nZWROb3RpZmljYXRpb24oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY29tcHV0ZUNlbGxzQm91bmRzKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHN1bW1hcnkgR2V0IGRhdGEgdmFsdWUgYXQgZ2l2ZW4gY2VsbC5cbiAgICAgKiBAZGVzYyBEZWxlZ2F0ZXMgdG8gdGhlIGJlaGF2aW9yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIGhvcml6b250YWwgY29vcmRpbmF0ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAtIFRoZSB2ZXJ0aWNhbCBjb29yZGluYXRlLlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKi9cbiAgICBnZXRWYWx1ZTogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWhhdmlvci5nZXRWYWx1ZSh4LCB5KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBTZXQgYSBkYXRhIHZhbHVlIGludG8gdGhlIGJlaGF2aW9yIChtb2RlbCkgYXQgdGhlIGdpdmVuIHBvaW50XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgaG9yaXpvbnRhbCBjb29yZGluYXRlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gVGhlIHZlcnRpY2FsIGNvb3JkaW5hdGUuXG4gICAgICovXG4gICAgc2V0VmFsdWU6IGZ1bmN0aW9uKHgsIHksIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuYmVoYXZpb3Iuc2V0VmFsdWUoeCwgeSwgdmFsdWUpO1xuICAgIH0sXG5cbiAgICBnZXRDb2x1bW5BbGlnbm1lbnQ6IGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVoYXZpb3IuZ2V0Q29sdW1uQWxpZ25tZW50KGMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFRoZSBkYXRhIGRpbWVuc2lvbnMgaGF2ZSBjaGFuZ2VkLCBvciBvdXIgcGl4ZWwgYm91bmRyaWVzIGhhdmUgY2hhbmdlZC5cbiAgICAgKiBBZGp1c3QgdGhlIHNjcm9sbGJhciBwcm9wZXJ0aWVzIGFzIG5lY2Vzc2FyeS5cbiAgICAgKi9cbiAgICBzeW5jaHJvbml6ZVNjcm9sbGluZ0JvdW5kcmllczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBudW1GaXhlZENvbHVtbnMgPSB0aGlzLmdldEZpeGVkQ29sdW1uQ291bnQoKTtcbiAgICAgICAgdmFyIG51bUZpeGVkUm93cyA9IHRoaXMuZ2V0Rml4ZWRSb3dDb3VudCgpO1xuXG4gICAgICAgIHZhciBudW1Db2x1bW5zID0gdGhpcy5nZXRDb2x1bW5Db3VudCgpO1xuICAgICAgICB2YXIgbnVtUm93cyA9IHRoaXMuZ2V0Um93Q291bnQoKTtcblxuICAgICAgICB2YXIgYm91bmRzID0gdGhpcy5nZXRCb3VuZHMoKTtcbiAgICAgICAgaWYgKCFib3VuZHMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2Nyb2xsYWJsZUhlaWdodCA9IGJvdW5kcy5oZWlnaHQgLSB0aGlzLmJlaGF2aW9yLmdldEZpeGVkUm93c01heEhlaWdodCgpIC0gMTU7IC8vNXB4IHBhZGRpbmcgYXQgYm90dG9tIGFuZCByaWdodCBzaWRlXG4gICAgICAgIHZhciBzY3JvbGxhYmxlV2lkdGggPSAoYm91bmRzLndpZHRoIC0gMjAwKSAtIHRoaXMuYmVoYXZpb3IuZ2V0Rml4ZWRDb2x1bW5zTWF4V2lkdGgoKSAtIDE1O1xuXG4gICAgICAgIHZhciBsYXN0UGFnZUNvbHVtbkNvdW50ID0gMDtcbiAgICAgICAgdmFyIGNvbHVtbnNXaWR0aCA9IDA7XG4gICAgICAgIGZvciAoOyBsYXN0UGFnZUNvbHVtbkNvdW50IDwgbnVtQ29sdW1uczsgbGFzdFBhZ2VDb2x1bW5Db3VudCsrKSB7XG4gICAgICAgICAgICB2YXIgZWFjaFdpZHRoID0gdGhpcy5nZXRDb2x1bW5XaWR0aChudW1Db2x1bW5zIC0gbGFzdFBhZ2VDb2x1bW5Db3VudCAtIDEpO1xuICAgICAgICAgICAgY29sdW1uc1dpZHRoICs9IGVhY2hXaWR0aDtcbiAgICAgICAgICAgIGlmIChjb2x1bW5zV2lkdGggPiBzY3JvbGxhYmxlV2lkdGgpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsYXN0UGFnZVJvd0NvdW50ID0gMDtcbiAgICAgICAgdmFyIHJvd3NIZWlnaHQgPSAwO1xuICAgICAgICBmb3IgKDsgbGFzdFBhZ2VSb3dDb3VudCA8IG51bVJvd3M7IGxhc3RQYWdlUm93Q291bnQrKykge1xuICAgICAgICAgICAgdmFyIGVhY2hIZWlnaHQgPSB0aGlzLmdldFJvd0hlaWdodChudW1Sb3dzIC0gbGFzdFBhZ2VSb3dDb3VudCAtIDEpO1xuICAgICAgICAgICAgcm93c0hlaWdodCArPSBlYWNoSGVpZ2h0O1xuICAgICAgICAgICAgaWYgKHJvd3NIZWlnaHQgPiBzY3JvbGxhYmxlSGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaE1heCA9IE1hdGgubWF4KDAsIG51bUNvbHVtbnMgLSBudW1GaXhlZENvbHVtbnMgLSBsYXN0UGFnZUNvbHVtbkNvdW50KTtcbiAgICAgICAgdGhpcy5zZXRIU2Nyb2xsYmFyVmFsdWVzKGhNYXgpO1xuXG4gICAgICAgIHZhciB2TWF4ID0gMSArIE1hdGgubWF4KDAsIG51bVJvd3MgLSBudW1GaXhlZFJvd3MgLSBsYXN0UGFnZVJvd0NvdW50KTtcbiAgICAgICAgdGhpcy5zZXRWU2Nyb2xsYmFyVmFsdWVzKHZNYXgpO1xuXG4gICAgICAgIHRoaXMuc2V0SFNjcm9sbFZhbHVlKE1hdGgubWluKHRoaXMuZ2V0SFNjcm9sbFZhbHVlKCksIGhNYXgpKTtcbiAgICAgICAgdGhpcy5zZXRWU2Nyb2xsVmFsdWUoTWF0aC5taW4odGhpcy5nZXRWU2Nyb2xsVmFsdWUoKSwgdk1heCkpO1xuXG4gICAgICAgIC8vdGhpcy5nZXRDYW52YXMoKS5yZXNpemUoKTtcbiAgICAgICAgdGhpcy5jb21wdXRlQ2VsbHNCb3VuZHMoKTtcbiAgICAgICAgdGhpcy5yZXBhaW50KCk7XG5cbiAgICAgICAgdGhpcy5yZXNpemVTY3JvbGxiYXJzKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgTm90ZSB0aGF0IFwidmlld2FibGUgcm93c1wiIGluY2x1ZGVzIGFueSBwYXJ0aWFsbHkgdmlld2FibGUgcm93cy5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIHZpZXdhYmxlIHJvd3MuXG4gICAgICovXG4gICAgZ2V0VmlzaWJsZVJvd3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRSZW5kZXJlcigpLmdldFZpc2libGVSb3dzKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgTm90ZSB0aGF0IFwidmlld2FibGUgY29sdW1uc1wiIGluY2x1ZGVzIGFueSBwYXJ0aWFsbHkgdmlld2FibGUgY29sdW1ucy5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIHZpZXdhYmxlIGNvbHVtbnMuXG4gICAgICovXG4gICAgZ2V0VmlzaWJsZUNvbHVtbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRSZW5kZXJlcigpLmdldFZpc2libGVDb2x1bW5zKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHN1bW1hcnkgSW5pdGlhbGl6ZSB0aGUgcmVuZGVyZXIgc3ViLWNvbXBvbmVudC5cbiAgICAgKi9cbiAgICBpbml0UmVuZGVyZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gbmV3IFJlbmRlcmVyKHRoaXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtSZW5kZXJlcn0gc3ViLWNvbXBvbmVudFxuICAgICAqL1xuICAgIGdldFJlbmRlcmVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge251bWJlcn0gVGhlIHdpZHRoIG9mIHRoZSBnaXZlbiBjb2x1bW4uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbHVtbkluZGV4IC0gVGhlIHVudHJhbnNsYXRlZCBjb2x1bW4gaW5kZXguXG4gICAgICovXG4gICAgZ2V0Q29sdW1uV2lkdGg6IGZ1bmN0aW9uKGNvbHVtbkluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlaGF2aW9yLmdldENvbHVtbldpZHRoKGNvbHVtbkluZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBTZXQgdGhlIHdpZHRoIG9mIHRoZSBnaXZlbiBjb2x1bW4uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbHVtbkluZGV4IC0gVGhlIHVudHJhbnNsYXRlZCBjb2x1bW4gaW5kZXguXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbHVtbldpZHRoIC0gVGhlIHdpZHRoIGluIHBpeGVscy5cbiAgICAgKi9cbiAgICBzZXRDb2x1bW5XaWR0aDogZnVuY3Rpb24oY29sdW1uSW5kZXgsIGNvbHVtbldpZHRoKSB7XG4gICAgICAgIHRoaXMuc3RvcEVkaXRpbmcoKTtcbiAgICAgICAgdGhpcy5iZWhhdmlvci5zZXRDb2x1bW5XaWR0aChjb2x1bW5JbmRleCwgY29sdW1uV2lkdGgpO1xuICAgIH0sXG5cbiAgICBnZXRDb2x1bW5FZGdlOiBmdW5jdGlvbihjKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlaGF2aW9yLmdldENvbHVtbkVkZ2UoYywgdGhpcy5nZXRSZW5kZXJlcigpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgdG90YWwgd2lkdGggb2YgYWxsIHRoZSBmaXhlZCBjb2x1bW5zLlxuICAgICAqL1xuICAgIGdldEZpeGVkQ29sdW1uc1dpZHRoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVoYXZpb3IuZ2V0Rml4ZWRDb2x1bW5zV2lkdGgoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgaGVpZ2h0IG9mIHRoZSBnaXZlbiByb3dcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcm93SW5kZXggLSBUaGUgdW50cmFuc2xhdGVkIGZpeGVkIGNvbHVtbiBpbmRleC5cbiAgICAgKi9cbiAgICBnZXRSb3dIZWlnaHQ6IGZ1bmN0aW9uKHJvd0luZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlaGF2aW9yLmdldFJvd0hlaWdodChyb3dJbmRleCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgU2V0IHRoZSBoZWlnaHQgb2YgdGhlIGdpdmVuIHJvdy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcm93SW5kZXggLSBUaGUgcm93IGluZGV4LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByb3dIZWlnaHQgLSBUaGUgd2lkdGggaW4gcGl4ZWxzLlxuICAgICAqL1xuICAgIHNldFJvd0hlaWdodDogZnVuY3Rpb24ocm93SW5kZXgsIHJvd0hlaWdodCkge1xuICAgICAgICB0aGlzLnN0b3BFZGl0aW5nKCk7XG4gICAgICAgIHRoaXMuYmVoYXZpb3Iuc2V0Um93SGVpZ2h0KHJvd0luZGV4LCByb3dIZWlnaHQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSB0b3RhbCBmaXhlZCByb3dzIGhlaWdodFxuICAgICAqL1xuICAgIGdldEZpeGVkUm93c0hlaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlaGF2aW9yLmdldEZpeGVkUm93c0hlaWdodCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBOdW1iZXIgb2YgX3Zpc2libGVfIGNvbHVtbnMuXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNvbHVtbnMuXG4gICAgICovXG4gICAgZ2V0Q29sdW1uQ291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWhhdmlvci5nZXRBY3RpdmVDb2x1bW5Db3VudCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgZml4ZWQgcm93cy5cbiAgICAgKi9cbiAgICBnZXRSb3dDb3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlaGF2aW9yLmdldFJvd0NvdW50KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge251bWJlcn0gVGhlIG51bWJlciBvZiB1bmZpbHRlcmVkIHJvd3MuXG4gICAgICovXG4gICAgZ2V0VW5maWx0ZXJlZFJvd0NvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVoYXZpb3IuZ2V0VW5maWx0ZXJlZFJvd0NvdW50KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge251bWJlcn0gVGhlIG51bWJlciBvZiBmaXhlZCBjb2x1bW5zLlxuICAgICAqL1xuICAgIGdldEZpeGVkQ29sdW1uQ291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWhhdmlvci5nZXRGaXhlZENvbHVtbkNvdW50KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMgVGhlIG51bWJlciBvZiBmaXhlZCByb3dzLlxuICAgICAqL1xuICAgIGdldEZpeGVkUm93Q291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWhhdmlvci5nZXRGaXhlZFJvd0NvdW50KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHN1bW1hcnkgVGhlIHRvcCBsZWZ0IGFyZWEgaGFzIGJlZW4gY2xpY2tlZCBvblxuICAgICAqIEBkZXNjIERlbGVnYXRlcyB0byB0aGUgYmVoYXZpb3IuXG4gICAgICogQHBhcmFtIHtldmVudH0gZXZlbnQgLSBUaGUgZXZlbnQgZGV0YWlscy5cbiAgICAgKi9cbiAgICB0b3BMZWZ0Q2xpY2tlZDogZnVuY3Rpb24obW91c2UpIHtcbiAgICAgICAgdGhpcy5iZWhhdmlvci50b3BMZWZ0Q2xpY2tlZCh0aGlzLCBtb3VzZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHN1bW1hcnkgQSBmaXhlZCByb3cgaGFzIGJlZW4gY2xpY2tlZC5cbiAgICAgKiBAZGVzYyBEZWxlZ2F0ZXMgdG8gdGhlIGJlaGF2aW9yLlxuICAgICAqIEBwYXJhbSB7ZXZlbnR9IGV2ZW50IC0gVGhlIGV2ZW50IGRldGFpbHMuXG4gICAgICovXG4gICAgcm93SGVhZGVyQ2xpY2tlZDogZnVuY3Rpb24obW91c2UpIHtcbiAgICAgICAgdGhpcy5iZWhhdmlvci5yb3dIZWFkZXJDbGlja2VkKHRoaXMsIG1vdXNlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAc3VtbWFyeSBBIGZpeGVkIGNvbHVtbiBoYXMgYmVlbiBjbGlja2VkLlxuICAgICAqIEBkZXNjIERlbGVnYXRlcyB0byB0aGUgYmVoYXZpb3IuXG4gICAgICogQHBhcmFtIHtldmVudH0gZXZlbnQgLSBUaGUgZXZlbnQgZGV0YWlscy5cbiAgICAgKi9cbiAgICBjb2x1bW5IZWFkZXJDbGlja2VkOiBmdW5jdGlvbihtb3VzZSkge1xuICAgICAgICB0aGlzLmJlaGF2aW9yLmNvbHVtbkhlYWRlckNsaWNrZWQodGhpcywgbW91c2UpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIEFuIGVkaXQgZXZlbnQgaGFzIG9jY3VycmVkLiBBY3RpdmF0ZSB0aGUgZWRpdG9yIGF0IHRoZSBnaXZlbiBjb29yZGluYXRlcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZXZlbnQuZ3JpZENlbGwueCAtIFRoZSBob3Jpem9udGFsIGNvb3JkaW5hdGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGV2ZW50LmdyaWRDZWxsLnkgLSBUaGUgdmVydGljYWwgY29vcmRpbmF0ZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtldmVudC5wcmltaXRpdmVFdmVudC50eXBlXVxuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR8Q2VsbEVkaXRvcn0gVGhlIGVkaXRvciBvYmplY3Qgb3IgYHVuZGVmaW5lZGAgaWYgbm8gZWRpdG9yIG9yIGVkaXRvciBhbHJlYWR5IG9wZW4uXG4gICAgICovXG4gICAgb25FZGl0b3JBY3RpdmF0ZTogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgdmFyIHBvaW50ID0gZXZlbnQuZ3JpZENlbGw7XG4gICAgICAgIHJldHVybiB0aGlzLmVkaXRBdChwb2ludCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHN1bW1hcnkgR2V0IHRoZSBjZWxsIGVkaXRvci5cbiAgICAgKiBAZGVzYyBEZWxlZ2F0ZXMgdG8gdGhlIGJlaGF2aW9yLlxuICAgICAqIEByZXR1cm5zIFRoZSBjZWxsIGVkaXRvciBhdCB0aGUgZ2l2ZW4gY29vcmRpbmF0ZXMuXG4gICAgICogQHBhcmFtIHtQb2ludH0gZWRpdFBvaW50IC0gVGhlIGdyaWQgY2VsbCBjb29yZGluYXRlcy5cbiAgICAgKi9cbiAgICBnZXRDZWxsRWRpdG9yQXQ6IGZ1bmN0aW9uKGVkaXRQb2ludCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWhhdmlvci5nZXRDZWxsRWRpdG9yQXQoZWRpdFBvaW50KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAc3VtbWFyeSBUb2dnbGUgSGlEUEkgc3VwcG9ydC5cbiAgICAgKiBAZGVzYyBIaURQSSBzdXBwb3J0IGlzIG5vdyAqb24qIGJ5IGRlZmF1bHQuXG4gICAgICogPiBUaGVyZSB1c2VkIHRvIGJlIGEgYnVnIGluIENocm9tZSB0aGF0IGNhdXNlZCBzZXZlcmUgc2xvdyBkb3duIG9uIGJpdCBibGl0IG9mIGxhcmdlIGltYWdlcywgc28gdGhpcyBIaURQSSBuZWVkZWQgdG8gYmUgb3B0aW9uYWwuXG4gICAgICovXG4gICAgdG9nZ2xlSGlEUEk6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy51c2VIaURQSSgpKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZSgnaGlkcGknKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdoaWRwaScsIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FudmFzLnJlc2l6ZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRlIEhpRFBJIHJhdGlvLlxuICAgICAqL1xuICAgIGdldEhpRFBJOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgICAgaWYgKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvICYmIHRoaXMudXNlSGlEUEkoKSkge1xuICAgICAgICAgICAgdmFyIGRldmljZVBpeGVsUmF0aW8gPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xuICAgICAgICAgICAgdmFyIGJhY2tpbmdTdG9yZVJhdGlvID0gY3R4LndlYmtpdEJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICAgICAgICAgICAgICBjdHgubW96QmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fFxuICAgICAgICAgICAgICAgIGN0eC5tc0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICAgICAgICAgICAgICBjdHgub0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICAgICAgICAgICAgICBjdHguYmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCAxO1xuXG4gICAgICAgICAgICB2YXIgcmF0aW8gPSBkZXZpY2VQaXhlbFJhdGlvIC8gYmFja2luZ1N0b3JlUmF0aW87XG4gICAgICAgICAgICByZXR1cm4gcmF0aW87XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSB3aWR0aCBvZiB0aGUgZ2l2ZW4gKHJlY2VudGx5IHJlbmRlcmVkKSBjb2x1bW4uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbEluZGV4IC0gVGhlIGNvbHVtbiBpbmRleC5cbiAgICAgKi9cbiAgICBnZXRSZW5kZXJlZFdpZHRoOiBmdW5jdGlvbihjb2xJbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5nZXRSZW5kZXJlZFdpZHRoKGNvbEluZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgaGVpZ2h0IG9mIHRoZSBnaXZlbiAocmVjZW50bHkgcmVuZGVyZWQpIHJvdy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcm93SW5kZXggLSBUdGhlIHJvdyBpbmRleC5cbiAgICAgKi9cbiAgICBnZXRSZW5kZXJlZEhlaWdodDogZnVuY3Rpb24ocm93SW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIuZ2V0UmVuZGVyZWRIZWlnaHQocm93SW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFVwZGF0ZSB0aGUgY3Vyc29yIHVuZGVyIHRoZSBob3ZlciBjZWxsLlxuICAgICAqL1xuICAgIHVwZGF0ZUN1cnNvcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjdXJzb3IgPSB0aGlzLmJlaGF2aW9yLmdldEN1cnNvckF0KC0xLCAtMSk7XG4gICAgICAgIHZhciBob3ZlckNlbGwgPSB0aGlzLmdldEhvdmVyQ2VsbCgpO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICBob3ZlckNlbGwgJiZcbiAgICAgICAgICAgIGhvdmVyQ2VsbC54ID4gLTEgJiZcbiAgICAgICAgICAgIGhvdmVyQ2VsbC55ID4gLTFcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB2YXIgeCA9IGhvdmVyQ2VsbC54ICsgdGhpcy5nZXRIU2Nyb2xsVmFsdWUoKTtcbiAgICAgICAgICAgIGN1cnNvciA9IHRoaXMuYmVoYXZpb3IuZ2V0Q3Vyc29yQXQoeCwgaG92ZXJDZWxsLnkgKyB0aGlzLmdldFZTY3JvbGxWYWx1ZSgpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJlQ3Vyc29yKGN1cnNvcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgUmVwYWludCB0aGUgZ2l2ZW4gY2VsbC5cbiAgICAgKiBAcGFyYW0ge3h9IHggLSBUaGUgaG9yaXpvbnRhbCBjb29yZGluYXRlLlxuICAgICAqIEBwYXJhbSB7eX0geSAtIFRoZSB2ZXJ0aWNhbCBjb29yZGluYXRlLlxuICAgICAqL1xuICAgIHJlcGFpbnRDZWxsOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHRoaXMuZ2V0UmVuZGVyZXIoKS5yZXBhaW50Q2VsbCh4LCB5KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVGhlIHVzZXIgaXMgY3VycmVudGx5IGRyYWdnaW5nIGEgY29sdW1uIHRvIHJlb3JkZXIgaXQuXG4gICAgICovXG4gICAgaXNEcmFnZ2luZ0NvbHVtbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMucmVuZGVyT3ZlcnJpZGVzQ2FjaGUuZHJhZ2dlcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBTY3JvbGwgdXAgb25lIGZ1bGwgcGFnZS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIHBhZ2VVcDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByb3dOdW0gPSB0aGlzLmdldFJlbmRlcmVyKCkuZ2V0UGFnZVVwUm93KCk7XG4gICAgICAgIHRoaXMuc2V0VlNjcm9sbFZhbHVlKHJvd051bSk7XG4gICAgICAgIHJldHVybiByb3dOdW07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgU2Nyb2xsIGRvd24gb25lIGZ1bGwgcGFnZS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIHBhZ2VEb3duOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJvd051bSA9IHRoaXMuZ2V0UmVuZGVyZXIoKS5nZXRQYWdlRG93blJvdygpO1xuICAgICAgICB0aGlzLnNldFZTY3JvbGxWYWx1ZShyb3dOdW0pO1xuICAgICAgICByZXR1cm4gcm93TnVtO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIE5vdCB5ZXQgaW1wbGVtZW50ZWQuXG4gICAgICovXG4gICAgcGFnZUxlZnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zb2xlLmxvZygncGFnZSBsZWZ0Jyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgTm90IHlldCBpbXBsZW1lbnRlZC5cbiAgICAgKi9cbiAgICBwYWdlUmlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zb2xlLmxvZygncGFnZSByaWdodCcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtvYmplY3RbXX0gT2JqZWN0cyB3aXRoIHRoZSB2YWx1ZXMgdGhhdCB3ZXJlIGp1c3QgcmVuZGVyZWQuXG4gICAgICovXG4gICAgZ2V0UmVuZGVyZWREYXRhOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gYXNzdW1lcyBvbmUgcm93IG9mIGhlYWRlcnNcbiAgICAgICAgdmFyIGJlaGF2aW9yID0gdGhpcy5iZWhhdmlvcixcbiAgICAgICAgICAgIHJlbmRlcmVyID0gdGhpcy5nZXRSZW5kZXJlcigpLFxuICAgICAgICAgICAgY29sQ291bnQgPSB0aGlzLmdldENvbHVtbkNvdW50KCksXG4gICAgICAgICAgICByb3dDb3VudCA9IHJlbmRlcmVyLmdldFZpc2libGVSb3dzKCksXG4gICAgICAgICAgICBoZWFkZXJzID0gbmV3IEFycmF5KGNvbENvdW50KSxcbiAgICAgICAgICAgIHJlc3VsdHMgPSBuZXcgQXJyYXkocm93Q291bnQpLFxuICAgICAgICAgICAgcm93O1xuXG4gICAgICAgIGhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbihoZWFkZXIsIGMpIHtcbiAgICAgICAgICAgIGhlYWRlcnNbY10gPSBiZWhhdmlvci5nZXRBY3RpdmVDb2x1bW4oYykuaGVhZGVyO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXN1bHRzLmZvckVhY2goZnVuY3Rpb24ocmVzdWx0LCByKSB7XG4gICAgICAgICAgICByb3cgPSByZXN1bHRzW3JdID0ge1xuICAgICAgICAgICAgICAgIGhpZXJhcmNoeTogYmVoYXZpb3IuZ2V0Rml4ZWRDb2x1bW5WYWx1ZSgwLCByKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbihmaWVsZCwgYykge1xuICAgICAgICAgICAgICAgIHJvd1tmaWVsZF0gPSBiZWhhdmlvci5nZXRWYWx1ZShjLCByKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBBbiBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBjdXJyZW50bHkgc2VsZWN0aW9uIHJvdy5cbiAgICAgKi9cbiAgICBnZXRTZWxlY3RlZFJvdzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxzID0gdGhpcy5zZWxlY3Rpb25Nb2RlbC5nZXRTZWxlY3Rpb25zKCk7XG4gICAgICAgIGlmIChzZWxzLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGJlaGF2aW9yID0gdGhpcy5iZWhhdmlvcixcbiAgICAgICAgICAgICAgICBjb2xDb3VudCA9IHRoaXMuZ2V0Q29sdW1uQ291bnQoKSxcbiAgICAgICAgICAgICAgICB0b3BSb3cgPSBzZWxzWzBdLm9yaWdpbi55LFxuICAgICAgICAgICAgICAgIHJvdyA9IHtcbiAgICAgICAgICAgICAgICAgICAgLy9oaWVyYXJjaHk6IGJlaGF2aW9yLmdldEZpeGVkQ29sdW1uVmFsdWUoMCwgdG9wUm93KVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgY29sQ291bnQ7IGMrKykge1xuICAgICAgICAgICAgICAgIHJvd1tiZWhhdmlvci5nZXRBY3RpdmVDb2x1bW4oYykuaGVhZGVyXSA9IGJlaGF2aW9yLmdldFZhbHVlKGMsIHRvcFJvdyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByb3c7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZmlyZVJlcXVlc3RDZWxsRWRpdDogZnVuY3Rpb24oY2VsbCwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGNsaWNrRXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ2Zpbi1yZXF1ZXN0LWNlbGwtZWRpdCcsIHtcbiAgICAgICAgICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgICAgZ3JpZENlbGw6IGNlbGwsXG4gICAgICAgICAgICAgICAgdGltZTogRGF0ZS5ub3coKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FudmFzLmRpc3BhdGNoRXZlbnQoY2xpY2tFdmVudCk7IC8vSSB3YXNuJ3QgY2FuY2VsbGVkXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFN5bnRoZXNpemUgYW5kIGZpcmUgYSBmaW4tYmVmb3JlLWNlbGwtZWRpdCBldmVudC5cbiAgICAgKiBAcGFyYW0ge1BvaW50fSBjZWxsIC0gVGhlIHgseSBjb29yZGluYXRlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWUgLSBUaGUgY3VycmVudCB2YWx1ZS5cbiAgICAgKi9cbiAgICBmaXJlQmVmb3JlQ2VsbEVkaXQ6IGZ1bmN0aW9uKGNlbGwsIG9sZFZhbHVlLCBuZXdWYWx1ZSwgY29udHJvbCkge1xuICAgICAgICB2YXIgY2xpY2tFdmVudCA9IG5ldyBDdXN0b21FdmVudCgnZmluLWJlZm9yZS1jZWxsLWVkaXQnLCB7XG4gICAgICAgICAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgb2xkVmFsdWU6IG9sZFZhbHVlLFxuICAgICAgICAgICAgICAgIG5ld1ZhbHVlOiBuZXdWYWx1ZSxcbiAgICAgICAgICAgICAgICBncmlkQ2VsbDogY2VsbCxcbiAgICAgICAgICAgICAgICB0aW1lOiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgICAgIGlucHV0OiBjb250cm9sLFxuICAgICAgICAgICAgICAgIHJvdzogdGhpcy5nZXRSb3coY2VsbC55KVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHByb2NlZWQgPSB0aGlzLmNhbnZhcy5kaXNwYXRjaEV2ZW50KGNsaWNrRXZlbnQpO1xuICAgICAgICByZXR1cm4gcHJvY2VlZDsgLy9JIHdhc24ndCBjYW5jZWxsZWRcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7UmVuZGVyZXJ9IHN1Yi1jb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge1BvaW50fSBjZWxsIC0gVGhlIHgseSBjb29yZGluYXRlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2xkVmFsdWUgLSBUaGUgb2xkIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBuZXdWYWx1ZSAtIFRoZSBuZXcgdmFsdWUuXG4gICAgICovXG4gICAgZmlyZUFmdGVyQ2VsbEVkaXQ6IGZ1bmN0aW9uKGNlbGwsIG9sZFZhbHVlLCBuZXdWYWx1ZSwgY29udHJvbCkge1xuICAgICAgICB2YXIgY2xpY2tFdmVudCA9IG5ldyBDdXN0b21FdmVudCgnZmluLWFmdGVyLWNlbGwtZWRpdCcsIHtcbiAgICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgICAgIG5ld1ZhbHVlOiBuZXdWYWx1ZSxcbiAgICAgICAgICAgICAgICBvbGRWYWx1ZTogb2xkVmFsdWUsXG4gICAgICAgICAgICAgICAgZ3JpZENlbGw6IGNlbGwsXG4gICAgICAgICAgICAgICAgdGltZTogRGF0ZS5ub3coKSxcbiAgICAgICAgICAgICAgICBpbnB1dDogY29udHJvbCxcbiAgICAgICAgICAgICAgICByb3c6IHRoaXMuZ2V0Um93KGNlbGwueSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2FudmFzLmRpc3BhdGNoRXZlbnQoY2xpY2tFdmVudCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgQXV0b3NpemUgdGhlIGNvbHVtbiBhdCBjb2xJbmRleCBmb3IgYmVzdCBmaXQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbEluZGV4IC0gVGhlIGNvbHVtbiBpbmRleCB0byBtb2RpZnkgYXRcbiAgICAgKi9cbiAgICBhdXRvc2l6ZUNvbHVtbjogZnVuY3Rpb24oYWN0aXZlQ29sdW1uSW5kZXgpIHtcbiAgICAgICAgdmFyIGNvbHVtbiA9IHRoaXMuYmVoYXZpb3IuZ2V0QWN0aXZlQ29sdW1uKGFjdGl2ZUNvbHVtbkluZGV4KTtcbiAgICAgICAgY29sdW1uLmNoZWNrQ29sdW1uQXV0b3NpemluZyh0cnVlKTtcbiAgICAgICAgdGhpcy5jb21wdXRlQ2VsbHNCb3VuZHMoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBFbmFibGUvZGlzYWJsZSBpZiB0aGlzIGNvbXBvbmVudCBjYW4gcmVjZWl2ZSB0aGUgZm9jdXMuXG4gICAgICogQHBhcmFtIHtib29sZWFufSAtIGNhblJlY2VpdmVGb2N1c1xuICAgICAqL1xuICAgIHNldEZvY3VzYWJsZTogZnVuY3Rpb24oY2FuUmVjZWl2ZUZvY3VzKSB7XG4gICAgICAgIHRoaXMuZ2V0Q2FudmFzKCkuc2V0Rm9jdXNhYmxlKGNhblJlY2VpdmVGb2N1cyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge251bWJlcn0gVGhlIG51bWJlciBvZiBjb2x1bW5zIHRoYXQgd2VyZSBqdXN0IHJlbmRlcmVkXG4gICAgICovXG4gICAgZ2V0VmlzaWJsZUNvbHVtbnNDb3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFJlbmRlcmVyKCkuZ2V0VmlzaWJsZUNvbHVtbnNDb3VudCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBudW1iZXIgb2Ygcm93cyB0aGF0IHdlcmUganVzdCByZW5kZXJlZFxuICAgICAqL1xuICAgIGdldFZpc2libGVSb3dzQ291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRSZW5kZXJlcigpLmdldFZpc2libGVSb3dzQ291bnQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICB1cGRhdGUgdGhlIHNpemUgb2YgdGhlIGdyaWRcbiAgICAgKlxuICAgICAqICMjIyMgcmV0dXJuczogaW50ZWdlclxuICAgICAqL1xuICAgIHVwZGF0ZVNpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmNhbnZhcy5jaGVja3NpemUoKTtcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFN0b3AgdGhlIGdsb2JhbCByZXBhaW50aW5nIGZsYWcgdGhyZWFkLlxuICAgICAqL1xuICAgIHN0b3BQYWludFRocmVhZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuY2FudmFzLnN0b3BQYWludFRocmVhZCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFN0b3AgdGhlIGdsb2JhbCByZXNpemUgY2hlY2sgZmxhZyB0aHJlYWQuXG4gICAgICovXG4gICAgc3RvcFJlc2l6ZVRocmVhZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuY2FudmFzLnN0b3BSZXNpemVUaHJlYWQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBSZXN0YXJ0IHRoZSBnbG9iYWwgcmVzaXplIGNoZWNrIGZsYWcgdGhyZWFkLlxuICAgICAqL1xuICAgIHJlc3RhcnRSZXNpemVUaHJlYWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmNhbnZhcy5yZXN0YXJ0UmVzaXplVGhyZWFkKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgUmVzdGFydCB0aGUgZ2xvYmFsIHJlcGFpbnRpbmcgY2hlY2sgZmxhZyB0aHJlYWQuXG4gICAgICovXG4gICAgcmVzdGFydFBhaW50VGhyZWFkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5jYW52YXMucmVzdGFydFBhaW50VGhyZWFkKCk7XG4gICAgfSxcblxuICAgIHN3YXBDb2x1bW5zOiBmdW5jdGlvbihzb3VyY2UsIHRhcmdldCkge1xuICAgICAgICAvL1R1cm5zIG91dCB0aGlzIGlzIGNhbGxlZCBkdXJpbmcgZHJhZ2dlZCAnaS5lJyB3aGVuIHRoZSBmbG9hdGVyIGNvbHVtbiBpcyByZXNodWZmbGVkXG4gICAgICAgIC8vYnkgdGhlIGN1cnJlbnRseSBkcmFnZ2VkIGNvbHVtbi4gVGhlIGNvbHVtbiBwb3NpdGlvbnMgYXJlIGNvbnN0YW50bHkgcmVzaHVmZmxlZFxuICAgICAgICB0aGlzLmJlaGF2aW9yLnN3YXBDb2x1bW5zKHNvdXJjZSwgdGFyZ2V0KTtcbiAgICB9LFxuXG4gICAgZW5kRHJhZ0NvbHVtbk5vdGlmaWNhdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuYmVoYXZpb3IuZW5kRHJhZ0NvbHVtbk5vdGlmaWNhdGlvbigpO1xuICAgIH0sXG5cbiAgICBnZXRGaXhlZENvbHVtbnNNYXhXaWR0aDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlaGF2aW9yLmdldEZpeGVkQ29sdW1uc01heFdpZHRoKCk7XG4gICAgfSxcblxuICAgIGlzTW91c2VEb3duSW5IZWFkZXJBcmVhOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGhlYWRlckNvbHVtbkNvdW50ID0gdGhpcy5nZXRIZWFkZXJDb2x1bW5Db3VudCgpO1xuICAgICAgICB2YXIgaGVhZGVyUm93Q291bnQgPSB0aGlzLmdldEhlYWRlclJvd0NvdW50KCk7XG4gICAgICAgIHZhciBtb3VzZURvd24gPSB0aGlzLmdldE1vdXNlRG93bigpO1xuICAgICAgICByZXR1cm4gbW91c2VEb3duLnggPCBoZWFkZXJDb2x1bW5Db3VudCB8fCBtb3VzZURvd24ueSA8IGhlYWRlclJvd0NvdW50O1xuICAgIH0sXG5cbiAgICBpc0hlYWRlcldyYXBwaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzb2x2ZVByb3BlcnR5KCdoZWFkZXJUZXh0V3JhcHBpbmcnKTtcbiAgICB9LFxuXG4gICAgX2dldEJvdW5kc09mQ2VsbDogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRSZW5kZXJlcigpLl9nZXRCb3VuZHNPZkNlbGwoeCwgeSk7XG4gICAgfSxcblxuICAgIGdldENvbHVtblByb3BlcnRpZXM6IGZ1bmN0aW9uKGNvbHVtbkluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlaGF2aW9yLmdldENvbHVtblByb3BlcnRpZXMoY29sdW1uSW5kZXgpO1xuICAgIH0sXG5cbiAgICBzZXRDb2x1bW5Qcm9wZXJ0aWVzOiBmdW5jdGlvbihjb2x1bW5JbmRleCwgcHJvcGVydGllcykge1xuICAgICAgICB0aGlzLmJlaGF2aW9yLnNldENvbHVtblByb3BlcnRpZXMoY29sdW1uSW5kZXgsIHByb3BlcnRpZXMpO1xuICAgIH0sXG5cbiAgICBtb3ZlU2luZ2xlU2VsZWN0OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHRoaXMuYmVoYXZpb3IubW92ZVNpbmdsZVNlbGVjdCh0aGlzLCB4LCB5KTtcbiAgICB9LFxuXG4gICAgc2VsZWN0Q2VsbDogZnVuY3Rpb24oeCwgeSwgc2lsZW50KSB7XG4gICAgICAgIHZhciBkb250Q2xlYXJSb3dzID0gdGhpcy5pc0NoZWNrYm94T25seVJvd1NlbGVjdGlvbnMoKTtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25Nb2RlbC5jbGVhcihkb250Q2xlYXJSb3dzKTtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25Nb2RlbC5zZWxlY3QoeCwgeSwgMCwgMCwgc2lsZW50KTtcbiAgICB9LFxuXG4gICAgZ2V0SGVhZGVyQ29sdW1uQ291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWhhdmlvci5nZXRIZWFkZXJDb2x1bW5Db3VudCgpO1xuICAgIH0sXG5cbiAgICB0b2dnbGVTb3J0OiBmdW5jdGlvbih4LCBrZXlzKSB7XG4gICAgICAgIHRoaXMuc3RvcEVkaXRpbmcoKTtcbiAgICAgICAgdmFyIGJlaGF2aW9yID0gdGhpcy5iZWhhdmlvcjtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBiZWhhdmlvci50b2dnbGVTb3J0KHgsIGtleXMpO1xuXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzZWxmLnN5bmNocm9uaXplU2Nyb2xsaW5nQm91bmRyaWVzKCk7XG4gICAgICAgICAgICAvL3NlbGYuYmVoYXZpb3JDaGFuZ2VkKCk7XG4gICAgICAgICAgICBpZiAoc2VsZi5pc0NvbHVtbkF1dG9zaXppbmcoKSkge1xuICAgICAgICAgICAgICAgIGJlaGF2aW9yLmF1dG9zaXplQWxsQ29sdW1ucygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5yZXBhaW50KCk7XG4gICAgICAgIH0sIDEwKTtcbiAgICB9LFxuXG4gICAgdG9nZ2xlU2VsZWN0Q29sdW1uOiBmdW5jdGlvbih4LCBrZXlzKSB7XG4gICAgICAgIGtleXMgPSBrZXlzIHx8IFtdO1xuICAgICAgICB2YXIgbW9kZWwgPSB0aGlzLnNlbGVjdGlvbk1vZGVsO1xuICAgICAgICB2YXIgYWxyZWFkeVNlbGVjdGVkID0gbW9kZWwuaXNDb2x1bW5TZWxlY3RlZCh4KTtcbiAgICAgICAgdmFyIGhhc0NUUkwgPSBrZXlzLmluZGV4T2YoJ0NUUkwnKSA+IC0xO1xuICAgICAgICB2YXIgaGFzU0hJRlQgPSBrZXlzLmluZGV4T2YoJ1NISUZUJykgPiAtMTtcbiAgICAgICAgaWYgKCFoYXNDVFJMICYmICFoYXNTSElGVCkge1xuICAgICAgICAgICAgbW9kZWwuY2xlYXIoKTtcbiAgICAgICAgICAgIGlmICghYWxyZWFkeVNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgbW9kZWwuc2VsZWN0Q29sdW1uKHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGhhc0NUUkwpIHtcbiAgICAgICAgICAgICAgICBpZiAoYWxyZWFkeVNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLmRlc2VsZWN0Q29sdW1uKHgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLnNlbGVjdENvbHVtbih4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGFzU0hJRlQpIHtcbiAgICAgICAgICAgICAgICBtb2RlbC5jbGVhcigpO1xuICAgICAgICAgICAgICAgIG1vZGVsLnNlbGVjdENvbHVtbih0aGlzLmxhc3RFZGdlU2VsZWN0aW9uWzBdLCB4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWFscmVhZHlTZWxlY3RlZCAmJiAhaGFzU0hJRlQpIHtcbiAgICAgICAgICAgIHRoaXMubGFzdEVkZ2VTZWxlY3Rpb25bMF0gPSB4O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVwYWludCgpO1xuICAgICAgICB0aGlzLmZpcmVTeW50aGV0aWNDb2x1bW5TZWxlY3Rpb25DaGFuZ2VkRXZlbnQoKTtcbiAgICB9LFxuXG4gICAgdG9nZ2xlU2VsZWN0Um93OiBmdW5jdGlvbih5LCBrZXlzKSB7XG4gICAgICAgIC8vd2UgY2FuIHNlbGVjdCB0aGUgdG90YWxzIHJvd3MgaWYgdGhleSBleGlzdCwgYnV0IG5vdCByb3dzIGFib3ZlIHRoYXRcbiAgICAgICAgaWYgKHkgPiB0aGlzLmdldEZpbHRlclJvd0luZGV4KCkpIHtcbiAgICAgICAgICAgIGtleXMgPSBrZXlzIHx8IFtdO1xuXG4gICAgICAgICAgICB2YXIgc20gPSB0aGlzLnNlbGVjdGlvbk1vZGVsO1xuICAgICAgICAgICAgdmFyIGFscmVhZHlTZWxlY3RlZCA9IHNtLmlzUm93U2VsZWN0ZWQoeSk7XG4gICAgICAgICAgICB2YXIgaGFzU0hJRlQgPSBrZXlzLmluZGV4T2YoJ1NISUZUJykgPj0gMDtcblxuICAgICAgICAgICAgaWYgKGFscmVhZHlTZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgIHNtLmRlc2VsZWN0Um93KHkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNpbmdsZVNlbGVjdCgpO1xuICAgICAgICAgICAgICAgIHNtLnNlbGVjdFJvdyh5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGhhc1NISUZUKSB7XG4gICAgICAgICAgICAgICAgc20uY2xlYXIoKTtcbiAgICAgICAgICAgICAgICBzbS5zZWxlY3RSb3codGhpcy5sYXN0RWRnZVNlbGVjdGlvblsxXSwgeSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghYWxyZWFkeVNlbGVjdGVkICYmICFoYXNTSElGVCkge1xuICAgICAgICAgICAgICAgIHRoaXMubGFzdEVkZ2VTZWxlY3Rpb25bMV0gPSB5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZXBhaW50KCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgc2luZ2xlU2VsZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGlzQ2hlY2tib3hPbmx5Um93U2VsZWN0aW9ucyA9IHRoaXMuaXNDaGVja2JveE9ubHlSb3dTZWxlY3Rpb25zKCksXG4gICAgICAgICAgICBpc1NpbmdsZVJvd1NlbGVjdGlvbk1vZGUgPSB0aGlzLmlzU2luZ2xlUm93U2VsZWN0aW9uTW9kZSgpLFxuICAgICAgICAgICAgaGFzQ1RSTCA9IGZhbHNlLFxuICAgICAgICAgICAgcmVzdWx0O1xuXG4gICAgICAgIGlmICh0aGlzLm1vdXNlRG93blN0YXRlKXtcbiAgICAgICAgICAgIC8vdHJpZ2dlcmVkIHByb2dyYW1tYXRpY2FsbHlcbiAgICAgICAgICAgIGhhc0NUUkwgPSB0aGlzLm1vdXNlRG93blN0YXRlLnByaW1pdGl2ZUV2ZW50LmRldGFpbC5wcmltaXRpdmVFdmVudC5jdHJsS2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0ID0gKFxuICAgICAgICAgICAgaXNDaGVja2JveE9ubHlSb3dTZWxlY3Rpb25zICYmIGlzU2luZ2xlUm93U2VsZWN0aW9uTW9kZSB8fFxuICAgICAgICAgICAgIWlzQ2hlY2tib3hPbmx5Um93U2VsZWN0aW9ucyAmJiAoIWhhc0NUUkwgfHwgaXNTaW5nbGVSb3dTZWxlY3Rpb25Nb2RlKVxuICAgICAgICApO1xuXG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uTW9kZWwuY2xlYXJSb3dTZWxlY3Rpb24oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIHNlbGVjdFZpZXdwb3J0Q2VsbDogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICB2YXIgaGVhZGVyUm93Q291bnQgPSB0aGlzLmdldEhlYWRlclJvd0NvdW50KCk7XG4gICAgICAgIHZhciByZW5kZXJlciA9IHRoaXMuZ2V0UmVuZGVyZXIoKTtcbiAgICAgICAgdmFyIHJlYWxYID0gcmVuZGVyZXIuZ2V0VmlzaWJsZUNvbHVtbnMoKVt4XTtcbiAgICAgICAgdmFyIHJlYWxZID0gcmVuZGVyZXIuZ2V0VmlzaWJsZVJvd3MoKVt5XTtcbiAgICAgICAgdGhpcy5jbGVhclNlbGVjdGlvbnMoKTtcbiAgICAgICAgdGhpcy5zZWxlY3QocmVhbFgsIHJlYWxZICsgaGVhZGVyUm93Q291bnQsIDAsIDApO1xuICAgICAgICB0aGlzLnNldE1vdXNlRG93bih0aGlzLm5ld1BvaW50KHJlYWxYLCByZWFsWSArIGhlYWRlclJvd0NvdW50KSk7XG4gICAgICAgIHRoaXMuc2V0RHJhZ0V4dGVudCh0aGlzLm5ld1BvaW50KDAsIDApKTtcbiAgICAgICAgdGhpcy5yZXBhaW50KCk7XG4gICAgfSxcblxuICAgIHNlbGVjdFRvVmlld3BvcnRDZWxsOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHZhciBzZWxlY3Rpb25zID0gdGhpcy5nZXRTZWxlY3Rpb25zKCk7XG4gICAgICAgIGlmIChzZWxlY3Rpb25zICYmIHNlbGVjdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgaGVhZGVyUm93Q291bnQgPSB0aGlzLmdldEhlYWRlclJvd0NvdW50KCk7XG4gICAgICAgICAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLmdldFJlbmRlcmVyKCk7XG4gICAgICAgICAgICB2YXIgcmVhbFggPSByZW5kZXJlci5nZXRWaXNpYmxlQ29sdW1ucygpW3hdO1xuICAgICAgICAgICAgdmFyIHJlYWxZID0gcmVuZGVyZXIuZ2V0VmlzaWJsZVJvd3MoKVt5XSArIGhlYWRlclJvd0NvdW50O1xuICAgICAgICAgICAgdmFyIHNlbGVjdGlvbiA9IHNlbGVjdGlvbnNbMF07XG4gICAgICAgICAgICB2YXIgb3JpZ2luID0gc2VsZWN0aW9uLm9yaWdpbjtcbiAgICAgICAgICAgIHRoaXMuc2V0RHJhZ0V4dGVudCh0aGlzLm5ld1BvaW50KHJlYWxYIC0gb3JpZ2luLngsIHJlYWxZIC0gb3JpZ2luLnkpKTtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0KG9yaWdpbi54LCBvcmlnaW4ueSwgcmVhbFggLSBvcmlnaW4ueCwgcmVhbFkgLSBvcmlnaW4ueSk7XG4gICAgICAgICAgICB0aGlzLnJlcGFpbnQoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBzZWxlY3RGaW5hbENlbGxPZkN1cnJlbnRSb3c6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgeCA9IHRoaXMuZ2V0Q29sdW1uQ291bnQoKSAtIDE7XG4gICAgICAgIHZhciB5ID0gdGhpcy5nZXRTZWxlY3RlZFJvd3MoKVswXTtcbiAgICAgICAgdmFyIGhlYWRlclJvd0NvdW50ID0gdGhpcy5nZXRIZWFkZXJSb3dDb3VudCgpO1xuICAgICAgICB0aGlzLmNsZWFyU2VsZWN0aW9ucygpO1xuICAgICAgICB0aGlzLnNjcm9sbEJ5KHRoaXMuZ2V0Q29sdW1uQ291bnQoKSwgMCk7XG4gICAgICAgIHRoaXMuc2VsZWN0KHgsIHkgKyBoZWFkZXJSb3dDb3VudCwgMCwgMCk7XG4gICAgICAgIHRoaXMuc2V0TW91c2VEb3duKHRoaXMubmV3UG9pbnQoeCwgeSArIGhlYWRlclJvd0NvdW50KSk7XG4gICAgICAgIHRoaXMuc2V0RHJhZ0V4dGVudCh0aGlzLm5ld1BvaW50KDAsIDApKTtcbiAgICAgICAgdGhpcy5yZXBhaW50KCk7XG4gICAgfSxcblxuICAgIHNlbGVjdFRvRmluYWxDZWxsT2ZDdXJyZW50Um93OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGVjdGlvbnMgPSB0aGlzLmdldFNlbGVjdGlvbnMoKTtcbiAgICAgICAgaWYgKHNlbGVjdGlvbnMgJiYgc2VsZWN0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb24gPSBzZWxlY3Rpb25zWzBdO1xuICAgICAgICAgICAgdmFyIG9yaWdpbiA9IHNlbGVjdGlvbi5vcmlnaW47XG4gICAgICAgICAgICB2YXIgZXh0ZW50ID0gc2VsZWN0aW9uLmV4dGVudDtcbiAgICAgICAgICAgIHZhciBjb2x1bW5Db3VudCA9IHRoaXMuZ2V0Q29sdW1uQ291bnQoKTtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsQnkoY29sdW1uQ291bnQsIDApO1xuXG4gICAgICAgICAgICB0aGlzLmNsZWFyU2VsZWN0aW9ucygpO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Qob3JpZ2luLngsIG9yaWdpbi55LCBjb2x1bW5Db3VudCAtIG9yaWdpbi54IC0gMSwgZXh0ZW50LnkpO1xuXG4gICAgICAgICAgICB0aGlzLnJlcGFpbnQoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBzZWxlY3RGaXJzdENlbGxPZkN1cnJlbnRSb3c6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgeCA9IDA7XG4gICAgICAgIHZhciB5ID0gdGhpcy5nZXRTZWxlY3RlZFJvd3MoKVswXTtcbiAgICAgICAgdmFyIGhlYWRlclJvd0NvdW50ID0gdGhpcy5nZXRIZWFkZXJSb3dDb3VudCgpO1xuICAgICAgICB0aGlzLmNsZWFyU2VsZWN0aW9ucygpO1xuICAgICAgICB0aGlzLnNldEhTY3JvbGxWYWx1ZSgwKTtcbiAgICAgICAgdGhpcy5zZWxlY3QoeCwgeSArIGhlYWRlclJvd0NvdW50LCAwLCAwKTtcbiAgICAgICAgdGhpcy5zZXRNb3VzZURvd24odGhpcy5uZXdQb2ludCh4LCB5ICsgaGVhZGVyUm93Q291bnQpKTtcbiAgICAgICAgdGhpcy5zZXREcmFnRXh0ZW50KHRoaXMubmV3UG9pbnQoMCwgMCkpO1xuICAgICAgICB0aGlzLnJlcGFpbnQoKTtcbiAgICB9LFxuXG4gICAgc2VsZWN0VG9GaXJzdENlbGxPZkN1cnJlbnRSb3c6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZWN0aW9ucyA9IHRoaXMuZ2V0U2VsZWN0aW9ucygpO1xuICAgICAgICBpZiAoc2VsZWN0aW9ucyAmJiBzZWxlY3Rpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGlvbiA9IHNlbGVjdGlvbnNbMF07XG4gICAgICAgICAgICB2YXIgb3JpZ2luID0gc2VsZWN0aW9uLm9yaWdpbjtcbiAgICAgICAgICAgIHZhciBleHRlbnQgPSBzZWxlY3Rpb24uZXh0ZW50O1xuICAgICAgICAgICAgdGhpcy5jbGVhclNlbGVjdGlvbnMoKTtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0KG9yaWdpbi54LCBvcmlnaW4ueSwgLW9yaWdpbi54LCBleHRlbnQueSk7XG4gICAgICAgICAgICB0aGlzLnNldEhTY3JvbGxWYWx1ZSgwKTtcbiAgICAgICAgICAgIHRoaXMucmVwYWludCgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHNlbGVjdEZpbmFsQ2VsbDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0Q2VsbCh0aGlzLmdldENvbHVtbkNvdW50KCkgLSAxLCB0aGlzLmdldFJvd0NvdW50KCkgLSAxKTtcbiAgICAgICAgdGhpcy5zY3JvbGxCeSh0aGlzLmdldENvbHVtbkNvdW50KCksIHRoaXMuZ2V0Um93Q291bnQoKSk7XG4gICAgICAgIHRoaXMucmVwYWludCgpO1xuICAgIH0sXG5cbiAgICBzZWxlY3RUb0ZpbmFsQ2VsbDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxlY3Rpb25zID0gdGhpcy5nZXRTZWxlY3Rpb25zKCk7XG4gICAgICAgIGlmIChzZWxlY3Rpb25zICYmIHNlbGVjdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uID0gc2VsZWN0aW9uc1swXTtcbiAgICAgICAgICAgIHZhciBvcmlnaW4gPSBzZWxlY3Rpb24ub3JpZ2luO1xuICAgICAgICAgICAgdmFyIGNvbHVtbkNvdW50ID0gdGhpcy5nZXRDb2x1bW5Db3VudCgpO1xuICAgICAgICAgICAgdmFyIHJvd0NvdW50ID0gdGhpcy5nZXRSb3dDb3VudCgpO1xuXG4gICAgICAgICAgICB0aGlzLmNsZWFyU2VsZWN0aW9ucygpO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Qob3JpZ2luLngsIG9yaWdpbi55LCBjb2x1bW5Db3VudCAtIG9yaWdpbi54IC0gMSwgcm93Q291bnQgLSBvcmlnaW4ueSAtIDEpO1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxCeShjb2x1bW5Db3VudCwgcm93Q291bnQpO1xuICAgICAgICAgICAgdGhpcy5yZXBhaW50KCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgaXNTaG93Um93TnVtYmVyczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc29sdmVQcm9wZXJ0eSgnc2hvd1Jvd051bWJlcnMnKTtcbiAgICB9LFxuICAgIGlzRWRpdGFibGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNvbHZlUHJvcGVydHkoJ2VkaXRhYmxlJykgPT09IHRydWU7XG4gICAgfSxcbiAgICBpc1Nob3dGaWx0ZXJSb3c6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNvbHZlUHJvcGVydHkoJ3Nob3dGaWx0ZXJSb3cnKTtcbiAgICB9LFxuICAgIGlzU2hvd0hlYWRlclJvdzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc29sdmVQcm9wZXJ0eSgnc2hvd0hlYWRlclJvdycpO1xuICAgIH0sXG4gICAgZ2V0SGVhZGVyUm93Q291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWhhdmlvci5nZXRIZWFkZXJSb3dDb3VudCgpO1xuICAgIH0sXG4gICAgaXNGaWx0ZXJSb3c6IGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgcmV0dXJuIHkgPT09IHRoaXMuZ2V0RmlsdGVyUm93SW5kZXgoKTtcbiAgICB9LFxuICAgIGdldEZpbHRlclJvd0luZGV4OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmlzU2hvd0ZpbHRlclJvdygpID8gLTEgOiB0aGlzLmlzU2hvd0hlYWRlclJvdygpID8gMSA6IDA7XG4gICAgfSxcbiAgICBzZXRHcm91cHM6IGZ1bmN0aW9uKGFycmF5T2ZDb2x1bW5JbmRleGVzKSB7XG4gICAgICAgIHRoaXMuYmVoYXZpb3Iuc2V0R3JvdXBzKGFycmF5T2ZDb2x1bW5JbmRleGVzKTtcbiAgICB9LFxuICAgIGhhc0hpZXJhcmNoeUNvbHVtbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlaGF2aW9yLmhhc0hpZXJhcmNoeUNvbHVtbigpO1xuICAgIH0sXG4gICAgaXNIaWVyYXJjaHlDb2x1bW46IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzSGllcmFyY2h5Q29sdW1uKCkgJiYgeCA9PT0gMDtcbiAgICB9LFxuICAgIGNoZWNrU2Nyb2xsYmFyVmlzaWJpbGl0eTogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIHZhciBob3ZlckNsYXNzT3ZlciA9IHRoaXMucmVzb2x2ZVByb3BlcnR5KCdzY3JvbGxiYXJIb3Zlck92ZXInKTtcbiAgICAgICAgLy8gdmFyIGhvdmVyQ2xhc3NPZmYgPSB0aGlzLnJlc29sdmVQcm9wZXJ0eSgnc2Nyb2xsYmFySG92ZXJPZmYnKTtcblxuICAgICAgICAvLyBpZiAoaG92ZXJDbGFzc09mZiA9PT0gJ3Zpc2libGUnKSB7XG4gICAgICAgIC8vICAgICB0aGlzLnNiSFNjcm9sbGVyLmNsYXNzTGlzdC5yZW1vdmUoaG92ZXJDbGFzc092ZXIpO1xuICAgICAgICAvLyAgICAgdGhpcy5zYlZTY3JvbGxlci5jbGFzc0xpc3QucmVtb3ZlKGhvdmVyQ2xhc3NPZmYpO1xuICAgICAgICAvLyAgICAgdGhpcy5zYkhTY3JvbGxlci5jbGFzc0xpc3QuYWRkKCd2aXNpYmxlJyk7XG4gICAgICAgIC8vICAgICB0aGlzLnNiVlNjcm9sbGVyLmNsYXNzTGlzdC5hZGQoJ3Zpc2libGUnKTtcbiAgICAgICAgLy8gfVxuICAgIH0sXG4gICAgaXNDb2x1bW5PclJvd1NlbGVjdGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uTW9kZWwuaXNDb2x1bW5PclJvd1NlbGVjdGVkKCk7XG4gICAgfSxcbiAgICBzZWxlY3RDb2x1bW46IGZ1bmN0aW9uKHgxLCB4Mikge1xuICAgICAgICB0aGlzLnNlbGVjdGlvbk1vZGVsLnNlbGVjdENvbHVtbih4MSwgeDIpO1xuICAgIH0sXG4gICAgc2VsZWN0Um93OiBmdW5jdGlvbih5MSwgeTIpIHtcbiAgICAgICAgdmFyIHNtID0gdGhpcy5zZWxlY3Rpb25Nb2RlbDtcbiAgICAgICAgdmFyIHNlbGVjdGlvbkVkZ2UgPSB0aGlzLmdldEZpbHRlclJvd0luZGV4KCkgKyAxO1xuXG4gICAgICAgIGlmICh0aGlzLnNpbmdsZVNlbGVjdCgpKSB7XG4gICAgICAgICAgICB5MSA9IHkyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gbXVsdGlwbGUgcm93IHNlbGVjdGlvblxuICAgICAgICAgICAgeTIgPSB5MiB8fCB5MTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWluID0gTWF0aC5taW4oeTEsIHkyKTtcbiAgICAgICAgaWYgKG1pbiA+PSBzZWxlY3Rpb25FZGdlKSB7XG4gICAgICAgICAgICB2YXIgbWF4ID0gTWF0aC5tYXgoeTEsIHkyKTtcbiAgICAgICAgICAgIHNtLnNlbGVjdFJvdyhtaW4sIG1heCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGlzUm93TnVtYmVyQXV0b3NpemluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc29sdmVQcm9wZXJ0eSgncm93TnVtYmVyQXV0b3NpemluZycpO1xuICAgIH0sXG4gICAgaXNSb3dTZWxlY3RlZDogZnVuY3Rpb24ocikge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb25Nb2RlbC5pc1Jvd1NlbGVjdGVkKHIpO1xuICAgIH0sXG4gICAgaXNDb2x1bW5TZWxlY3RlZDogZnVuY3Rpb24oYykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb25Nb2RlbC5pc0NvbHVtblNlbGVjdGVkKGMpO1xuICAgIH0sXG4gICAgbG9va3VwRmVhdHVyZTogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlaGF2aW9yLmxvb2t1cEZlYXR1cmUoa2V5KTtcbiAgICB9LFxuICAgIGdldFJvdzogZnVuY3Rpb24oeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWhhdmlvci5nZXRSb3coeSk7XG4gICAgfSxcbiAgICBpc0NlbGxTZWxlY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNvbHZlUHJvcGVydHkoJ2NlbGxTZWxlY3Rpb24nKSA9PT0gdHJ1ZTtcbiAgICB9LFxuICAgIGlzUm93U2VsZWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzb2x2ZVByb3BlcnR5KCdyb3dTZWxlY3Rpb24nKSA9PT0gdHJ1ZTtcbiAgICB9LFxuICAgIGlzQ29sdW1uU2VsZWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzb2x2ZVByb3BlcnR5KCdjb2x1bW5TZWxlY3Rpb24nKSA9PT0gdHJ1ZTtcbiAgICB9LFxuICAgIGdldENvbXB1dGVkUm93OiBmdW5jdGlvbih5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlaGF2aW9yLmdldENvbXB1dGVkUm93KHkpO1xuICAgIH0sXG4gICAgaXNDb2x1bW5BdXRvc2l6aW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzb2x2ZVByb3BlcnR5KCdjb2x1bW5BdXRvc2l6aW5nJykgPT09IHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IEdldCBhIHJlZmVyZW5jZSB0byB0aGUgZmlsdGVyIGF0dGFjaGVkIHRvIHRoZSBIeXBlcmdyaWQuXG4gICAgICogQHJldHVybnMge0ZpbHRlclRyZWV9XG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBnZXRHbG9iYWxGaWx0ZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWhhdmlvci5nZXRHbG9iYWxGaWx0ZXIoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgQXR0YWNoL2RldGFjaCBhIGZpbHRlciB0byBhIEh5cGVyZ3JpZC5cbiAgICAgKiBAcGFyYW0ge0ZpbHRlclRyZWV9IFtmaWx0ZXJdIC0gVGhlIGZpbHRlciBvYmplY3QuIElmIHVuZGVmaW5lZCwgYW55IGF0dGFjaGVkIGZpbHRlciBpcyByZW1vdmVkLlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICovXG4gICAgc2V0R2xvYmFsRmlsdGVyOiBmdW5jdGlvbihmaWx0ZXIpIHtcbiAgICAgICAgdGhpcy5iZWhhdmlvci5zZXRHbG9iYWxGaWx0ZXIoZmlsdGVyKTtcbiAgICAgICAgdGhpcy5iZWhhdmlvckNoYW5nZWQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgU2V0IHRoZSBjYXNlIHNlbnNpdGl2aXR5IG9mIGZpbHRlciB0ZXN0cyBhZ2FpbnN0IGRhdGEuXG4gICAgICogQGRlc2MgQ2FzZSBzZW5zaXRpdml0eSBwZXJ0YWlucyB0byBzdHJpbmcgY29tcGFyZXMgb25seS4gVGhpcyBpbmNsdWRlcyB1bnR5cGVkIGNvbHVtbnMsIGNvbHVtbnMgdHlwZWQgYXMgc3RyaW5ncywgdHlwZWQgY29sdW1ucyBjb250YWluaW5nIGRhdGEgdGhhdCBjYW5ub3QgYmUgY29lcmNlZCB0byB0eXBlIG9yIHdoZW4gdGhlIGZpbHRlciBleHByZXNzaW9uIG9wZXJhbmQgY2Fubm90IGJlIGNvZXJjZWQuXG4gICAgICpcbiAgICAgKiBOT1RFOiBUaGlzIGlzIGEgc2hhcmVkIHByb3BlcnR5IGFuZCBhZmZlY3RzIGFsbCBncmlkIG1hbmFnZWQgYnkgdGhpcyBpbnN0YW5jZSBvZiB0aGUgYXBwLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNTZW5zaXRpdmVcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHNldEdsb2JhbEZpbHRlckNhc2VTZW5zaXRpdml0eTogZnVuY3Rpb24oaXNTZW5zaXRpdmUpIHtcbiAgICAgICAgLy8gdGhpcyBzZXR0aW5nIGFmZmVjdHMgYWxsIGdyaWRzXG4gICAgICAgIHRoaXMuYmVoYXZpb3Iuc2V0R2xvYmFsRmlsdGVyQ2FzZVNlbnNpdGl2aXR5KGlzU2Vuc2l0aXZlKTtcbiAgICAgICAgdGhpcy5jb21wdXRlQ2VsbHNCb3VuZHMoKTtcbiAgICAgICAgdGhpcy5iZWhhdmlvckNoYW5nZWQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBjb2x1bW5JbmRleE9yTmFtZSAtIFRoZSBfY29sdW1uIGZpbHRlcl8gdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7RmlsdGVyVHJlZUdldFN0YXRlT3B0aW9uc09iamVjdH0gW29wdGlvbnNdIC0gUGFzc2VkIHRvIHRoZSBmaWx0ZXIncyB7QGxpbmsgRGVmYXVsdEZpbHRlciNnZXRTdGF0ZXxnZXRTdGF0ZX0gbWV0aG9kLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuc3ludGF4PSdDUUwnXSAtIFRoZSBzeW50YXggdG8gdXNlIHRvIGRlc2NyaWJlIHRoZSBmaWx0ZXIgc3RhdGUuIE5vdGUgdGhhdCBgZ2V0RmlsdGVyYCdzIGRlZmF1bHQgc3ludGF4LCBgJ0NRTCdgLCBkaWZmZXJzIGZyb20gdGhlIG90aGVyIGdldCBzdGF0ZSBtZXRob2RzLlxuICAgICAqIEByZXR1cm5zIHtGaWx0ZXJUcmVlU3RhdGVPYmplY3R9XG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBnZXRGaWx0ZXI6IGZ1bmN0aW9uKGNvbHVtbkluZGV4T3JOYW1lLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlaGF2aW9yLmdldEZpbHRlcihjb2x1bW5JbmRleE9yTmFtZSwgb3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IFNldCBhIHBhcnRpY3VsYXIgY29sdW1uIGZpbHRlcidzIHN0YXRlLlxuICAgICAqIEBkZXNjIEFmdGVyIHNldHRpbmcgdGhlIG5ldyBmaWx0ZXIgc3RhdGU6XG4gICAgICogKiBSZWFwcGxpZXMgdGhlIGZpbHRlciB0byB0aGUgZGF0YSBzb3VyY2UuXG4gICAgICogKiBDYWxscyBgYmVoYXZpb3JDaGFuZ2VkKClgIHRvIHVwZGF0ZSB0aGUgZ3JpZCBjYW52YXMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBjb2x1bW5JbmRleE9yTmFtZSAtIFRoZSBfY29sdW1uIGZpbHRlcl8gdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gW3N0YXRlXSAtIEEgZmlsdGVyIHRyZWUgb2JqZWN0IG9yIGEgSlNPTiwgU1FMLCBvciBDUUwgc3ViZXhwcmVzc2lvbiBzdHJpbmcgdGhhdCBkZXNjcmliZXMgdGhlIGEgbmV3IHN0YXRlIGZvciB0aGUgbmFtZWQgY29sdW1uIGZpbHRlci4gVGhlIGV4aXN0aW5nIGNvbHVtbiBmaWx0ZXIgc3ViZXhwcmVzc2lvbiBpcyByZXBsYWNlZCB3aXRoIGEgbmV3IG5vZGUgYmFzZWQgb24gdGhpcyBzdGF0ZS4gSWYgaXQgZG9lcyBub3QgZXhpc3QsIHRoZSBuZXcgc3ViZXhwcmVzc2lvbiBpcyBhZGRlZCB0byB0aGUgY29sdW1uIGZpbHRlcnMgc3VidHJlZSAoYGZpbHRlci5jb2x1bW5GaWx0ZXJzYCkuXG4gICAgICpcbiAgICAgKiBJZiB1bmRlZmluZWQsIHJlbW92ZXMgdGhlIGVudGlyZSBjb2x1bW4gZmlsdGVyIHN1YmV4cHJlc3Npb24gZnJvbSB0aGUgY29sdW1uIGZpbHRlcnMgc3VidHJlZS5cbiAgICAgKiBAcGFyYW0ge0ZpbHRlclRyZWVTZXRTdGF0ZU9wdGlvbnNPYmplY3R9IFtvcHRpb25zXSAtIFBhc3NlZCB0byB0aGUgZmlsdGVyJ3MgW3NldFN0YXRlXXtAbGluayBodHRwOi8vam9uZWl0LmdpdGh1Yi5pby9maWx0ZXItdHJlZS9GaWx0ZXJUcmVlLmh0bWwjc2V0U3RhdGV9IG1ldGhvZC4gWW91IG1heSBtaXggaW4gbWVtYmVycyBvZiB0aGUge0BsaW5rIGh0dHA6Ly9qb25laXQuZ2l0aHViLmlvL2ZpbHRlci10cmVlL2dsb2JhbC5odG1sI0ZpbHRlclRyZWVWYWxpZGF0aW9uT3B0aW9uc09iamVjdHxGaWx0ZXJUcmVlVmFsaWRhdGlvbk9wdGlvbnNPYmplY3R9XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnN5bnRheD0nQ1FMJ10gLSBUaGUgc3ludGF4IHRvIHVzZSB0byBkZXNjcmliZSB0aGUgZmlsdGVyIHN0YXRlLiBOb3RlIHRoYXQgYHNldEZpbHRlcmAncyBkZWZhdWx0IHN5bnRheCwgYCdDUUwnYCwgZGlmZmVycyBmcm9tIHRoZSBvdGhlciBnZXQgc3RhdGUgbWV0aG9kcy5cbiAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfEVycm9yfHN0cmluZ30gYHVuZGVmaW5lZGAgaW5kaWNhdGVzIHN1Y2Nlc3MuXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBzZXRGaWx0ZXI6IGZ1bmN0aW9uKGNvbHVtbkluZGV4T3JOYW1lLCBzdGF0ZSwgb3B0aW9ucykge1xuICAgICAgICBpZiAodGhpcy5jZWxsRWRpdG9yKSB7XG4gICAgICAgICAgICB0aGlzLmNlbGxFZGl0b3IuaGlkZUVkaXRvcigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYmVoYXZpb3Iuc2V0RmlsdGVyKGNvbHVtbkluZGV4T3JOYW1lLCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuYmVoYXZpb3JDaGFuZ2VkKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7RmlsdGVyVHJlZUdldFN0YXRlT3B0aW9uc09iamVjdH0gW29wdGlvbnNdIC0gUGFzc2VkIHRvIHRoZSBmaWx0ZXIncyB7QGxpbmsgRGVmYXVsdEZpbHRlciNnZXRTdGF0ZXxnZXRTdGF0ZX0gbWV0aG9kLlxuICAgICAqIEByZXR1cm5zIHtGaWx0ZXJUcmVlU3RhdGVPYmplY3R9XG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBnZXRGaWx0ZXJzOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlaGF2aW9yLmdldEZpbHRlcnMob3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7RmlsdGVyVHJlZVN0YXRlT2JqZWN0fSBzdGF0ZVxuICAgICAqIEBwYXJhbSB7RmlsdGVyVHJlZVNldFN0YXRlT3B0aW9uc09iamVjdH0gW29wdGlvbnNdIC0gUGFzc2VkIHRvIHRoZSBmaWx0ZXIncyBbc2V0U3RhdGVde0BsaW5rIGh0dHA6Ly9qb25laXQuZ2l0aHViLmlvL2ZpbHRlci10cmVlL0ZpbHRlclRyZWUuaHRtbCNzZXRTdGF0ZX0gbWV0aG9kLiBZb3UgbWF5IG1peCBpbiBtZW1iZXJzIG9mIHRoZSB7QGxpbmsgaHR0cDovL2pvbmVpdC5naXRodWIuaW8vZmlsdGVyLXRyZWUvZ2xvYmFsLmh0bWwjRmlsdGVyVHJlZVZhbGlkYXRpb25PcHRpb25zT2JqZWN0fEZpbHRlclRyZWVWYWxpZGF0aW9uT3B0aW9uc09iamVjdH1cbiAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfEVycm9yfHN0cmluZ30gYHVuZGVmaW5lZGAgaW5kaWNhdGVzIHN1Y2Nlc3MuXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBzZXRGaWx0ZXJzOiBmdW5jdGlvbihzdGF0ZSwgb3B0aW9ucykge1xuICAgICAgICBpZiAodGhpcy5jZWxsRWRpdG9yKSB7XG4gICAgICAgICAgICB0aGlzLmNlbGxFZGl0b3IuaGlkZUVkaXRvcigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYmVoYXZpb3Iuc2V0RmlsdGVycyhzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuYmVoYXZpb3JDaGFuZ2VkKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7RmlsdGVyVHJlZUdldFN0YXRlT3B0aW9uc09iamVjdH0gW29wdGlvbnNdIC0gUGFzc2VkIHRvIHRoZSBmaWx0ZXIncyB7QGxpbmsgRGVmYXVsdEZpbHRlciNnZXRTdGF0ZXxnZXRTdGF0ZX0gbWV0aG9kLlxuICAgICAqIEByZXR1cm5zIHtGaWx0ZXJUcmVlU3RhdGVPYmplY3R9XG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBnZXRUYWJsZUZpbHRlcjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWhhdmlvci5nZXRUYWJsZUZpbHRlcihvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtGaWx0ZXJUcmVlU3RhdGVPYmplY3R9IHN0YXRlXG4gICAgICogQHBhcmFtIHtGaWx0ZXJUcmVlU2V0U3RhdGVPcHRpb25zT2JqZWN0fSBbb3B0aW9uc10gLSBQYXNzZWQgdG8gdGhlIGZpbHRlcidzIFtzZXRTdGF0ZV17QGxpbmsgaHR0cDovL2pvbmVpdC5naXRodWIuaW8vZmlsdGVyLXRyZWUvRmlsdGVyVHJlZS5odG1sI3NldFN0YXRlfSBtZXRob2QuIFlvdSBtYXkgbWl4IGluIG1lbWJlcnMgb2YgdGhlIHtAbGluayBodHRwOi8vam9uZWl0LmdpdGh1Yi5pby9maWx0ZXItdHJlZS9nbG9iYWwuaHRtbCNGaWx0ZXJUcmVlVmFsaWRhdGlvbk9wdGlvbnNPYmplY3R8RmlsdGVyVHJlZVZhbGlkYXRpb25PcHRpb25zT2JqZWN0fVxuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR8RXJyb3J8c3RyaW5nfSBgdW5kZWZpbmVkYCBpbmRpY2F0ZXMgc3VjY2Vzcy5cbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHNldFRhYmxlRmlsdGVyOiBmdW5jdGlvbihzdGF0ZSwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLmJlaGF2aW9yLnNldFRhYmxlRmlsdGVyKHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5iZWhhdmlvckNoYW5nZWQoKTtcbiAgICB9LFxuXG4gICAgc2VsZWN0Um93c0Zyb21DZWxsczogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0NoZWNrYm94T25seVJvd1NlbGVjdGlvbnMoKSkge1xuICAgICAgICAgICAgdmFyIGxhc3QsXG4gICAgICAgICAgICAgICAgaGFzQ1RSTCA9IHRoaXMubW91c2VEb3duU3RhdGUucHJpbWl0aXZlRXZlbnQuZGV0YWlsLnByaW1pdGl2ZUV2ZW50LmN0cmxLZXk7XG5cbiAgICAgICAgICAgIGlmIChoYXNDVFJMICYmICF0aGlzLmlzU2luZ2xlUm93U2VsZWN0aW9uTW9kZSgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25Nb2RlbC5zZWxlY3RSb3dzRnJvbUNlbGxzKDAsIGhhc0NUUkwpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgobGFzdCA9IHRoaXMuc2VsZWN0aW9uTW9kZWwuZ2V0TGFzdFNlbGVjdGlvbigpKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0Um93KG51bGwsIGxhc3QuY29ybmVyLnkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFyUm93U2VsZWN0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHNlbGVjdENvbHVtbnNGcm9tQ2VsbHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnNlbGVjdGlvbk1vZGVsLnNlbGVjdENvbHVtbnNGcm9tQ2VsbHMoKTtcbiAgICB9LFxuICAgIGdldFNlbGVjdGVkUm93czogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlaGF2aW9yLmdldFNlbGVjdGVkUm93cygpO1xuICAgIH0sXG4gICAgZ2V0U2VsZWN0ZWRDb2x1bW5zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVoYXZpb3IuZ2V0U2VsZWN0ZWRDb2x1bW5zKCk7XG4gICAgfSxcbiAgICBnZXRTZWxlY3Rpb25zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVoYXZpb3IuZ2V0U2VsZWN0aW9ucygpO1xuICAgIH0sXG4gICAgZ2V0TGFzdFNlbGVjdGlvblR5cGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb25Nb2RlbC5nZXRMYXN0U2VsZWN0aW9uVHlwZSgpO1xuICAgIH0sXG4gICAgaXNDZWxsU2VsZWN0ZWQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uTW9kZWwuaXNDZWxsU2VsZWN0ZWQoeCwgeSk7XG4gICAgfSxcbiAgICBpc0luQ3VycmVudFNlbGVjdGlvblJlY3RhbmdsZTogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb25Nb2RlbC5pc0luQ3VycmVudFNlbGVjdGlvblJlY3RhbmdsZSh4LCB5KTtcbiAgICB9LFxuICAgIHNlbGVjdEFsbFJvd3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnNlbGVjdGlvbk1vZGVsLnNlbGVjdEFsbFJvd3MoKTtcbiAgICB9LFxuICAgIGFyZUFsbFJvd3NTZWxlY3RlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGlvbk1vZGVsLmFyZUFsbFJvd3NTZWxlY3RlZCgpO1xuICAgIH0sXG4gICAgdG9nZ2xlU2VsZWN0QWxsUm93czogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmFyZUFsbFJvd3NTZWxlY3RlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbk1vZGVsLmNsZWFyKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdEFsbFJvd3MoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlcGFpbnQoKTtcbiAgICB9LFxuICAgIGlzU2luZ2xlUm93U2VsZWN0aW9uTW9kZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc29sdmVQcm9wZXJ0eSgnc2luZ2xlUm93U2VsZWN0aW9uTW9kZScpO1xuICAgIH0sXG4gICAgbmV3UG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh4LCB5KTtcbiAgICB9LFxuICAgIG5ld1JlY3RhbmdsZTogZnVuY3Rpb24oeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICByZXR1cm4gbmV3IFJlY3RhbmdsZSh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9LFxuICAgIGdldEZvcm1hdHRlZFZhbHVlOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZvcm1hdFZhbHVlKFxuICAgICAgICAgICAgdGhpcy5nZXRDb2x1bW5Qcm9wZXJ0aWVzKHgpLmZvcm1hdCxcbiAgICAgICAgICAgIHRoaXMuZ2V0VmFsdWUoeCwgeSArIHRoaXMuZ2V0SGVhZGVyUm93Q291bnQoKSlcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgU3RpY2t5IGhhc2ggb2YgZGlhbG9nIG9wdGlvbnMgb2JqZWN0cy5cbiAgICAgKiBAZGVzYyBFYWNoIGtleSBpcyBhIGRpYWxvZyBuYW1lOyB0aGUgdmFsdWUgaXMgdGhlIG9wdGlvbnMgb2JqZWN0IGZvciB0aGF0IGRpYWxvZy5cbiAgICAgKiBUaGUgZGVmYXVsdCBkaWFsb2cgb3B0aW9ucyBvYmplY3QgaGFzIHRoZSBrZXkgYCd1bmRlZmluZWQnYCwgd2hpY2ggaXMgdW5kZWZpbmVkIGJ5IGRlZmF1bHQ7IGl0IGlzIHNldCBieSBjYWxsaW5nIGBzZXREaWFsb2dPcHRpb25zYCB3aXRoIG5vIGBkaWFsb2dOYW1lYCBwYXJhbWV0ZXIuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBkaWFsb2dPcHRpb25zOiB7fSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IFNldCBhbmQvb3IgcmV0dXJuIGEgc3BlY2lmaWMgZGlhbG9nIG9wdGlvbnMgb2JqZWN0ICpvciogYSBkZWZhdWx0IGRpYWxvZyBvcHRpb25zIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBkZXNjIElmIGBvcHRpb25zYCBkZWZpbmVkOlxuICAgICAqICogSWYgYGRpYWxvZ05hbWVgIGRlZmluZWQ6IFNhdmUgdGhlIHNwZWNpZmljIGRpYWxvZydzIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqICogSWYgYGRpYWxvZ05hbWVgIHVuZGVmaW5lZDogU2F2ZSB0aGUgZGVmYXVsdCBkaWFsb2cgb3B0aW9ucyBvYmplY3QuXG4gICAgICpcbiAgICAgKiBJZiBgb3B0aW9uc2AgaXMgX25vdF8gZGVmaW5lZCwgbm8gbmV3IGRpYWxvZyBvcHRpb25zIG9iamVjdCB3aWxsIGJlIHNhdmVkOyBidXQgYSBwcmV2aW91c2x5IHNhdmVkIHByZXNldCB3aWxsIGJlIHJldHVybmVkIChhZnRlciBtaXhpbmcgaW4gdGhlIGRlZmF1bHQgcHJlc2V0IGlmIHRoZXJlIGlzIG9uZSkuXG4gICAgICpcbiAgICAgKiBUaGUgZGVmYXVsdCBkaWFsb2cgb3B0aW9ucyBvYmplY3QgaXMgdXNlZCBpbiB0d28gd2F5czpcbiAgICAgKiAqIHdoZW4gYSBkaWFsb2cgaGFzIG5vIG9wdGlvbnMgb2JqZWN0XG4gICAgICogKiBhcyBhIG1peC1pbiBiYXNlIHdoZW4gYSBkaWFsb2cgZG9lcyBoYXZlIGFuIG9wdGlvbnMgb2JqZWN0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2RpYWxvZ05hbWVdIElmIHVuZGVmaW5lZCwgYG9wdGlvbnNgIGRlZmluZXMgdGhlIGRlZmF1bHQgZGlhbG9nIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBJZiBkZWZpbmVkLCBwcmVzZXQgdGhlIG5hbWVkIGRpYWxvZyBvcHRpb25zIG9iamVjdCBvciB0aGUgZGVmYXVsdCBkaWFsb2cgb3B0aW9ucyBvYmplY3QgaWYgbmFtZSBpcyB1bmRlZmluZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBPbmUgb2Y6XG4gICAgICogKiBXaGVuIGBvcHRpb25zYCB1bmRlZmluZWQsIGZpcnN0IG9mOlxuICAgICAqICAgKiBwcmV2aW91cyBwcmVzZXRcbiAgICAgKiAgICogZGVmYXVsdCBwcmVzZXRcbiAgICAgKiAgICogZW1wdHkgb2JqZWN0XG4gICAgICogKiBXaGVuIGBvcHRpb25zYCBkZWZpbmVkLCBmaXJzdCBvZjpcbiAgICAgKiAgICogbWl4LWluOiBkZWZhdWx0IHByZXNldCBtZW1iZXJzICsgYG9wdGlvbnNgIG1lbWJlcnNcbiAgICAgKiAgICogYG9wdGlvbnNgIHZlcmJhdGltIHdoZW4gZGVmYXVsdCBwcmVzZXQgdW5kZWZpbmVkXG4gICAgICovXG4gICAgc2V0RGlhbG9nT3B0aW9uczogZnVuY3Rpb24oZGlhbG9nTmFtZSwgb3B0aW9ucykge1xuICAgICAgICBpZiAodHlwZW9mIGRpYWxvZ05hbWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gZGlhbG9nTmFtZTtcbiAgICAgICAgICAgIGRpYWxvZ05hbWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRlZmF1bHRPcHRpb25zID0gdGhpcy5kaWFsb2dPcHRpb25zLnVuZGVmaW5lZDtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgZGlhbG9nTmFtZSAmJiB0aGlzLmRpYWxvZ09wdGlvbnNbZGlhbG9nTmFtZV07XG4gICAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLmRpYWxvZ09wdGlvbnNbZGlhbG9nTmFtZV0gPSBvcHRpb25zO1xuICAgICAgICAgICAgaWYgKGRlZmF1bHRPcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IF8oe30pLmV4dGVuZChkZWZhdWx0T3B0aW9ucywgb3B0aW9ucyk7IC8vIG1ha2UgYSBtaXgtaW5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBkZWZhdWx0T3B0aW9ucyB8fCB7fTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3B0aW9ucztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogT3B0aW9ucyBvYmplY3RzIGFyZSByZW1lbWJlcmVkIGZvciBzdWJzZXF1ZW50IHVzZS4gQWx0ZXJuYXRpdmVseSwgdGhleSBjYW4gYmUgcHJlc2V0IGJ5IGNhbGxpbmcge0BsaW5rIEh5cGVyZ3JpZCNzZXREaWFsb2dPcHRpb25zfHNldERpYWxvZ09wdGlvbnN9LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkaWFsb2dOYW1lXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAtIElmIG9taXR0ZWQsIHVzZSB0aGUgb3B0aW9ucyBvYmplY3QgcHJldmlvdXNseSBnaXZlbiBoZXJlIChvciB0byB7QGxpbmsgSHlwZXJncmlkI3NldERpYWxvZ09wdGlvbnN8c2V0RGlhbG9nT3B0aW9uc30pLCBpZiBhbnkuIEluIGFueSBjYXNlLCB0aGUgcmVzdWx0YW50IG9wdGlvbnMgb2JqZWN0LCBpZiBhbnksIGlzIG1peGVkIGludG8gdGhlIGRlZmF1bHQgb3B0aW9ucyBvYmplY3QsIGlmIHRoZXJlIGlzIG9uZS5cbiAgICAgKi9cbiAgICBvcGVuRGlhbG9nOiBmdW5jdGlvbihkaWFsb2dOYW1lLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuc3RvcEVkaXRpbmcoKTtcbiAgICAgICAgb3B0aW9ucyA9IHRoaXMuc2V0RGlhbG9nT3B0aW9ucyhkaWFsb2dOYW1lLCBvcHRpb25zKTtcbiAgICAgICAgb3B0aW9ucy50ZXJtaW5hdGUgPSBmdW5jdGlvbigpIHsgLy8gd2hlbiBhYm91dC10by1iZS1vcGVuZWQgZGlhbG9nIGlzIGV2ZW50dWFsbHkgY2xvc2VkXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5kaWFsb2c7XG4gICAgICAgIH0uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5kaWFsb2cgPSB0aGlzLmJlaGF2aW9yLm9wZW5EaWFsb2coZGlhbG9nTmFtZSwgb3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8vIGFsdGhvdWdoIHlvdSBjYW4gaGF2ZSBtdWx0aXBsZSBkaWFsb2dzIG9wZW4gYXQgdGhlIHNhbWUgdGltZSwgdGhlIGZvbGxvd2luZyBlbmZvcmNlcyBvbmUgYXQgYSB0aW1lIChmb3Igbm93KVxuICAgIHRvZ2dsZURpYWxvZzogZnVuY3Rpb24obmV3RGlhbG9nTmFtZSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgZGlhbG9nID0gdGhpcy5kaWFsb2csXG4gICAgICAgICAgICBvbGREaWFsb2dOYW1lID0gZGlhbG9nICYmIGRpYWxvZy4kJENMQVNTX05BTUU7XG4gICAgICAgIGlmICghZGlhbG9nIHx8ICF0aGlzLmRpYWxvZy5jbG9zZSgpICYmIG9sZERpYWxvZ05hbWUgIT09IG5ld0RpYWxvZ05hbWUpIHtcbiAgICAgICAgICAgIGlmICghZGlhbG9nKSB7XG4gICAgICAgICAgICAgICAgLy8gb3BlbiBuZXcgZGlhbG9nIG5vd1xuICAgICAgICAgICAgICAgIHRoaXMub3BlbkRpYWxvZyhuZXdEaWFsb2dOYW1lLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gb3BlbiBuZXcgZGlhbG9nIHdoZW4gYWxyZWFkeS1vcGVuZWQgZGlhbG9nIGZpbmlzaGVzIGNsb3NpbmcgZHVlIHRvIC5jbG9zZURpYWxvZygpIGFib3ZlXG4gICAgICAgICAgICAgICAgZGlhbG9nLnRlcm1pbmF0ZSA9IHRoaXMub3BlbkRpYWxvZy5iaW5kKHRoaXMsIG5ld0RpYWxvZ05hbWUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IE9uZSBvZjpcbiAgICAgKiAqIGAnYWN0aXZlJ2AgLSBUaGVyZSBpcyBhdCBsZWFzdCBvbmUgZGVmaW5lZCBmaWx0ZXIgKGxlYWYgbm9kZSkgaW4gdGhlIGZpbHRlciB0cmVlLlxuICAgICAqICogYCdpbmFjdGl2ZSdgIC0gVGhlcmUgYXJlIG5vIGRlZmluZWQgZmlsdGVycyAobm8gbGVhZiBub2RlcykgaW4gdGhlIGZpbHRlciB0cmVlLlxuICAgICAqICogYCdlcnJvcidgIC0gVGhlcmUgaXMgYXQgbGVhc3Qgb25lIHBhcnRpYWxseSBkZWZpbmVkIGZpbHRlci5cbiAgICAgKi9cbiAgICBnZXRGaWx0ZXJTdGF0dXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZmlsdGVyID0gdGhpcy5nZXRHbG9iYWxGaWx0ZXIoKSxcbiAgICAgICAgICAgIHJlc3VsdDtcblxuICAgICAgICBpZiAoZmlsdGVyLmludmFsaWQoKSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gJ2Vycm9yJztcbiAgICAgICAgfSBlbHNlIGlmIChmaWx0ZXIuZmlsdGVyQ291bnQoKSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gJ2FjdGl2ZSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSAnaW5hY3RpdmUnO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxufTtcblxuLyoqXG4gKiBAc3VtbWFyeSBVcGRhdGUgZGVlcCBwcm9wZXJ0aWVzIHdpdGggbmV3IHZhbHVlcy5cbiAqIEBkZXNjIFRoaXMgZnVuY3Rpb24gaXMgYSByZWN1cnNpdmUgcHJvcGVydHkgc2V0dGVyIHdoaWNoIHVwZGF0ZXMgYSBkZWVwIHByb3BlcnR5IGluIGEgZGVzdGluYXRpb24gb2JqZWN0IHdpdGggdGhlIHZhbHVlIG9mIGEgY29uZ3J1ZW50IHByb3BlcnR5IGluIGEgc291cmNlIG9iamVjdC5cbiAqXG4gKiA+IFRlcm1pbm9sb2d5OiBBIGRlZXAgcHJvcGVydHkgaXMgYSBcInRlcm1pbmFsIG5vZGVcIiAocHJpbWl0aXZlIHZhbHVlKSBuZXN0ZWQgYXQgc29tZSBkZXB0aCAoaS5lLiwgZGVwdGggPiAxKSBpbnNpZGUgYSBjb21wbGV4IG9iamVjdCAoYW4gb2JqZWN0IGNvbnRhaW5pbmcgbmVzdGVkIG9iamVjdHMpLiBBIGNvbmdydWVudCBwcm9wZXJ0eSBpcyBhIHByb3BlcnR5IGluIGFub3RoZXIgb2JqZWN0IHdpdGggdGhlIHNhbWUgbmFtZSBhbmQgYXQgdGhlIHNhbWUgbGV2ZWwgb2YgbmVzdGluZy5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHNpbXBsZSBhbmQgZWxlZ2FudC4gSSByZWNvbW1lbmQgeW91IHN0dWR5IHRoZSBjb2RlLCB3aGljaCBub25ldGhlbGVzcyBpbXBsaWVzIGFsbCBvZiB0aGUgZm9sbG93aW5nOlxuICpcbiAqICogSWYgdGhlIGRlZXAgcHJvcGVydHkgaXMgX25vdF8gZm91bmQgaW4gYGRlc3RpbmF0aW9uYCwgaXQgd2lsbCBiZSBjcmVhdGVkLlxuICogKiBJZiB0aGUgZGVlcCBwcm9wZXJ0eSBpcyBmb3VuZCBpbiBgZGVzdGluYXRpb25gIF9hbmRfIGlzIGEgcHJpbWl0aXZlIHR5cGUsIGl0IHdpbGwgYmUgbW9kaWZpZWQgKG92ZXJ3cml0dGVuIHdpdGggdGhlIHZhbHVlIGZyb20gYHNvdXJjZWApLlxuICogKiBJZiB0aGUgZGVlcCBwcm9wZXJ0eSBpcyBmb3VuZCBpbiBgZGVzdGluYXRpb25gIF9idXRfIGlzIG5vdCBhIHByaW1pdGl2ZSB0eXBlIChpLmUuLCBpcyBhIG5lc3RlZCBvYmplY3QpLCBpdCB3aWxsIF9hbHNvXyBiZSBvdmVyd3JpdHRlbiB3aXRoIHRoZSAocHJpbWl0aXZlKSB2YWx1ZSBmcm9tIGBzb3VyY2VgLlxuICogKiBJZiB0aGUgbmVzdGVkIG9iamVjdCB0aGUgZGVlcCBwcm9wZXJ0eSBpbmhhYml0cyBpbiBgc291cmNlYCBpcyBub3QgZm91bmQgaW4gYGRlc3RpbmF0aW9uYCwgaXQgd2lsbCBiZSBjcmVhdGVkLlxuICogKiBJZiB0aGUgbmVzdGVkIG9iamVjdCB0aGUgZGVlcCBwcm9wZXJ0eSBpbmhhYml0cyBpbiBgc291cmNlYCBpcyBmb3VuZCBpbiBgZGVzdGluYXRpb25gIGJ1dCBpcyBub3QgaW4gZmFjdCBhbiBvYmplY3QgKGkuZS4sIGl0IGlzIGEgcHJpbWl0aXZlIHZhbHVlKSwgaXQgd2lsbCBiZSBvdmVyd3JpdHRlbiB3aXRoIGEgcmVmZXJlbmNlIHRvIHRoYXQgb2JqZWN0LlxuICogKiBJZiB0aGUgcHJpbWl0aXZlIHZhbHVlIGlzIGB1bmRlZmluZWRgLCB0aGUgZGVzdGluYXRpb24gcHJvcGVydHkgaXMgZGVsZXRlZC5cbiAqICogYHNvdXJjZWAgbWF5IGNvbnRhaW4gbXVsdGlwbGUgcHJvcGVydGllcyB0byB1cGRhdGUuXG4gKlxuICogVGhhdCBvbmUgcnVsZSBpcyBzaW1wbHkgdGhpczogSWYgYm90aCB0aGUgc291cmNlIF9hbmRfIHRoZSBkZXN0aW5hdGlvbiBwcm9wZXJ0aWVzIGFyZSBvYmplY3RzLCB0aGVuIHJlY3Vyc2U7IGVsc2Ugb3ZlcndyaXRlIHRoZSBkZXN0aW5hdGlvbiBwcm9wZXJ0eSB3aXRoIHRoZSBzb3VyY2UgcHJvcGVydHkuXG4gKlxuICogPiBDYXZlYXQ6IFRoaXMgaXMgX25vdF8gZXF1aXZhbGVudCB0byBhIGRlZXAgZXh0ZW5kIGZ1bmN0aW9uLiBXaGlsZSBib3RoIGEgZGVlcCBleHRlbmQgYW5kIHRoaXMgZnVuY3Rpb24gd2lsbCByZWN1cnNlIG92ZXIgYSBjb21wbGV4IG9iamVjdCwgdGhleSBhcmUgZnVuZGFtZW50YWxseSBkaWZmZXJlbnQ6IEEgZGVlcCBleHRlbmQgY2xvbmVzIHRoZSBuZXN0ZWQgb2JqZWN0cyBhcyBpdCBmaW5kcyB0aGVtOyB0aGlzIGZ1bmN0aW9uIG1lcmVseSB1cGRhdGVzIHRoZW0gKG9yIGNyZWF0ZXMgdGhlbSB3aGVyZSB0aGV5IGRvbid0IGV4aXN0KS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gZGVzdGluYXRpb24gLSBBbiBvYmplY3QgdG8gdXBkYXRlIHdpdGggbmV3IG9yIG1vZGlmaWVkIHByb3BlcnR5IHZhbHVlc1xuICogQHBhcmFtIHtvYmplY3R9IHNvdXJjZSAtIEEgY29uZ3J1ZW50IG9iamVjdCBjb250aW5hbHkgKG9ubHkpIHRoZSBuZXcgb3IgbW9kaWZpZWQgcHJvcGVydHkgdmFsdWVzLlxuICogQHJldHVybnMge29iamVjdH0gQWx3YXlzIHJldHVybnMgYGRlc3RpbmF0aW9uYC5cbiAqL1xuZnVuY3Rpb24gYWRkRGVlcFByb3BlcnRpZXMoZGVzdGluYXRpb24sIHNvdXJjZSkge1xuICAgIF8oc291cmNlKS5lYWNoKGZ1bmN0aW9uKHByb3BlcnR5LCBrZXkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkZXN0aW5hdGlvbltrZXldID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgcHJvcGVydHkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBhZGREZWVwUHJvcGVydGllcyhkZXN0aW5hdGlvbltrZXldLCBwcm9wZXJ0eSk7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvcGVydHkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZGVsZXRlIGRlc3RpbmF0aW9uW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbltrZXldID0gcHJvcGVydHk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZGVzdGluYXRpb247XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVJlY3QocmVjdCkge1xuICAgIHZhciBvID0gcmVjdC5vcmlnaW47XG4gICAgdmFyIGMgPSByZWN0LmNvcm5lcjtcblxuICAgIHZhciBveCA9IE1hdGgubWluKG8ueCwgYy54KTtcbiAgICB2YXIgb3kgPSBNYXRoLm1pbihvLnksIGMueSk7XG5cbiAgICB2YXIgY3ggPSBNYXRoLm1heChvLngsIGMueCk7XG4gICAgdmFyIGN5ID0gTWF0aC5tYXgoby55LCBjLnkpO1xuXG4gICAgdmFyIHJlc3VsdCA9IG5ldyBSZWN0YW5nbGUob3gsIG95LCBjeCAtIG94LCBjeSAtIG95KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkUG9seW1lclRoZW1lKCkge1xuICAgIGNsZWFyT2JqZWN0UHJvcGVydGllcyhwb2x5bWVyVGhlbWUpO1xuICAgIHZhciBwYiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3BhcGVyLWJ1dHRvbicpO1xuXG4gICAgcGIuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICBwYi5zZXRBdHRyaWJ1dGUoJ2Rpc2FibGVkJywgdHJ1ZSk7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChwYik7XG4gICAgdmFyIHAgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShwYik7XG5cbiAgICB2YXIgc2VjdGlvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NlY3Rpb24nKTtcbiAgICBzZWN0aW9uLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgc2VjdGlvbi5zZXRBdHRyaWJ1dGUoJ2hlcm8nLCB0cnVlKTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHNlY3Rpb24pO1xuXG4gICAgdmFyIGggPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdodG1sJykpO1xuICAgIHZhciBoYiA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2h0bWwsIGJvZHknKSk7XG4gICAgdmFyIHMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShzZWN0aW9uKTtcblxuICAgIHBvbHltZXJUaGVtZS5jb2x1bW5IZWFkZXJCYWNrZ3JvdW5kQ29sb3IgPSBwLmNvbG9yO1xuICAgIHBvbHltZXJUaGVtZS5yb3dIZWFkZXJCYWNrZ3JvdW5kQ29sb3IgPSBwLmNvbG9yO1xuICAgIHBvbHltZXJUaGVtZS50b3BMZWZ0QmFja2dyb3VuZENvbG9yID0gcC5jb2xvcjtcbiAgICBwb2x5bWVyVGhlbWUubGluZUNvbG9yID0gcC5iYWNrZ3JvdW5kQ29sb3I7XG5cbiAgICBwb2x5bWVyVGhlbWUuYmFja2dyb3VuZENvbG9yMiA9IGhiLmJhY2tncm91bmRDb2xvcjtcblxuICAgIHBvbHltZXJUaGVtZS5jb2xvciA9IGguY29sb3I7XG4gICAgcG9seW1lclRoZW1lLmZvbnRGYW1pbHkgPSBoLmZvbnRGYW1pbHk7XG4gICAgcG9seW1lclRoZW1lLmJhY2tncm91bmRDb2xvciA9IHMuYmFja2dyb3VuZENvbG9yO1xuXG4gICAgcGIuc2V0QXR0cmlidXRlKCdkaXNhYmxlZCcsIGZhbHNlKTtcbiAgICBwYi5zZXRBdHRyaWJ1dGUoJ3NlY29uZGFyeScsIHRydWUpO1xuICAgIHBiLnNldEF0dHJpYnV0ZSgncmFpc2VkJywgdHJ1ZSk7XG4gICAgcCA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHBiKTtcblxuICAgIHBvbHltZXJUaGVtZS5jb2x1bW5IZWFkZXJDb2xvciA9IHAuY29sb3I7XG4gICAgcG9seW1lclRoZW1lLnJvd0hlYWRlckNvbG9yID0gcC5jb2xvcjtcbiAgICBwb2x5bWVyVGhlbWUudG9wTGVmdENvbG9yID0gcC5jb2xvcjtcblxuXG4gICAgcG9seW1lclRoZW1lLmJhY2tncm91bmRTZWxlY3Rpb25Db2xvciA9IHAuYmFja2dyb3VuZENvbG9yO1xuICAgIHBvbHltZXJUaGVtZS5mb3JlZ3JvdW5kU2VsZWN0aW9uQ29sb3IgPSBwLmNvbG9yO1xuXG4gICAgcGIuc2V0QXR0cmlidXRlKCdzZWNvbmRhcnknLCBmYWxzZSk7XG4gICAgcGIuc2V0QXR0cmlidXRlKCd3YXJuaW5nJywgdHJ1ZSk7XG5cbiAgICBwb2x5bWVyVGhlbWUuY29sdW1uSGVhZGVyRm9yZWdyb3VuZFNlbGVjdGlvbkNvbG9yID0gcC5jb2xvcjtcbiAgICBwb2x5bWVyVGhlbWUuY29sdW1uSGVhZGVyQmFja2dyb3VuZFNlbGVjdGlvbkNvbG9yID0gcC5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgcG9seW1lclRoZW1lLnJvd0hlYWRlckZvcmVncm91bmRTZWxlY3Rpb25Db2xvciA9IHAuY29sb3I7XG4gICAgcG9seW1lclRoZW1lLmZpeGVkQ29sdW1uQmFja2dyb3VuZFNlbGVjdGlvbkNvbG9yID0gcC5iYWNrZ3JvdW5kQ29sb3I7XG5cbiAgICAvL2NoZWNrIGlmIHRoZXJlIGlzIGFjdHVhbGx5IGEgdGhlbWUgbG9hZGVkIGlmIG5vdCwgY2xlYXIgb3V0IGFsbCBib2d1cyB2YWx1ZXNcbiAgICAvL2Zyb20gbXkgY2FjaGVcbiAgICBpZiAocG9seW1lclRoZW1lLmNvbHVtbkhlYWRlckJhY2tncm91bmRTZWxlY3Rpb25Db2xvciA9PT0gJ3JnYmEoMCwgMCwgMCwgMCknIHx8XG4gICAgICAgIHBvbHltZXJUaGVtZS5saW5lQ29sb3IgPT09ICd0cmFuc3BhcmVudCcpIHtcbiAgICAgICAgY2xlYXJPYmplY3RQcm9wZXJ0aWVzKHBvbHltZXJUaGVtZSk7XG4gICAgfVxuXG4gICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChwYik7XG4gICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChzZWN0aW9uKTtcbn1cblxuZnVuY3Rpb24gY2xlYXJPYmplY3RQcm9wZXJ0aWVzKG9iaikge1xuICAgIGZvciAodmFyIHByb3AgaW4gb2JqKSB7XG4gICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBvYmpbcHJvcF07XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIHZhbE9yRnVuYyhkYXRhUm93LCBjb2x1bW5OYW1lKSB7XG4gICAgdmFyIHZmID0gZGF0YVJvd1tjb2x1bW5OYW1lXSxcbiAgICAgICAgcmVzdWx0ID0gKHR5cGVvZiB2ZilbMF0gPT09ICdmJyA/IHZmKGRhdGFSb3csIGNvbHVtbk5hbWUpIDogdmY7XG4gICAgcmV0dXJuIHJlc3VsdCB8fCByZXN1bHQgPT09IDAgfHwgcmVzdWx0ID09PSBmYWxzZSA/IHJlc3VsdCA6ICcnO1xufVxuXG4vKipcbiAqIEBzdW1tYXJ5IFNoYXJlZCBsb2NhbGl6YXRpb24gZGVmYXVsdHMgZm9yIGFsbCBncmlkIGluc3RhbmNlcy5cbiAqIEBkZXNjIFRoZXNlIHByb3BlcnR5IHZhbHVlcyBhcmUgb3ZlcnJpZGRlbiBieSB0aG9zZSBzdXBwbGllZCBpbiB0aGUgYEh5cGVyZ3JpZGAgY29uc3RydWN0b3IncyBgb3B0aW9ucy5sb2NhbGl6YXRpb25gLlxuICogQHByb3BlcnR5IHtzdHJpbmd8c3RyaW5nW119IFtvcHRpb25zLmxvY2FsaXphdGlvbi5kZWZhdWx0TG9jYWxlXSAtIFRoZSBkZWZhdWx0IGxvY2FsZSB0byB1c2Ugd2hlbiBhbiBleHBsaWNpdCBgbG9jYWxlYCBpcyBvbWl0dGVkIGZyb20gbG9jYWxpemVyIGNvbnN0cnVjdG9yIGNhbGxzLiBQYXNzZWQgdG8gSW50bC5OdW1iZXJGb3JtYXRgIGFuZCBgSW50bC5EYXRlRm9ybWF0YC4gU2VlIHtAIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0ludGwjTG9jYWxlX2lkZW50aWZpY2F0aW9uX2FuZF9uZWdvdGlhdGlvbnxMb2NhbGUgaWRlbnRpZmljYXRpb24gYW5kIG5lZ290aWF0aW9ufSBmb3IgbW9yZSBpbmZvcm1hdGlvbi4gT21pdHRpbmcgd2lsbCB1c2UgdGhlIHJ1bnRpbWUncyBsb2NhbCBsYW5ndWFnZSBhbmQgcmVnaW9uLlxuICogQHByb3BlcnR5IHtvYmplY3R9IFtvcHRpb25zLmxvY2FsaXphdGlvbi5udW1iZXJPcHRpb25zXSAtIE9wdGlvbnMgcGFzc2VkIHRvIGBJbnRsLk51bWJlckZvcm1hdGAgZm9yIGNyZWF0aW5nIHRoZSBiYXNpYyBcIm51bWJlclwiIGxvY2FsaXplci5cbiAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBbb3B0aW9ucy5sb2NhbGl6YXRpb24uZGF0ZU9wdGlvbnNdIC0gT3B0aW9ucyBwYXNzZWQgdG8gYEludGwuRGF0ZUZvcm1hdGAgZm9yIGNyZWF0aW5nIHRoZSBiYXNpYyBcImRhdGVcIiBsb2NhbGl6ZXIuXG4gKi9cblxuSHlwZXJncmlkLmxvY2FsaXphdGlvbiA9IHtcbiAgICBsb2NhbGU6ICdlbi1VUycsXG4gICAgbnVtYmVyT3B0aW9uczogeyBtYXhpbXVtRnJhY3Rpb25EaWdpdHM6IDAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBIeXBlcmdyaWQ7XG4iLCIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBPbmx5IDEgY2hvaWNlIGZyb20gZWFjaCBibG9jayBiZWxvdyBzaG91bGQgYmUgZXhwb3NlZCAodW5jb21tZW50ZWQpOlxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuXHRhbmFseXRpY3M6IHJlcXVpcmUoJ2h5cGVyLWFuYWx5dGljcycpLCAvLyBucG1cbiAgICAvL2FuYWx5dGljczogcmVxdWlyZSgnLi4vLi4vaHlwZXItYW5hbHl0aWNzL3NyYycpLCAvLyBkZXZlbG9wZXJzXG5cbiAgICBGaWx0ZXJUcmVlOiByZXF1aXJlKCdmaWx0ZXItdHJlZScpLCAvLyBucG1cbiAgICAvL0ZpbHRlclRyZWU6IHJlcXVpcmUoJy4uLy4uL2ZpbHRlci10cmVlJyksIC8vIGRldmVsb3BlcnNcblxufTtcbiIsIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgXyA9IHJlcXVpcmUoJ29iamVjdC1pdGVyYXRvcnMnKTtcbnZhciBCYXNlID0gcmVxdWlyZSgnLi4vbGliL0Jhc2UnKTtcblxudmFyIENvbHVtbiA9IHJlcXVpcmUoJy4vQ29sdW1uJyk7XG52YXIgZGlhbG9ncyA9IHJlcXVpcmUoJy4uL2RpYWxvZ3MnKTtcbnZhciBEZWZhdWx0RmlsdGVyID0gcmVxdWlyZSgnLi4vZmlsdGVyL0RlZmF1bHRGaWx0ZXInKTtcblxudmFyIG5vRXhwb3J0UHJvcGVydGllcyA9IFtcbiAgICAnY29sdW1uSGVhZGVyJyxcbiAgICAnY29sdW1uSGVhZGVyQ29sdW1uU2VsZWN0aW9uJyxcbiAgICAnZmlsdGVyUHJvcGVydGllcycsXG4gICAgJ3Jvd0hlYWRlcicsXG4gICAgJ3Jvd0hlYWRlclJvd1NlbGVjdGlvbicsXG4gICAgJ3Jvd051bWJlcnNQcm9wZXJ0aWVzJyxcbiAgICAndHJlZUNvbHVtblByb3BlcnRpZXMnLFxuICAgICd0cmVlQ29sdW1uUHJvcGVydGllc0NvbHVtblNlbGVjdGlvbicsXG5dO1xuXG52YXIgaXNOdWxsID0ge1xuICAgIGlzTnVsbDogdHJ1ZVxufTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBhYnN0cmFjdFxuICogQGRlc2MgQSBzb3J0IG9mIFwibW9kZWwrKy5cIiBJdCBjb250YWlucyBhbGwgY29kZS9kYXRhIHRoYXQncyBuZWNlc3NhcnkgZm9yIGVhc2lseSBpbXBsZW1lbnRpbmcgYSB2aXJ0dWFsIGRhdGEgc291cmNlIGFuZCBpdHMgbWFuaXB1bGF0aW9uL2FuYWx5dGljcy5cbiAqXG4gKi9cbnZhciBCZWhhdmlvciA9IEJhc2UuZXh0ZW5kKCdCZWhhdmlvcicsIHtcblxuICAgIC8qKlxuICAgICAqIEBkZXNjIHRoaXMgaXMgdGhlIGNhbGxiYWNrIGZvciB0aGUgcGx1Z2luIHBhdHRlcm4gb2YgbmVzdGVkIHRhZ3NcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb258bWVudUl0ZW1bXX0gW3NjaGVtYT1kZXJpdmVkU2NoZW1hXSAtIFBhc3NlZCB0byBiZWhhdmlvciBjb25zdHJ1Y3Rvci4gTWF5IGJlOlxuICAgICAqICogQSBzY2hlbWEgYXJyYXlcbiAgICAgKiAqIEEgZnVuY3Rpb24gcmV0dXJuaW5nIGEgc2NoZW1hIGFycmF5LiBDYWxsZWQgYXQgZmlsdGVyIHJlc2V0IHRpbWUgd2l0aCBiZWhhdmlvciBhcyBjb250ZXh0LlxuICAgICAqICogT21pdCB0byBnZW5lcmF0ZSBhIGJhc2ljIHNjaGVtYSBmcm9tIGB0aGlzLmNvbHVtbnNgLlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihncmlkLCBzY2hlbWEsIGRhdGFSb3dzKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7SHlwZXJncmlkfVxuICAgICAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdyaWQgPSBncmlkO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7RGF0YU1vZGVsfVxuICAgICAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRhdGFNb2RlbCA9IHRoaXMuZ2V0TmV3RGF0YU1vZGVsKCk7XG5cbiAgICAgICAgZ3JpZC5zZXRCZWhhdmlvcih0aGlzKTtcblxuICAgICAgICB0aGlzLnJlc2V0KCk7XG5cbiAgICAgICAgdGhpcy5pbml0aWFsaXplRmVhdHVyZUNoYWluKGdyaWQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZGVzYyBjcmVhdGUgdGhlIGZlYXR1cmUgY2hhaW4gLSB0aGlzIGlzIHRoZSBbY2hhaW4gb2YgcmVzcG9uc2liaWxpdHldKGh0dHA6Ly9jMi5jb20vY2dpL3dpa2k/Q2hhaW5PZlJlc3BvbnNpYmlsaXR5UGF0dGVybikgcGF0dGVybi5cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBpbml0aWFsaXplRmVhdHVyZUNoYWluOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHN1bW1hcnkgSGFzaCBvZiBmZWF0dXJlIGNsYXNzIG5hbWVzLlxuICAgICAgICAgKiBAZGVzYyBCdWlsdCBoZXJlIGJ1dCBvdGhlcndpc2Ugbm90IGluIHVzZS5cbiAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5mZWF0dXJlTWFwID0ge307XG5cbiAgICAgICAgdGhpcy5mZWF0dXJlcy5mb3JFYWNoKGZ1bmN0aW9uKEZlYXR1cmVDb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgdmFyIG5ld0ZlYXR1cmUgPSBuZXcgRmVhdHVyZUNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgc2VsZi5mZWF0dXJlTWFwW25ld0ZlYXR1cmUuJCRDTEFTU19OQU1FXSA9IG5ld0ZlYXR1cmU7XG4gICAgICAgICAgICBpZiAoc2VsZi5mZWF0dXJlQ2hhaW4pIHtcbiAgICAgICAgICAgICAgICBzZWxmLmZlYXR1cmVDaGFpbi5zZXROZXh0KG5ld0ZlYXR1cmUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBAc3VtbWFyeSBDb250cm9sbGVyIGNoYWluIG9mIGNvbW1hbmQuXG4gICAgICAgICAgICAgICAgICogQGRlc2MgRWFjaCBmZWF0dXJlIGlzIGxpbmtlZCB0byB0aGUgbmV4dCBmZWF0dXJlLlxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtGZWF0dXJlfVxuICAgICAgICAgICAgICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBzZWxmLmZlYXR1cmVDaGFpbiA9IG5ld0ZlYXR1cmU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5mZWF0dXJlQ2hhaW4pIHtcbiAgICAgICAgICAgIHRoaXMuZmVhdHVyZUNoYWluLmluaXRpYWxpemVPbihncmlkKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBmZWF0dXJlczogW10sIC8vIG92ZXJyaWRlIGluIGltcGxlbWVudGluZyBjbGFzcyB1bmxlc3Mgbm8gZmVhdHVyZXNcblxuICAgIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlZENvbHVtbkNvdW50ID0gMzA7XG4gICAgICAgIHRoaXMucmVuZGVyZWRSb3dDb3VudCA9IDYwO1xuICAgICAgICB0aGlzLmRhdGFVcGRhdGVzID0ge307IC8vZm9yIG92ZXJyaWRpbmcgd2l0aCBlZGl0IHZhbHVlcztcbiAgICAgICAgdGhpcy5zY3JvbGxQb3NpdGlvblggPSB0aGlzLnNjcm9sbFBvc2l0aW9uWSA9IDA7XG4gICAgICAgIHRoaXMuY2xlYXJDb2x1bW5zKCk7XG4gICAgICAgIHRoaXMuY2xlYXJTdGF0ZSgpO1xuICAgICAgICB0aGlzLmRhdGFNb2RlbC5yZXNldCgpO1xuICAgICAgICB0aGlzLmNyZWF0ZUNvbHVtbnMoKTtcbiAgICB9LFxuXG4gICAgY2xlYXJDb2x1bW5zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtDb2x1bW5bXX1cbiAgICAgICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb2x1bW5zID0gW107XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtDb2x1bW5bXX1cbiAgICAgICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hbGxDb2x1bW5zID0gW107XG5cbiAgICAgICAgdGhpcy5hbGxDb2x1bW5zWy0xXSA9IHRoaXMuY29sdW1uc1stMV0gPSB0aGlzLm5ld0NvbHVtbigtMSk7XG4gICAgICAgIHRoaXMuYWxsQ29sdW1uc1stMl0gPSB0aGlzLmNvbHVtbnNbLTJdID0gdGhpcy5uZXdDb2x1bW4oLTIpO1xuXG4gICAgICAgIHRoaXMuY29sdW1uRW51bSA9IHt9O1xuICAgIH0sXG5cbiAgICBnZXRBY3RpdmVDb2x1bW46IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sdW1uc1t4XTtcbiAgICB9LFxuICAgIGdldFZpc2libGVDb2x1bW46IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZXByZWNhdGVkKCdnZXRWaXNpYmxlQ29sdW1uKHgpJywgJ2dldEFjdGl2ZUNvbHVtbih4KScsICcxLjAuNicsIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBnZXRWaXNpYmxlQ29sdW1uTmFtZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlcHJlY2F0ZWQoJ2dldFZpc2libGVDb2x1bW5OYW1lKHgpJywgJ2dldEFjdGl2ZUNvbHVtbih4KS5uYW1lJywgJzEuMC42JywgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIGdldENvbHVtbklkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVwcmVjYXRlZCgnZ2V0Q29sdW1uSWQoeCknLCAnZ2V0QWN0aXZlQ29sdW1uKHgpLmhlYWRlcicsICcxLjAuNicsIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBnZXRIZWFkZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZXByZWNhdGVkKCdnZXRIZWFkZXIoeCknLCAnZ2V0QWN0aXZlQ29sdW1uKHgpLmhlYWRlcicsICcxLjAuNicsIGFyZ3VtZW50cyk7XG4gICAgfSxcblxuICAgIGdldENvbHVtbjogZnVuY3Rpb24oeCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hbGxDb2x1bW5zW3hdO1xuICAgIH0sXG5cbiAgICBuZXdDb2x1bW46IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGNvbHVtbiA9IG5ldyBDb2x1bW4odGhpcywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuZ2V0UHJpdmF0ZVN0YXRlKCkuY29sdW1uUHJvcGVydGllc1tjb2x1bW4uaW5kZXhdID0gdGhpcy5jcmVhdGVDb2x1bW5Qcm9wZXJ0aWVzKCk7XG4gICAgICAgIHJldHVybiBjb2x1bW47XG4gICAgfSxcblxuICAgIGFkZENvbHVtbjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICB2YXIgY29sdW1uID0gdGhpcy5uZXdDb2x1bW4ob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuY29sdW1ucy5wdXNoKGNvbHVtbik7XG4gICAgICAgIHRoaXMuYWxsQ29sdW1ucy5wdXNoKGNvbHVtbik7XG4gICAgICAgIHJldHVybiBjb2x1bW47XG4gICAgfSxcblxuICAgIGNyZWF0ZUNvbHVtbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvL2NvbmNyZXRlIGltcGxlbWVudGF0aW9uIGhlcmVcbiAgICB9LFxuXG4gICAgY3JlYXRlQ29sdW1uUHJvcGVydGllczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB0YWJsZVN0YXRlID0gdGhpcy5nZXRQcml2YXRlU3RhdGUoKTtcbiAgICAgICAgdmFyIHByb3BlcnRpZXMgPSBPYmplY3QuY3JlYXRlKHRhYmxlU3RhdGUpO1xuXG4gICAgICAgIHByb3BlcnRpZXMucm93TnVtYmVyc1Byb3BlcnRpZXMgPSBPYmplY3QuY3JlYXRlKHByb3BlcnRpZXMsIHtcbiAgICAgICAgICAgIGZvcmVncm91bmRTZWxlY3Rpb25Db2xvcjoge1xuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb2x1bW5IZWFkZXJGb3JlZ3JvdW5kU2VsZWN0aW9uQ29sb3I7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29sdW1uSGVhZGVyRm9yZWdyb3VuZFNlbGVjdGlvbkNvbG9yID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJhY2tncm91bmRTZWxlY3Rpb25Db2xvcjoge1xuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb2x1bW5IZWFkZXJCYWNrZ3JvdW5kU2VsZWN0aW9uQ29sb3I7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29sdW1uSGVhZGVyQmFja2dyb3VuZFNlbGVjdGlvbkNvbG9yID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBwcm9wZXJ0aWVzLnJvd0hlYWRlciA9IE9iamVjdC5jcmVhdGUocHJvcGVydGllcywge1xuICAgICAgICAgICAgZm9udDoge1xuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yb3dIZWFkZXJGb250O1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJvd0hlYWRlckZvbnQgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29sb3I6IHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucm93SGVhZGVyQ29sb3I7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucm93SGVhZGVyQ29sb3IgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiB7XG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJvd0hlYWRlckJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yb3dIZWFkZXJCYWNrZ3JvdW5kQ29sb3IgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZm9yZWdyb3VuZFNlbGVjdGlvbkZvbnQ6IHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucm93SGVhZGVyRm9yZWdyb3VuZFNlbGVjdGlvbkZvbnQ7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucm93SGVhZGVyRm9yZWdyb3VuZFNlbGVjdGlvbkZvbnQgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZm9yZWdyb3VuZFNlbGVjdGlvbkNvbG9yOiB7XG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJvd0hlYWRlckZvcmVncm91bmRTZWxlY3Rpb25Db2xvcjtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yb3dIZWFkZXJGb3JlZ3JvdW5kU2VsZWN0aW9uQ29sb3IgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYmFja2dyb3VuZFNlbGVjdGlvbkNvbG9yOiB7XG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJvd0hlYWRlckJhY2tncm91bmRTZWxlY3Rpb25Db2xvcjtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yb3dIZWFkZXJCYWNrZ3JvdW5kU2VsZWN0aW9uQ29sb3IgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHByb3BlcnRpZXMuY29sdW1uSGVhZGVyID0gT2JqZWN0LmNyZWF0ZShwcm9wZXJ0aWVzLCB7XG4gICAgICAgICAgICBmb250OiB7XG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbHVtbkhlYWRlckZvbnQ7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29sdW1uSGVhZGVyRm9udCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb2xvcjoge1xuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb2x1bW5IZWFkZXJDb2xvcjtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb2x1bW5IZWFkZXJDb2xvciA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29sdW1uSGVhZGVyQmFja2dyb3VuZENvbG9yO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbHVtbkhlYWRlckJhY2tncm91bmRDb2xvciA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmb3JlZ3JvdW5kU2VsZWN0aW9uRm9udDoge1xuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb2x1bW5IZWFkZXJGb3JlZ3JvdW5kU2VsZWN0aW9uRm9udDtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb2x1bW5IZWFkZXJGb3JlZ3JvdW5kU2VsZWN0aW9uRm9udCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmb3JlZ3JvdW5kU2VsZWN0aW9uQ29sb3I6IHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29sdW1uSGVhZGVyRm9yZWdyb3VuZFNlbGVjdGlvbkNvbG9yO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbHVtbkhlYWRlckZvcmVncm91bmRTZWxlY3Rpb25Db2xvciA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBiYWNrZ3JvdW5kU2VsZWN0aW9uQ29sb3I6IHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29sdW1uSGVhZGVyQmFja2dyb3VuZFNlbGVjdGlvbkNvbG9yO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbHVtbkhlYWRlckJhY2tncm91bmRTZWxlY3Rpb25Db2xvciA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcHJvcGVydGllcy5jb2x1bW5IZWFkZXJDb2x1bW5TZWxlY3Rpb24gPSBPYmplY3QuY3JlYXRlKHByb3BlcnRpZXMuY29sdW1uSGVhZGVyLCB7XG4gICAgICAgICAgICBmb3JlZ3JvdW5kU2VsZWN0aW9uQ29sb3I6IHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29sdW1uSGVhZGVyRm9yZWdyb3VuZENvbHVtblNlbGVjdGlvbkNvbG9yO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbHVtbkhlYWRlckZvcmVncm91bmRDb2x1bW5TZWxlY3Rpb25Db2xvciA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBiYWNrZ3JvdW5kU2VsZWN0aW9uQ29sb3I6IHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29sdW1uSGVhZGVyQmFja2dyb3VuZENvbHVtblNlbGVjdGlvbkNvbG9yO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbHVtbkhlYWRlckJhY2tncm91bmRDb2x1bW5TZWxlY3Rpb25Db2xvciA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcHJvcGVydGllcy5yb3dIZWFkZXJSb3dTZWxlY3Rpb24gPSBPYmplY3QuY3JlYXRlKHByb3BlcnRpZXMucm93SGVhZGVyLCB7XG4gICAgICAgICAgICBmb3JlZ3JvdW5kU2VsZWN0aW9uQ29sb3I6IHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucm93SGVhZGVyRm9yZWdyb3VuZFJvd1NlbGVjdGlvbkNvbG9yO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJvd0hlYWRlckZvcmVncm91bmRSb3dTZWxlY3Rpb25Db2xvciA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBiYWNrZ3JvdW5kU2VsZWN0aW9uQ29sb3I6IHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucm93SGVhZGVyQmFja2dyb3VuZFJvd1NlbGVjdGlvbkNvbG9yO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJvd0hlYWRlckJhY2tncm91bmRSb3dTZWxlY3Rpb25Db2xvciA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcHJvcGVydGllcy5maWx0ZXJQcm9wZXJ0aWVzID0gT2JqZWN0LmNyZWF0ZShwcm9wZXJ0aWVzLCB7XG4gICAgICAgICAgICBmb250OiB7XG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbHRlckZvbnQ7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlsdGVyRm9udCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb2xvcjoge1xuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXJDb2xvcjtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maWx0ZXJDb2xvciA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyQmFja2dyb3VuZENvbG9yO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbHRlckJhY2tncm91bmRDb2xvciA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmb3JlZ3JvdW5kU2VsZWN0aW9uQ29sb3I6IHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyRm9yZWdyb3VuZFNlbGVjdGlvbkNvbG9yO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbHRlckZvcmVncm91bmRTZWxlY3Rpb25Db2xvciA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBiYWNrZ3JvdW5kU2VsZWN0aW9uQ29sb3I6IHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyQmFja2dyb3VuZFNlbGVjdGlvbkNvbG9yO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbHRlckJhY2tncm91bmRTZWxlY3Rpb25Db2xvciA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjZWxsQm9yZGVyU3R5bGU6IHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyQ2VsbEJvcmRlclN0eWxlO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbHRlckNlbGxCb3JkZXJTdHlsZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjZWxsQm9yZGVyVGhpY2tuZXNzOiB7XG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbHRlckNlbGxCb3JkZXJUaGlja25lc3M7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlsdGVyQ2VsbEJvcmRlclRoaWNrbmVzcyA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcHJvcGVydGllcy50cmVlQ29sdW1uUHJvcGVydGllcyA9IE9iamVjdC5jcmVhdGUocHJvcGVydGllcywge1xuICAgICAgICAgICAgZm9udDoge1xuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50cmVlQ29sdW1uRm9udDtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmVlQ29sdW1uRm9udCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb2xvcjoge1xuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50cmVlQ29sdW1uQ29sb3I7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJlZUNvbHVtbkNvbG9yID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjoge1xuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50cmVlQ29sdW1uQmFja2dyb3VuZENvbG9yO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyZWVDb2x1bW5CYWNrZ3JvdW5kQ29sb3IgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZm9yZWdyb3VuZFNlbGVjdGlvbkNvbG9yOiB7XG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRyZWVDb2x1bW5Gb3JlZ3JvdW5kU2VsZWN0aW9uQ29sb3I7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJlZUNvbHVtbkZvcmVncm91bmRTZWxlY3Rpb25Db2xvciA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBiYWNrZ3JvdW5kU2VsZWN0aW9uQ29sb3I6IHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJlZUNvbHVtbkJhY2tncm91bmRTZWxlY3Rpb25Db2xvcjtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmVlQ29sdW1uQmFja2dyb3VuZFNlbGVjdGlvbkNvbG9yID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBwcm9wZXJ0aWVzLnRyZWVDb2x1bW5Qcm9wZXJ0aWVzQ29sdW1uU2VsZWN0aW9uID0gT2JqZWN0LmNyZWF0ZShwcm9wZXJ0aWVzLnRyZWVDb2x1bW5Qcm9wZXJ0aWVzLCB7XG4gICAgICAgICAgICBmb3JlZ3JvdW5kU2VsZWN0aW9uQ29sb3I6IHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJlZUNvbHVtbkZvcmVncm91bmRDb2x1bW5TZWxlY3Rpb25Db2xvcjtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmVlQ29sdW1uRm9yZWdyb3VuZENvbHVtblNlbGVjdGlvbkNvbG9yID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJhY2tncm91bmRTZWxlY3Rpb25Db2xvcjoge1xuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50cmVlQ29sdW1uQmFja2dyb3VuZENvbHVtblNlbGVjdGlvbkNvbG9yO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyZWVDb2x1bW5CYWNrZ3JvdW5kQ29sdW1uU2VsZWN0aW9uQ29sb3IgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBwcm9wZXJ0aWVzO1xuICAgIH0sXG5cbiAgICBnZXRDb2x1bW5XaWR0aDogZnVuY3Rpb24oeCkge1xuICAgICAgICB2YXIgY29sdW1uID0gdGhpcy5nZXRBY3RpdmVDb2x1bW4oeCk7XG4gICAgICAgIGlmICghY29sdW1uKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXNvbHZlUHJvcGVydHkoJ2RlZmF1bHRDb2x1bW5XaWR0aCcpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB3aWR0aCA9IGNvbHVtbi5nZXRXaWR0aCgpO1xuICAgICAgICByZXR1cm4gd2lkdGg7XG4gICAgfSxcblxuICAgIHNldENvbHVtbldpZHRoOiBmdW5jdGlvbih4LCB3aWR0aCkge1xuICAgICAgICB0aGlzLmdldEFjdGl2ZUNvbHVtbih4KS5zZXRXaWR0aCh3aWR0aCk7XG4gICAgICAgIHRoaXMuc3RhdGVDaGFuZ2VkKCk7XG4gICAgfSxcblxuICAgIGdldENlbGxSZW5kZXJlcjogZnVuY3Rpb24oY29uZmlnLCB4LCB5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEFjdGl2ZUNvbHVtbih4KS5nZXRDZWxsUmVuZGVyZXIoY29uZmlnLCB4LCB5KTtcbiAgICB9LFxuICAgIGdldENlbGxQcm92aWRlcjogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZXByZWNhdGVkKCdnZXRDZWxsUHJvdmlkZXIoKScsICdncmlkLmNlbGxSZW5kZXJlcnMnLCAnMS4wLjYnLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgY3JlYXRlQ2VsbFByb3ZpZGVyOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ2dldENlbGxQcm92aWRlcigpIGlzIGRlcHJlY2F0ZWQgYXMgb2YgdjEuMC42LiBObyByZXBsYWNlbWVudDsgZG8gbm90IGNhbGwuIFByZXZpb3VzbHkgY2FsbGVkIGJ5IGBCZWhhdmlvcmAgY29uc3RydWN0b3I7IGBuZXcgQ2VsbFJlbmRlcmVycygpYCBpcyBub3cgY2FsbGVkIGJ5IGBIeXBlcmdyaWRgIGNvbnN0cnVjdG9yIGluc3RlYWQuJywgYXJndW1lbnRzKTtcbiAgICB9LFxuXG4gICAgYXBwbHlBbmFseXRpY3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmRhdGFNb2RlbC5hcHBseUFuYWx5dGljcygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgdXRpbGl0eSBmdW5jdGlvbiB0byBlbXB0eSBhbiBvYmplY3Qgb2YgaXRzIG1lbWJlcnNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb2JqIC0gdGhlIG9iamVjdCB0byBlbXB0eVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2V4cG9ydFByb3BzXVxuICAgICAqICogYHVuZGVmaW5lZGAgKG9taXR0ZWQpIC0gZGVsZXRlICphbGwqIHByb3BlcnRpZXNcbiAgICAgKiAqICoqZmFsc3kqKiAtIGRlbGV0ZSAqb25seSogdGhlIGV4cG9ydCBwcm9wZXJ0aWVzXG4gICAgICogKiAqKnRydXRoeSoqIC0gZGVsZXRlIGFsbCBwcm9wZXJ0aWVzICpleGNlcHQqIHRoZSBleHBvcnQgcHJvcGVydGllc1xuICAgICAqL1xuICAgIGNsZWFyT2JqZWN0UHJvcGVydGllczogZnVuY3Rpb24ob2JqLCBleHBvcnRQcm9wcykge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgb2JqLmhhc093blByb3BlcnR5KGtleSkgJiYgKFxuICAgICAgICAgICAgICAgICAgICBleHBvcnRQcm9wcyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgICAgICAgICFleHBvcnRQcm9wcyAmJiBub0V4cG9ydFByb3BlcnRpZXMuaW5kZXhPZihrZXkpID49IDAgfHxcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0UHJvcHMgJiYgbm9FeHBvcnRQcm9wZXJ0aWVzLmluZGV4T2Yoa2V5KSA8IDBcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgb2JqW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGdldHRlciBmb3IgYSBbTWVtZW50b10oaHR0cDovL2MyLmNvbS9jZ2kvd2lraT9NZW1lbnRvUGF0dGVybikgT2JqZWN0XG4gICAgICogQHJldHVybnMge29iamVjdH1cbiAgICAgKi9cbiAgICBnZXRQcml2YXRlU3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMudGFibGVTdGF0ZSkge1xuICAgICAgICAgICAgdGhpcy50YWJsZVN0YXRlID0gdGhpcy5nZXREZWZhdWx0U3RhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy50YWJsZVN0YXRlO1xuICAgIH0sXG5cbiAgICAvL3RoaXMgaXMgZWZmZWN0aXZlbHkgYSBjbG9uZSwgd2l0aCBjZXJ0YWluIHRoaW5ncyByZW1vdmVkLi4uLlxuICAgIGdldFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNvcHkgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHRoaXMuZ2V0UHJpdmF0ZVN0YXRlKCkpKTtcbiAgICAgICAgdGhpcy5jbGVhck9iamVjdFByb3BlcnRpZXMoY29weS5jb2x1bW5Qcm9wZXJ0aWVzLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiBjb3B5O1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGNsZWFyIGFsbCB0YWJsZSBzdGF0ZVxuICAgICAqL1xuICAgIGNsZWFyU3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogbWVtZW50byBmb3IgdGhlIHVzZXIgY29uZmlndXJlZCB2aXN1YWwgcHJvcGVydGllcyBvZiB0aGUgdGFibGVcbiAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50YWJsZVN0YXRlID0gbnVsbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm4ge29iamVjdH0gTmV3bHkgY3JlYXRlZCBkZWZhdWx0IGVtcHR5IHRhYmxlc3RhdGUuXG4gICAgICovXG4gICAgZ2V0RGVmYXVsdFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHRhYmxlUHJvcGVydGllcyA9IHRoaXMuZ3JpZC5fZ2V0UHJvcGVydGllcygpO1xuICAgICAgICB2YXIgc3RhdGUgPSBPYmplY3QuY3JlYXRlKHRhYmxlUHJvcGVydGllcyk7XG5cbiAgICAgICAgXyhzdGF0ZSkuZXh0ZW5kT3duKHtcbiAgICAgICAgICAgIHJvd0hlaWdodHM6IHt9LFxuICAgICAgICAgICAgY29sdW1uUHJvcGVydGllczogW11cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgUmVzdG9yZSB0aGlzIHRhYmxlIHRvIGEgcHJldmlvdXMgc3RhdGUuXG4gICAgICogU2VlIHRoZSBbbWVtZW50byBwYXR0ZXJuXShodHRwOi8vYzIuY29tL2NnaS93aWtpP01lbWVudG9QYXR0ZXJuKS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbWVtZW50byAtIGFuIGVuY2Fwc3VsYXRlZCByZXByZXNlbnRhdGlvbiBvZiB0YWJsZSBzdGF0ZVxuICAgICAqL1xuICAgIHNldFN0YXRlOiBmdW5jdGlvbihtZW1lbnRvKSB7XG5cbiAgICAgICAgLy93ZSBkb24ndCB3YW50IHRvIGNsb2JiZXIgdGhlIGNvbHVtbiBwcm9wZXJ0aWVzIGNvbXBsZXRlbHlcbiAgICAgICAgaWYgKCFtZW1lbnRvLmNvbHVtbkluZGV4ZXMpIHtcbiAgICAgICAgICAgIHZhciBmaWVsZHMgPSB0aGlzLmRhdGFNb2RlbC5nZXRGaWVsZHMoKTtcbiAgICAgICAgICAgIG1lbWVudG8uY29sdW1uSW5kZXhlcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWVsZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBtZW1lbnRvLmNvbHVtbkluZGV4ZXNbaV0gPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBjb2xQcm9wZXJ0aWVzID0gbWVtZW50by5jb2x1bW5Qcm9wZXJ0aWVzO1xuICAgICAgICBkZWxldGUgbWVtZW50by5jb2x1bW5Qcm9wZXJ0aWVzO1xuICAgICAgICB0aGlzLnRhYmxlU3RhdGUgPSBudWxsO1xuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLmdldFByaXZhdGVTdGF0ZSgpO1xuICAgICAgICB0aGlzLmNyZWF0ZUNvbHVtbnMoKTtcbiAgICAgICAgdGhpcy5fc2V0Q29sdW1uT3JkZXIobWVtZW50by5jb2x1bW5JbmRleGVzKTtcbiAgICAgICAgXyhzdGF0ZSkuZXh0ZW5kT3duKG1lbWVudG8pO1xuICAgICAgICB0aGlzLnNldEFsbENvbHVtblByb3BlcnRpZXMoY29sUHJvcGVydGllcyk7XG4gICAgICAgIG1lbWVudG8uY29sdW1uUHJvcGVydGllcyA9IGNvbFByb3BlcnRpZXM7XG5cbiAgICAgICAgLy9qdXN0IHRvIGJlIGNsb3NlLyBpdCdzIGVhc2llciBvbiB0aGUgZXllc1xuICAgICAgICB0aGlzLnNldENvbHVtbldpZHRoKC0xLCAyNC4xOTMzNTkzNzUpO1xuICAgICAgICB0aGlzLmRhdGFNb2RlbC5hcHBseVN0YXRlKCk7XG4gICAgfSxcblxuICAgIHNldEFsbENvbHVtblByb3BlcnRpZXM6IGZ1bmN0aW9uKHByb3BlcnRpZXMpIHtcbiAgICAgICAgcHJvcGVydGllcyA9IHByb3BlcnRpZXMgfHwgW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLmdldFByaXZhdGVTdGF0ZSgpLmNvbHVtblByb3BlcnRpZXNbaV07XG4gICAgICAgICAgICB0aGlzLmNsZWFyT2JqZWN0UHJvcGVydGllcyhjdXJyZW50LCBmYWxzZSk7XG4gICAgICAgICAgICBfKGN1cnJlbnQpLmV4dGVuZE93bihwcm9wZXJ0aWVzW2ldKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfc2V0Q29sdW1uT3JkZXI6IGZ1bmN0aW9uKGluZGV4ZXMpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGluZGV4ZXMpKXtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWluZGV4ZXMpIHtcbiAgICAgICAgICAgIHRoaXMuY29sdW1ucy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29sdW1ucy5sZW5ndGggPSBpbmRleGVzLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmRleGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmNvbHVtbnNbaV0gPSB0aGlzLmFsbENvbHVtbnNbaW5kZXhlc1tpXV07XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGZldGNoIHRoZSB2YWx1ZSBmb3IgYSBwcm9wZXJ0eSBrZXlcbiAgICAgKiBAcmV0dXJucyB7Kn0gVGhlIHZhbHVlIG9mIHRoZSBnaXZlbiBwcm9wZXJ0eS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gYSBwcm9wZXJ0eSBuYW1lXG4gICAgICovXG4gICAgcmVzb2x2ZVByb3BlcnR5OiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JpZC5yZXNvbHZlUHJvcGVydHkoa2V5KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIEEgc3BlY2lmaWMgY2VsbCB3YXMgY2xpY2tlZDsgeW91J3ZlIGJlZW4gbm90aWZpZWQuXG4gICAgICogQHBhcmFtIHtQb2ludH0gY2VsbCAtIHBvaW50IG9mIGNlbGwgY29vcmRpbmF0ZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSBhbGwgZXZlbnQgaW5mb3JtYXRpb25cbiAgICAgKi9cbiAgICBjZWxsQ2xpY2tlZDogZnVuY3Rpb24oY2VsbCwgZXZlbnQpIHtcbiAgICAgICAgdGhpcy5kYXRhTW9kZWwuY2VsbENsaWNrZWQoY2VsbCwgZXZlbnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgQSBzcGVjaWZpYyBjZWxsIHdhcyBsZSBkb3VibGUtY2xpY2tlZDsgeW91J3ZlIGJlZW4gbm90aWZpZWQuXG4gICAgICogQHBhcmFtIHtQb2ludH0gY2VsbCAtIHBvaW50IG9mIGNlbGwgY29vcmRpbmF0ZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSBhbGwgZXZlbnQgaW5mb3JtYXRpb25cbiAgICAgKi9cbiAgICBjZWxsRG91YmxlQ2xpY2tlZDogZnVuY3Rpb24oY2VsbCwgZXZlbnQpIHtcblxuICAgIH0sXG5cbiAgICBsb29rdXBGZWF0dXJlOiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmVhdHVyZU1hcFtrZXldO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2Mgc2V0dGVyIGZvciB0aGUgaHlwZXJncmlkXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKi9cbiAgICBzZXRHcmlkOiBmdW5jdGlvbihncmlkKSB7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBGaXJzdCBjaGVjayB0byBzZWUgaWYgc29tZXRoaW5nIHdhcyBvdmVycmlkZGVuLlxuICAgICAqIEByZXR1cm4geyp9IFRoZSB2YWx1ZSBhdCBgeCx5YCBmb3IgdGhlIHRvcCBsZWZ0IHNlY3Rpb24gb2YgdGhlIGh5cGVyZ3JpZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCAtIHggY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0geSBjb29yZGluYXRlXG4gICAgICovXG4gICAgZ2V0VmFsdWU6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgdmFyIGNvbHVtbiA9IHRoaXMuZ2V0QWN0aXZlQ29sdW1uKHgpO1xuICAgICAgICByZXR1cm4gY29sdW1uICYmIGNvbHVtbi5nZXRWYWx1ZSh5KTtcbiAgICB9LFxuXG4gICAgZ2V0VW5maWx0ZXJlZFZhbHVlOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHZhciBjb2x1bW4gPSB0aGlzLmdldEFjdGl2ZUNvbHVtbih4KTtcbiAgICAgICAgcmV0dXJuIGNvbHVtbiAmJiBjb2x1bW4uZ2V0VW5maWx0ZXJlZFZhbHVlKHkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgdXBkYXRlIHRoZSBkYXRhIGF0IHBvaW50IHgsIHkgd2l0aCB2YWx1ZVxuICAgICAqIEByZXR1cm4gVGhlIGRhdGEuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSB4IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAtIHkgY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZSAtIHRoZSB2YWx1ZSB0byB1c2VcbiAgICAgKi9cbiAgICBzZXRWYWx1ZTogZnVuY3Rpb24oeCwgeSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGNvbHVtbiA9IHRoaXMuZ2V0QWN0aXZlQ29sdW1uKHgpO1xuICAgICAgICByZXR1cm4gY29sdW1uICYmIGNvbHVtbi5zZXRWYWx1ZSh5LCB2YWx1ZSk7XG4gICAgfSxcblxuICAgIGdldERhdGFWYWx1ZTogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhTW9kZWwuZ2V0VmFsdWUoeCwgeSk7XG4gICAgfSxcblxuICAgIHNldERhdGFWYWx1ZTogZnVuY3Rpb24oeCwgeSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5kYXRhTW9kZWwuc2V0VmFsdWUoeCwgeSwgdmFsdWUpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIEZpcnN0IGNoZWNrcyB0byBzZWUgaWYgc29tZXRoaW5nIHdhcyBvdmVycmlkZGVuLlxuICAgICAqIEByZXR1cm4geyp9IFRoZSB2YWx1ZSBhdCB4LHkgZm9yIHRoZSB0b3AgbGVmdCBzZWN0aW9uIG9mIHRoZSBoeXBlcmdyaWQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSB4IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAtIHkgY29vcmRpbmF0ZVxuICAgICAqL1xuICAgIGdldENlbGxQcm9wZXJ0aWVzOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHZhciBjb2x1bW4gPSB0aGlzLmFsbENvbHVtbnNbeF07XG4gICAgICAgIHJldHVybiBjb2x1bW4gJiYgY29sdW1uLmdldENlbGxQcm9wZXJ0aWVzKHkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgdXBkYXRlIHRoZSBkYXRhIGF0IHBvaW50IHgsIHkgd2l0aCB2YWx1ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0geCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSB5IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWUgLSB0aGUgdmFsdWUgdG8gdXNlXG4gICAgICovXG4gICAgc2V0Q2VsbFByb3BlcnRpZXM6IGZ1bmN0aW9uKHgsIHksIHZhbHVlKSB7XG4gICAgICAgIHZhciBjb2x1bW4gPSB0aGlzLmFsbENvbHVtbnNbeF07XG4gICAgICAgIGlmIChjb2x1bW4pIHtcbiAgICAgICAgICAgIGNvbHVtbi5zZXRDZWxsUHJvcGVydGllcyh5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBudW1iZXIgb2Ygcm93cyBpbiB0aGUgaHlwZXJncmlkLlxuICAgICAqL1xuICAgIGdldFJvd0NvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YU1vZGVsLmdldFJvd0NvdW50KCk7XG4gICAgfSxcblxuICAgIGdldFVuZmlsdGVyZWRSb3dDb3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFNb2RlbC5nZXRVbmZpbHRlcmVkUm93Q291bnQoKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBoZWlnaHQgaW4gcGl4ZWxzIG9mIHRoZSBmaXhlZCByb3dzIGFyZWEgIG9mIHRoZSBoeXBlcmdyaWQuXG4gICAgICovXG4gICAgZ2V0Rml4ZWRSb3dzSGVpZ2h0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNvdW50ID0gdGhpcy5nZXRGaXhlZFJvd0NvdW50KCk7XG4gICAgICAgIHZhciB0b3RhbCA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgdG90YWwgPSB0b3RhbCArIHRoaXMuZ2V0Um93SGVpZ2h0KGkpO1xuICAgICAgICB9XG4gICAgICAgIC8vdmFyIGZvb3RlckhlaWdodCA9IHRoaXMuZ2V0RGVmYXVsdFJvd0hlaWdodCgpO1xuICAgICAgICAvL3RvdGFsID0gdG90YWwgKyAoZm9vdGVySGVpZ2h0ICogdGhpcy5nZXRGb290ZXJSb3dDb3VudCgpKTtcbiAgICAgICAgcmV0dXJuIHRvdGFsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgaGVpZ2h0IGluIHBpeGVscyBvZiBhIHNwZWNpZmljIHJvdyBpbiB0aGUgaHlwZXJncmlkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByb3dOdW0gLSByb3cgaW5kZXggb2YgaW50ZXJlc3RcbiAgICAgKi9cbiAgICBnZXRSb3dIZWlnaHQ6IGZ1bmN0aW9uKHJvd051bSkge1xuICAgICAgICB2YXIgcm93SGVpZ2h0cyA9IHRoaXMuZ2V0UHJpdmF0ZVN0YXRlKCkucm93SGVpZ2h0cztcbiAgICAgICAgcmV0dXJuIHJvd0hlaWdodHMgJiYgcm93SGVpZ2h0c1tyb3dOdW1dIHx8IHRoaXMuZ2V0RGVmYXVsdFJvd0hlaWdodCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgVGhlIHZhbHVlIGlzIGxhemlseSBpbml0aWFsaXplZCBhbmQgY29tZXMgZnJvbSB0aGUgcHJvcGVydGllcyBtZWNoYW5pc20gZm9yICdgZGVmYXVsdFJvd0hlaWdodGAnLCB3aGljaCBzaG91bGQgYmUgfjIwcHguXG4gICAgICogQHJldHVybnMge251bWJlcn0gVGhlIHJvdyBoZWlnaHQgaW4gcGl4ZWxzLlxuICAgICAqL1xuICAgIGdldERlZmF1bHRSb3dIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuZGVmYXVsdFJvd0hlaWdodCkge1xuICAgICAgICAgICAgdGhpcy5kZWZhdWx0Um93SGVpZ2h0ID0gdGhpcy5yZXNvbHZlUHJvcGVydHkoJ2RlZmF1bHRSb3dIZWlnaHQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5kZWZhdWx0Um93SGVpZ2h0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2Mgc2V0IHRoZSBwaXhlbCBoZWlnaHQgb2YgYSBzcGVjaWZpYyByb3dcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcm93TnVtIC0gdGhlIHJvdyBpbmRleCBvZiBpbnRlcmVzdFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgLSBwaXhlbCBoZWlnaHRcbiAgICAgKi9cbiAgICBzZXRSb3dIZWlnaHQ6IGZ1bmN0aW9uKHJvd051bSwgaGVpZ2h0KSB7XG4gICAgICAgIHZhciB0YWJsZVN0YXRlID0gdGhpcy5nZXRQcml2YXRlU3RhdGUoKTtcbiAgICAgICAgdGFibGVTdGF0ZS5yb3dIZWlnaHRzW3Jvd051bV0gPSBNYXRoLm1heCg1LCBoZWlnaHQpO1xuICAgICAgICB0aGlzLnN0YXRlQ2hhbmdlZCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgVGhpcyB3aWxsIGFsbG93ICdmbG9hdGluZycgZml4ZWQgcm93cy5cbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBtYXhpbXVtIGhlaWdodCBvZiB0aGUgZml4ZWQgcm93cyBhcmVhIGluIHRoZSBoeXBlcmdyaWQuXG4gICAgICovXG4gICAgZ2V0Rml4ZWRSb3dzTWF4SGVpZ2h0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Rml4ZWRSb3dzSGVpZ2h0KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSB3aWR0aCBvZiB0aGUgZml4ZWQgY29sdW1uIGFyZWEgaW4gdGhlIGh5cGVyZ3JpZC5cbiAgICAgKi9cbiAgICBnZXRGaXhlZENvbHVtbnNXaWR0aDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjb3VudCA9IHRoaXMuZ2V0Rml4ZWRDb2x1bW5Db3VudCgpO1xuICAgICAgICB2YXIgdG90YWwgPSAwO1xuICAgICAgICBpZiAodGhpcy5ncmlkLmlzU2hvd1Jvd051bWJlcnMoKSkge1xuICAgICAgICAgICAgdG90YWwgPSB0aGlzLmdldENvbHVtbldpZHRoKC0xKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIHRvdGFsID0gdG90YWwgKyB0aGlzLmdldENvbHVtbldpZHRoKGkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b3RhbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFRoaXMgZXhpc3RzIHRvIHN1cHBvcnQgXCJmbG9hdGluZ1wiIGNvbHVtbnMuXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgdG90YWwgd2lkdGggb2YgdGhlIGZpeGVkIGNvbHVtbnMgYXJlYS5cbiAgICAgKi9cbiAgICBnZXRGaXhlZENvbHVtbnNNYXhXaWR0aDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEZpeGVkQ29sdW1uc1dpZHRoKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBTZXQgdGhlIHNjcm9sbCBwb3NpdGlvbiBpbiB2ZXJ0aWNhbCBkaW1lbnNpb24gYW5kIG5vdGlmeSBsaXN0ZW5lcnMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSB0aGUgbmV3IHkgdmFsdWVcbiAgICAgKi9cbiAgICBfc2V0U2Nyb2xsUG9zaXRpb25ZOiBmdW5jdGlvbih5KSB7XG4gICAgICAgIHRoaXMuc2V0U2Nyb2xsUG9zaXRpb25ZKHkpO1xuICAgICAgICB0aGlzLmNoYW5nZWQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFNldCB0aGUgc2Nyb2xsIHBvc2l0aW9uIGluIGhvcml6b250YWwgZGltZW5zaW9uIGFuZCBub3RpZnkgbGlzdGVuZXJzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gdGhlIG5ldyB4IHZhbHVlXG4gICAgICovXG4gICAgX3NldFNjcm9sbFBvc2l0aW9uWDogZnVuY3Rpb24oeCkge1xuICAgICAgICB0aGlzLnNldFNjcm9sbFBvc2l0aW9uWCh4KTtcbiAgICAgICAgdGhpcy5jaGFuZ2VkKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBTZXQgdGhlIG51bWJlciBvZiBjb2x1bW5zIGp1c3QgcmVuZGVyZWQsIGluY2x1ZGluZyBwYXJ0aWFsbHkgcmVuZGVyZWQgY29sdW1ucy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY291bnQgLSBob3cgbWFueSBjb2x1bW5zIHdlcmUganVzdCByZW5kZXJlZFxuICAgICAqL1xuICAgIHNldFJlbmRlcmVkQ29sdW1uQ291bnQ6IGZ1bmN0aW9uKGNvdW50KSB7XG4gICAgICAgIHRoaXMucmVuZGVyZWRDb2x1bW5Db3VudCA9IGNvdW50O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgU2V0IHRoZSBudW1iZXIgb2Ygcm93cyBqdXN0IHJlbmRlcmVkLCBpbmNsdWRpbmcgcGFydGlhbGx5IHJlbmRlcmVkIHJvd3MuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvdW50IC0gaG93IG1hbnkgcm93cyB3ZXJlIGp1c3QgcmVuZGVyZWRcbiAgICAgKi9cbiAgICBzZXRSZW5kZXJlZFJvd0NvdW50OiBmdW5jdGlvbihjb3VudCkge1xuICAgICAgICB0aGlzLnJlbmRlcmVkUm93Q291bnQgPSBjb3VudDtcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgVGhlIGZpeGVkIHJvdyBhcmVhIGhhcyBiZWVuIGNsaWNrZWQsIG1hc3NhZ2UgdGhlIGRldGFpbHMgYW5kIGNhbGwgdGhlIHJlYWwgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbW91c2UgLSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgX2ZpeGVkUm93Q2xpY2tlZDogZnVuY3Rpb24oZ3JpZCwgbW91c2UpIHtcbiAgICAgICAgdmFyIHggPSB0aGlzLnRyYW5zbGF0ZUNvbHVtbkluZGV4KHRoaXMuZ2V0U2Nyb2xsUG9zaXRpb25YKCkgKyBtb3VzZS5ncmlkQ2VsbC54IC0gdGhpcy5nZXRGaXhlZENvbHVtbkNvdW50KCkpO1xuICAgICAgICB2YXIgdHJhbnNsYXRlZFBvaW50ID0gdGhpcy5ncmlkLm5ld1BvaW50KHgsIG1vdXNlLmdyaWRDZWxsLnkpO1xuICAgICAgICBtb3VzZS5ncmlkQ2VsbCA9IHRyYW5zbGF0ZWRQb2ludDtcbiAgICAgICAgdGhpcy5maXhlZFJvd0NsaWNrZWQoZ3JpZCwgbW91c2UpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgVGhlIGZpeGVkIGNvbHVtbiBhcmVhIGhhcyBiZWVuIGNsaWNrZWQsIG1hc3NhZ2UgdGhlIGRldGFpbHMgYW5kIGNhbGwgdGhlIHJlYWwgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbW91c2UgLSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgX2ZpeGVkQ29sdW1uQ2xpY2tlZDogZnVuY3Rpb24oZ3JpZCwgbW91c2UpIHtcbiAgICAgICAgdmFyIHRyYW5zbGF0ZWRQb2ludCA9IHRoaXMuZ3JpZC5uZXdQb2ludChtb3VzZS5ncmlkQ2VsbC54LCB0aGlzLmdldFNjcm9sbFBvc2l0aW9uWSgpICsgbW91c2UuZ3JpZENlbGwueSAtIHRoaXMuZ2V0Rml4ZWRSb3dDb3VudCgpKTtcbiAgICAgICAgbW91c2UuZ3JpZENlbGwgPSB0cmFuc2xhdGVkUG9pbnQ7XG4gICAgICAgIHRoaXMuZml4ZWRDb2x1bW5DbGlja2VkKGdyaWQsIG1vdXNlKTtcbiAgICB9LFxuXG4gICAgbW92ZVNpbmdsZVNlbGVjdDogZnVuY3Rpb24oZ3JpZCwgeCwgeSkge1xuICAgICAgICBpZiAodGhpcy5mZWF0dXJlQ2hhaW4pIHtcbiAgICAgICAgICAgIHRoaXMuZmVhdHVyZUNoYWluLm1vdmVTaW5nbGVTZWxlY3QoZ3JpZCwgeCwgeSk7XG4gICAgICAgICAgICB0aGlzLnNldEN1cnNvcihncmlkKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgZGVsZWdhdGUgc2V0dGluZyB0aGUgY3Vyc29yIHVwIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKi9cbiAgICBzZXRDdXJzb3I6IGZ1bmN0aW9uKGdyaWQpIHtcbiAgICAgICAgZ3JpZC51cGRhdGVDdXJzb3IoKTtcbiAgICAgICAgdGhpcy5mZWF0dXJlQ2hhaW4uc2V0Q3Vyc29yKGdyaWQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgZGVsZWdhdGUgaGFuZGxpbmcgbW91c2UgbW92ZSB0byB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBvbk1vdXNlTW92ZTogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuZmVhdHVyZUNoYWluKSB7XG4gICAgICAgICAgICB0aGlzLmZlYXR1cmVDaGFpbi5oYW5kbGVNb3VzZU1vdmUoZ3JpZCwgZXZlbnQpO1xuICAgICAgICAgICAgdGhpcy5zZXRDdXJzb3IoZ3JpZCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGRlbGVnYXRlIGhhbmRsaW5nIHRhcCB0byB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBvbkNsaWNrOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAodGhpcy5mZWF0dXJlQ2hhaW4pIHtcbiAgICAgICAgICAgIHRoaXMuZmVhdHVyZUNoYWluLmhhbmRsZUNsaWNrKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgICAgIHRoaXMuc2V0Q3Vyc29yKGdyaWQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBkZWxlZ2F0ZSBoYW5kbGluZyB0YXAgdG8gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgb25Db250ZXh0TWVudTogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgdmFyIHByb2NlZWQgPSBncmlkLmZpcmVTeW50aGV0aWNDb250ZXh0TWVudUV2ZW50KGV2ZW50KTtcbiAgICAgICAgaWYgKHByb2NlZWQgJiYgdGhpcy5mZWF0dXJlQ2hhaW4pIHtcbiAgICAgICAgICAgIHRoaXMuZmVhdHVyZUNoYWluLmhhbmRsZUNvbnRleHRNZW51KGdyaWQsIGV2ZW50KTtcbiAgICAgICAgICAgIHRoaXMuc2V0Q3Vyc29yKGdyaWQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBkZWxlZ2F0ZSBoYW5kbGluZyB3aGVlbCBtb3ZlZCB0byB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBvbldoZWVsTW92ZWQ6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmZlYXR1cmVDaGFpbikge1xuICAgICAgICAgICAgdGhpcy5mZWF0dXJlQ2hhaW4uaGFuZGxlV2hlZWxNb3ZlZChncmlkLCBldmVudCk7XG4gICAgICAgICAgICB0aGlzLnNldEN1cnNvcihncmlkKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgZGVsZWdhdGUgaGFuZGxpbmcgbW91c2UgdXAgdG8gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgb25Nb3VzZVVwOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAodGhpcy5mZWF0dXJlQ2hhaW4pIHtcbiAgICAgICAgICAgIHRoaXMuZmVhdHVyZUNoYWluLmhhbmRsZU1vdXNlVXAoZ3JpZCwgZXZlbnQpO1xuICAgICAgICAgICAgdGhpcy5zZXRDdXJzb3IoZ3JpZCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGRlbGVnYXRlIGhhbmRsaW5nIG1vdXNlIGRyYWcgdG8gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgb25Nb3VzZURyYWc6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmZlYXR1cmVDaGFpbikge1xuICAgICAgICAgICAgdGhpcy5mZWF0dXJlQ2hhaW4uaGFuZGxlTW91c2VEcmFnKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgICAgIHRoaXMuc2V0Q3Vyc29yKGdyaWQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBkZWxlZ2F0ZSBoYW5kbGluZyBrZXkgZG93biB0byB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBvbktleURvd246IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmZlYXR1cmVDaGFpbikge1xuICAgICAgICAgICAgdGhpcy5mZWF0dXJlQ2hhaW4uaGFuZGxlS2V5RG93bihncmlkLCBldmVudCk7XG4gICAgICAgICAgICB0aGlzLnNldEN1cnNvcihncmlkKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgZGVsZWdhdGUgaGFuZGxpbmcga2V5IHVwIHRvIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIG9uS2V5VXA6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmZlYXR1cmVDaGFpbikge1xuICAgICAgICAgICAgdGhpcy5mZWF0dXJlQ2hhaW4uaGFuZGxlS2V5VXAoZ3JpZCwgZXZlbnQpO1xuICAgICAgICAgICAgdGhpcy5zZXRDdXJzb3IoZ3JpZCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGRlbGVnYXRlIGhhbmRsaW5nIGRvdWJsZSBjbGljayB0byB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBvbkRvdWJsZUNsaWNrOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAodGhpcy5mZWF0dXJlQ2hhaW4pIHtcbiAgICAgICAgICAgIHRoaXMuZmVhdHVyZUNoYWluLmhhbmRsZURvdWJsZUNsaWNrKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgICAgIHRoaXMuc2V0Q3Vyc29yKGdyaWQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBkZWxlZ2F0ZSBoYW5kbGluZyBkb3VibGUgY2xpY2sgdG8gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IFtvcHRpb25zXSAtIEZvcndhcmRlZCB0byBkaWFsb2cgY29uc3RydWN0b3IuXG4gICAgICovXG4gICAgb3BlbkRpYWxvZzogZnVuY3Rpb24oZGlhbG9nTmFtZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IGRpYWxvZ3NbZGlhbG9nTmFtZV0odGhpcy5ncmlkLCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGRlbGVnYXRlIGhhbmRsaW5nIG1vdXNlIGRvd24gdG8gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlTW91c2VEb3duOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAodGhpcy5mZWF0dXJlQ2hhaW4pIHtcbiAgICAgICAgICAgIHRoaXMuZmVhdHVyZUNoYWluLmhhbmRsZU1vdXNlRG93bihncmlkLCBldmVudCk7XG4gICAgICAgICAgICB0aGlzLnNldEN1cnNvcihncmlkKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgZGVsZWdhdGUgaGFuZGxpbmcgbW91c2UgZXhpdCB0byB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVNb3VzZUV4aXQ6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmZlYXR1cmVDaGFpbikge1xuICAgICAgICAgICAgdGhpcy5mZWF0dXJlQ2hhaW4uaGFuZGxlTW91c2VFeGl0KGdyaWQsIGV2ZW50KTtcbiAgICAgICAgICAgIHRoaXMuc2V0Q3Vyc29yKGdyaWQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyB0aGlzIGZ1bmN0aW9uIGlzIHJlcGxhY2VkIGJ5IHRoZSBncmlkIG9uIGluaXRpYWxpemF0aW9uIGFuZCBzZXJ2ZXMgYXMgdGhlIGNhbGxiYWNrXG4gICAgICovXG4gICAgY2hhbmdlZDogZnVuY3Rpb24oKSB7fSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyB0aGlzIGZ1bmN0aW9uIGlzIHJlcGxhY2VkIGJ5IHRoZSBncmlkIG9uIGluaXRpYWxpemF0aW9uIGFuZCBzZXJ2ZXMgYXMgdGhlIGNhbGxiYWNrXG4gICAgICovXG4gICAgc2hhcGVDaGFuZ2VkOiBmdW5jdGlvbigpIHt9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IENhbiByZS1vcmRlciBjb2x1bW5zLlxuICAgICAqL1xuICAgIGlzQ29sdW1uUmVvcmRlcmFibGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIHByb3BlcnRpZXMgZm9yIGEgc3BlY2lmaWMgY29sdW1uLiBUaGVzZSBhcmUgdXNlZCBpZiBubyBjZWxsIHByb3BlcnRpZXMgYXJlIHNwZWNpZmllZC5cbiAgICAgKiBAcGFyYW0ge2luZGV4fSBjb2x1bW5JbmRleCAtIHRoZSBjb2x1bW4gaW5kZXggb2YgaW50ZXJlc3RcbiAgICAgKi9cbiAgICBnZXRDb2x1bW5Qcm9wZXJ0aWVzOiBmdW5jdGlvbihjb2x1bW5JbmRleCkge1xuICAgICAgICB2YXIgY29sdW1uID0gdGhpcy5jb2x1bW5zW2NvbHVtbkluZGV4XTtcbiAgICAgICAgaWYgKCFjb2x1bW4pIHtcbiAgICAgICAgICAgIHJldHVybiBpc051bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByb3BlcnRpZXMgPSBjb2x1bW4uZ2V0UHJvcGVydGllcygpOyAvL1RPRE86IHJldHVybnMgYG51bGxgIG9uIEh5cGVyZ3JpZC5wcm90b3R5cGUucmVzZXQoKTtcbiAgICAgICAgaWYgKCFwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNOdWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm9wZXJ0aWVzO1xuICAgIH0sXG5cbiAgICBzZXRDb2x1bW5Qcm9wZXJ0aWVzOiBmdW5jdGlvbihjb2x1bW5JbmRleCwgcHJvcGVydGllcykge1xuICAgICAgICB2YXIgY29sdW1uID0gdGhpcy5hbGxDb2x1bW5zW2NvbHVtbkluZGV4XTtcbiAgICAgICAgdmFyIGNvbHVtblByb3BlcnRpZXMgPSBjb2x1bW4uZ2V0UHJvcGVydGllcygpO1xuICAgICAgICBfKGNvbHVtblByb3BlcnRpZXMpLmV4dGVuZE93bihwcm9wZXJ0aWVzKTtcbiAgICAgICAgdGhpcy5jaGFuZ2VkKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENsZWFycyBhbGwgY2VsbCBwcm9wZXJ0aWVzIG9mIGdpdmVuIGNvbHVtbiBvciBvZiBhbGwgY29sdW1ucy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2NvbHVtbkluZGV4XSAtIE9taXQgZm9yIGFsbCBjb2x1bW5zLlxuICAgICAqL1xuICAgIGNsZWFyQWxsQ2VsbFByb3BlcnRpZXM6IGZ1bmN0aW9uKGNvbHVtbkluZGV4KSB7XG4gICAgICAgIGlmIChjb2x1bW5JbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5hbGxDb2x1bW5zLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hbGxDb2x1bW5zW2ldLmNsZWFyQWxsQ2VsbFByb3BlcnRpZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBjb2x1bW4gPSB0aGlzLmFsbENvbHVtbnNbaV07XG4gICAgICAgICAgICBpZiAoY29sdW1uKSB7XG4gICAgICAgICAgICAgICAgY29sdW1uLmNsZWFyQWxsQ2VsbFByb3BlcnRpZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgUmVidWlsZCB0aGUgY29sdW1uIG9yZGVyIGluZGV4ZXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBjb2x1bW5JbmRleGVzIC0gbGlzdCBvZiBjb2x1bW4gaW5kZXhlc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NpbGVudD1mYWxzZV0gLSB3aGV0aGVyIHRvIHRyaWdnZXIgY29sdW1uIGNoYW5nZWQgZXZlbnRcbiAgICAgKi9cbiAgICBzZXRDb2x1bW5JbmRleGVzOiBmdW5jdGlvbihjb2x1bW5JbmRleGVzLCBzaWxlbnQpIHtcbiAgICAgICAgdmFyIHRhYmxlU3RhdGUgPSB0aGlzLmdldFByaXZhdGVTdGF0ZSgpO1xuICAgICAgICB0aGlzLl9zZXRDb2x1bW5PcmRlcihjb2x1bW5JbmRleGVzKTtcbiAgICAgICAgdGFibGVTdGF0ZS5jb2x1bW5JbmRleGVzID0gY29sdW1uSW5kZXhlcztcbiAgICAgICAgdGhpcy5jaGFuZ2VkKCk7XG4gICAgICAgIGlmICghc2lsZW50KSB7XG4gICAgICAgICAgICB0aGlzLmdyaWQuZmlyZVN5bnRoZXRpY09uQ29sdW1uc0NoYW5nZWRFdmVudCgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmdbXX0gQWxsIHRoZSBjdXJyZW50bHkgaGlkZGVuIGNvbHVtbiBoZWFkZXIgbGFiZWxzLlxuICAgICAqL1xuICAgIGdldEhpZGRlbkNvbHVtbkRlc2NyaXB0b3JzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHRhYmxlU3RhdGUgPSB0aGlzLmdldFByaXZhdGVTdGF0ZSgpO1xuICAgICAgICB2YXIgaW5kZXhlcyA9IHRhYmxlU3RhdGUuY29sdW1uSW5kZXhlcztcbiAgICAgICAgdmFyIGxhYmVscyA9IFtdO1xuICAgICAgICB2YXIgY29sdW1uQ291bnQgPSB0aGlzLmdldEFjdGl2ZUNvbHVtbkNvdW50KCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29sdW1uQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgaWYgKGluZGV4ZXMuaW5kZXhPZihpKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29sdW1uID0gdGhpcy5nZXRBY3RpdmVDb2x1bW4oaSk7XG4gICAgICAgICAgICAgICAgbGFiZWxzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBpZDogaSxcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyOiBjb2x1bW4uaGVhZGVyLFxuICAgICAgICAgICAgICAgICAgICBmaWVsZDogY29sdW1uLm5hbWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGFiZWxzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGlkZSBjb2x1bW5zIHRoYXQgYXJlIHNwZWNpZmllZCBieSB0aGVpciBpbmRleGVzXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXlPZkluZGV4ZXMgLSBhbiBhcnJheSBvZiBjb2x1bW4gaW5kZXhlcyB0byBoaWRlXG4gICAgICovXG4gICAgaGlkZUNvbHVtbnM6IGZ1bmN0aW9uKGFycmF5T2ZJbmRleGVzKSB7XG4gICAgICAgIHZhciB0YWJsZVN0YXRlID0gdGhpcy5nZXRQcml2YXRlU3RhdGUoKTtcbiAgICAgICAgdmFyIG9yZGVyID0gdGFibGVTdGF0ZS5jb2x1bW5JbmRleGVzO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5T2ZJbmRleGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZWFjaCA9IGFycmF5T2ZJbmRleGVzW2ldO1xuICAgICAgICAgICAgaWYgKG9yZGVyLmluZGV4T2YoZWFjaCkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgb3JkZXIuc3BsaWNlKG9yZGVyLmluZGV4T2YoZWFjaCksIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJuIHtpbnRlZ2VyfSBUaGUgbnVtYmVyIG9mIGZpeGVkIGNvbHVtbnMuXG4gICAgICovXG4gICAgZ2V0Rml4ZWRDb2x1bW5Db3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFByaXZhdGVTdGF0ZSgpLmZpeGVkQ29sdW1uQ291bnQgfHwgMDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHNldCB0aGUgbnVtYmVyIG9mIGZpeGVkIGNvbHVtbnNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiAtIHRoZSBpbnRlZ2VyIGNvdW50IG9mIGhvdyBtYW55IGNvbHVtbnMgdG8gYmUgZml4ZWRcbiAgICAgKi9cbiAgICBzZXRGaXhlZENvbHVtbkNvdW50OiBmdW5jdGlvbihuKSB7XG4gICAgICAgIHRoaXMuZ2V0UHJpdmF0ZVN0YXRlKCkuZml4ZWRDb2x1bW5Db3VudCA9IG47XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJuIHtpbnRlZ2VyfSBUaGUgbnVtYmVyIG9mIGZpeGVkIHJvd3MuXG4gICAgICovXG4gICAgZ2V0Rml4ZWRSb3dDb3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy50YWJsZVN0YXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaGVhZGVycyA9IHRoaXMuZ3JpZC5nZXRIZWFkZXJSb3dDb3VudCgpO1xuICAgICAgICB2YXIgdXNlcnNTaXplID0gdGhpcy50YWJsZVN0YXRlLmZpeGVkUm93Q291bnQgfHwgMDtcbiAgICAgICAgcmV0dXJuIGhlYWRlcnMgKyB1c2Vyc1NpemU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBTZXQgdGhlIG51bWJlciBvZiBmaXhlZCByb3dzLCB3aGljaCBpbmNsdWRlcyAodG9wIHRvIGJvdHRvbSBvcmRlcik6XG4gICAgICogMS4gVGhlIGhlYWRlciByb3dzXG4gICAgICogICAgMS4gVGhlIGhlYWRlciBsYWJlbHMgcm93IChvcHRpb25hbClcbiAgICAgKiAgICAyLiBUaGUgZmlsdGVyIHJvdyAob3B0aW9uYWwpXG4gICAgICogICAgMy4gVGhlIHRvcCB0b3RhbCByb3dzICgwIG9yIG1vcmUpXG4gICAgICogMi4gVGhlIG5vbi1zY3JvbGxpbmcgcm93cyAoZXh0ZXJuYWxseSBjYWxsZWQgXCJ0aGUgZml4ZWQgcm93c1wiKVxuICAgICAqXG4gICAgICogQHJldHVybnMge251bWJlcn0gU3VtIG9mIHRoZSBhYm92ZSBvciAwIGlmIG5vbmUgb2YgdGhlIGFib3ZlIGFyZSBpbiB1c2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiAtIFRoZSBudW1iZXIgb2Ygcm93cy5cbiAgICAgKi9cbiAgICBzZXRGaXhlZFJvd0NvdW50OiBmdW5jdGlvbihuKSB7XG4gICAgICAgIHRoaXMudGFibGVTdGF0ZS5maXhlZFJvd0NvdW50ID0gbjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiBoZWFkZXIgcm93cy5cbiAgICAgKiBBIHBvcnRpb24gb2YgdGhlIG51bWJlciByZXR1cm5lZCBieSB7QGxpbmsgQmVoYXZpb3IjZ2V0Rml4ZWRSb3dDb3VudCgpfGdldEZpeGVkUm93Q291bnQoKX0uXG4gICAgICogKFRoZSByZW1haW5pbmcgX2ZpeGVkIHJvd3NfIGFyZSB0aGUgX3RvcCB0b3RhbHNfIHJvd3MuKVxuICAgICAqL1xuICAgIGdldEhlYWRlclJvd0NvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGhlYWRlciA9IHRoaXMuZ3JpZC5pc1Nob3dIZWFkZXJSb3coKSA/IDEgOiAwO1xuICAgICAgICB2YXIgZmlsdGVyID0gdGhpcy5ncmlkLmlzU2hvd0ZpbHRlclJvdygpID8gMSA6IDA7XG4gICAgICAgIHZhciB0b3RhbHMgPSB0aGlzLmdldFRvcFRvdGFscygpLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIGhlYWRlciArIGZpbHRlciArIHRvdGFscztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiBmb290ZXIgcm93cywgY29uc2lzdGluZyBlbnRpcmVseSBvZiAwIG9yIG1vcmUgX2JvdHRvbSB0b3RhbHNfIHJvd3MuXG4gICAgICovXG4gICAgZ2V0Rm9vdGVyUm93Q291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRCb3R0b21Ub3RhbHMoKS5sZW5ndGg7XG4gICAgfSxcblxuICAgIGdldFRvcFRvdGFsczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFNb2RlbC5nZXRUb3BUb3RhbHMoKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAc3VtbWFyeSBTZXQgdGhlIG51bWJlciBvZiBoZWFkZXIgcm93cy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiAtIFRoZSBudW1iZXIgb2YgX2ZpeGVkIHJvd3NfIHRvIHJlc2VydmUgYXMgaGVhZGVyIHJvd3MuXG4gICAgICogKFRoZSByZW1haW5pbmcgX2ZpeGVkIHJvd3NfIGFyZSB0aGUgX3RvcCB0b3RhbHNfIHJvd3MuKVxuICAgICAqL1xuICAgIHNldEhlYWRlclJvd0NvdW50OiBmdW5jdGlvbihuKSB7XG4gICAgICAgIHRoaXMudGFibGVTdGF0ZS5oZWFkZXJSb3dDb3VudCA9IG47XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgZml4ZWQgcm93cy5cbiAgICAgKi9cbiAgICBnZXRIZWFkZXJDb2x1bW5Db3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyaWQucmVzb2x2ZVByb3BlcnR5KCdoZWFkZXJDb2x1bW5Db3VudCcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgZml4ZWQgcm93cy5cbiAgICAgKi9cbiAgICBzZXRIZWFkZXJDb2x1bW5Db3VudDogZnVuY3Rpb24obnVtYmVyT2ZIZWFkZXJDb2x1bW5zKSB7XG4gICAgICAgIHRoaXMudGFibGVTdGF0ZS5oZWFkZXJDb2x1bW5Db3VudCA9IG51bWJlck9mSGVhZGVyQ29sdW1ucztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGEgZG5kIGNvbHVtbiBoYXMganVzdCBiZWVuIGRyb3BwZWQsIHdlJ3ZlIGJlZW4gbm90aWZpZWRcbiAgICAgKi9cbiAgICBlbmREcmFnQ29sdW1uTm90aWZpY2F0aW9uOiBmdW5jdGlvbigpIHt9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm4ge251bGx9IHRoZSBjdXJzb3IgYXQgYSBzcGVjaWZpYyB4LHkgY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gdGhlIHggY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gdGhlIHkgY29vcmRpbmF0ZVxuICAgICAqL1xuICAgIGdldEN1cnNvckF0OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBOdW1iZXIgb2YgX3Zpc2libGVfIGNvbHVtbnMuXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIHRvdGFsIG51bWJlciBvZiBjb2x1bW5zLlxuICAgICAqL1xuICAgIGdldEFjdGl2ZUNvbHVtbkNvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sdW1ucy5sZW5ndGg7XG4gICAgfSxcbiAgICBnZXRDb2x1bW5Db3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlcHJlY2F0ZWQoJ2dldENvbHVtbkNvdW50KCknLCAnZ2V0QWN0aXZlQ29sdW1uQ291bnQoKScsICcxLjAuNicsIGFyZ3VtZW50cyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBjb2x1bW4gYWxpZ25tZW50IGF0IGNvbHVtbiBgeGA6IGAnbGVmdCdgLCBgJ2NlbnRlcidgICwgb3IgYCdyaWdodCdgXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgY29sdW1uIGluZGV4IG9mIGludGVyZXN0LlxuICAgICAqL1xuICAgIGdldENvbHVtbkFsaWdubWVudDogZnVuY3Rpb24oeCkge1xuICAgICAgICByZXR1cm4gJ2NlbnRlcic7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBRdWlldGx5IHNldCB0aGUgaG9yaXpvbnRhbCBzY3JvbGwgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgbmV3IHBvc2l0aW9uIGluIHBpeGVscy5cbiAgICAgKi9cbiAgICBzZXRTY3JvbGxQb3NpdGlvblg6IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2Nyb2xsUG9zaXRpb25YID0geDtcbiAgICB9LFxuXG4gICAgZ2V0U2Nyb2xsUG9zaXRpb25YOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsUG9zaXRpb25YO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgUXVpZXRseSBzZXQgdGhlIHZlcnRpY2FsIHNjcm9sbCBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAtIFRoZSBuZXcgcG9zaXRpb24gaW4gcGl4ZWxzLlxuICAgICAqL1xuICAgIHNldFNjcm9sbFBvc2l0aW9uWTogZnVuY3Rpb24oeSkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zY3JvbGxQb3NpdGlvblkgPSB5O1xuICAgIH0sXG5cbiAgICBnZXRTY3JvbGxQb3NpdGlvblk6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY3JvbGxQb3NpdGlvblk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJuIHtjZWxsRWRpdG9yfSBUaGUgY2VsbCBlZGl0b3IgZm9yIHRoZSBjZWxsIGF0IHRoZSBnaXZlbiBjb29yZGluYXRlcy5cbiAgICAgKiBAcGFyYW0ge1BvaW50fSBlZGl0UG9pbnQgLSBUaGUgZ3JpZCBjZWxsIGNvb3JkaW5hdGVzLlxuICAgICAqL1xuICAgIGdldENlbGxFZGl0b3JBdDogZnVuY3Rpb24oZWRpdFBvaW50KSB7XG4gICAgICAgIHZhciBjZWxsRWRpdG9yLCBvcHRpb25zLFxuICAgICAgICAgICAgY29sdW1uID0gdGhpcy5nZXRBY3RpdmVDb2x1bW4oZWRpdFBvaW50LngpO1xuXG4gICAgICAgIGlmIChjb2x1bW4pIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgY29sdW1uOiBjb2x1bW4sXG4gICAgICAgICAgICAgICAgZWRpdFBvaW50OiBlZGl0UG9pbnRcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGNlbGxFZGl0b3IgPSB0aGlzLmdyaWQuaXNGaWx0ZXJSb3coZWRpdFBvaW50LnkpXG4gICAgICAgICAgICAgICAgPyB0aGlzLmdyaWQuY2VsbEVkaXRvcnMuY3JlYXRlKCdmaWx0ZXJib3gnLCBvcHRpb25zKVxuICAgICAgICAgICAgICAgIDogY29sdW1uLmdldENlbGxFZGl0b3JBdChlZGl0UG9pbnQueSwgb3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2VsbEVkaXRvcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIGNvbHVtbiBpbmRleC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBrZXlzXG4gICAgICovXG4gICAgdG9nZ2xlU29ydDogZnVuY3Rpb24oeCwga2V5cykge1xuICAgICAgICB0aGlzLmdldEFjdGl2ZUNvbHVtbih4KS50b2dnbGVTb3J0KGtleXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIHdlIHNob3VsZCBoaWdobGlnaHQgb24gaG92ZXJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzQ29sdW1uSG92ZXJlZCAtIHRoZSBjb2x1bW4gaXMgaG92ZXJlZCBvciBub3RcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzUm93SG92ZXJlZCAtIHRoZSByb3cgaXMgaG92ZXJlZCBvciBub3RcbiAgICAgKi9cbiAgICBoaWdobGlnaHRDZWxsT25Ib3ZlcjogZnVuY3Rpb24oaXNDb2x1bW5Ib3ZlcmVkLCBpc1Jvd0hvdmVyZWQpIHtcbiAgICAgICAgcmV0dXJuIGlzQ29sdW1uSG92ZXJlZCAmJiBpc1Jvd0hvdmVyZWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyB0aGlzIGZ1bmN0aW9uIGlzIGEgaG9vayBhbmQgaXMgY2FsbGVkIGp1c3QgYmVmb3JlIHRoZSBwYWludGluZyBvZiBhIGNlbGwgb2NjdXJzXG4gICAgICogQHBhcmFtIHt3aW5kb3cuZmluLnJlY3Rhbmd1bGFyLlBvaW50fSBjZWxsXG4gICAgICovXG4gICAgY2VsbFByb3BlcnRpZXNQcmVQYWludE5vdGlmaWNhdGlvbjogZnVuY3Rpb24oY2VsbCkge1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyB0aGlzIGZ1bmN0aW9uIGlzIGEgaG9vayBhbmQgaXMgY2FsbGVkIGp1c3QgYmVmb3JlIHRoZSBwYWludGluZyBvZiBhIGZpeGVkIHJvdyBjZWxsIG9jY3Vyc1xuICAgICAqIEBwYXJhbSB7d2luZG93LmZpbi5yZWN0YW5ndWxhci5Qb2ludH0gY2VsbFxuICAgICAqL1xuICAgIGNlbGxGaXhlZFJvd1ByZVBhaW50Tm90aWZpY2F0aW9uOiBmdW5jdGlvbihjZWxsKSB7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHRoaXMgZnVuY3Rpb24gaXMgYSBob29rIGFuZCBpcyBjYWxsZWQganVzdCBiZWZvcmUgdGhlIHBhaW50aW5nIG9mIGEgZml4ZWQgY29sdW1uIGNlbGwgb2NjdXJzXG4gICAgICogQHBhcmFtIHt3aW5kb3cuZmluLnJlY3Rhbmd1bGFyLlBvaW50fSBjZWxsXG4gICAgICovXG4gICAgY2VsbEZpeGVkQ29sdW1uUHJlUGFpbnROb3RpZmljYXRpb246IGZ1bmN0aW9uKGNlbGwpIHtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgdGhpcyBmdW5jdGlvbiBpcyBhIGhvb2sgYW5kIGlzIGNhbGxlZCBqdXN0IGJlZm9yZSB0aGUgcGFpbnRpbmcgb2YgYSB0b3AgbGVmdCBjZWxsIG9jY3Vyc1xuICAgICAqIEBwYXJhbSB7d2luZG93LmZpbi5yZWN0YW5ndWxhci5Qb2ludH0gY2VsbFxuICAgICAqL1xuICAgIGNlbGxUb3BMZWZ0UHJlUGFpbnROb3RpZmljYXRpb246IGZ1bmN0aW9uKGNlbGwpIHtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgdGhpcyBmdW5jdGlvbiBlbmhhbmNlIHRoZSBkb3VibGUgY2xpY2sgZXZlbnQganVzdCBiZWZvcmUgaXQncyBicm9hZGNhc3QgdG8gbGlzdGVuZXJzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gZXZlbnQgdG8gZW5oYW5jZVxuICAgICAqL1xuICAgIGVuaGFuY2VEb3VibGVDbGlja0V2ZW50OiBmdW5jdGlvbihldmVudCkge30sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2Mgc3dhcCBzcmMgYW5kIHRhciBjb2x1bW5zXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNyYyAtIGNvbHVtbiBpbmRleFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0YXIgLSBjb2x1bW4gaW5kZXhcbiAgICAgKi9cbiAgICBzd2FwQ29sdW1uczogZnVuY3Rpb24oc291cmNlLCB0YXJnZXQpIHtcbiAgICAgICAgdmFyIGNvbHVtbnMgPSB0aGlzLmNvbHVtbnM7XG4gICAgICAgIHZhciB0bXAgPSBjb2x1bW5zW3NvdXJjZV07XG4gICAgICAgIGNvbHVtbnNbc291cmNlXSA9IGNvbHVtbnNbdGFyZ2V0XTtcbiAgICAgICAgY29sdW1uc1t0YXJnZXRdID0gdG1wO1xuICAgICAgICB0aGlzLmNoYW5nZWQoKTtcbiAgICB9LFxuXG4gICAgZ2V0Q29sdW1uRWRnZTogZnVuY3Rpb24oYywgcmVuZGVyZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YU1vZGVsLmdldENvbHVtbkVkZ2UoYywgcmVuZGVyZXIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSBjb2x1bW4gaW5kZXhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAtIHRvdGFscyByb3cgaW5kZXggbG9jYWwgdG8gdGhlIHRvdGFscyBhcmVhXG4gICAgICogQHBhcmFtIHZhbHVlXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gW2FyZWFzPVsndG9wJywgJ2JvdHRvbSddXSAtIG1heSBpbmNsdWRlIGAndG9wJ2AgYW5kL29yIGAnYm90dG9tJ2BcbiAgICAgKi9cbiAgICBzZXRUb3RhbHNWYWx1ZTogZnVuY3Rpb24oeCwgeSwgdmFsdWUsIGFyZWFzKSB7XG4gICAgICAgIHRoaXMuZ3JpZC5zZXRUb3RhbHNWYWx1ZU5vdGlmaWNhdGlvbih4LCB5LCB2YWx1ZSwgYXJlYXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQHJldHVybiB7b2JqZWN0fSBUaGUgb2JqZWN0IGF0IHkgaW5kZXguXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSB0aGUgcm93IGluZGV4IG9mIGludGVyZXN0XG4gICAgICovXG4gICAgZ2V0Um93OiBmdW5jdGlvbih5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFNb2RlbC5nZXRSb3coeSk7XG4gICAgfSxcblxuICAgIGNvbnZlcnRWaWV3UG9pbnRUb0RhdGFQb2ludDogZnVuY3Rpb24odmlld1BvaW50KSB7XG4gICAgICAgIHZhciBuZXdYID0gdGhpcy5nZXRBY3RpdmVDb2x1bW4odmlld1BvaW50LngpLmluZGV4O1xuICAgICAgICB2YXIgbmV3UG9pbnQgPSB0aGlzLmdyaWQubmV3UG9pbnQobmV3WCwgdmlld1BvaW50LnkpO1xuICAgICAgICByZXR1cm4gbmV3UG9pbnQ7XG4gICAgfSxcblxuICAgIHNldEdyb3VwczogZnVuY3Rpb24oYXJyYXlPZkNvbHVtbkluZGV4ZXMpIHtcbiAgICAgICAgdGhpcy5kYXRhTW9kZWwuc2V0R3JvdXBzKGFycmF5T2ZDb2x1bW5JbmRleGVzKTtcbiAgICAgICAgdGhpcy5jcmVhdGVDb2x1bW5zKCk7XG4gICAgICAgIHRoaXMuY2hhbmdlZCgpO1xuICAgIH0sXG5cbiAgICBzZXRBZ2dyZWdhdGVzOiBmdW5jdGlvbihtYXBPZktleXNUb0Z1bmN0aW9ucykge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHRoaXMuZGF0YU1vZGVsLnNldEFnZ3JlZ2F0ZXMobWFwT2ZLZXlzVG9GdW5jdGlvbnMpO1xuICAgICAgICB0aGlzLmNyZWF0ZUNvbHVtbnMoKTtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNlbGYuY2hhbmdlZCgpO1xuICAgICAgICB9LCAxMDApO1xuICAgIH0sXG5cbiAgICBoYXNIaWVyYXJjaHlDb2x1bW46IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIGdldFJvd0NvbnRleHRGdW5jdGlvbjogZnVuY3Rpb24oc2VsZWN0ZWRSb3dzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBnZXRTZWxlY3Rpb25NYXRyaXhGdW5jdGlvbjogZnVuY3Rpb24oc2VsZWN0ZWRSb3dzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBnZXRDb21wdXRlZFJvdzogZnVuY3Rpb24oeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhTW9kZWwuZ2V0Q29tcHV0ZWRSb3coeSk7XG4gICAgfSxcblxuICAgIGF1dG9zaXplQWxsQ29sdW1uczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuY2hlY2tDb2x1bW5BdXRvc2l6aW5nKHRydWUpO1xuICAgICAgICB0aGlzLmNoYW5nZWQoKTtcbiAgICB9LFxuXG4gICAgY2hlY2tDb2x1bW5BdXRvc2l6aW5nOiBmdW5jdGlvbihmb3JjZSkge1xuICAgICAgICBmb3JjZSA9IGZvcmNlID09PSB0cnVlO1xuICAgICAgICB0aGlzLmF1dG9TaXplUm93TnVtYmVyQ29sdW1uKCk7XG4gICAgICAgIHRoaXMuYWxsQ29sdW1uc1stMl0uY2hlY2tDb2x1bW5BdXRvc2l6aW5nKGZvcmNlKTtcbiAgICAgICAgdGhpcy5hbGxDb2x1bW5zLmZvckVhY2goZnVuY3Rpb24oY29sdW1uKSB7XG4gICAgICAgICAgICBjb2x1bW4uY2hlY2tDb2x1bW5BdXRvc2l6aW5nKGZvcmNlKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIGF1dG9TaXplUm93TnVtYmVyQ29sdW1uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuZ3JpZC5pc1Jvd051bWJlckF1dG9zaXppbmcoKSkge1xuICAgICAgICAgICAgdGhpcy5hbGxDb2x1bW5zWy0xXS5jaGVja0NvbHVtbkF1dG9zaXppbmcodHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0TmV3RmlsdGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG5ld0ZpbHRlciA9IG5ldyBEZWZhdWx0RmlsdGVyKHtcbiAgICAgICAgICAgIHNjaGVtYTogdHlwZW9mIHRoaXMuc2NoZW1hID09PSAnZnVuY3Rpb24nID8gdGhpcy5zY2hlbWEodGhpcy5jb2x1bW5zKSA6IHRoaXMuc2NoZW1hLFxuICAgICAgICAgICAgY2FzZVNlbnNpdGl2ZUNvbHVtbk5hbWVzOiB0aGlzLmdyaWQucmVzb2x2ZVByb3BlcnR5KCdmaWx0ZXJDYXNlU2Vuc2l0aXZlQ29sdW1uTmFtZXMnKSxcbiAgICAgICAgICAgIHJlc29sdmVBbGlhc2VzOiB0aGlzLmdyaWQucmVzb2x2ZVByb3BlcnR5KCdmaWx0ZXJSZXNvbHZlQWxpYXNlcycpLFxuICAgICAgICAgICAgZGVmYXVsdENvbHVtbkZpbHRlck9wZXJhdG9yOiB0aGlzLmdyaWQucmVzb2x2ZVByb3BlcnR5KCdmaWx0ZXJEZWZhdWx0Q29sdW1uRmlsdGVyT3BlcmF0b3InKVxuICAgICAgICB9KTtcbiAgICAgICAgbmV3RmlsdGVyLmxvYWRDb2x1bW5Qcm9wZXJ0aWVzRnJvbVNjaGVtYSh0aGlzLmNvbHVtbnMpO1xuICAgICAgICByZXR1cm4gbmV3RmlsdGVyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBHZXQgYSByZWZlcmVuY2UgdG8gdGhlIGZpbHRlciBhdHRhY2hlZCB0byB0aGUgSHlwZXJncmlkLlxuICAgICAqIEByZXR1cm5zIHtGaWx0ZXJUcmVlfVxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBnZXRHbG9iYWxGaWx0ZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhTW9kZWwuZ2V0R2xvYmFsRmlsdGVyKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IEF0dGFjaC9kZXRhY2ggYSBmaWx0ZXIgdG8gYSBIeXBlcmdyaWQuXG4gICAgICogQHBhcmFtIHtGaWx0ZXJUcmVlfSBbZmlsdGVyXSAtIFRoZSBmaWx0ZXIgb2JqZWN0LiBJZiB1bmRlZmluZWQsIGFueSBhdHRhY2hlZCBmaWx0ZXIgaXMgcmVtb3ZlZCwgdHVybmluZyBmaWx0ZXJpbmcgT0ZGLlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBzZXRHbG9iYWxGaWx0ZXI6IGZ1bmN0aW9uKGZpbHRlcikge1xuICAgICAgICB0aGlzLmRhdGFNb2RlbC5zZXRHbG9iYWxGaWx0ZXIoZmlsdGVyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgU2V0IHRoZSBjYXNlIHNlbnNpdGl2aXR5IG9mIGZpbHRlciB0ZXN0cyBhZ2FpbnN0IGRhdGEuXG4gICAgICogQGRlc2MgQ2FzZSBzZW5zaXRpdml0eSBwZXJ0YWlucyB0byBzdHJpbmcgY29tcGFyZXMgb25seS4gVGhpcyBpbmNsdWRlcyB1bnR5cGVkIGNvbHVtbnMsIGNvbHVtbnMgdHlwZWQgYXMgc3RyaW5ncywgdHlwZWQgY29sdW1ucyBjb250YWluaW5nIGRhdGEgdGhhdCBjYW5ub3QgYmUgY29lcmNlZCB0byB0eXBlIG9yIHdoZW4gdGhlIGZpbHRlciBleHByZXNzaW9uIG9wZXJhbmQgY2Fubm90IGJlIGNvZXJjZWQuXG4gICAgICpcbiAgICAgKiBOT1RFOiBUaGlzIGlzIGEgc2hhcmVkIHByb3BlcnR5IGFuZCBhZmZlY3RzIGFsbCBncmlkIG1hbmFnZWQgYnkgdGhpcyBpbnN0YW5jZSBvZiB0aGUgYXBwLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNTZW5zaXRpdmVcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICovXG4gICAgc2V0R2xvYmFsRmlsdGVyQ2FzZVNlbnNpdGl2aXR5OiBmdW5jdGlvbihpc1NlbnNpdGl2ZSkge1xuICAgICAgICB0aGlzLmRhdGFNb2RlbC5zZXRHbG9iYWxGaWx0ZXJDYXNlU2Vuc2l0aXZpdHkoaXNTZW5zaXRpdmUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IGNvbHVtbkluZGV4T3JOYW1lIC0gVGhlIF9jb2x1bW4gZmlsdGVyXyB0byBzZXQuXG4gICAgICogQHBhcmFtIHtGaWx0ZXJUcmVlR2V0U3RhdGVPcHRpb25zT2JqZWN0fSBbb3B0aW9uc10gLSBQYXNzZWQgdG8gdGhlIGZpbHRlcidzIHtAbGluayBEZWZhdWx0RmlsdGVyI2dldFN0YXRlfGdldFN0YXRlfSBtZXRob2QuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5zeW50YXg9J0NRTCddIC0gVGhlIHN5bnRheCB0byB1c2UgdG8gZGVzY3JpYmUgdGhlIGZpbHRlciBzdGF0ZS4gTm90ZSB0aGF0IGBnZXRGaWx0ZXJgJ3MgZGVmYXVsdCBzeW50YXgsIGAnQ1FMJ2AsIGRpZmZlcnMgZnJvbSB0aGUgb3RoZXIgZ2V0IHN0YXRlIG1ldGhvZHMuXG4gICAgICogQHJldHVybnMge0ZpbHRlclRyZWVTdGF0ZU9iamVjdH1cbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICovXG4gICAgZ2V0RmlsdGVyOiBmdW5jdGlvbihjb2x1bW5JbmRleE9yTmFtZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhTW9kZWwuZ2V0RmlsdGVyKGNvbHVtbkluZGV4T3JOYW1lLCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgU2V0IGEgcGFydGljdWxhciBjb2x1bW4gZmlsdGVyJ3Mgc3RhdGUuXG4gICAgICogQGRlc2MgQWZ0ZXIgc2V0dGluZyB0aGUgbmV3IGZpbHRlciBzdGF0ZSwgcmVhcHBsaWVzIHRoZSBmaWx0ZXIgdG8gdGhlIGRhdGEgc291cmNlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gY29sdW1uSW5kZXhPck5hbWUgLSBUaGUgX2NvbHVtbiBmaWx0ZXJfIHRvIHNldC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IFtzdGF0ZV0gLSBBIGZpbHRlciB0cmVlIG9iamVjdCBvciBhIEpTT04sIFNRTCwgb3IgQ1FMIHN1YmV4cHJlc3Npb24gc3RyaW5nIHRoYXQgZGVzY3JpYmVzIHRoZSBhIG5ldyBzdGF0ZSBmb3IgdGhlIG5hbWVkIGNvbHVtbiBmaWx0ZXIuIFRoZSBleGlzdGluZyBjb2x1bW4gZmlsdGVyIHN1YmV4cHJlc3Npb24gaXMgcmVwbGFjZWQgd2l0aCBhIG5ldyBub2RlIGJhc2VkIG9uIHRoaXMgc3RhdGUuIElmIGl0IGRvZXMgbm90IGV4aXN0LCB0aGUgbmV3IHN1YmV4cHJlc3Npb24gaXMgYWRkZWQgdG8gdGhlIGNvbHVtbiBmaWx0ZXJzIHN1YnRyZWUgKGBmaWx0ZXIuY29sdW1uRmlsdGVyc2ApLlxuICAgICAqXG4gICAgICogSWYgdW5kZWZpbmVkLCByZW1vdmVzIHRoZSBlbnRpcmUgY29sdW1uIGZpbHRlciBzdWJleHByZXNzaW9uIGZyb20gdGhlIGNvbHVtbiBmaWx0ZXJzIHN1YnRyZWUuXG4gICAgICogQHBhcmFtIHtGaWx0ZXJUcmVlU2V0U3RhdGVPcHRpb25zT2JqZWN0fSBbb3B0aW9uc10gLSBQYXNzZWQgdG8gdGhlIGZpbHRlcidzIFtzZXRTdGF0ZV17QGxpbmsgaHR0cDovL2pvbmVpdC5naXRodWIuaW8vZmlsdGVyLXRyZWUvRmlsdGVyVHJlZS5odG1sI3NldFN0YXRlfSBtZXRob2QuIFlvdSBtYXkgbWl4IGluIG1lbWJlcnMgb2YgdGhlIHtAbGluayBodHRwOi8vam9uZWl0LmdpdGh1Yi5pby9maWx0ZXItdHJlZS9nbG9iYWwuaHRtbCNGaWx0ZXJUcmVlVmFsaWRhdGlvbk9wdGlvbnNPYmplY3R8RmlsdGVyVHJlZVZhbGlkYXRpb25PcHRpb25zT2JqZWN0fVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5zeW50YXg9J0NRTCddIC0gVGhlIHN5bnRheCB0byB1c2UgdG8gZGVzY3JpYmUgdGhlIGZpbHRlciBzdGF0ZS4gTm90ZSB0aGF0IGBzZXRGaWx0ZXJgJ3MgZGVmYXVsdCBzeW50YXgsIGAnQ1FMJ2AsIGRpZmZlcnMgZnJvbSB0aGUgb3RoZXIgZ2V0IHN0YXRlIG1ldGhvZHMuXG4gICAgICogQHJldHVybnMge3VuZGVmaW5lZHxFcnJvcnxzdHJpbmd9IGB1bmRlZmluZWRgIGluZGljYXRlcyBzdWNjZXNzLlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBzZXRGaWx0ZXI6IGZ1bmN0aW9uKGNvbHVtbkluZGV4T3JOYW1lLCBzdGF0ZSwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLmRhdGFNb2RlbC5zZXRGaWx0ZXIoY29sdW1uSW5kZXhPck5hbWUsIHN0YXRlLCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtGaWx0ZXJUcmVlR2V0U3RhdGVPcHRpb25zT2JqZWN0fSBbb3B0aW9uc10gLSBQYXNzZWQgdG8gdGhlIGZpbHRlcidzIHtAbGluayBEZWZhdWx0RmlsdGVyI2dldFN0YXRlfGdldFN0YXRlfSBtZXRob2QuXG4gICAgICogQHJldHVybnMge0ZpbHRlclRyZWVTdGF0ZU9iamVjdH1cbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICovXG4gICAgZ2V0RmlsdGVyczogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhTW9kZWwuZ2V0RmlsdGVycyhvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtGaWx0ZXJUcmVlU3RhdGVPYmplY3R9IHN0YXRlXG4gICAgICogQHBhcmFtIHtGaWx0ZXJUcmVlU2V0U3RhdGVPcHRpb25zT2JqZWN0fSBbb3B0aW9uc10gLSBQYXNzZWQgdG8gdGhlIGZpbHRlcidzIFtzZXRTdGF0ZV17QGxpbmsgaHR0cDovL2pvbmVpdC5naXRodWIuaW8vZmlsdGVyLXRyZWUvRmlsdGVyVHJlZS5odG1sI3NldFN0YXRlfSBtZXRob2QuIFlvdSBtYXkgbWl4IGluIG1lbWJlcnMgb2YgdGhlIHtAbGluayBodHRwOi8vam9uZWl0LmdpdGh1Yi5pby9maWx0ZXItdHJlZS9nbG9iYWwuaHRtbCNGaWx0ZXJUcmVlVmFsaWRhdGlvbk9wdGlvbnNPYmplY3R8RmlsdGVyVHJlZVZhbGlkYXRpb25PcHRpb25zT2JqZWN0fVxuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR8RXJyb3J8c3RyaW5nfSBgdW5kZWZpbmVkYCBpbmRpY2F0ZXMgc3VjY2Vzcy5cbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICovXG4gICAgc2V0RmlsdGVyczogZnVuY3Rpb24oc3RhdGUsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5kYXRhTW9kZWwuc2V0RmlsdGVycyhzdGF0ZSwgb3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7RmlsdGVyVHJlZUdldFN0YXRlT3B0aW9uc09iamVjdH0gW29wdGlvbnNdIC0gUGFzc2VkIHRvIHRoZSBmaWx0ZXIncyB7QGxpbmsgRGVmYXVsdEZpbHRlciNnZXRTdGF0ZXxnZXRTdGF0ZX0gbWV0aG9kLlxuICAgICAqIEByZXR1cm5zIHtGaWx0ZXJUcmVlU3RhdGVPYmplY3R9XG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGdldFRhYmxlRmlsdGVyOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFNb2RlbC5nZXRUYWJsZUZpbHRlcihvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtGaWx0ZXJUcmVlU3RhdGVPYmplY3R9IHN0YXRlXG4gICAgICogQHBhcmFtIHtGaWx0ZXJUcmVlU2V0U3RhdGVPcHRpb25zT2JqZWN0fSBbb3B0aW9uc10gLSBQYXNzZWQgdG8gdGhlIGZpbHRlcidzIFtzZXRTdGF0ZV17QGxpbmsgaHR0cDovL2pvbmVpdC5naXRodWIuaW8vZmlsdGVyLXRyZWUvRmlsdGVyVHJlZS5odG1sI3NldFN0YXRlfSBtZXRob2QuIFlvdSBtYXkgbWl4IGluIG1lbWJlcnMgb2YgdGhlIHtAbGluayBodHRwOi8vam9uZWl0LmdpdGh1Yi5pby9maWx0ZXItdHJlZS9nbG9iYWwuaHRtbCNGaWx0ZXJUcmVlVmFsaWRhdGlvbk9wdGlvbnNPYmplY3R8RmlsdGVyVHJlZVZhbGlkYXRpb25PcHRpb25zT2JqZWN0fVxuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR8RXJyb3J8c3RyaW5nfSBgdW5kZWZpbmVkYCBpbmRpY2F0ZXMgc3VjY2Vzcy5cbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICovXG4gICAgc2V0VGFibGVGaWx0ZXI6IGZ1bmN0aW9uKHN0YXRlLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuZGF0YU1vZGVsLnNldFRhYmxlRmlsdGVyKHN0YXRlLCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgZ2V0U2VsZWN0ZWRSb3dzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JpZC5zZWxlY3Rpb25Nb2RlbC5nZXRTZWxlY3RlZFJvd3MoKTtcbiAgICB9LFxuXG4gICAgZ2V0U2VsZWN0ZWRDb2x1bW5zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JpZC5zZWxlY3Rpb25Nb2RlbC5nZXRTZWxlY3RlZENvbHVtbnMoKTtcbiAgICB9LFxuXG4gICAgZ2V0U2VsZWN0aW9uczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyaWQuc2VsZWN0aW9uTW9kZWwuZ2V0U2VsZWN0aW9ucygpO1xuICAgIH0sXG5cbiAgICBnZXREYXRhOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YU1vZGVsLmdldERhdGEoKTtcbiAgICB9LFxuXG4gICAgZ2V0RmlsdGVyZWREYXRhOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YU1vZGVsLmdldEZpbHRlcmVkRGF0YSgpO1xuICAgIH0sXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBCZWhhdmlvcjtcbiIsIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfID0gcmVxdWlyZSgnb2JqZWN0LWl0ZXJhdG9ycycpO1xuXG52YXIgcHJvcGVydHlOYW1lcyA9IFtcbiAgICAnaW5kZXgnLFxuICAgICduYW1lJyxcbiAgICAnaGVhZGVyJyxcbiAgICAndHlwZSdcbl07XG5cbi8qKiBAc3VtbWFyeSBDcmVhdGUgYSBuZXcgYENvbHVtbmAgb2JqZWN0LlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0gYmVoYXZpb3JcbiAqIEBwYXJhbSB7bnVtYmVyfG9iamVjdH0gaW5kZXhPck9wdGlvbnMgLSBJZiBhIG51bWJlciwgc2hvcnRoYW5kIGZvciBgb3B0aW9ucy5pbmRleGAuXG4gKlxuICogRm9yIHBvc2l0aXZlIHZhbHVlcyBvZiBgb3B0aW9ucy5pbmRleGAsIHNlZSB7QGxpbmsgQ29sdW1uI2luaXRpYWxpemV8aW5pdGlhbGl6ZX0uIE5vdGUgdGhhdCBmb3IgbmV3IGNvbHVtbnMsIHlvdSBtdXN0IHN1cHBseSBlaXRoZXIgYGluZGV4YCBvciBgbmFtZWAuIElmIHlvdSBzdXBwbHkgYm90aCwgdGhleSBtdXN0IG1hdGNoIHRoZSBkZWZpbml0aWlvbiBpbiBkYXRhIG1vZGVsJ3MgYGZpZWxkc2AgbGlzdC5cbiAqXG4gKiBOZWdhdGl2ZSB2YWx1ZXMgYXJlIHNwZWNpYWwgY2FzZXM6XG4gKiBgaW5kZXhgIHwgTWVhbmluZ1xuICogOi0tLS0tOiB8IC0tLS0tLS0tXG4gKiAgICAtMSAgIHwgUm93IGhlYWRlciBjb2x1bW5cbiAqICAgIC0yICAgfCBUcmVlIChkcmlsbC1kb3duKSBjb2x1bW5cbiAqXG4gKlxuICovXG5mdW5jdGlvbiBDb2x1bW4oYmVoYXZpb3IsIGluZGV4T3JPcHRpb25zKSB7XG4gICAgdGhpcy5iZWhhdmlvciA9IGJlaGF2aW9yO1xuICAgIHRoaXMuZGF0YU1vZGVsID0gYmVoYXZpb3IuZGF0YU1vZGVsO1xuICAgIHRoaXMuY2VsbFByb3BlcnRpZXMgPSBbXTtcblxuICAgIHZhciBvcHRpb25zID0gdHlwZW9mIGluZGV4T3JPcHRpb25zID09PSAnb2JqZWN0JyA/IGluZGV4T3JPcHRpb25zIDogeyBpbmRleDogaW5kZXhPck9wdGlvbnMgfSxcbiAgICAgICAgaW5kZXggPSBvcHRpb25zLmluZGV4O1xuXG4gICAgc3dpdGNoIChpbmRleCkge1xuXG4gICAgICAgIGNhc2UgLTE6XG4gICAgICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICB0aGlzLm5hbWUgPSAnJztcbiAgICAgICAgICAgIHRoaXMuaGVhZGVyID0gJyc7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIC0yOlxuICAgICAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgdGhpcy5uYW1lID0gJ3RyZWUnO1xuICAgICAgICAgICAgdGhpcy5oZWFkZXIgPSAnVHJlZSc7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgICAgICAgIHRocm93ICdgaW5kZXhgIG91dCBvZiByYW5nZSc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0KG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuXG4gICAgfVxufVxuXG5Db2x1bW4ucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBDb2x1bW4ucHJvdG90eXBlLmNvbnN0cnVjdG9yLFxuXG4gICAgLyoqIEBzdW1tYXJ5IFNldCBvciByZXNldCB0aGUgcHJvcGVydGllcyBvZiBhIGNvbHVtbiBvYmplY3QuXG4gICAgICogQGRlc2MgV2hlbiAocmUpc2V0dGluZyBhIGNvbHVtbiBvYmplY3QsIHRoZSBvYmplY3QgbXVzdCBlbmQgdXAgd2l0aCBmdWxseSBkZWZpbmVkIGBpbmRleGAgYW5kIGBuYW1lYCBwcm9wZXJ0aWVzLiBJZiBvbmUgaXMgbWlzc2luZyBpdCB3aWxsIGJlIGRlcml2ZWQgZnJvbSB0aGUgZGF0YSBtb2RlbCdzIGBmaWVsZHNgIGxpc3QuXG4gICAgICogTm90ZTogVGhlc2UgcHJvcGVydGllcyBvZiB0aGUgY29sdW1uIG9iamVjdCBzaG91bGQgbm90IGJlIGNvbmZ1c2VkIHdpdGggdGhlIG1lbWJlcnMgb2YgdGhlIGNvbHVtblByb3BlcnRpZXMgb2JqZWN0IHdoaWNoIHN1cHBvcnRzIGdyaWQgcmVuZGVyIGFuZCBpcyBzb21ldGhpbmcgZWxzZSBlbnRpcmVseS5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIFJlcXVpcmVkIGJlY2F1c2UgeW91IG11c3Qgc3VwcGx5IGF0IGxlYXN0IGBpbmRleGAgb3IgYG5hbWVgLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucy5pbmRleF1cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMubmFtZV1cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMuaGVhZGVyXVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucy50eXBlXVxuICAgICAqL1xuICAgIHNldDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICB2YXIgZmllbGRzID0gdGhpcy5kYXRhTW9kZWwuZ2V0RmllbGRzKCk7XG4gICAgICAgIHZhciBjb2x1bW4gPSB0aGlzO1xuICAgICAgICBwcm9wZXJ0eU5hbWVzLmZvckVhY2goZnVuY3Rpb24ob3B0aW9uKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9uIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBjb2x1bW5bb3B0aW9uXSA9IG9wdGlvbnNbb3B0aW9uXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG9wdGlvbiA9PT0gJ25hbWUnKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbHVtbi5uYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uLm5hbWUgPSBmaWVsZHNbY29sdW1uLmluZGV4XTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvbHVtbi5pbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbi5pbmRleCA9IGZpZWxkcy5pbmRleE9mKGNvbHVtbi5uYW1lKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoY29sdW1uLmluZGV4ID09PSB1bmRlZmluZWQgfHwgY29sdW1uLm5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyAnRXhwZWN0ZWQgY29sdW1uIG5hbWUgb3IgaW5kZXguJztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGZpZWxkc1tjb2x1bW4uaW5kZXhdICE9PSBjb2x1bW4ubmFtZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyAnRXhwZWN0ZWQgdG8gZmluZCBgY29sdW1uLm5hbWVgIGluIHBvc2l0aW9uIGBjb2x1bW4uaW5kZXhgIGluIGRhdGEgbW9kZWxcXCdzIGZpZWxkcyBsaXN0Lic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgR2V0IG9yIHNldCB0aGUgdGV4dCBvZiB0aGUgY29sdW1uJ3MgaGVhZGVyLlxuICAgICAqIEBkZXNjIFRoZSBfaGVhZGVyXyBpcyB0aGUgbGFiZWwgYXQgdGhlIHRvcCBvZiB0aGUgY29sdW1uLlxuICAgICAqXG4gICAgICogU2V0dGluZyB0aGUgdmFsdWUgaGVyZSB1cGRhdGVzIHRoZSBoZWFkZXIgaW4gYm90aCB0aGlzIGNvbHVtbiBvYmplY3QgYXMgd2VsbCBhcyB0aGUgYGZpZWxkc2AgKGFrYSwgaGVhZGVyKSBhcnJheSBpbiB0aGUgdW5kZXJseWluZyBkYXRhIHNvdXJjZS5cbiAgICAgKlxuICAgICAqIFRoZSBuZXcgdGV4dCB3aWxsIGFwcGVhciBvbiB0aGUgbmV4dCByZXBhaW50LlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgc2V0IGhlYWRlcihoZWFkZXJUZXh0KSB7XG4gICAgICAgIHRoaXMuZGF0YU1vZGVsLmdldEhlYWRlcnMoKVt0aGlzLmluZGV4XSA9IHRoaXMuX2hlYWRlciA9IGhlYWRlclRleHQ7XG4gICAgfSxcbiAgICBnZXQgaGVhZGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGVhZGVyO1xuICAgIH0sXG5cbiAgICBnZXRVbmZpbHRlcmVkVmFsdWU6IGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YU1vZGVsLmdldFVuZmlsdGVyZWRWYWx1ZSh0aGlzLmluZGV4LCB5KTtcbiAgICB9LFxuXG4gICAgZ2V0VmFsdWU6IGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YU1vZGVsLmdldFZhbHVlKHRoaXMuaW5kZXgsIHkpO1xuICAgIH0sXG5cbiAgICBzZXRWYWx1ZTogZnVuY3Rpb24oeSwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YU1vZGVsLnNldFZhbHVlKHRoaXMuaW5kZXgsIHksIHZhbHVlKTtcbiAgICB9LFxuXG4gICAgZ2V0V2lkdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcHJvcGVydGllcyA9IHRoaXMuZ2V0UHJvcGVydGllcygpO1xuICAgICAgICByZXR1cm4gcHJvcGVydGllcyAmJiBwcm9wZXJ0aWVzLndpZHRoIHx8IHRoaXMuYmVoYXZpb3IucmVzb2x2ZVByb3BlcnR5KCdkZWZhdWx0Q29sdW1uV2lkdGgnKTtcbiAgICB9LFxuXG4gICAgc2V0V2lkdGg6IGZ1bmN0aW9uKHdpZHRoKSB7XG4gICAgICAgIHRoaXMuZ2V0UHJvcGVydGllcygpLndpZHRoID0gTWF0aC5tYXgoNSwgd2lkdGgpO1xuICAgIH0sXG5cbiAgICBnZXRDZWxsUmVuZGVyZXI6IGZ1bmN0aW9uKGNvbmZpZywgeCwgeSkge1xuICAgICAgICBjb25maWcudW50cmFuc2xhdGVkWCA9IHg7XG4gICAgICAgIGNvbmZpZy55ID0geTtcblxuICAgICAgICBjb25maWcueCA9IHRoaXMuaW5kZXg7XG4gICAgICAgIGNvbmZpZy5ub3JtYWxpemVkWSA9IHkgLSB0aGlzLmJlaGF2aW9yLmdldEhlYWRlclJvd0NvdW50KCk7XG5cbiAgICAgICAgLy8gTGVnYWN5IGNvbmZpZy54IGFuZCBjb25maWcueSB3ZXJlIGNvbmZ1c2luZyBiZWNhdXNlIHRoZSB4IHdhcyB0cmFuc2xhdGVkIHdoaWxlIHRoZSB5IHdhcyBub3QuXG4gICAgICAgIC8vIFRoZXNlIGhhdmUgYmVlbiBkZXByZWNhdGVkIGFuZCBhcmUgY3VycmVudGx5IGltcGxlbWVudGVkIGFzIGdldHRlcnMgd2l0aCBkZXByZWNhdGlvbiB3YXJuaW5ncy5cbiAgICAgICAgLy8gUmF0aGVyIHRoYW4gZGVmaW5pbmcgdGhlc2UgZ2V0dGVycyBoZXJlIG9uIGV2ZXJ5IGNlbGwgcmVuZGVyLCB0aGV5IGFyZSBkZWZpbmVkIG9uY2UgaW4gQmVoYXZpb3IucHJvdG90eXBlLmdldERlZmF1bHRTdGF0ZS5cbiAgICAgICAgLy9jb25maWcueCA9IHRoaXMuaW5kZXg7XG4gICAgICAgIC8vY29uZmlnLnkgPSB5O1xuXG4gICAgICAgIHZhciBkZWNsYXJlZFJlbmRlcmVyTmFtZSA9XG4gICAgICAgICAgICB0aGlzLmdldENlbGxQcm9wZXJ0aWVzKHkpLnJlbmRlcmVyIHx8XG4gICAgICAgICAgICB0aGlzLmdldFByb3BlcnRpZXMoKS5yZW5kZXJlcjtcblxuICAgICAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLmRhdGFNb2RlbC5nZXRDZWxsKGNvbmZpZywgZGVjbGFyZWRSZW5kZXJlck5hbWUpO1xuICAgICAgICByZW5kZXJlci5jb25maWcgPSBjb25maWc7XG4gICAgICAgIHJldHVybiByZW5kZXJlcjtcbiAgICB9LFxuXG4gICAgZ2V0Q2VsbFByb3BlcnRpZXM6IGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgeSA9IHRoaXMuZGF0YU1vZGVsLmdldERhdGFJbmRleCh5KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2VsbFByb3BlcnRpZXNbeV0gfHwge307XG4gICAgfSxcblxuICAgIHNldENlbGxQcm9wZXJ0aWVzOiBmdW5jdGlvbih5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmNlbGxQcm9wZXJ0aWVzW3ldID0gdmFsdWU7XG4gICAgfSxcblxuICAgIGNsZWFyQWxsQ2VsbFByb3BlcnRpZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmNlbGxQcm9wZXJ0aWVzLmxlbmd0aCA9IDA7XG4gICAgfSxcblxuICAgIGNoZWNrQ29sdW1uQXV0b3NpemluZzogZnVuY3Rpb24oZm9yY2UpIHtcbiAgICAgICAgdmFyIHByb3BlcnRpZXMgPSB0aGlzLmdldFByb3BlcnRpZXMoKTtcbiAgICAgICAgdmFyIGEsIGIsIGQ7XG4gICAgICAgIGlmIChwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBhID0gcHJvcGVydGllcy53aWR0aDtcbiAgICAgICAgICAgIGIgPSBwcm9wZXJ0aWVzLnByZWZlcnJlZFdpZHRoIHx8IGE7XG4gICAgICAgICAgICBkID0gcHJvcGVydGllcy5jb2x1bW5BdXRvc2l6ZWQgJiYgIWZvcmNlO1xuICAgICAgICAgICAgaWYgKGEgIT09IGIgfHwgIWQpIHtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzLndpZHRoID0gIWQgPyBiIDogTWF0aC5tYXgoYSwgYik7XG4gICAgICAgICAgICAgICAgcHJvcGVydGllcy5jb2x1bW5BdXRvc2l6ZWQgPSAhaXNOYU4ocHJvcGVydGllcy53aWR0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0Q2VsbFR5cGU6IGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5nZXRWYWx1ZSh5KTtcbiAgICAgICAgdmFyIHR5cGUgPSB0aGlzLnR5cGVPZih2YWx1ZSk7XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgIH0sXG5cbiAgICBnZXRUeXBlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHByb3BzID0gdGhpcy5nZXRQcm9wZXJ0aWVzKCk7XG4gICAgICAgIHZhciB0eXBlID0gcHJvcHMudHlwZTtcbiAgICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgICAgICB0eXBlID0gdGhpcy5jb21wdXRlQ29sdW1uVHlwZSgpO1xuICAgICAgICAgICAgaWYgKHR5cGUgIT09ICd1bmtub3duJykge1xuICAgICAgICAgICAgICAgIHByb3BzLnR5cGUgPSB0eXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgIH0sXG5cbiAgICBjb21wdXRlQ29sdW1uVHlwZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBoZWFkZXJSb3dDb3VudCA9IHRoaXMuYmVoYXZpb3IuZ2V0SGVhZGVyUm93Q291bnQoKTtcbiAgICAgICAgdmFyIGhlaWdodCA9IHRoaXMuYmVoYXZpb3IuZ2V0Um93Q291bnQoKTtcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5nZXRWYWx1ZShoZWFkZXJSb3dDb3VudCk7XG4gICAgICAgIHZhciBlYWNoVHlwZSA9IHRoaXMudHlwZU9mKHZhbHVlKTtcbiAgICAgICAgaWYgKCFlYWNoVHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuICd1bmtub3duJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgdHlwZSA9IHRoaXMudHlwZU9mKHZhbHVlKTtcbiAgICAgICAgdmFyIGlzTnVtYmVyID0gKCh0eXBlb2YgdmFsdWUpID09PSAnbnVtYmVyJyk7XG4gICAgICAgIGZvciAodmFyIHkgPSBoZWFkZXJSb3dDb3VudDsgeSA8IGhlaWdodDsgeSsrKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMuZ2V0VmFsdWUoeSk7XG4gICAgICAgICAgICBlYWNoVHlwZSA9IHRoaXMudHlwZU9mKHZhbHVlKTtcbiAgICAgICAgICAgIGlmICh0eXBlICE9PSBlYWNoVHlwZSkge1xuICAgICAgICAgICAgICAgIGlmIChpc051bWJlciAmJiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykpIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9ICdmbG9hdCc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdtaXhlZCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgIH0sXG5cbiAgICB0eXBlT2Y6IGZ1bmN0aW9uKHNvbWV0aGluZykge1xuICAgICAgICBpZiAoc29tZXRoaW5nID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0eXBlT2YgPSB0eXBlb2Ygc29tZXRoaW5nO1xuICAgICAgICBzd2l0Y2ggKHR5cGVPZikge1xuICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gc29tZXRoaW5nLmNvbnN0cnVjdG9yLm5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KHNvbWV0aGluZykgPT09IHNvbWV0aGluZyA/ICdpbnQnIDogJ2Zsb2F0JztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVPZjtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXRQcm9wZXJ0aWVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVoYXZpb3IuZ2V0UHJpdmF0ZVN0YXRlKCkuY29sdW1uUHJvcGVydGllc1t0aGlzLmluZGV4XTtcbiAgICB9LFxuXG4gICAgc2V0UHJvcGVydGllczogZnVuY3Rpb24ocHJvcGVydGllcykge1xuICAgICAgICB2YXIgY3VycmVudCA9IHRoaXMuZ2V0UHJvcGVydGllcygpO1xuICAgICAgICB0aGlzLmNsZWFyT2JqZWN0UHJvcGVydGllcyhjdXJyZW50LCBmYWxzZSk7XG4gICAgICAgIF8oY3VycmVudCkuZXh0ZW5kT3duKHByb3BlcnRpZXMpO1xuICAgIH0sXG5cbiAgICB0b2dnbGVTb3J0OiBmdW5jdGlvbihrZXlzKSB7XG4gICAgICAgIHRoaXMuZGF0YU1vZGVsLnRvZ2dsZVNvcnQodGhpcy5pbmRleCwga2V5cyk7XG4gICAgfSxcblxuICAgIHVuU29ydDogZnVuY3Rpb24oZGVmZXJyZWQpIHtcbiAgICAgICAgdGhpcy5kYXRhTW9kZWwudW5Tb3J0Q29sdW1uKHRoaXMuaW5kZXgsIGRlZmVycmVkKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgZGV0ZXJtaW5lcyB0aGUgcHJvcG9zZWQgY2VsbCBlZGl0b3IgbmFtZSBmcm9tIHRoZSByZW5kZXIgcHJvcGVydGllcy4gVGhlIGFsZ29yaXRobSBpczpcbiAgICAgKiAxLiBgZWRpdG9yYCByZW5kZXIgcHJvcGVydHkgKGNlbGwgZWRpdG9yIG5hbWUpXG4gICAgICogMi4gYGZvcm1hdGAgcmVuZGVyIHByb3BlcnR5IChsb2NhbGl6ZXIgbmFtZSlcbiAgICAgKiAzLiBgdHlwZWAgY29sdW1uIHByb3BlcnR5ICh0eXBlIG5hbWUpXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgXCJyZW5kZXIgcHJvcGVydHlcIiBtZWFucyBpbiBlYWNoIGNhc2UgdGhlIGZpcnN0IGRlZmluZWQgcHJvcGVydHkgZm91bmQgb24gdGhlIGNlbGwsIGNvbHVtbiwgb3IgZ3JpZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gVGhlIG9yaWdpbmFsIHVudHJhbnNsYXRlZCByb3cgaW5kZXguXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBXaWxsIGJlIGRlY29yYXRlZCB3aXRoIGBmb3JtYXRgIGFuZCBgY29sdW1uYC5cbiAgICAgKiBAcGFyYW0ge1BvaW50fSBvcHRpb25zLmVkaXRQb2ludFxuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR8Q2VsbEVkaXRvcn0gRmFsc3kgdmFsdWUgbWVhbnMgZWl0aGVyIG5vIGRlY2xhcmVkIGNlbGwgZWRpdG9yIF9vcl8gaW5zdGFudGlhdGlvbiBhYm9ydGVkIGJ5IGZhbHN5IHJldHVybiByZXR1cm4gZnJvbSBmaXJlUmVxdWVzdENlbGxFZGl0LlxuICAgICAqL1xuICAgIGdldENlbGxFZGl0b3JBdDogZnVuY3Rpb24oeSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgY2VsbEVkaXRvcixcbiAgICAgICAgICAgIGNlbGxQcm9wcyA9IHRoaXMuZ2V0Q2VsbFByb3BlcnRpZXMoeSksXG4gICAgICAgICAgICBjb2x1bW5Qcm9wcyA9IHRoaXMuZ2V0UHJvcGVydGllcygpLFxuICAgICAgICAgICAgZWRpdG9yTmFtZSA9IGNlbGxQcm9wcy5lZGl0b3IgfHwgY29sdW1uUHJvcHMuZWRpdG9yO1xuXG4gICAgICAgIG9wdGlvbnMuZm9ybWF0ID0gY2VsbFByb3BzLmZvcm1hdCB8fCBjb2x1bW5Qcm9wcy5mb3JtYXQ7XG5cbiAgICAgICAgY2VsbEVkaXRvciA9IHRoaXMuZGF0YU1vZGVsLmdldENlbGxFZGl0b3JBdCh0aGlzLmluZGV4LCB5LCBlZGl0b3JOYW1lLCBvcHRpb25zKTtcblxuICAgICAgICBpZiAoY2VsbEVkaXRvciAmJiAhY2VsbEVkaXRvci5ncmlkKSB7XG4gICAgICAgICAgICAvLyBjZWxsIGVkaXRvciByZXR1cm5lZCBidXQgbm90IGZ1bGx5IGluc3RhbnRpYXRlZCAoYWJvcnRlZCBieSBmYWxzeSByZXR1cm4gZnJvbSBmaXJlUmVxdWVzdENlbGxFZGl0KVxuICAgICAgICAgICAgY2VsbEVkaXRvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjZWxsRWRpdG9yO1xuICAgIH0sXG5cbiAgICBnZXRGb3JtYXR0ZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbG9jYWxpemVyTmFtZSA9IHRoaXMuZ2V0UHJvcGVydGllcygpLmZvcm1hdDtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVoYXZpb3IuZ3JpZC5sb2NhbGl6YXRpb24uZ2V0KGxvY2FsaXplck5hbWUpLmZvcm1hdDtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbHVtbjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIExvY2FsID0gcmVxdWlyZSgnLi9Mb2NhbCcpO1xudmFyIERhdGFNb2RlbEpTT04gPSByZXF1aXJlKCcuLi9kYXRhTW9kZWxzL0pTT04nKTtcbnZhciBDb2x1bW5TY2hlbWFGYWN0b3J5ID0gcmVxdWlyZSgnLi4vZmlsdGVyL0NvbHVtblNjaGVtYUZhY3RvcnknKTtcbnZhciBmZWF0dXJlcyA9IHJlcXVpcmUoJy4uL2ZlYXR1cmVzJyk7XG52YXIgYWdncmVnYXRpb25zID0gcmVxdWlyZSgnLi4vU2hhcmVkLmpzJykuYW5hbHl0aWNzLnV0aWwuYWdncmVnYXRpb25zO1xuXG4vKipcbiAqIEBuYW1lIGJlaGF2aW9ycy5KU09OXG4gKiBAZGVzYyA+IFNhbWUgcGFyYW1ldGVycyBhcyB7QGxpbmsgYmVoYXZpb3JzLkJlaGF2aW9yI2luaXRpYWxpemV8aW5pdGlhbGl6ZX0sIHdoaWNoIGlzIGNhbGxlZCBieSB0aGlzIGNvbnN0cnVjdG9yLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBCZWhhdmlvclxuICovXG52YXIgSlNPTiA9IExvY2FsLmV4dGVuZCgnYmVoYXZpb3JzLkpTT04nLCB7XG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBDb25zdHJ1Y3RvciBsb2dpYywgY2FsbGVkIF9hZnRlcl97QGxpbmsgQmVoYXZpb3IjaW5pdGlhbGl6ZXxCZWhhdmlvci5pbml0aWFsaXplKCl9LlxuICAgICAqIEBkZXNjIFRoaXMgbWV0aG9kIHdpbGwgYmUgY2FsbGVkIHVwb24gaW5zdGFudGlhdGlvbiBvZiB0aGlzIGNsYXNzIG9yIG9mIGFueSBjbGFzcyB0aGF0IGV4dGVuZHMgZnJvbSB0aGlzIGNsYXNzLlxuICAgICAqID4gQWxsIGBpbml0aWFsaXplKClgIG1ldGhvZHMgaW4gdGhlIGluaGVyaXRhbmNlIGNoYWluIGFyZSBjYWxsZWQsIGluIHR1cm4sIGVhY2ggd2l0aCB0aGUgc2FtZSBwYXJhbWV0ZXJzIHRoYXQgd2VyZSBwYXNzZWQgdG8gdGhlIGNvbnN0cnVjdG9yLCBiZWdpbm5pbmcgd2l0aCB0aGF0IG9mIHRoZSBtb3N0IFwic2VuaW9yXCIgY2xhc3MgdGhyb3VnaCB0aGF0IG9mIHRoZSBjbGFzcyBvZiB0aGUgbmV3IGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGdyaWQgLSB0aGUgaHlwZXJncmlkXG4gICAgICogQHBhcmFtIHt1bmRlZmluZWR8ZnVuY3Rpb258bWVudUl0ZW1bXX0gc2NoZW1hIC0gQWxyZWFkeSBjb25zdW1lZCBieSBCZWhhdmlvcidzIHtAbGluayBCZWhhdmlvciNpbml0aWFsaXplfGluaXRpYWxpemV9LlxuICAgICAqIEBwYXJhbSB7b2JqZWN0W119IGRhdGFSb3dzIC0gTWF5IGJlOlxuICAgICAqICogQW4gYXJyYXkgb2YgY29uZ3J1ZW50IHJhdyBkYXRhIG9iamVjdHNcbiAgICAgKiAqIEEgZnVuY3Rpb24gcmV0dXJuaW5nIHNhbWVcbiAgICAgKiBAbWVtYmVyT2YgYmVoYXZpb3JzLkpTT04ucHJvdG90eXBlXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oZ3JpZCwgc2NoZW1hLCBkYXRhUm93cykge1xuICAgICAgICB0aGlzLnNldERhdGEoZGF0YVJvd3MsIHNjaGVtYSk7XG4gICAgfSxcblxuICAgIGZlYXR1cmVzOiBbXG4gICAgICAgIGZlYXR1cmVzLkNlbGxTZWxlY3Rpb24sXG4gICAgICAgIGZlYXR1cmVzLktleVBhZ2luZyxcbiAgICAgICAgZmVhdHVyZXMuQ29sdW1uUGlja2VyLFxuICAgICAgICBmZWF0dXJlcy5Db2x1bW5SZXNpemluZyxcbiAgICAgICAgZmVhdHVyZXMuUm93UmVzaXppbmcsXG4gICAgICAgIGZlYXR1cmVzLkZpbHRlcnMsXG4gICAgICAgIGZlYXR1cmVzLlJvd1NlbGVjdGlvbixcbiAgICAgICAgZmVhdHVyZXMuQ29sdW1uU2VsZWN0aW9uLFxuICAgICAgICBmZWF0dXJlcy5Db2x1bW5Nb3ZpbmcsXG4gICAgICAgIGZlYXR1cmVzLkNvbHVtblNvcnRpbmcsXG4gICAgICAgIGZlYXR1cmVzLkNlbGxFZGl0aW5nLFxuICAgICAgICBmZWF0dXJlcy5DZWxsQ2xpY2ssXG4gICAgICAgIGZlYXR1cmVzLk9uSG92ZXJcbiAgICBdLFxuXG4gICAgYWdncmVnYXRpb25zOiBhZ2dyZWdhdGlvbnMsXG5cbiAgICBjcmVhdGVDb2x1bW5zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRhdGFNb2RlbCA9IHRoaXMuZGF0YU1vZGVsO1xuICAgICAgICB2YXIgY29sdW1uQ291bnQgPSBkYXRhTW9kZWwuZ2V0Q29sdW1uQ291bnQoKTtcbiAgICAgICAgdmFyIGhlYWRlcnMgPSBkYXRhTW9kZWwuZ2V0SGVhZGVycygpO1xuICAgICAgICB2YXIgZmllbGRzID0gZGF0YU1vZGVsLmdldEZpZWxkcygpO1xuICAgICAgICB2YXIgUkVHRVhfQ0FNRUxfQ0FTRSA9IC8oW15fQS1aXSkoW0EtWl0rKS9nO1xuICAgICAgICB0aGlzLmNsZWFyQ29sdW1ucygpO1xuICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgY29sdW1uQ291bnQ7IGluZGV4KyspIHtcbiAgICAgICAgICAgIHZhciBoZWFkZXIgPSBoZWFkZXJzW2luZGV4XTtcbiAgICAgICAgICAgIHZhciBjb2x1bW4gPSB0aGlzLmFkZENvbHVtbih7IGluZGV4OiBpbmRleCwgaGVhZGVyOiBoZWFkZXIgfSk7XG4gICAgICAgICAgICB0aGlzLmNvbHVtbkVudW1bY29sdW1uLm5hbWUucmVwbGFjZShSRUdFWF9DQU1FTF9DQVNFLCAnJDFfJDInKS50b1VwcGVyQ2FzZSgpXSA9IGluZGV4O1xuICAgICAgICAgICAgdmFyIHByb3BlcnRpZXMgPSBjb2x1bW4uZ2V0UHJvcGVydGllcygpO1xuICAgICAgICAgICAgcHJvcGVydGllcy5maWVsZCA9IGZpZWxkc1tpbmRleF07XG4gICAgICAgICAgICBwcm9wZXJ0aWVzLmhlYWRlciA9IGhlYWRlcjtcbiAgICAgICAgICAgIHByb3BlcnRpZXMuY29tcGxleEZpbHRlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0TmV3RGF0YU1vZGVsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRhTW9kZWxKU09OKHRoaXMuZ3JpZCk7XG4gICAgfSxcblxuICAgIGFwcGx5QW5hbHl0aWNzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5kYXRhTW9kZWwuYXBwbHlBbmFseXRpY3MoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIGJlaGF2aW9ycy5KU09OLnByb3RvdHlwZVxuICAgICAqIEBkZXNjcmlwdGlvbiBTZXQgdGhlIGhlYWRlciBsYWJlbHMuXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gaGVhZGVyTGFiZWxzIC0gVGhlIGhlYWRlciBsYWJlbHMuXG4gICAgICovXG4gICAgc2V0SGVhZGVyczogZnVuY3Rpb24oaGVhZGVyTGFiZWxzKSB7XG4gICAgICAgIHRoaXMuZGF0YU1vZGVsLnNldEhlYWRlcnMoaGVhZGVyTGFiZWxzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIGJlaGF2aW9ycy5KU09OLnByb3RvdHlwZVxuICAgICAqIEBkZXNjcmlwdGlvbiBTZXQgdGhlIGZpZWxkcyBhcnJheS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBmaWVsZE5hbWVzIC0gVGhlIGZpZWxkIG5hbWVzLlxuICAgICAqL1xuICAgIHNldEZpZWxkczogZnVuY3Rpb24oZmllbGROYW1lcykge1xuICAgICAgICAvL3dlcmUgZGVmaW5pbmcgdGhlIGNvbHVtbnMgYmFzZWQgb24gZmllbGQgbmFtZXMuLi4uXG4gICAgICAgIC8vd2UgbXVzdCByZWJ1aWxkIHRoZSBjb2x1bW4gZGVmaW5pdGlvbnNcbiAgICAgICAgdGhpcy5kYXRhTW9kZWwuc2V0RmllbGRzKGZpZWxkTmFtZXMpO1xuICAgICAgICB0aGlzLmNyZWF0ZUNvbHVtbnMoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIGJlaGF2aW9ycy5KU09OLnByb3RvdHlwZVxuICAgICAqIEBkZXNjcmlwdGlvbiBTZXQgdGhlIGRhdGEgZmllbGQuXG4gICAgICogQHBhcmFtIHtvYmplY3RbXX0gZGF0YVJvd3MgLSBBbiBhcnJheSBvZiB1bmlmb3JtIG9iamVjdHMgYmFja2luZyB0aGUgcm93cyBpbiB0aGUgZ3JpZC5cbiAgICAgKi9cbiAgICBzZXREYXRhOiBmdW5jdGlvbihkYXRhUm93cywgb3B0aW9ucykge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICBncmlkID0gdGhpcy5ncmlkO1xuXG4gICAgICAgIHRoaXMuZGF0YU1vZGVsLnNldERhdGEoZGF0YVJvd3MsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmNyZWF0ZUNvbHVtbnMoKTtcblxuICAgICAgICB0aGlzLnNjaGVtYSA9IG9wdGlvbnMgJiYgb3B0aW9ucy5zY2hlbWEgfHwgZGVyaXZlU2NoZW1hO1xuICAgICAgICB0aGlzLnNldEdsb2JhbEZpbHRlcih0aGlzLmdldE5ld0ZpbHRlcigpKTtcblxuICAgICAgICBpZiAoZ3JpZC5jZWxsRWRpdG9yKSB7XG4gICAgICAgICAgICBncmlkLmNlbGxFZGl0b3IuY2FuY2VsRWRpdGluZygpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGdyaWQuaXNDb2x1bW5BdXRvc2l6aW5nKCkpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5hdXRvc2l6ZUFsbENvbHVtbnMoKTtcbiAgICAgICAgICAgIH0sIDEwMCk7XG4gICAgICAgICAgICBncmlkLmFsbG93RXZlbnRzKGRhdGFSb3dzLmxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHNlbGYuZ2V0Q29sdW1uKC0xKS5jaGVja0NvbHVtbkF1dG9zaXppbmcodHJ1ZSk7XG4gICAgICAgICAgICAgICAgZ3JpZC5hbGxvd0V2ZW50cyhkYXRhUm93cy5sZW5ndGgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgU2V0IHRoZSB0b3AgdG90YWxzLlxuICAgICAqIEBtZW1iZXJPZiBiZWhhdmlvcnMuSlNPTi5wIHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtBcnJheTxBcnJheT59IHRvdGFsUm93cyAtIGFycmF5IG9mIHJvd3MgKGFycmF5cykgb2YgdG90YWxzXG4gICAgICovXG4gICAgc2V0VG9wVG90YWxzOiBmdW5jdGlvbih0b3RhbFJvd3MpIHtcbiAgICAgICAgdGhpcy5kYXRhTW9kZWwuc2V0VG9wVG90YWxzKHRvdGFsUm93cyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IEdldCB0aGUgdG9wIHRvdGFscy5cbiAgICAgKiBAbWVtYmVyT2YgYmVoYXZpb3JzLkpTT04ucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge0FycmF5PEFycmF5Pn1cbiAgICAgKi9cbiAgICBnZXRUb3BUb3RhbHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhTW9kZWwuZ2V0VG9wVG90YWxzKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IFNldCB0aGUgYm90dG9tIHRvdGFscy5cbiAgICAgKiBAbWVtYmVyT2YgYmVoYXZpb3JzLkpTT04ucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtBcnJheTxBcnJheT59IHRvdGFsUm93cyAtIGFycmF5IG9mIHJvd3MgKGFycmF5cykgb2YgdG90YWxzXG4gICAgICovXG4gICAgc2V0Qm90dG9tVG90YWxzOiBmdW5jdGlvbih0b3RhbFJvd3MpIHtcbiAgICAgICAgdGhpcy5kYXRhTW9kZWwuc2V0Qm90dG9tVG90YWxzKHRvdGFsUm93cyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IEdldCB0aGUgYm90dG9tIHRvdGFscy5cbiAgICAgKiBAbWVtYmVyT2YgYmVoYXZpb3JzLkpTT04ucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge0FycmF5PEFycmF5Pn1cbiAgICAgKi9cbiAgICBnZXRCb3R0b21Ub3RhbHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhTW9kZWwuZ2V0Qm90dG9tVG90YWxzKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBiZWhhdmlvcnMuSlNPTi5wcm90b3R5cGVcbiAgICAgKiBAZGVzY3JpcHRpb24gQnVpbGQgdGhlIGZpZWxkcyBhbmQgaGVhZGVycyBmcm9tIHRoZSBzdXBwbGllZCBjb2x1bW4gZGVmaW5pdGlvbnMuXG4gICAgICogYGBgamF2YXNjcmlwdFxuICAgICAqIG15SnNvbkJlaGF2aW9yLnNldENvbHVtbnMoW1xuICAgICAqICAgICB7IGhlYWRlcjogJ1N0b2NrIE5hbWUnLCBuYW1lOiAnc2hvcnRfZGVzY3JpcHRpb24nIH0sXG4gICAgICogICAgIHsgaGVhZGVyOiAnU3RhdHVzJywgbmFtZTogJ3RyYWRpbmdfcGhhc2UnIH0sXG4gICAgICogICAgIHsgaGVhZGVyOiAnUmVmZXJlbmNlIFByaWNlJywgbmFtZTogJ3JlZmVyZW5jZV9wcmljZScgfVxuICAgICAqIF0pO1xuICAgICAqIGBgYFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGNvbHVtbkRlZmluaXRpb25zIC0gYW4gYXJyYXkgb2Ygb2JqZWN0cyB3aXRoIGZpZWxkcyAndGl0bGUnLCBhbmQgJ2ZpZWxkJ1xuICAgICAqL1xuICAgIHNldENvbHVtbnM6IGZ1bmN0aW9uKGNvbHVtbkRlZmluaXRpb25zKSB7XG4gICAgICAgIHRoaXMuZGF0YU1vZGVsLnNldENvbHVtbnMoY29sdW1uRGVmaW5pdGlvbnMpOyAvLyBUT0RPOiB0aGlzIG1ldGhvZCBpcyBtaXNzaW5nXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBiZWhhdmlvcnMuSlNPTi5wcm90b3R5cGVcbiAgICAgKiBAZGVzY3JpcHRpb24gRW5oYW5jZSB0aGUgZG91YmxlLWNsaWNrIGV2ZW50IGp1c3QgYmVmb3JlIGl0J3MgYnJvYWRjYXN0IHRvIGxpc3RlbmVycy5cbiAgICAgKiBAcGFyYW0ge1BvaW50fSBldmVudFxuICAgICAqL1xuICAgIGVuaGFuY2VEb3VibGVDbGlja0V2ZW50OiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICBldmVudC5yb3cgPSB0aGlzLmdldFJvdyhldmVudC5ncmlkQ2VsbC55KTtcbiAgICB9LFxuXG4gICAgc2V0RGF0YVByb3ZpZGVyOiBmdW5jdGlvbihkYXRhUHJvdmlkZXIpIHtcbiAgICAgICAgdGhpcy5kYXRhTW9kZWwuc2V0RGF0YVByb3ZpZGVyKGRhdGFQcm92aWRlcik7XG4gICAgfSxcblxuICAgIGhhc0hpZXJhcmNoeUNvbHVtbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFNb2RlbC5oYXNIaWVyYXJjaHlDb2x1bW4oKTtcbiAgICB9LFxuXG4gICAgZ2V0Q29sdW1uQWxpZ25tZW50OiBmdW5jdGlvbih4KSB7XG4gICAgICAgIGlmICh4ID09PSAwICYmIHRoaXMuaGFzSGllcmFyY2h5Q29sdW1uKCkpIHtcbiAgICAgICAgICAgIHJldHVybiAnbGVmdCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gJ2NlbnRlcic7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0R3JvdXBzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YU1vZGVsLmdldEdyb3VwcygpO1xuICAgIH0sXG4gICAgZ2V0QXZhaWxhYmxlR3JvdXBzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YU1vZGVsLmdldEF2YWlsYWJsZUdyb3VwcygpO1xuICAgIH0sXG4gICAgZ2V0SGlkZGVuQ29sdW1uczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFNb2RlbC5nZXRIaWRkZW5Db2x1bW5zKCk7XG4gICAgfSxcblxuICAgIGdldEFjdGl2ZUNvbHVtbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhTW9kZWwuZ2V0QWN0aXZlQ29sdW1ucygpO1xuICAgIH0sXG4gICAgZ2V0VmlzaWJsZUNvbHVtbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZXByZWNhdGVkKCdnZXRWaXNpYmxlQ29sdW1ucygpJywgJ2dldEFjdGl2ZUNvbHVtbnMoKScsICcxLjAuNicsIGFyZ3VtZW50cyk7XG4gICAgfSxcblxuICAgIGdldFNlbGVjdGVkUm93czogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBvZmZzZXQgPSAtdGhpcy5ncmlkLmdldEhlYWRlclJvd0NvdW50KCk7XG4gICAgICAgIHZhciBzZWxlY3Rpb25zID0gdGhpcy5ncmlkLnNlbGVjdGlvbk1vZGVsLmdldFNlbGVjdGVkUm93cygpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gc2VsZWN0aW9ucy5tYXAoZnVuY3Rpb24oZWFjaCkge1xuICAgICAgICAgICAgcmV0dXJuIGVhY2ggKyBvZmZzZXQ7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBnZXRTZWxlY3RlZENvbHVtbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ncmlkLnNlbGVjdGlvbk1vZGVsLmdldFNlbGVjdGVkQ29sdW1ucygpO1xuICAgIH0sXG5cbiAgICBnZXRTZWxlY3Rpb25zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JpZC5zZWxlY3Rpb25Nb2RlbC5nZXRTZWxlY3Rpb25zKCk7XG4gICAgfSxcblxuICAgIGdldFNvcnRlZENvbHVtbkluZGV4ZXM6IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gdGhpcy5kYXRhTW9kZWwuZ2V0U29ydGVkQ29sdW1uSW5kZXhlcygpO1xuICAgIH0sXG5cbiAgICBzb3J0Q2hhbmdlZDogZnVuY3Rpb24oaGlkZGVuQ29sdW1ucyl7XG4gICAgICAgIHZhciBkaXJ0eSA9IHJlbW92ZUhpZGRlbkNvbHVtbnMoXG4gICAgICAgICAgICB0aGlzLmdldFNvcnRlZENvbHVtbkluZGV4ZXMoKSxcbiAgICAgICAgICAgIChoaWRkZW5Db2x1bW5zIHx8IHRoaXMuZ2V0SGlkZGVuQ29sdW1ucygpKVxuICAgICAgICApO1xuICAgICAgICBpZiAoZGlydHkpe1xuICAgICAgICAgICAgdGhpcy5hcHBseUFuYWx5dGljcygpO1xuICAgICAgICB9XG4gICAgfVxuXG59KTtcblxuXG5mdW5jdGlvbiBkZXJpdmVTY2hlbWEoKSB7XG4gICAgcmV0dXJuIG5ldyBDb2x1bW5TY2hlbWFGYWN0b3J5KHRoaXMuY29sdW1ucykuc2NoZW1hO1xufVxuXG5cbi8vTG9naWMgdG8gbW92ZWQgdG8gYWRhcHRlciBsYXllciBvdXRzaWRlIG9mIEh5cGVyZ3JpZCBDb3JlXG5mdW5jdGlvbiByZW1vdmVIaWRkZW5Db2x1bW5zKG9sZFNvcnRlZCwgaGlkZGVuQ29sdW1ucyl7XG4gICAgdmFyIGRpcnR5ID0gZmFsc2U7XG4gICAgb2xkU29ydGVkLmZvckVhY2goZnVuY3Rpb24oaSkge1xuICAgICAgICB2YXIgaiA9IDAsXG4gICAgICAgICAgICBjb2xJbmRleDtcbiAgICAgICAgd2hpbGUgKGogPCBoaWRkZW5Db2x1bW5zLmxlbmd0aCkge1xuICAgICAgICAgICAgY29sSW5kZXggPSBoaWRkZW5Db2x1bW5zW2pdLmluZGV4ICsgMTsgLy9oYWNrIHRvIGdldCBhcm91bmQgMCBpbmRleFxuICAgICAgICAgICAgaWYgKGNvbEluZGV4ID09PSBpKSB7XG4gICAgICAgICAgICAgICAgaGlkZGVuQ29sdW1uc1tqXS51blNvcnQoKTtcbiAgICAgICAgICAgICAgICBkaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBqKys7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZGlydHk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gSlNPTjtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy92YXIgTGlzdERyYWdvbiA9IHJlcXVpcmUoJ2xpc3QtZHJhZ29uJyk7XG5cbnZhciBCZWhhdmlvciA9IHJlcXVpcmUoJy4vQmVoYXZpb3InKTtcbi8vdmFyIERhdGFNb2RlbEpTT04gPSByZXF1aXJlKCcuLi9kYXRhTW9kZWxzL0pTT04nKTtcbi8vdmFyIGZlYXR1cmVzID0gcmVxdWlyZSgnLi4vZmVhdHVyZXMnKTtcbi8vdmFyIGFnZ3JlZ2F0aW9ucyA9IHJlcXVpcmUoJy4uL2xvY2FsX25vZGVfbW9kdWxlcy9maW5hbmFseXRpY3MnKS5hZ2dyZWdhdGlvbnM7XG5cbi8qKlxuICogQG5hbWUgYmVoYXZpb3JzLkxvY2FsXG4gKiBAZGVzYyA+IFNhbWUgcGFyYW1ldGVycyBhcyB7QGxpbmsgYmVoYXZpb3JzLkJlaGF2aW9yI2luaXRpYWxpemV8aW5pdGlhbGl6ZX0sIHdoaWNoIGlzIGNhbGxlZCBieSB0aGlzIGNvbnN0cnVjdG9yLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBCZWhhdmlvclxuICovXG52YXIgTG9jYWwgPSBCZWhhdmlvci5leHRlbmQoJ0xvY2FsJywge1xuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBMb2NhbDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEJlaGF2aW9yID0gcmVxdWlyZSgnLi9CZWhhdmlvcicpO1xuXG52YXIgbm9vcCA9IGZ1bmN0aW9uKCkge30sXG4gICAgbjAwcCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIEJlaGF2aW9yXG4gKi9cbnZhciBOdWxsID0gQmVoYXZpb3IuZXh0ZW5kKCdOdWxsJywge1xuXG4gICAgLy9pbml0YWxpemU6IGZ1bmN0aW9uKGdyaWQsIGNvbXBvbmVudCkge30sXG5cbiAgICBzZXRTY3JvbGxQb3NpdGlvblk6IG5vb3AsXG4gICAgc2V0U2Nyb2xsUG9zaXRpb25YOiBub29wLFxuICAgIGdldEFjdGl2ZUNvbHVtbkNvdW50OiBuMDBwLFxuICAgIGdldEZpeGVkQ29sdW1uQ291bnQ6IG4wMHAsXG4gICAgZ2V0Rml4ZWRDb2x1bW5zV2lkdGg6IG4wMHAsXG4gICAgZ2V0Rml4ZWRDb2x1bW5zTWF4V2lkdGg6IG4wMHAsXG4gICAgc2V0UmVuZGVyZWRXaWR0aDogbjAwcCxcbiAgICBnZXRSb3dDb3VudDogbjAwcCxcbiAgICBnZXRGaXhlZFJvd0NvdW50OiBuMDBwLFxuICAgIGdldEZpeGVkUm93c0hlaWdodDogbjAwcCxcbiAgICBnZXRGaXhlZFJvd3NNYXhIZWlnaHQ6IG4wMHAsXG4gICAgc2V0UmVuZGVyZWRIZWlnaHQ6IG4wMHAsXG4gICAgZ2V0Q2VsbFByb3ZpZGVyOiBub29wLFxuICAgIGNsaWNrOiBub29wLFxuICAgIGRvdWJsZUNsaWNrOiBub29wXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBOdWxsO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBCZWhhdmlvcjogcmVxdWlyZSgnLi9CZWhhdmlvcicpLCAvLyBhYnN0cmFjdCBiYXNlIGNsYXNzXG4gICAgSlNPTjogcmVxdWlyZSgnLi9KU09OJyksXG4gICAgTnVsbDogcmVxdWlyZSgnLi9OdWxsJylcbn07IiwiLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIG11c3RhY2hlID0gcmVxdWlyZSgnbXVzdGFjaGUnKTtcbnZhciBfID0gcmVxdWlyZSgnb2JqZWN0LWl0ZXJhdG9ycycpO1xuXG52YXIgQmFzZSA9IHJlcXVpcmUoJy4uL2xpYi9CYXNlJyk7XG52YXIgZWZmZWN0cyA9IHJlcXVpcmUoJy4uL2xpYi9lZmZlY3RzJyk7XG52YXIgTG9jYWxpemF0aW9uID0gcmVxdWlyZSgnLi4vbGliL0xvY2FsaXphdGlvbicpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgQ2VsbEVkaXRvciA9IEJhc2UuZXh0ZW5kKCdDZWxsRWRpdG9yJywge1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGdyaWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucyAtIFByb3BlcnRpZXMgbGlzdGVkIGJlbG93ICsgYXJiaXRyYXJ5IG11c3RhY2hlIFwidmFyaWFibGVzXCIgZm9yIG1lcmdpbmcgaW50byB0ZW1wbGF0ZS5cbiAgICAgKiBAcGFyYW0ge1BvaW50fSBvcHRpb25zLmVkaXRQb2ludFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5mb3JtYXRdIC0gTmFtZSBvZiBhIGxvY2FsaXplciB3aXRoIHdoaWNoIHRvIG92ZXJyaWRlIHByb3RvdHlwZSdzIGBsb2NhbGl6ZXJgIHByb3BlcnR5LlxuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKGdyaWQsIG9wdGlvbnMpIHtcblxuICAgICAgICAvLyBFc3RhYmxpc2ggYHRoaXMuZWRpdFBvaW50YCBhbmQgcG9zc2libHkgYHRoaXMuZm9ybWF0YDsgcGx1cyBvdGhlciBhcmJpdHJhcnkgcHJvcGVydGllcyBmb3IgbXVzdGFjaGUgdXNlLlxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkoa2V5KSAmJiB0aGlzW2tleV0gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzW2tleV0gPSBvcHRpb25zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdmFsdWUgPSBncmlkLmJlaGF2aW9yLmdldFZhbHVlKHRoaXMuZWRpdFBvaW50LngsIHRoaXMuZWRpdFBvaW50LnkpO1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZVsxXTsgLy9pdCdzIGEgbmVzdGVkIG9iamVjdFxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIG15IGluc3RhbmNlIG9mIGh5cGVyZ3JpZFxuICAgICAgICAgKiBAdHlwZSB7SHlwZXJncmlkfVxuICAgICAgICAgKiBAbWVtYmVyT2YgQ2VsbEVkaXRvci5wcm90b3R5cGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ3JpZCA9IGdyaWQ7XG5cbiAgICAgICAgdGhpcy5ncmlkLmNlbGxFZGl0b3IgPSB0aGlzO1xuXG4gICAgICAgIHRoaXMubG9jYWxlID0gZ3JpZC5sb2NhbGl6YXRpb24ubG9jYWxlOyAvLyBmb3IgdGVtcGxhdGUncyBgbGFuZ2AgYXR0cmlidXRlXG5cbiAgICAgICAgLy8gb3ZlcnJpZGUgbmF0aXZlIGxvY2FsaXplciB3aXRoIGxvY2FsaXplciBuYW1lZCBpbiBmb3JtYXQgaWYgZGVmaW5lZCAoZnJvbSBpbnN0YW50aWF0aW9uIG9wdGlvbnMpXG4gICAgICAgIGlmICh0aGlzLmZvcm1hdCkge1xuICAgICAgICAgICAgdGhpcy5sb2NhbGl6ZXIgPSB0aGlzLmdyaWQubG9jYWxpemF0aW9uLmdldCh0aGlzLmZvcm1hdCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmluaXRpYWxWYWx1ZSA9IHZhbHVlO1xuXG4gICAgICAgIHZhciBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdESVYnKTtcbiAgICAgICAgY29udGFpbmVyLmlubmVySFRNTCA9IG11c3RhY2hlLnJlbmRlcih0aGlzLnRlbXBsYXRlLCB0aGlzKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBvYmplY3QncyBpbnB1dCBjb250cm9sLCBvbmUgb2Y6XG4gICAgICAgICAqICogKmlucHV0IGVsZW1lbnQqIC0gYW4gYEhUTUxFbGVtZW50YCB0aGF0IGhhcyBhIGB2YWx1ZWAgYXR0cmlidXRlLCBzdWNoIGFzIGBIVE1MSW5wdXRFbGVtZW50YCwgYEhUTUxCdXR0b25FbGVtZW50YCwgZXRjLlxuICAgICAgICAgKiAqICpjb250YWluZXIgZWxlbWVudCogLSBhbiBgSFRNTEVsZW1lbnRgIGNvbnRhaW5pbmcgb25lIG9yIG1vcmUgaW5wdXQgZWxlbWVudHMsIG9ubHkgb25lIG9mIHdoaWNoIGNvbnRhaW5zIHRoZSBlZGl0b3IgdmFsdWUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBhY2Nlc3MgdG8gdGhlIGlucHV0IGNvbnRyb2wgaXRzZWxmICh3aGljaCBtYXkgb3IgbWF5IG5vdCBiZSB0aGUgc2FtZSBhcyBgdGhpcy5lbGApLCBzZWUgYHRoaXMuaW5wdXRgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAgICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgICAgICogQG1lbWJlck9mIENlbGxFZGl0b3IucHJvdG90eXBlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmVsID0gY29udGFpbmVyLmZpcnN0Q2hpbGQ7XG5cbiAgICAgICAgdGhpcy5pbnB1dCA9IHRoaXMuZWw7XG5cbiAgICAgICAgdGhpcy5lcnJvcnMgPSAwO1xuXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIHRoaXMua2V5dXAuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGdyaWQuZmlyZVN5bnRoZXRpY0VkaXRvcktleURvd25FdmVudChzZWxmLCBlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcigna2V5cHJlc3MnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBncmlkLmZpcmVTeW50aGV0aWNFZGl0b3JLZXlQcmVzc0V2ZW50KHNlbGYsIGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5lbC5vbmJsdXIgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBzZWxmLmNhbmNlbEVkaXRpbmcoKTtcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgbG9jYWxpemVyOiBMb2NhbGl6YXRpb24ucHJvdG90eXBlLm51bGwsXG5cbiAgICBzcGVjaWFsS2V5dXBzOiB7XG4gICAgICAgIC8vMHgwODogJ2NsZWFyU3RvcEVkaXRpbmcnLCAvLyBiYWNrc3BhY2VcbiAgICAgICAgMHgwOTogJ3N0b3BFZGl0aW5nJywgLy8gdGFiXG4gICAgICAgIDB4MGQ6ICdzdG9wRWRpdGluZycsIC8vIHJldHVybi9lbnRlclxuICAgICAgICAweDFiOiAnY2FuY2VsRWRpdGluZycgLy8gZXNjYXBlXG4gICAgfSxcblxuICAgIGtleXVwOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICB2YXIgc3BlY2lhbEtleXVwID0gdGhpcy5zcGVjaWFsS2V5dXBzW2Uua2V5Q29kZV07XG5cbiAgICAgICAgICAgIGlmIChzcGVjaWFsS2V5dXApIHtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXNbc3BlY2lhbEtleXVwXSgzKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmdyaWQucmVwYWludCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmdyaWQudGFrZUZvY3VzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmdyaWQuZmlyZVN5bnRoZXRpY0VkaXRvcktleVVwRXZlbnQodGhpcywgZSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogaWYgdHJ1ZSwgY2hlY2sgdGhhdCB0aGUgZWRpdG9yIGlzIGluIHRoZSByaWdodCBsb2NhdGlvblxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICogQG1lbWJlck9mIENlbGxFZGl0b3IucHJvdG90eXBlXG4gICAgICovXG4gICAgY2hlY2tFZGl0b3JQb3NpdGlvbkZsYWc6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxFZGl0b3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgVGhpcyBmdW5jdGlvbiBpcyBhIGNhbGxiYWNrIGZyb20gdGhlIGZpbi1oeXBlcmdyaWQuICAgSXQgaXMgY2FsbGVkIGFmdGVyIGVhY2ggcGFpbnQgb2YgdGhlIGNhbnZhcy5cbiAgICAgKi9cbiAgICBncmlkUmVuZGVyZWROb3RpZmljYXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmNoZWNrRWRpdG9yKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsRWRpdG9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHNjcm9sbCB2YWx1ZXMgaGF2ZSBjaGFuZ2VkLCB3ZSd2ZSBiZWVuIG5vdGlmaWVkXG4gICAgICovXG4gICAgc2Nyb2xsVmFsdWVDaGFuZ2VkTm90aWZpY2F0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5jaGVja0VkaXRvclBvc2l0aW9uRmxhZyA9IHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsRWRpdG9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIG1vdmUgdGhlIGVkaXRvciB0byB0aGUgY3VycmVudCBlZGl0b3IgcG9pbnRcbiAgICAgKi9cbiAgICBtb3ZlRWRpdG9yOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNlbGxCb3VuZHMgPSB0aGlzLmdyaWQuX2dldEJvdW5kc09mQ2VsbCh0aGlzLmVkaXRQb2ludC54LCB0aGlzLmVkaXRQb2ludC55KTtcblxuICAgICAgICAvL2hhY2sgdG8gYWNjb21tb2RhdGUgYm9vdHN0cmFwIG1hcmdpbiBpc3N1ZXMuLi5cbiAgICAgICAgdmFyIHhPZmZzZXQgPVxuICAgICAgICAgICAgdGhpcy5ncmlkLmRpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0IC1cbiAgICAgICAgICAgIHRoaXMuZ3JpZC5kaXZDYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdDtcblxuICAgICAgICBjZWxsQm91bmRzLnggLT0geE9mZnNldDtcblxuICAgICAgICB0aGlzLnNldEJvdW5kcyhjZWxsQm91bmRzKTtcbiAgICB9LFxuXG4gICAgYmVnaW5FZGl0aW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuZ3JpZC5maXJlUmVxdWVzdENlbGxFZGl0KHRoaXMuZWRpdFBvaW50LCB0aGlzLmluaXRpYWxWYWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tFZGl0b3JQb3NpdGlvbkZsYWcgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5jaGVja0VkaXRvcigpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBiZWdpbkVkaXRBdDogZnVuY3Rpb24oQ29uc3RydWN0b3IsIG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVwcmVjYXRlZCgnYmVnaW5FZGl0QXQocG9pbnQpJywgJ2JlZ2luRWRpdGluZygpJywgJzEuMC42Jyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IFB1dCB0aGUgdmFsdWUgaW50byBvdXIgZWRpdG9yLlxuICAgICAqIEBkZXNjIEZvcm1hdHMgdGhlIHZhbHVlIGFuZCBkaXNwbGF5cyBpdC5cbiAgICAgKiBUaGUgbG9jYWxpemVyJ3Mge0BsaW5rIGxvY2FsaXplckludGVyZmFjZSNmb3JtYXR8Zm9ybWF0fSBtZXRob2Qgd2lsbCBiZSBjYWxsZWQuXG4gICAgICpcbiAgICAgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCBpZiB5b3VyIGVkaXRvciBoYXMgYWRkaXRpb25hbCBvciBhbHRlcm5hdGl2ZSBHVUkgZWxlbWVudHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gdmFsdWUgLSBUaGUgcmF3IHVuZm9ybWF0dGVkIHZhbHVlIGZyb20gdGhlIGRhdGEgc291cmNlIHRoYXQgd2Ugd2FudCB0byBlZGl0LlxuICAgICAqIEBtZW1iZXJPZiBDZWxsRWRpdG9yLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHNldEVkaXRvclZhbHVlOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB0aGlzLmlucHV0LnZhbHVlID0gdGhpcy5sb2NhbGl6ZXIuZm9ybWF0KHZhbHVlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxFZGl0b3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgZGlzcGxheSB0aGUgZWRpdG9yXG4gICAgICovXG4gICAgc2hvd0VkaXRvcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZWwuc3R5bGUuZGlzcGxheSA9ICdpbmxpbmUnO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEVkaXRvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoaWRlIHRoZSBlZGl0b3JcbiAgICAgKi9cbiAgICBoaWRlRWRpdG9yOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5lbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIH0sXG5cbiAgICAvKiogQHN1bW1hcnkgU3RvcHMgZWRpdGluZy5cbiAgICAgKiBAZGVzYyBCZWZvcmUgc2F2aW5nLCB2YWxpZGF0ZXMgdGhlIGVkaXRlZCB2YWx1ZSBpbiB0d28gcGhhc2VzIGFzIGZvbGxvd3M6XG4gICAgICogMS4gQ2FsbCBgdmFsaWRhdGVFZGl0b3JWYWx1ZWAuIChDYWxscyB0aGUgbG9jYWxpemVyJ3MgYGludmFsaWQoKWAgZnVuY3Rpb24sIGlmIGF2YWlsYWJsZS4pXG4gICAgICogMi4gQ2F0Y2ggYW55IGVycm9ycyB0aHJvd24gYnkgdGhlIHtAbGluayBDZWxsRWRpdG9yI2dldEVkaXRvclZhbHVlfGdldEVkaXRvclZhbHVlfSBtZXRob2QuXG4gICAgICpcbiAgICAgKiAqKklmIHRoZSBlZGl0ZWQgdmFsdWUgcGFzc2VzIGJvdGggcGhhc2VzIG9mIHRoZSB2YWxpZGF0aW9uOioqXG4gICAgICogU2F2ZXMgdGhlIGVkaXRlZCB2YWx1ZSBieSBjYWxsaW5nIHRoZSB7QGxpbmsgQ2VsbEVkaXRvciNzYXZlRWRpdG9yVmFsdWV8c2F2ZUVkaXRvclZhbHVlfSBtZXRob2QuXG4gICAgICpcbiAgICAgKiAqKk9uIHZhbGlkYXRpb24gZmFpbHVyZToqKlxuICAgICAqIDEuIElmIGBmZWVkYmFja2Agd2FzIG9taXR0ZWQsIGNhbmNlbHMgZWRpdGluZywgZGlzY2FyZGluZyB0aGUgZWRpdGVkIHZhbHVlLlxuICAgICAqIDIuIElmIGBmZWVkYmFja2Agd2FzIHByb3ZpZGVkLCBnaXZlcyB0aGUgdXNlciBzb21lIGZlZWRiYWNrIChzZWUgYGZlZWRiYWNrYCwgYmVsb3cpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtmZWVkYmFja10gV2hhdCB0byBkbyBvbiB2YWxpZGF0aW9uIGZhaWx1cmU6XG4gICAgICogKiBJZiBvbWl0dGVkLCBzaW1wbHkgY2FuY2VscyBlZGl0aW5nIHdpdGhvdXQgc2F2aW5nIGVkaXRlZCB2YWx1ZS5cbiAgICAgKiAqIElmIDAsIHNob3dzIHRoZSBlcnJvciBmZWVkYmFjayBlZmZlY3QgKHNlZSB0aGUge0BsaW5rIENlbGxFZGl0b3IjZXJyb3JFZmZlY3R8ZXJyb3JFZmZlY3R9IHByb3BlcnR5KS5cbiAgICAgKiAqIElmID4gMCwgc2hvd3MgdGhlIGVycm9yIGZlZWRiYWNrIGVmZmVjdCBfYW5kXyBjYWxscyB0aGUge0BsaW5rIENlbGxFZGl0b3IjZXJyb3JFZmZlY3RFbmR8ZXJyb3JFZmZlY3RFbmR9IG1ldGhvZCkgZXZlcnkgYGZlZWRiYWNrYCBjYWxsKHMpIHRvIGBzdG9wRWRpdGluZ2AuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFRydXRoeSBtZWFucyBzdWNjZXNzZnVsIHN0b3AuIEZhbHN5IG1lYW5zIHN5bnRheCBlcnJvciBwcmV2ZW50ZWQgc3RvcC4gTm90ZSB0aGF0IGVkaXRpbmcgaXMgY2FuY2VsZWQgd2hlbiBubyBmZWVkYmFjayByZXF1ZXN0ZWQgYW5kIHN1Y2Nlc3NmdWwgc3RvcCBpbmNsdWRlcyAoc3VjY2Vzc2Z1bCkgY2FuY2VsLlxuICAgICAqIEBtZW1iZXJPZiBDZWxsRWRpdG9yLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHN0b3BFZGl0aW5nOiBmdW5jdGlvbihmZWVkYmFjaykge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW58c3RyaW5nfEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIGVycm9yID0gdGhpcy52YWxpZGF0ZUVkaXRvclZhbHVlKCk7XG5cbiAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLmdldEVkaXRvclZhbHVlKCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBlcnJvciA9IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZXJyb3IgJiYgdGhpcy5ncmlkLmZpcmVTeW50aGV0aWNFZGl0b3JEYXRhQ2hhbmdlRXZlbnQodGhpcywgdGhpcy5pbml0aWFsVmFsdWUsIHZhbHVlKSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNhdmVFZGl0b3JWYWx1ZSh2YWx1ZSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBlcnJvciA9IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuaGlkZUVkaXRvcigpO1xuICAgICAgICAgICAgdGhpcy5ncmlkLmNlbGxFZGl0b3IgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5lbC5yZW1vdmUoKTtcbiAgICAgICAgfSBlbHNlIGlmIChmZWVkYmFjayA+PSAwKSB7IC8vIG5ldmVyIHRydWUgd2hlbiBgZmVlZGJhY2tgIHVuZGVmaW5lZFxuICAgICAgICAgICAgdmFyIHBvaW50ID0gdGhpcy5lZGl0UG9pbnQ7XG4gICAgICAgICAgICB0aGlzLmdyaWQuc2VsZWN0Vmlld3BvcnRDZWxsKHBvaW50LngsIHBvaW50LnkgLSB0aGlzLmdyaWQuZ2V0SGVhZGVyUm93Q291bnQoKSk7XG4gICAgICAgICAgICB0aGlzLmVycm9yRWZmZWN0QmVnaW4oKyt0aGlzLmVycm9ycyAlIGZlZWRiYWNrID09PSAwICYmIGVycm9yKTtcbiAgICAgICAgfSBlbHNlIHsgLy8gaW52YWxpZCBidXQgbm8gZmVlZGJhY2tcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNhbmNlbEVkaXRpbmcoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAhZXJyb3I7XG4gICAgfSxcblxuICAgIC8qKiBAc3VtbWFyeSBDYW5jZWxzIGVkaXRpbmcuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFN1Y2Nlc3NmdWwuIChDYW5jZWwgaXMgYWx3YXlzIHN1Y2Nlc3NmdWwuKVxuICAgICAqL1xuICAgIGNhbmNlbEVkaXRpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5ncmlkLmNlbGxFZGl0b3IpIHsgLy8gYmVjYXVzZSBzdG9wRWRpdGluZydzIC5yZW1vdmUgdHJpZ2dlcnMgYmx1ciB3aGljaCBjb21lcyBoZXJlXG4gICAgICAgICAgICB0aGlzLnNldEVkaXRvclZhbHVlKHRoaXMuaW5pdGlhbFZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMuaGlkZUVkaXRvcigpO1xuICAgICAgICAgICAgdGhpcy5ncmlkLmNlbGxFZGl0b3IgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5lbC5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsbHMgdGhlIGVmZmVjdCBmdW5jdGlvbiBpbmRpY2F0ZWQgaW4gdGhlIHtAbGluayBDZWxsRWRpdG9yI2Vycm9yRWZmZWN0fGVycm9yRWZmZWN0fSBwcm9wZXJ0eSB3aGljaCB0cmlnZ2VycyBhIHNlcmllcyBvZiBDU1MgdHJhbnNpdGlvbnMuXG4gICAgICogQHBhcmFtIHtib29sZWFufHN0cmluZ3xFcnJvcn0gW2Vycm9yXSAtIElmIGRlZmluZWQsIGNhbGwgdGhlIHtAbGluayBDZWxsRWRpdG9yI2Vycm9yRWZmZWN0RW5kfGVycm9yRWZmZWN0RW5kfSBtZXRob2QgYXQgdGhlIGVuZCBvZiB0aGUgbGFzdCBlZmZlY3QgdHJhbnNpdGlvbiB3aXRoIHRoaXMgZXJyb3IuXG4gICAgICogQG1lbWJlck9mIENlbGxFZGl0b3IucHJvdG90eXBlXG4gICAgICovXG4gICAgZXJyb3JFZmZlY3RCZWdpbjogZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7IGNhbGxiYWNrOiBlcnJvciAmJiB0aGlzLmVycm9yRWZmZWN0RW5kLmJpbmQodGhpcywgZXJyb3IpIH0sXG4gICAgICAgICAgICBlZmZlY3QgPSB0aGlzLmVycm9yRWZmZWN0O1xuXG4gICAgICAgIGlmICh0eXBlb2YgZWZmZWN0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZWZmZWN0ID0gdGhpcy5lcnJvckVmZmVjdHNbZWZmZWN0XTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZWZmZWN0ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgXyhvcHRpb25zKS5leHRlbmRPd24oZWZmZWN0Lm9wdGlvbnMpO1xuICAgICAgICAgICAgZWZmZWN0ID0gZWZmZWN0LmVmZmVjdG9yO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBlZmZlY3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGVmZmVjdC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgJ0V4cGVjdGVkIGB0aGlzLmVycm9yRWZmZWN0YCB0byByZXNvbHZlIHRvIGFuIGVycm9yIGVmZmVjdCBmdW5jdGlvbi4nO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gZXhwZWN0cyB0byBiZSBwYXNzZWQgYW4gZXJyb3IuIFRoZXJlIGlzIG5vIHBvaW50IGluIGNhbGxpbmcgdGhpcyBmdW5jdGlvbiBpZiB0aGVyZSBpcyBubyBlcnJvci4gTmV2ZXJ0aGVsZXNzLCBpZiBjYWxsZWQgd2l0aCBhIGZhbHN5IGBlcnJvcmAsIHJldHVybnMgd2l0aG91dCBkb2luZyBhbnl0aGluZy5cbiAgICAgKiBAdGhpcyB7Q2VsbEVkaXRvcn1cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW58c3RyaW5nfEVycm9yfSBbZXJyb3JdXG4gICAgICovXG4gICAgZXJyb3JFZmZlY3RFbmQ6IGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgdmFyIG1zZyA9XG4gICAgICAgICAgICAgICAgJ0ludmFsaWQgdmFsdWUuIFRvIHJlc29sdmUsIGRvIG9uZSBvZiB0aGUgZm9sbG93aW5nOlxcblxcbicgK1xuICAgICAgICAgICAgICAgICcgICAqIENvcnJlY3QgdGhlIGVycm9yIGFuZCB0cnkgYWdhaW4uXFxuJyArXG4gICAgICAgICAgICAgICAgJyAgICAgICAgIC0gb3IgLVxcbicgK1xuICAgICAgICAgICAgICAgICcgICAqIENhbmNlbCBlZGl0aW5nIGJ5IHByZXNzaW5nIHRoZSBcImVzY1wiIChlc2NhcGUpIGtleS4nO1xuXG4gICAgICAgICAgICBlcnJvciA9IGVycm9yLm1lc3NhZ2UgfHwgZXJyb3I7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXJyb3IgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IgPSAnJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMubG9jYWxpemVyLmV4cGVjdGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IgPSBlcnJvciA/IGVycm9yICsgJ1xcbicgKyB0aGlzLmxvY2FsaXplci5leHBlY3RhdGlvbiA6IHRoaXMubG9jYWxpemVyLmV4cGVjdGF0aW9uO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBlcnJvciA9ICdcXG4nICsgZXJyb3I7XG4gICAgICAgICAgICAgICAgZXJyb3IgPSBlcnJvci5yZXBsYWNlKC9bXFxuXFxyXSsvZywgJ1xcblxcbiAgICogJyk7XG4gICAgICAgICAgICAgICAgbXNnICs9ICdcXG5cXG5BZGRpdGlvbmFsIGluZm9ybWF0aW9uIGFib3V0IHRoaXMgZXJyb3I6JyArIGVycm9yO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhbGVydChtc2cpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWFsZXJ0XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqIEB0eXBlZGVmIGVmZmVjdE9iamVjdFxuICAgICAqIEBwcm9wZXJ0eSB7ZWZmZWN0RnVuY3Rpb259IGVmZmVjdG9yXG4gICAgICogQHByb3BlcnR5IHtvYmplY3R9IFtvcHRpb25zXSAtIEFuIG9wdGlvbnMgb2JqZWN0IHdpdGggd2hpY2ggdG8gY2FsbCB0aGUgZnVuY3Rpb24uXG4gICAgICovXG4gICAgLyoqXG4gICAgICogTWF5IGJlIG9uZSBvZjpcbiAgICAgKiAqICoqc3RyaW5nKiogLSBOYW1lIG9mIHJlZ2lzdGVyZWQgZXJyb3IgZWZmZWN0LlxuICAgICAqICogKiplZmZlY3RGdW5jdGlvbioqIC0gUmVmZXJlbmNlIHRvIGFuIGVmZmVjdCBmdW5jdGlvbi5cbiAgICAgKiAqICoqZWZmZWN0T2JqZWN0KiogLSBSZWZlcmVuY2UgdG8gYW4gZWZmZWN0T2JqZWN0IGNvbnRhaW5pbmcgYW4ge0BsaW5rIGVmZmVjdEZ1bmN0aW9ufSBhbmQgYW4gYG9wdGlvbnNgIG9iamVjdCB3aXRoIHdoaWNoIHRvIGNhbGwgdGhlIGZ1bmN0aW9uLlxuICAgICAqIEB0eXBlIHtzdHJpbmd8ZWZmZWN0RnVuY3Rpb258ZWZmZWN0T2JqZWN0fVxuICAgICAqIEBtZW1iZXJPZiBDZWxsRWRpdG9yLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGVycm9yRWZmZWN0OiAnc2hha2VyJyxcblxuICAgIC8qKlxuICAgICAqIEhhc2ggb2YgcmVnaXN0ZXJlZCB7QGxpbmsgZWZmZWN0RnVuY3Rpb259cyBvciB7QGxpbmsgZWZmZWN0T2JqZWN0fXMuXG4gICAgICogQG1lbWJlck9mIENlbGxFZGl0b3IucHJvdG90eXBlXG4gICAgICovXG4gICAgZXJyb3JFZmZlY3RzOiB7XG4gICAgICAgIHNoYWtlcjogZWZmZWN0cy5zaGFrZXIsXG4gICAgICAgIGdsb3dlcjogZWZmZWN0cy5nbG93ZXJcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGRlc2Mgc2F2ZSB0aGUgbmV3IHZhbHVlIGludG8gdGhlIGJlaGF2aW9yIChtb2RlbClcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEVkaXRvci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBzYXZlRWRpdG9yVmFsdWU6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHZhciBwb2ludCA9IHRoaXMuZWRpdFBvaW50O1xuXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgICEodmFsdWUgJiYgdmFsdWUgPT09IHRoaXMuaW5pdGlhbFZhbHVlKSAmJiAvLyBkYXRhIGNoYW5nZWRcbiAgICAgICAgICAgIHRoaXMuZ3JpZC5maXJlQmVmb3JlQ2VsbEVkaXQocG9pbnQsIHRoaXMuaW5pdGlhbFZhbHVlLCB2YWx1ZSwgdGhpcykgLy8gbm90IGFib3J0aW5nXG4gICAgICAgICkge1xuICAgICAgICAgICAgdGhpcy5ncmlkLmJlaGF2aW9yLnNldFZhbHVlKHBvaW50LngsIHBvaW50LnksIHZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMuZ3JpZC5maXJlQWZ0ZXJDZWxsRWRpdChwb2ludCwgdGhpcy5pbml0aWFsVmFsdWUsIHZhbHVlLCB0aGlzKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBFeHRyYWN0IHRoZSBlZGl0ZWQgdmFsdWUgZnJvbSB0aGUgZWRpdG9yLlxuICAgICAqIEBkZXNjIERlLWZvcm1hdCB0aGUgZWRpdGVkIHN0cmluZyBiYWNrIGludG8gYSBwcmltaXRpdmUgdmFsdWUuXG4gICAgICpcbiAgICAgKiBUaGUgbG9jYWxpemVyJ3Mge0BsaW5rIGxvY2FsaXplckludGVyZmFjZSNwYXJzZXxwYXJzZX0gbWV0aG9kIHdpbGwgYmUgY2FsbGVkIG9uIHRoZSB0ZXh0IGJveCBjb250ZW50cy5cbiAgICAgKlxuICAgICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIGlmIHlvdXIgZWRpdG9yIGhhcyBhZGRpdGlvbmFsIG9yIGFsdGVybmF0aXZlIEdVSSBlbGVtZW50cy4gVGhlIEdVSSBlbGVtZW50cyB3aWxsIGluZmx1ZW5jZSB0aGUgcHJpbWl0aXZlIHZhbHVlLCBlaXRoZXIgYnkgYWx0ZXJpbmcgdGhlIGVkaXRlZCBzdHJpbmcgYmVmb3JlIGl0IGlzIHBhcnNlZCwgb3IgYnkgdHJhbnNmb3JtaW5nIHRoZSBwYXJzZWQgdmFsdWUgYmVmb3JlIHJldHVybmluZyBpdC5cbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSB0aGUgY3VycmVudCBlZGl0b3IncyB2YWx1ZVxuICAgICAqIEBtZW1iZXJPZiBDZWxsRWRpdG9yLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGdldEVkaXRvclZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxpemVyLnBhcnNlKHRoaXMuaW5wdXQudmFsdWUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJZiB0aGVyZSBpcyBubyB2YWxpZGF0b3Igb24gdGhlIGxvY2FsaXplciwgcmV0dXJucyBmYWxzeSAobm90IGludmFsaWQ7IHBvc3NpYmx5IHZhbGlkKS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbnxzdHJpbmd9IFRydXRoeSB2YWx1ZSBtZWFucyBpbnZhbGlkLiBJZiBhIHN0cmluZywgdGhpcyB3aWxsIGJlIGFuIGVycm9yIG1lc3NhZ2UuIElmIG5vdCBhIHN0cmluZywgaXQgbWVyZWx5IGluZGljYXRlcyBhIGdlbmVyaWMgaW52YWxpZCByZXN1bHQuXG4gICAgICovXG4gICAgdmFsaWRhdGVFZGl0b3JWYWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsaXplci5pbnZhbGlkICYmIHRoaXMubG9jYWxpemVyLmludmFsaWQodGhpcy5pbnB1dC52YWx1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IFJlcXVlc3QgZm9jdXMgZm9yIG15IGlucHV0IGNvbnRyb2wuXG4gICAgICogQGRlc2MgU2VlIEdSSUQtOTUgXCJTY3JvbGxiYXIgbW92ZXMgaW53YXJkXCIgZm9yIGlzc3VlIGFuZCB3b3JrLWFyb3VuZCBleHBsYW5hdGlvbi5cbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEVkaXRvci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICB0YWtlRm9jdXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZWwgPSB0aGlzLmVsLFxuICAgICAgICAgICAgbGVmdFdhcyA9IGVsLnN0eWxlLmxlZnQsXG4gICAgICAgICAgICB0b3BXYXMgPSBlbC5zdHlsZS50b3A7XG5cbiAgICAgICAgZWwuc3R5bGUubGVmdCA9IGVsLnN0eWxlLnRvcCA9IDA7IC8vIHdvcmstYXJvdW5kOiBtb3ZlIHRvIHVwcGVyIGxlZnRcblxuICAgICAgICB0aGlzLmlucHV0LmZvY3VzKCk7XG4gICAgICAgIHRoaXMuc2VsZWN0QWxsKCk7XG5cbiAgICAgICAgZWwuc3R5bGUubGVmdCA9IGxlZnRXYXM7XG4gICAgICAgIGVsLnN0eWxlLnRvcCA9IHRvcFdhcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxFZGl0b3IucHJvdG90eXBlXG4gICAgICogQGRlc2Mgc2VsZWN0IGV2ZXJ5dGhpbmdcbiAgICAgKi9cbiAgICBzZWxlY3RBbGw6IG51bGxQYXR0ZXJuLFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxFZGl0b3IucHJvdG90eXBlXG4gICAgICogQGRlc2Mgc2V0IHRoZSBib3VuZHMgb2YgbXkgaW5wdXQgY29udHJvbFxuICAgICAqIEBwYXJhbSB7cmVjdGFuZ2xlfSByZWN0YW5nbGUgLSB0aGUgYm91bmRzIHRvIG1vdmUgdG9cbiAgICAgKi9cbiAgICBzZXRCb3VuZHM6IGZ1bmN0aW9uKGNlbGxCb3VuZHMpIHtcbiAgICAgICAgdmFyIGlucHV0ID0gdGhpcy5lbDtcblxuICAgICAgICBpbnB1dC5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgIGlucHV0LnN0eWxlLmxlZnQgPSBweChjZWxsQm91bmRzLnggLSAxKTtcbiAgICAgICAgaW5wdXQuc3R5bGUudG9wID0gcHgoY2VsbEJvdW5kcy55IC0gMSk7XG4gICAgICAgIGlucHV0LnN0eWxlLndpZHRoID0gcHgoY2VsbEJvdW5kcy53aWR0aCArIDIpO1xuICAgICAgICBpbnB1dC5zdHlsZS5oZWlnaHQgPSBweChjZWxsQm91bmRzLmhlaWdodCArIDIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZGVzYyBjaGVjayB0aGF0IHRoZSBlZGl0b3IgaXMgaW4gdGhlIGNvcnJlY3QgbG9jYXRpb24sIGFuZCBpcyBzaG93aW5nL2hpZGRlbiBhcHByb3ByaWF0ZWx5XG4gICAgICogQG1lbWJlck9mIENlbGxFZGl0b3IucHJvdG90eXBlXG4gICAgICovXG4gICAgY2hlY2tFZGl0b3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5jaGVja0VkaXRvclBvc2l0aW9uRmxhZykge1xuICAgICAgICAgICAgdGhpcy5jaGVja0VkaXRvclBvc2l0aW9uRmxhZyA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHRoaXMuZ3JpZC5pc0RhdGFWaXNpYmxlKHRoaXMuZWRpdFBvaW50LngsIHRoaXMuZWRpdFBvaW50LnkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRFZGl0b3JWYWx1ZSh0aGlzLmluaXRpYWxWYWx1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5hdHRhY2hFZGl0b3IoKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1vdmVFZGl0b3IoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNob3dFZGl0b3IoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRha2VGb2N1cygpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhpZGVFZGl0b3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBhdHRhY2hFZGl0b3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaW5wdXQgPSB0aGlzLmVsLFxuICAgICAgICAgICAgZGl2ID0gdGhpcy5ncmlkLmRpdixcbiAgICAgICAgICAgIHJlZmVyZW5jZU5vZGUgPSBkaXYucXVlcnlTZWxlY3RvckFsbCgnLmZpbmJhci1ob3Jpem9udGFsLCAuZmluYmFyLXZlcnRpY2FsJyk7XG5cbiAgICAgICAgZGl2Lmluc2VydEJlZm9yZShpbnB1dCwgcmVmZXJlbmNlTm9kZS5sZW5ndGggPyByZWZlcmVuY2VOb2RlWzBdIDogbnVsbCk7XG4gICAgfSxcblxuICAgIHRlbXBsYXRlOiAnJ1xuXG59KTtcblxuZnVuY3Rpb24gbnVsbFBhdHRlcm4oKSB7fVxuZnVuY3Rpb24gcHgobikgeyByZXR1cm4gbiArICdweCc7IH1cblxuXG5DZWxsRWRpdG9yLmFic3RyYWN0ID0gdHJ1ZTsgLy8gZG9uJ3QgaW5zdGFudGlhdGUgZGlyZWN0bHlcblxuXG5tb2R1bGUuZXhwb3J0cyA9IENlbGxFZGl0b3I7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBDZWxsRWRpdG9yID0gcmVxdWlyZSgnLi9DZWxsRWRpdG9yJyk7XG5cbi8qKlxuICogQXMgb2Ygc3ByaW5nIDIwMTY6XG4gKiBGdW5jdGlvbnMgd2VsbCBpbiBDaHJvbWUgYW5kIEZpcmVmb3g7IHVuaW1wbGVtZW50ZWQgaW4gU2FmYXJpLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBDZWxsRWRpdG9yXG4gKi9cbnZhciBDb2xvciA9IENlbGxFZGl0b3IuZXh0ZW5kKCdDb2xvcicsIHtcblxuICAgIHRlbXBsYXRlOiAnPGlucHV0IHR5cGU9XCJjb2xvclwiIGxhbmc9XCJ7e2xvY2FsZX19XCIgc3R5bGU9XCJ7e3N0eWxlfX1cIj4nXG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbG9yO1xuIiwiLy8gQ29tYm9Cb3guanMgLSBBIGNvbWJvLWJveCBpcyBhIGNvbWJpbmF0aW9uIG9mIGEgdGV4dC1ib3ggYW5kIGEgZHJvcC1kb3duLlxuLy8gVXNlciBtYXkgdHlwZSBpbnRvIGl0IGFuZC9vciBzZWxlY3QgYW4gaXRlbSBmcm9tIHRoZSBkcm9wLWRvd24gKGJ5IGNsaWNraW5nIG9uIHRoZSB0cmlhbmdsZSBhdCB0aGUgcmlnaHQpLlxuLy8gVGhlIGRyb3AtZG93biBoYXMgc2VjdGlvbnMgd2hpY2ggYXJlIHRvZ2dsZWQgZnJvbSBhIGNvbnRyb2wgYXJlYSBiZXR3ZWVuIHRoZSB0ZXh0LWJveCBhbmQgdGhlIGRyb3AtZG93bi5cblxuLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFRleHRmaWVsZCA9IHJlcXVpcmUoJy4vVGV4dGZpZWxkJyk7XG52YXIgcHJvdG90eXBlID0gcmVxdWlyZSgnLi9DZWxsRWRpdG9yJykucHJvdG90eXBlO1xudmFyIFF1ZXVlbGVzcyA9IHJlcXVpcmUoJy4uL2xpYi9xdWV1ZWxlc3MnKTtcbnZhciBlbGZvciA9IHJlcXVpcmUoJy4uL2xpYi9lbGZvcicpO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbnZhciBUT0dHTEVfTU9ERV9QUkVGSVggPSAndG9nZ2xlLW1vZGUtJztcblxudmFyIHN0YXRlVG9BY3Rpb25NYXAgPSB7XG4gICAgaGlkZGVuOiBzbGlkZURvd24sXG4gICAgdmlzaWJsZTogc2xpZGVVcFxufTtcblxuLyoqXG4gKiBBIGNvbWJvIGJveCBpcyBhIHRleHQgYm94IHRoYXQgYWxzbyBoYXMgYSBkcm9wLWRvd24gY29udGFpbmluZyBvcHRpb25zLiBUaGUgZHJvcC1kb3duIGNvbnNpc3RzIG9mIGFuIGFjdHVhbCBkcm9wLWRvd24gbGlzdCAoYSBgPHNlbGVjdD5gIGxpc3QpIHBsdXMgYSBfY29udHJvbCBhcmVhXyBhYm92ZSBpdCBjb250YWluaW5nIHRvZ2dsZXMuIFRoZSB0b2dnbGVzIGNvbnRyb2wgdGhlIHZpc2liaWxpdHkgb2YgdGhlIHZhcmlvdXMgXCJtb2RlIGxpc3RzLlwiXG4gKlxuICogRnVuY3Rpb25zIHdlbGwgaW4gQ2hyb21lLCBTYWZhcmksIEZpcmVmb3gsIGFuZCBJbnRlcm5ldCBFeHBsb3Jlci5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgVGV4dGZpZWxkXG4gKi9cbnZhciBDb21ib0JveCA9IFRleHRmaWVsZC5leHRlbmQoJ0NvbWJvQm94Jywge1xuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBlbCA9IHRoaXMuZWw7XG5cbiAgICAgICAgdGhpcy5pbnB1dCA9IGVsLnF1ZXJ5U2VsZWN0b3IoJ2lucHV0Jyk7XG4gICAgICAgIHRoaXMuZHJvcHBlciA9IGVsLnF1ZXJ5U2VsZWN0b3IoJ3NwYW4nKTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gZWwucXVlcnlTZWxlY3RvcignZGl2Jyk7XG4gICAgICAgIHRoaXMuY29udHJvbHMgPSB0aGlzLm9wdGlvbnMucXVlcnlTZWxlY3RvcignZGl2Jyk7XG4gICAgICAgIHRoaXMuZHJvcGRvd24gPSB0aGlzLm9wdGlvbnMucXVlcnlTZWxlY3Rvcignc2VsZWN0Jyk7XG5cbiAgICAgICAgdGhpcy5jb250cm9sbGFibGUgPSB0aGlzLm1vZGVzLmxlbmd0aCA+IDE7XG5cbiAgICAgICAgLy8gc2V0IHVwIGEgdHJhbnNpdGlvbiBlbmQgY29udHJvbGxlclxuICAgICAgICB0aGlzLm9wdGlvbnNUcmFuc2l0aW9uID0gbmV3IFF1ZXVlbGVzcyh0aGlzLm9wdGlvbnMsIHRoaXMpO1xuXG4gICAgICAgIHRoaXMubWVudU1vZGVzU291cmNlID0gdGhpcy5jb2x1bW4ubWVudU1vZGVzIHx8IHsgZGlzdGluY3RWYWx1ZXM6IHRydWUgfTtcblxuICAgICAgICAvLyB3aXJlLXVwc1xuICAgICAgICB0aGlzLmRyb3BwZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy50b2dnbGVEcm9wRG93bi5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5kcm9wZG93bi5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXdoZWVsJywgZnVuY3Rpb24oZSkgeyBlLnN0b3BQcm9wYWdhdGlvbigpOyB9KTtcbiAgICAgICAgdGhpcy5kcm9wZG93bi5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLmluc2VydFRleHQuYmluZCh0aGlzKSk7XG4gICAgICAgIGVsLm9uYmx1ciA9IG51bGw7IC8vIHZvaWQgdGhpcyBvbmUsIHNldCBieSBzdXBlcidzIGluaXRpYWxpemVcbiAgICB9LFxuXG4gICAgdGVtcGxhdGU6IFtcbic8ZGl2IGNsYXNzPVwiaHlwZXJncmlkLWlucHV0XCIgdGl0bGU9XCJcIj4nLFxuJyAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBsYW5nPVwie3tsb2NhbGV9fVwiIHN0eWxlPVwie3tzdHlsZX19XCI+JyxcbicgICAgPHNwYW4gdGl0bGU9XCJDbGljayBmb3Igb3B0aW9uc1wiPjwvc3Bhbj4nLFxuJyAgICA8ZGl2PicsXG4nICAgICAgICA8ZGl2PjwvZGl2PicsXG4nICAgICAgICA8c2VsZWN0IHNpemU9XCIxMlwiIGxhbmc9XCJ7e2xvY2FsZX19XCI+PC9zZWxlY3Q+JyxcbicgICAgPC9kaXY+Jyxcbic8L2Rpdj4nXG4gICAgXS5qb2luKCdcXG4nKSxcblxuICAgIG1vZGVzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdkaXN0aW5jdFZhbHVlcycsXG4gICAgICAgICAgICBhcHBlbmRPcHRpb25zOiBmdW5jdGlvbihvcHRncm91cCkge1xuICAgICAgICAgICAgICAgIC8vIGdldCB0aGUgZGlzdGluY3QgY29sdW1uIHZhbHVlcyBhbmQgc29ydCB0aGVtXG4gICAgICAgICAgICAgICAgdmFyIGRpc3RpbmN0ID0ge30sXG4gICAgICAgICAgICAgICAgICAgIGQgPSBbXSxcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uTmFtZSA9IHRoaXMuY29sdW1uLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlciA9IHRoaXMuY29sdW1uLmdldEZvcm1hdHRlcigpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5ncmlkLmJlaGF2aW9yLmdldERhdGEoKS5mb3JFYWNoKGZ1bmN0aW9uKGRhdGFSb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbCA9IGZvcm1hdHRlcihkYXRhUm93W2NvbHVtbk5hbWVdKTtcbiAgICAgICAgICAgICAgICAgICAgZGlzdGluY3RbdmFsXSA9IChkaXN0aW5jdFt2YWxdIHx8IDApICsgMTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBkaXN0aW5jdCkge1xuICAgICAgICAgICAgICAgICAgICBkLnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB3aGlsZSAob3B0Z3JvdXAuZmlyc3RFbGVtZW50Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0Z3JvdXAuZmlyc3RFbGVtZW50Q2hpbGQucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZC5zb3J0KCkuZm9yRWFjaChmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9wdGlvbiA9IG5ldyBPcHRpb24odmFsICsgJyAoJyArIGRpc3RpbmN0W3ZhbF0gKyAnKScsIHZhbCk7XG4gICAgICAgICAgICAgICAgICAgIG9wdGdyb3VwLmFwcGVuZENoaWxkKG9wdGlvbik7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZC5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBdLFxuXG4gICAgc2hvd0VkaXRvcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBtZW51TW9kZXNTb3VyY2UgPSB0aGlzLm1lbnVNb2Rlc1NvdXJjZSxcbiAgICAgICAgICAgIG1lbnVNb2RlcyA9IHRoaXMubWVudU1vZGVzID0ge307XG5cbiAgICAgICAgLy8gYnVpbGQgdGhlIHByb3h5XG4gICAgICAgIHRoaXMubW9kZXMuZm9yRWFjaChmdW5jdGlvbihtb2RlKSB7XG4gICAgICAgICAgICB2YXIgbW9kZU5hbWUgPSBtb2RlLm5hbWU7XG4gICAgICAgICAgICBpZiAobW9kZU5hbWUgaW4gbWVudU1vZGVzU291cmNlKSB7XG4gICAgICAgICAgICAgICAgbWVudU1vZGVzW21vZGVOYW1lXSA9IG1lbnVNb2Rlc1NvdXJjZVttb2RlTmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHdpcmUtdXBzXG4gICAgICAgIGlmICh0aGlzLmNvbnRyb2xsYWJsZSkge1xuICAgICAgICAgICAgdGhpcy5jb250cm9scy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIG9uTW9kZUljb25DbGljay5iaW5kKHRoaXMpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNldCB0aGUgaW5pdGlhbCBzdGF0ZSBvZiB0aGUgbW9kZSB0b2dnbGVzXG4gICAgICAgIHRoaXMubW9kZXMuZm9yRWFjaChmdW5jdGlvbihtb2RlKSB7XG4gICAgICAgICAgICAvLyBjcmVhdGUgYSB0b2dnbGVcbiAgICAgICAgICAgIHZhciB0b2dnbGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgICAgICBpZiAodGhpcy5jb250cm9sbGFibGUpIHtcbiAgICAgICAgICAgICAgICB0b2dnbGUuY2xhc3NOYW1lID0gVE9HR0xFX01PREVfUFJFRklYICsgbW9kZS5uYW1lO1xuICAgICAgICAgICAgICAgIHRvZ2dsZS50aXRsZSA9ICdUb2dnbGUgJyArIChtb2RlLmxhYmVsIHx8IG1vZGUubmFtZSkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICB0b2dnbGUudGV4dENvbnRlbnQgPSBtb2RlLnN5bWJvbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY29udHJvbHMuYXBwZW5kQ2hpbGQodG9nZ2xlKTtcblxuICAgICAgICAgICAgLy8gY3JlYXRlIGFuZCBsYWJlbCBhIG5ldyBvcHRncm91cFxuICAgICAgICAgICAgaWYgKG1vZGUuc2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3B0Z3JvdXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdvcHRncm91cCcpO1xuICAgICAgICAgICAgICAgIG9wdGdyb3VwLmxhYmVsID0gbW9kZS5sYWJlbDtcbiAgICAgICAgICAgICAgICBvcHRncm91cC5jbGFzc05hbWUgPSAnc3VibWVudS0nICsgbW9kZS5uYW1lO1xuICAgICAgICAgICAgICAgIG9wdGdyb3VwLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IG1vZGUuYmFja2dyb3VuZENvbG9yO1xuICAgICAgICAgICAgICAgIHRoaXMuZHJvcGRvd24uYWRkKG9wdGdyb3VwKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2V0TW9kZUljb25BbmRPcHRncm91cC5jYWxsKHRoaXMsIHRvZ2dsZSwgbW9kZS5uYW1lLCBtZW51TW9kZXNbbW9kZS5uYW1lXSk7XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICAgICAgcHJvdG90eXBlLnNob3dFZGl0b3IuY2FsbCh0aGlzKTtcbiAgICB9LFxuXG4gICAgaGlkZUVkaXRvcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIHRoaXMgaXMgd2hlcmUgeW91IHdvdWxkIHBlcnNpc3QgdGhpcy5tZW51TW9kZXNcbiAgICAgICAgcHJvdG90eXBlLmhpZGVFZGl0b3IuY2FsbCh0aGlzKTtcbiAgICB9LFxuXG4gICAgdG9nZ2xlRHJvcERvd246IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9uc1RyYW5zaXRpb24udHJhbnNpdGlvbmluZykge1xuICAgICAgICAgICAgdmFyIHN0YXRlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy5kcm9wZG93bikudmlzaWJpbGl0eTtcbiAgICAgICAgICAgIHN0YXRlVG9BY3Rpb25NYXBbc3RhdGVdLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgaW5zZXJ0VGV4dDogZnVuY3Rpb24oZSkge1xuICAgICAgICAvLyByZXBsYWNlIHRoZSBpbnB1dCB0ZXh0IHdpdGggdGhlIGRyb3AtZG93biB0ZXh0XG4gICAgICAgIHRoaXMuaW5wdXQuZm9jdXMoKTtcbiAgICAgICAgdGhpcy5pbnB1dC52YWx1ZSA9IHRoaXMuZHJvcGRvd24udmFsdWU7XG4gICAgICAgIHRoaXMuaW5wdXQuc2V0U2VsZWN0aW9uUmFuZ2UoMCwgdGhpcy5pbnB1dC52YWx1ZS5sZW5ndGgpO1xuXG4gICAgICAgIC8vIGNsb3NlIHRoZSBkcm9wLWRvd25cbiAgICAgICAgdGhpcy50b2dnbGVEcm9wRG93bigpO1xuICAgIH1cbn0pO1xuXG5mdW5jdGlvbiBvbk1vZGVJY29uQ2xpY2soZSkge1xuICAgIHZhciBjdHJsID0gZS50YXJnZXQ7XG5cbiAgICBpZiAoY3RybC50YWdOYW1lID09PSAnU1BBTicpIHtcbiAgICAgICAgLy8gZXh0cmEgY3QgdGhlIG1vZGUgbmFtZSBmcm9tIHRoZSB0b2dnbGUgY29udHJvbCdzIGNsYXNzIG5hbWVcbiAgICAgICAgdmFyIG1vZGVDbGFzc05hbWUgPSBBcnJheS5wcm90b3R5cGUuZmluZC5jYWxsKGN0cmwuY2xhc3NMaXN0LCBmdW5jdGlvbihjbGFzc05hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xhc3NOYW1lLmluZGV4T2YoVE9HR0xFX01PREVfUFJFRklYKSA9PT0gMDtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgbW9kZU5hbWUgPSBtb2RlQ2xhc3NOYW1lLnN1YnN0cihUT0dHTEVfTU9ERV9QUkVGSVgubGVuZ3RoKTtcblxuICAgICAgICAvLyB0b2dnbGUgbW9kZSBpbiB0aGUgZmlsdGVyXG4gICAgICAgIHZhciBtb2RlU3RhdGUgPSB0aGlzLm1lbnVNb2Rlc1ttb2RlTmFtZV0gXj0gMTtcblxuICAgICAgICBzZXRNb2RlSWNvbkFuZE9wdGdyb3VwLmNhbGwodGhpcywgY3RybCwgbW9kZU5hbWUsIG1vZGVTdGF0ZSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBzZXRNb2RlSWNvbkFuZE9wdGdyb3VwKGN0cmwsIG5hbWUsIHN0YXRlKSB7XG4gICAgdmFyIHN0eWxlLCBvcHRncm91cCwgc3VtLCBkaXNwbGF5LFxuICAgICAgICBtb2RlID0gdGhpcy5tb2Rlcy5maW5kKGZ1bmN0aW9uKG1vZGUpIHsgcmV0dXJuIG1vZGUubmFtZSA9PT0gbmFtZTsgfSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2hhZG93XG5cbiAgICAvLyBzZXQgaWNvbiBzdGF0ZSAoY29sb3IpXG4gICAgY3RybC5jbGFzc0xpc3QudG9nZ2xlKCdhY3RpdmUnLCAhIXN0YXRlKTtcblxuICAgIC8vIGVtcHR5IHRoZSBvcHRncm91cCBpZiBoaWRpbmc7IHJlYnVpbGQgaXQgaWYgc2hvd2luZ1xuICAgIGlmIChzdGF0ZSkgeyAvLyByZWJ1aWxkIGl0XG4gICAgICAgIC8vIHNob3cgcHJvZ3Jlc3MgY3Vyc29yIGZvciAoYXQgbGVhc3QpIDEvMyBzZWNvbmRcbiAgICAgICAgc3R5bGUgPSB0aGlzLmVsLnN0eWxlO1xuICAgICAgICBzdHlsZS5jdXJzb3IgPSAncHJvZ3Jlc3MnO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBzdHlsZS5jdXJzb3IgPSBudWxsOyB9LCAzMzMpO1xuXG4gICAgICAgIGlmIChtb2RlLnNlbGVjdG9yKSB7XG4gICAgICAgICAgICBvcHRncm91cCA9IHRoaXMuZHJvcGRvd24ucXVlcnlTZWxlY3Rvcihtb2RlLnNlbGVjdG9yKTtcbiAgICAgICAgICAgIHN1bSA9IG1vZGUuYXBwZW5kT3B0aW9ucy5jYWxsKHRoaXMsIG9wdGdyb3VwKTtcblxuICAgICAgICAgICAgLy8gdXBkYXRlIHN1bVxuICAgICAgICAgICAgb3B0Z3JvdXAubGFiZWwgPSBvcHRncm91cC5sYWJlbC5yZXBsYWNlKC8gXFwoXFxkK1xcKSQvLCAnJyk7IC8vIHJlbW92ZSBvbGQgc3VtXG4gICAgICAgICAgICBvcHRncm91cC5sYWJlbCArPSAnICgnICsgc3VtICsgJyknO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3VtID0gbW9kZS5hcHBlbmRPcHRpb25zLmNhbGwodGhpcywgdGhpcy5kcm9wZG93bik7XG4gICAgICAgICAgICBpZiAoIXRoaXMuY29udHJvbGxhYmxlKSB7XG4gICAgICAgICAgICAgICAgY3RybC50ZXh0Q29udGVudCA9IHN1bSArICcgdmFsdWVzJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGRpc3BsYXkgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGRpc3BsYXkgPSAnbm9uZSc7XG4gICAgfVxuXG4gICAgLy8gaGlkZS9zaG93IHRoZSBncm91cFxuICAgIGVsZm9yLmVhY2goXG4gICAgICAgIG1vZGUuc2VsZWN0b3IgfHwgJzpzY29wZT5vcHRpb24sOnNjb3BlPm9wdGdyb3VwOm5vdChbY2xhc3NdKScsXG4gICAgICAgIGZ1bmN0aW9uIGl0ZXJhdGVlKGVsKSB7IGVsLnN0eWxlLmRpc3BsYXkgPSBkaXNwbGF5OyB9LFxuICAgICAgICB0aGlzLmRyb3Bkb3duXG4gICAgKTtcblxuICAgIC8vIFRPRE86IFJlc2V0IHRoZSB3aWR0aCBvZiB0aGlzLm9wdGlvbnMgdG8gdGhlIG5hdHVyYWwgd2lkdGggb2YgdGhpcy5kcm9wZG93bi4gVG8gZG8gdGhpcywgd2UgbmVlZCB0byByZW1vdmUgdGhlIGxhdHRlcidzIFwid2lkdGg6IDEwMCVcIiBmcm9tIHRoZSBDU1MgYW5kIHRoZW4gc2V0IGFuIGV4cGxpY2l0IHRoaXMub3B0aW9ucy5zdHlsZS53aWR0aCBiYXNlZCBvbiB0aGUgY29tcHV0ZWQgd2lkdGggb2YgdGhpcy5kcm9wZG93bi4gVGhpcyBpcyBjb21wbGljYXRlZCBieSB0aGUgZmFjdCB0aGF0IGl0IGNhbm5vdCBiZSBkb25lIGJlZm9yZSBpdCBpcyBpbiB0aGUgRE9NLlxufVxuXG5mdW5jdGlvbiBzbGlkZURvd24oKSB7XG4gICAgLy8gcHJlc2VydmUgdGhlIHRleHQgYm94J3MgY3VycmVudCB0ZXh0IHNlbGVjdGlvbiwgd2hpY2ggaXMgYWJvdXQgdG8gYmUgbG9zdFxuICAgIHRoaXMuc2VsZWN0aW9uU3RhcnQgPSB0aGlzLmlucHV0LnNlbGVjdGlvblN0YXJ0O1xuICAgIHRoaXMuc2VsZWN0aW9uRW5kID0gdGhpcy5pbnB1dC5zZWxlY3Rpb25FbmQ7XG5cbiAgICAvLyBjbGVhbiB1cCB0aGUgc2VsZWN0IGxpc3QgZnJvbSBsYXN0IHVzYWdlXG4gICAgdGhpcy5kcm9wZG93bi5zZWxlY3RlZEluZGV4ID0gLTE7IC8vIGJlIGtpbmQgKHJlbW92ZSBwcmV2aW91cyBzZWxlY3Rpb24pXG4gICAgdGhpcy5kcm9wZG93bi5zdHlsZS5zY3JvbGxUb3AgPSAwOyAvLyByZXdpbmRcblxuICAgIC8vIHNob3cgdGhlIGRyb3AtZG93biBzbGlkZSBkb3duIGVmZmVjdFxuICAgIHRoaXMub3B0aW9ucy5zdHlsZS52aXNpYmlsaXR5ID0gJ3Zpc2libGUnO1xuICAgIHZhciBkcm9wRG93bkhlaWdodCA9IHRoaXMuZHJvcGRvd24uc2l6ZSAqIDE1O1xuICAgIHRoaXMub3B0aW9ucy5zdHlsZS5oZWlnaHQgPSAyICsgMTUgKyBkcm9wRG93bkhlaWdodCArIDIgKyAncHgnOyAvLyBzdGFydHMgdGhlIHNsaWRlIGRvd24gZWZmZWN0XG5cbiAgICAvLyB3aGlsZSBpbiBkcm9wLWRvd24sIGxpc3RlbiBmb3IgY2xpY2tzIGluIHRleHQgYm94IHdoaWNoIG1lYW5zIGFicHJ0XG4gICAgdGhpcy5pbnB1dC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLnNsaWRlVXBCb3VuZCA9IHNsaWRlVXAuYmluZCh0aGlzKSk7XG5cbiAgICAvLyB3YWl0IGZvciB0cmFuc2l0aW9uIHRvIGVuZFxuICAgIHRoaXMub3B0aW9uc1RyYW5zaXRpb24uYmVnaW4oKTtcbn1cblxuZnVuY3Rpb24gc2xpZGVVcCgpIHtcbiAgICAvLyBzdG9wIGxpc3RlbmluZyB0byBpbnB1dCBjbGlja3NcbiAgICB0aGlzLmlucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuc2xpZGVVcEJvdW5kKTtcblxuICAgIC8vIHN0YXJ0IHRoZSBzbGlkZSB1cCBlZmZlY3RcbiAgICB0aGlzLm9wdGlvbnMuc3R5bGUuaGVpZ2h0ID0gMDtcblxuICAgIC8vIHNjaGVkdWxlIHRoZSBoaWRlIHRvIG9jY3VyIGFmdGVyIHRoZSBzbGlkZSB1cCBlZmZlY3RcbiAgICB0aGlzLm9wdGlvbnNUcmFuc2l0aW9uLmJlZ2luKGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICAgIH0pO1xufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gQ29tYm9Cb3g7XG4iLCIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ2VsbEVkaXRvciA9IHJlcXVpcmUoJy4vQ2VsbEVkaXRvcicpO1xuXG52YXIgaXNDaHJvbWl1bSA9IHdpbmRvdy5jaHJvbWUsXG4gICAgd2luTmF2ID0gd2luZG93Lm5hdmlnYXRvcixcbiAgICB2ZW5kb3JOYW1lID0gd2luTmF2LnZlbmRvcixcbiAgICBpc09wZXJhID0gd2luTmF2LnVzZXJBZ2VudC5pbmRleE9mKCdPUFInKSA+IC0xLFxuICAgIGlzSUVlZGdlID0gd2luTmF2LnVzZXJBZ2VudC5pbmRleE9mKCdFZGdlJykgPiAtMSxcbiAgICBpc0lPU0Nocm9tZSA9IHdpbk5hdi51c2VyQWdlbnQubWF0Y2goJ0NyaU9TJyksXG4gICAgaXNDaHJvbWUgPSAhaXNJT1NDaHJvbWUgJiZcbiAgICAgICAgaXNDaHJvbWl1bSAhPT0gbnVsbCAmJlxuICAgICAgICBpc0Nocm9taXVtICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgdmVuZG9yTmFtZSA9PT0gJ0dvb2dsZSBJbmMuJyAmJlxuICAgICAgICBpc09wZXJhID09IGZhbHNlICYmIGlzSUVlZGdlID09IGZhbHNlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuXG4vKipcbiAqIEFzIG9mIHNwcmluZyAyMDE2OlxuICogRnVuY3Rpb25zIHdlbGwgaW4gQ2hyb21lIGV4Y2VwdCBubyBsb2NhbGl6YXRpb24gKGRheSwgbW9udGggbmFtZXM7IGRhdGUgZm9ybWF0KS5cbiAqIFVuaW1wbGVtZW50ZWQgaW4gU2FmYXJpLCBGaXJlZm94LCBJbnRlcm5ldCBFeHBsb3Jlci5cbiAqIFRoaXMgaXMgYSBcInNubWFydFwiIGNvbnRyb2wuIEl0IGRldGVjdHMgQ2hyb21lOlxuICogKiBJZiBDaHJvbWUsIHVzZXMgY2hyb21lRGF0ZSBvdmVycmlkZXMgZm9ybWF0IHRvIHRoYXQgcmVxdWlyZWQgYnkgdGhlIHZhbHVlIGF0dHJpYnV0ZSwgeXl5eS1tbS1kZC4gKE5vdGUgdGhhdCB0aGlzIGlzIG5vdCB0aGUgZm9ybWF0IGRpc3BsYXllZCBpbiB0aGUgY29udHJvbCwgd2hpY2ggaXMgYWx3YXlzIG1tL2RkL3l5eXkuKVxuICogKiBPdGhlcndpc2UgdXNlcyBsb2NhbGl6ZWQgZGF0ZSBmb3JtYXQgX2J1dF8gZmFsbHMgYmFjayB0byBhIHJlZ3VsYXIgdGV4dCBib3guXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIENlbGxFZGl0b3JcbiAqL1xudmFyIERhdGUgPSBDZWxsRWRpdG9yLmV4dGVuZCgnRGF0ZScsIHtcblxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKGdyaWQpIHtcblxuICAgICAgICB2YXIgbG9jYWxpemVyTmFtZSxcbiAgICAgICAgICAgIHVzZXNEYXRlSW5wdXRDb250cm9sID0gaXNDaHJvbWU7XG5cbiAgICAgICAgaWYgKHVzZXNEYXRlSW5wdXRDb250cm9sKSB7XG4gICAgICAgICAgICBsb2NhbGl6ZXJOYW1lID0gJ2Nocm9tZURhdGUnO1xuICAgICAgICAgICAgdGhpcy50ZW1wbGF0ZSA9ICc8aW5wdXQgdHlwZT1cImRhdGVcIj4nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbG9jYWxpemVyTmFtZSA9ICdkYXRlJztcbiAgICAgICAgICAgIHRoaXMudGVtcGxhdGUgPSAnPGlucHV0IHR5cGU9XCJ0ZXh0XCI+JztcblxuICAgICAgICAgICAgdGhpcy5zZWxlY3RBbGwgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGFzdENoYXJQbHVzT25lID0gdGhpcy5nZXRFZGl0b3JWYWx1ZSgpLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB0aGlzLmlucHV0LnNldFNlbGVjdGlvblJhbmdlKDAsIGxhc3RDaGFyUGx1c09uZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5sb2NhbGl6ZXIgPSBncmlkLmxvY2FsaXphdGlvbi5nZXQobG9jYWxpemVyTmFtZSk7XG4gICAgfVxufSk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBEYXRlO1xuIiwiLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHBvcE1lbnUgPSByZXF1aXJlKCdwb3AtbWVudScpO1xudmFyIENvbmRpdGlvbmFscyA9IHJlcXVpcmUoJy4uL1NoYXJlZCcpLkZpbHRlclRyZWUuQ29uZGl0aW9uYWxzO1xuXG52YXIgQ29tYm9Cb3ggPSByZXF1aXJlKCcuL0NvbWJvQm94Jyk7XG52YXIgcHJvdG90eXBlID0gcmVxdWlyZSgnLi9DZWxsRWRpdG9yJykucHJvdG90eXBlO1xuXG5cbi8qKlxuICogVGhlIHNlbGVjdCBsaXN0IGNvbnNpc3RzIG9mIHRoZSBmb2xsb3dpbmcgc2V0cyBvZiBkcm9wLWRvd24gaXRlbXM6XG4gKiAqIGBvcGVyYXRvcnNgIChpY29uICombHQ7KikgVGhlIHBhcnRpY3VsYXIgc2VsZWN0aW9uIG9mIG9wZXJhdG9ycyBmb3IgdGhpcyBjb2x1bW4uIENvbWVzIGZyb20gdGhlIGZpbHRlciB0cmVlLlxuICogKiBgZGlzdGluY3RWYWx1ZXNgIChpY29uICojKikgTGlzdCBvZiBkaXN0aW5jdCBjb2x1bW4gdmFsdWVzLiBDYWxjdWxhdGVkIGZyb20gaW5zcGVjdGlvbiBvZiBjb2x1bW4gdmFsdWVzIG9uIF9hbmRfIG9uIGljb24gY2xpY2suXG4gKiAqIGBjb2x1bW5OYW1lc2AgKGljb24gKlQqKSBMaXN0IG90aGVyIGNvbHVtbiBuYW1lcy4gQ2FsY3VsYXRlZCBmcm9tIGluc3BlY3Rpb24gb2YgY29sdW1uIHZhbHVlcyBvbiBfYW5kXyBvbiBpY29uIGNsaWNrLlxuICpcbiAqIFRoZSBjb250cm9sIGFyZWEgcmVmbGVjdHMgdGhlIGB0aGlzLm1vZGVzYCBhcnJheSAoYWJvdmUpLiBJdCBpcyBtb2RlbGVkIGJ5IGEgJ21lbnVNb2Rlc2Agb2JqZWN0LCBhIGhhc2ggd2l0aCBib29sZWFuIHByb3BlcnRpZXMgcmVwcmVzZW50aW5nIHRoZSBzdGF0ZSBvZiBlYWNoIG9mIHRoZSBzZXRzIG9mIG1lbnUgaXRlbXMgb3V0bGluZWQgYWJvdmUuIE1pc3NpbmcgcHJvcGVydGllcyBhcmUgZmFsc3kgYnkgaW1wbGljYXRpb24uIFRoZSBzdGF0ZSBzZW1hbnRpY3MgYXJlOlxuICogICAqIGAxYCBvciBgdHJ1ZWAgbWVhbnMgYWRkcyBDU1MgY2xhc3MgYGFjdGl2ZWAgdG8gaWNvbiBfYW5kXyBzaG93cyBzZXQncyBpdGVtcyBpbiBkcm9wLWRvd24uXG4gKiAgICogYDBgIG9yIGBmYWxzZWAgbWVhbnMgcmVtb3ZlcyAoQ1NTIGNsYXNzIGBhY3RpdmVgIGZyb20gaWNvbiBfYW5kXyBoaWRlcyBzZXQncyBpdGVtcyBpbiBkcm9wLWRvd24uXG4gKlxuICogKlBlcnNpc3RpbmcgY2hhbmdlczoqIFRoZSBvbmx5IGNoYW5nZSB0aGlzIFVJIHN1cHBvcnRzIChiZXNpZGVzIHRoZSBmaWx0ZXIgdGV4dCBpdHNlbGYpIGlzIHRoZSBtZW51IG1vZGUgc3RhdGVzLCB3aGljaCBhcmUgZXhwZWN0ZWQgdG8gYmUgXCJzdGlja3kuXCIgVGhhdCBpcywgdGhleSBhcmUgXCJwZXJzaXN0ZWRcIiAod3JpdHRlbiBiYWNrKSB0byB0aGUgZmlsdGVyLiBIb3dldmVyLCB0aGVyZSBpcyBhIHByb2JsZW06IFdoZW4gdGhlIGNvbHVtbiBmaWx0ZXIgaXMgYmxhbmsgaXQgZG9lc24ndCBhY3R1YWxseSBleGlzdCB5ZXQgaW4gdGhlIGZpbHRlciwgc28gdGhlcmUgaXMgbm93aGVyZSB0byBzYXZlIGl0LiBUaGUgc29sdXRpb24gaXMgdG8gcmVhZCB0aGUgYG1lbnVNb2Rlc2AgaGFzaCBfZnJvbV8gdGhlIGZpbHRlciB0cmVlIGJ1dCBkb24ndCBtb2RpZnkgaXQgdW50aWwgZW5kIG9mIGVkaXRpbmcuIFJlYWRpbmcgaXQgZnJvbSB0aGUgZmlsdGVyIHRyZWUgcGlja3MgdXAgcHJldmlvdXMgc2V0dGluZyBpZiB0aGVyZSB3YXMgYW4gZXh0YW50IGNvbHVtbiBmaWx0ZXIgb3IgdGhlIGRlZmF1bHQgaWYgdGhlcmUgd2FzIG5vdC4gQnV0IHRoZW4sIHJhdGhlciB0aGFuIG1vZGlmeWluZyB0aGlzIHN0cnVjdHVyZSAoYmVjYXVzZSBpdCBtaWdodCBiZSB0aGUgZGVmYXVsdCBhbmQgd2UgZG9uJ3Qgd2FudCB0byBvdmVyd3JpdGUgdGhhdCksIHdlIGhhbmcgYSBwcm94eSBjb3B5IG9mZiB0aGUgYmVoYXZpb3IncyBjb2x1bW4gb2JqZWN0IGZvciB0aGlzIGNvbHVtbi4gVGhpcyB3aWxsIHBlcnNpc3QgaXQgZm9yIHRoZSBkdXJhdGlvbiBvZiB0aGUgYXBwIHNlc3Npb24uIEF0IGVuZCBvZiBlZGl0aW5nLCBpZiBhbmQgb25seSBpZiB0aGVyZSBpcyBub3cgYSBjb2x1bW4gZmlsdGVyICh0ZXh0IGlzIG5vdCBibGFuayksIHdlIGNvcHkgaXQgdG8gdGhlIGNvbHVtbiBmaWx0ZXIncyBzdWJ0cmVlIG5vZGUgaW4gdGhlIGZpbHRlciB0cmVlLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQ29tYm9Cb3hcbiAqL1xudmFyIEZpbHRlckJveCA9IENvbWJvQm94LmV4dGVuZCgnRmlsdGVyQm94Jywge1xuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgLy8gbG9vayBpbiB0aGUgZmlsdGVyLCB1bmRlciBjb2x1bW4gZmlsdGVycywgZm9yIGEgY29sdW1uIGZpbHRlciBmb3IgdGhpcyBjb2x1bW5cbiAgICAgICAgdmFyIHJvb3QgPSB0aGlzLmdyaWQuZ2V0R2xvYmFsRmlsdGVyKCksXG4gICAgICAgICAgICBjb2x1bW5OYW1lID0gdGhpcy5jb2x1bW4ubmFtZSxcbiAgICAgICAgICAgIGNvbHVtbkZpbHRlcnMgPSB0aGlzLmdyaWQuZ2V0R2xvYmFsRmlsdGVyKCkuY29sdW1uRmlsdGVycyxcbiAgICAgICAgICAgIGNvbHVtbkZpbHRlclN1YnRyZWUgPSByb290LmdldENvbHVtbkZpbHRlcihjb2x1bW5OYW1lKSB8fCB7fSxcbiAgICAgICAgICAgIGNvbHVtblNjaGVtYSA9IHJvb3Quc2NoZW1hLmxvb2t1cChjb2x1bW5OYW1lKSB8fCB7fTtcblxuXG4gICAgICAgIC8vIGdldCB0aGUgb3BlcmF0b3IgbGlzdCBmcm9tIHRoZSBub2RlLCBzY2hlbWEsIHR5cGVPcE1hcCwgb3Igcm9vdDpcbiAgICAgICAgLy8gKFRoaXMgbWltaWNzIHRoZSBjb2RlIGluIEZpbHRlckxlYWYuanMncyBgZ2V0T3BNZW51YCBmdW5jdGlvbiBiZWNhdWFzZSB0aGUgbm9kZSBtYXkgbm90IGV4aXN0IHlldC4pXG4gICAgICAgIHRoaXMub3BNZW51ID1cblxuICAgICAgICAgICAgLy8gcHVsbCBvcGVyYXRvciBsaXN0IGZyb20gY29sdW1uIHNjaGVtYSBpZiBhdmFpbGFibGVcbiAgICAgICAgICAgIGNvbHVtblNjaGVtYS5vcE1lbnUgfHxcblxuICAgICAgICAgICAgLy8gb3BlcmF0b3IgbGlzdCBmb3IgdGhlIGNvbHVtbidzIHR5cGUgaWYgYXZhaWxhYmxlXG4gICAgICAgICAgICByb290LnR5cGVPcE1hcCAmJiByb290LnR5cGVPcE1hcFtjb2x1bW5TY2hlbWEudHlwZSB8fCBjb2x1bW5GaWx0ZXJTdWJ0cmVlLnR5cGVdIHx8XG5cbiAgICAgICAgICAgIC8vIGRlZmF1bHQgb3BlcmF0b3IgbGlzdCAod2hpY2ggaXRzZWxmIGRlZmF1bHRzIHRvIGBDb25kaXRpb25hbHMuZGVmYXVsdE9wTWVudWApXG4gICAgICAgICAgICByb290Lm9wTWVudTtcblxuXG4gICAgICAgIC8vIGdldCB0aGUgY29sdW1uIGZpbHRlcidzIGBtZW51TW9kZXNgIG9iamVjdCAtLSBjb250YWlucyB0aGUgc3RhdGVzIG9mIHRoZSBkcm9wLWRvd24gb3B0aW9uIGljb25zOlxuICAgICAgICB0aGlzLm1lbnVNb2Rlc1NvdXJjZSA9XG5cbiAgICAgICAgICAgIC8vIGZpcnN0IHRyeSBwcm94eSBmcm9tIGxhc3QgdGltZSAoYmVjYXVzZSBlZGl0aW5nIG1heSBoYXZlIGVuZGVkIHdpdGhvdXQgYSBjb2x1bW4gZmlsdGVyIHRvIHB1dCBpbiB0aGUgZmlsdGVyIHRyZWUpXG4gICAgICAgICAgICB0aGlzLmNvbHVtbi5tZW51TW9kZXMgfHxcblxuICAgICAgICAgICAgLy8gRUxTRSB0cnkgY29sdW1uIGZpbHRlcidzIGBtZW51TW9kZXNgIFdIRU4gYXZhaWxhYmxlXG4gICAgICAgICAgICBjb2x1bW5GaWx0ZXJTdWJ0cmVlLm1lbnVNb2RlcyB8fFxuICAgICAgICAgICAgY29sdW1uRmlsdGVyU3VidHJlZS5tZW51TW9kZXMgfHxcblxuICAgICAgICAgICAgLy8gdHJ5IHVzZSBjb2x1bW4gc2NoZW1hJ3MgYG1lbnVNb2Rlc2Agd2hlbiBkZWZpbmVkXG4gICAgICAgICAgICBjb2x1bW5TY2hlbWEubWVudU1vZGVzIHx8XG5cbiAgICAgICAgICAgIC8vIEVMU0UgdHJ5IHRoZSBmaWx0ZXIgZGVmYXVsdCAod2hpY2ggaXRzZWxmIGRlZmF1bHRzIHRvIG9wZXJhdG9ycyBPTiwgb3RoZXJzIE9GRjsgc2VlIGRlZmluaXRpb24gYXQgdG9wIG9mIERlZmF1bHRGaWx0ZXIuanMpXG4gICAgICAgICAgICBjb2x1bW5GaWx0ZXJzLm1lbnVNb2RlcztcblxuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIFdoZW4gdGhlcmUncyBvbmx5IG9uZSBtb2RlIGRlZmluZWQgaGVyZSwgdGhlIGNvbnRyb2wgYXJlYSBwb3J0aW9uIG9mIHRoZSBVSSBpcyBoaWRkZW4uXG4gICAgICovXG4gICAgbW9kZXM6IFtcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ29wZXJhdG9ycycsXG4gICAgICAgICAgICBzeW1ib2w6ICc8JyxcbiAgICAgICAgICAgIGFwcGVuZE9wdGlvbnM6IGZ1bmN0aW9uKGRyb3Bkb3duKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFkcm9wZG93bi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVmFyaW91cyAgb3BlcmF0b3Igb3B0aW9ucyBhbmQvb3Igb3B0Z3JvdXBzIHZhcnkgcGVyIGNvbHVtbiBiYXNlZCBvbiBgb3BNZW51YC5cbiAgICAgICAgICAgICAgICAgICAgcG9wTWVudS5idWlsZChkcm9wZG93biwgdGhpcy5vcE1lbnUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwOiBmdW5jdGlvbihncm91cE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gQ29uZGl0aW9uYWxzLmdyb3Vwc1tncm91cE5hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21wdDogbnVsbFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBsaXN0IG9mIGNvbmp1bmN0aW9ucyBpcyBhbiBleHRyYSBhbmQgaXMgZm9yIGFsbCBjb2x1bW5zLiBBbGwgb3BlcmF0b3Igb3B0Z3JvdXBzIGFyZSBjbGFzc2xlc3MuXG4gICAgICAgICAgICAgICAgICAgIHZhciBvcHRncm91cCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29wdGdyb3VwJyk7XG4gICAgICAgICAgICAgICAgICAgIG9wdGdyb3VwLmxhYmVsID0gJ0Nvbmp1bmN0aW9ucyc7XG4gICAgICAgICAgICAgICAgICAgIG9wdGdyb3VwLmFwcGVuZENoaWxkKG5ldyBPcHRpb24oJ2FuZCcsICcgYW5kICcpKTtcbiAgICAgICAgICAgICAgICAgICAgb3B0Z3JvdXAuYXBwZW5kQ2hpbGQobmV3IE9wdGlvbignb3InLCAnIG9yICcpKTtcbiAgICAgICAgICAgICAgICAgICAgb3B0Z3JvdXAuYXBwZW5kQ2hpbGQobmV3IE9wdGlvbignbm9yJywgJyBub3IgJykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbmFtZTogJ2NvbHVtbk5hbWVzJyxcbiAgICAgICAgICAgIGxhYmVsOiAnQ29sdW1uIE5hbWVzJyxcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnb3B0Z3JvdXAuc3VibWVudS1jb2x1bW5OYW1lcycsXG4gICAgICAgICAgICBzeW1ib2w6ICdBJyxcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJyNlZmYnLFxuICAgICAgICAgICAgYXBwZW5kT3B0aW9uczogZnVuY3Rpb24ob3B0Z3JvdXApIHtcbiAgICAgICAgICAgICAgICB2YXIgY29sdW1ucyA9IHRoaXMuZ3JpZC5iZWhhdmlvci5jb2x1bW5zLFxuICAgICAgICAgICAgICAgICAgICB4ID0gdGhpcy5lZGl0UG9pbnQueDtcblxuICAgICAgICAgICAgICAgIHdoaWxlIChvcHRncm91cC5maXJzdEVsZW1lbnRDaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICBvcHRncm91cC5maXJzdEVsZW1lbnRDaGlsZC5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb2x1bW5zLmZvckVhY2goZnVuY3Rpb24oY29sdW1uLCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggIT09IHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuYW1lID0gY29sdW1uLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uID0gbmV3IE9wdGlvbihuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbi50aXRsZSA9ICdbJyArIG5hbWUgKyAnXVxcclwiJyArIGNvbHVtbi5oZWFkZXIgKyAnXCInO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0Z3JvdXAuYXBwZW5kQ2hpbGQob3B0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb2x1bW5zLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbmFtZTogJ2Rpc3RpbmN0VmFsdWVzJyxcbiAgICAgICAgICAgIGxhYmVsOiAnRGlzdGluY3QgVmFsdWVzJyxcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnb3B0Z3JvdXAuc3VibWVudS1kaXN0aW5jdFZhbHVlcycsXG4gICAgICAgICAgICBzeW1ib2w6ICcjJyxcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJyNmZWYnLFxuICAgICAgICAgICAgYXBwZW5kT3B0aW9uczogQ29tYm9Cb3gucHJvdG90eXBlLm1vZGVzWzBdLmFwcGVuZE9wdGlvbnNcbiAgICAgICAgfVxuICAgIF0sXG5cbiAgICAvKipcbiAgICAgKiBXcml0ZSB0aGUgYG1lbnVNb2Rlc2AgcHJveHkgdG8gdGhlIGZpbHRlciB0cmVlJ3MgY29sdW1uIGZpbHRlciBzdWJ0cmVlIG5vZGUuXG4gICAgICogV2UgbG9vayB1cCB0aGUgbm9kZSBhZ2FpbiBoZXJlIGJlY2F1c2UgaXQgbWlnaHQgYmUgbmV3OyBvciBtYXkgaGF2ZSBiZWVuIGRlbGV0ZWQgJiByZWNyZWF0ZWQgZHVyaW5nIGVkaXRpbmcuXG4gICAgICovXG4gICAgaGlkZUVkaXRvcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIGxvb2sgaW4gdGhlIGZpbHRlciwgdW5kZXIgY29sdW1uIGZpbHRlcnMsIGZvciBhIGNvbHVtbiBmaWx0ZXIgZm9yIHRoaXMgY29sdW1uXG4gICAgICAgIHZhciBmaWx0ZXIgPSB0aGlzLmdyaWQuZ2V0R2xvYmFsRmlsdGVyKCksXG4gICAgICAgICAgICBjb2x1bW5OYW1lID0gdGhpcy5jb2x1bW4ubmFtZSxcbiAgICAgICAgICAgIGNvbHVtbkZpbHRlclN1YnRyZWUgPSBmaWx0ZXIuZ2V0Q29sdW1uRmlsdGVyKGNvbHVtbk5hbWUpO1xuXG4gICAgICAgIGlmIChjb2x1bW5GaWx0ZXJTdWJ0cmVlKSB7XG4gICAgICAgICAgICAvLyB3cml0ZSBiYWNrIHRvIGZpbHRlci10cmVlIG5vZGUgZm9yIHBlcnNpc3Rpbmcgd2l0aCBnZXRTdGF0ZVxuICAgICAgICAgICAgY29sdW1uRmlsdGVyU3VidHJlZS5tZW51TW9kZXMgPSB0aGlzLm1lbnVNb2RlcztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY29sdW1uLm1lbnVNb2RlcyA9IHRoaXMubWVudU1vZGVzO1xuXG4gICAgICAgIENvbWJvQm94LnByb3RvdHlwZS5oaWRlRWRpdG9yLmNhbGwodGhpcyk7XG4gICAgfSxcblxuICAgIGtleXVwOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICBwcm90b3R5cGUua2V5dXAuY2FsbCh0aGlzLCBlKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuZ3JpZC5yZXNvbHZlUHJvcGVydHkoJ2ZpbHRlcmluZ01vZGUnKSA9PT0gJ2ltbWVkaWF0ZScpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNhdmVFZGl0b3JWYWx1ZSh0aGlzLmdldEVkaXRvclZhbHVlKCkpO1xuICAgICAgICAgICAgICAgIHRoaXMubW92ZUVkaXRvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGluc2VydFRleHQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgLy8gaW5zZXJ0IHRoZSBkcm9wLWRvd25iIHRleHQgYXQgdGhlIGluc2VydGlvbiBwb2ludCBvciBvdmVyIHRoZSBzZWxlY3RlZCB0ZXh0XG4gICAgICAgIHRoaXMuaW5wdXQuZm9jdXMoKTtcbiAgICAgICAgdGhpcy5pbnB1dC5zZXRSYW5nZVRleHQodGhpcy5kcm9wZG93bi52YWx1ZSwgdGhpcy5zZWxlY3Rpb25TdGFydCwgdGhpcy5zZWxlY3Rpb25FbmQsICdlbmQnKTtcblxuICAgICAgICAvLyBjbG9zZSB0aGUgZHJvcC1kb3duXG4gICAgICAgIHRoaXMudG9nZ2xlRHJvcERvd24oKTtcbiAgICB9XG5cbn0pO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gRmlsdGVyQm94O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVGV4dGZpZWxkID0gcmVxdWlyZSgnLi9UZXh0ZmllbGQnKTtcblxuLyoqXG4gKiBGdW5jdGlvbnMgd2VsbCBpbiBDaHJvbWUsIFNhZmFyaSwgRmlyZWZveCwgYW5kIEludGVybmV0IEV4cGxvcmVyLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBUZXh0ZmllbGRcbiAqL1xudmFyIE51bWJlciA9IFRleHRmaWVsZC5leHRlbmQoJ051bWJlcicsIHtcblxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKGdyaWQpIHtcbiAgICAgICAgdGhpcy5sb2NhbGl6ZXIgPSBncmlkLmxvY2FsaXphdGlvbi5nZXQoJ251bWJlcicpO1xuICAgIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gTnVtYmVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ2VsbEVkaXRvciA9IHJlcXVpcmUoJy4vQ2VsbEVkaXRvcicpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQ2VsbEVkaXRvclxuICovXG52YXIgU2xpZGVyID0gQ2VsbEVkaXRvci5leHRlbmQoJ1NsaWRlcicsIHtcblxuICAgIHRlbXBsYXRlOiAnPGlucHV0IHR5cGU9XCJyYW5nZVwiIGxhbmc9XCJ7e2xvY2FsZX19XCIgc3R5bGU9XCJ7e3N0eWxlfX1cIj4nXG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNsaWRlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIENlbGxFZGl0b3IgPSByZXF1aXJlKCcuL0NlbGxFZGl0b3IuanMnKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIENlbGxFZGl0b3JcbiAqL1xudmFyIFNwaW5uZXIgPSBDZWxsRWRpdG9yLmV4dGVuZCgnU3Bpbm5lcicsIHtcblxuICAgIHRlbXBsYXRlOiAnPGlucHV0IHR5cGU9XCJudW1iZXJcIiBsYW5nPVwie3tsb2NhbGV9fVwiIHN0eWxlPVwie3tzdHlsZX19XCI+J1xuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBTcGlubmVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ2VsbEVkaXRvciA9IHJlcXVpcmUoJy4vQ2VsbEVkaXRvci5qcycpO1xudmFyIExvY2FsaXphdGlvbiA9IHJlcXVpcmUoJy4uL2xpYi9Mb2NhbGl6YXRpb24nKTtcblxuXG4vKipcbiAqIEFzIG9mIHNwcmluZyAyMDE2OlxuICogRnVuY3Rpb25zIHdlbGwgaW4gQ2hyb21lLCBTYWZhcmksIEZpcmVmb3gsIGFuZCBJbnRlcm5ldCBFeHBsb3Jlci5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQ2VsbEVkaXRvclxuICovXG52YXIgVGV4dGZpZWxkID0gQ2VsbEVkaXRvci5leHRlbmQoJ1RleHRmaWVsZCcsIHtcblxuICAgIHRlbXBsYXRlOiAnPGlucHV0IHR5cGU9XCJ0ZXh0XCIgbGFuZz1cInt7bG9jYWxlfX1cIiBzdHlsZT1cInt7c3R5bGV9fVwiPicsXG5cbiAgICBsb2NhbGl6ZXI6IExvY2FsaXphdGlvbi5wcm90b3R5cGUuc3RyaW5nLFxuXG4gICAgc2VsZWN0QWxsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGxhc3RDaGFyUGx1c09uZSA9IHRoaXMuZ2V0RWRpdG9yVmFsdWUoKS5sZW5ndGg7XG4gICAgICAgIHRoaXMuaW5wdXQuc2V0U2VsZWN0aW9uUmFuZ2UoMCwgbGFzdENoYXJQbHVzT25lKTtcbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBUZXh0ZmllbGQ7XG4iLCIvKipcbiAqIEBtb2R1bGUgY2VsbEVkaXRvcnNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICpcbiAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtwcml2YXRlUmVnaXN0cnk9ZmFsc2VdIC0gVGhpcyBpbnN0YW5jZSB3aWxsIHVzZSBhIHByaXZhdGUgcmVnaXN0cnkuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gQ2VsbEVkaXRvcnMoZ3JpZCwgcHJpdmF0ZVJlZ2lzdHJ5KSB7XG4gICAgdGhpcy5ncmlkID0gZ3JpZDtcblxuICAgIGlmIChwcml2YXRlUmVnaXN0cnkpIHtcbiAgICAgICAgdGhpcy5lZGl0b3JzID0ge307XG4gICAgfVxuXG4gICAgLy8gcHJlcmVnaXN0ZXIgdGhlIHN0YW5kYXJkIGNlbGwgZWRpdG9yc1xuICAgIGlmIChwcml2YXRlUmVnaXN0cnkgfHwgIXRoaXMuZ2V0KCdjZWxsZWRpdG9yJykpIHtcbiAgICAgICAgdGhpcy5hZGQocmVxdWlyZSgnLi9DZWxsRWRpdG9yJykpO1xuICAgICAgICB0aGlzLmFkZChyZXF1aXJlKCcuL0NvbWJvQm94JykpO1xuICAgICAgICB0aGlzLmFkZChyZXF1aXJlKCcuL0NvbG9yJykpO1xuICAgICAgICB0aGlzLmFkZChyZXF1aXJlKCcuL0RhdGUnKSk7XG4gICAgICAgIHRoaXMuYWRkKHJlcXVpcmUoJy4vRmlsdGVyQm94JykpO1xuICAgICAgICB0aGlzLmFkZChyZXF1aXJlKCcuL051bWJlcicpKTtcbiAgICAgICAgdGhpcy5hZGQocmVxdWlyZSgnLi9TbGlkZXInKSk7XG4gICAgICAgIHRoaXMuYWRkKHJlcXVpcmUoJy4vU3Bpbm5lcicpKTtcbiAgICAgICAgdGhpcy5hZGQocmVxdWlyZSgnLi9UZXh0ZmllbGQnKSk7XG4gICAgfVxufVxuXG5DZWxsRWRpdG9ycy5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IENlbGxFZGl0b3JzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciwgLy8gcHJlc2VydmUgY29uc3RydWN0b3JcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IFJlZ2lzdGVyIGEgY2VsbCBlZGl0b3IgY29uc3RydWN0b3IuXG4gICAgICogQGRlc2MgQWRkcyBhIGN1c3RvbSBjZWxsIGVkaXRvciBjb25zdHJ1Y3RvciB0byB0aGUgYGVkaXRvcnNgIGhhc2ggdXNpbmcgdGhlIHByb3ZpZGVkIG5hbWUgKG9yIHRoZSBjbGFzcyBuYW1lKSwgY29udmVydGVkIHRvIGFsbCBsb3dlciBjYXNlLlxuICAgICAqXG4gICAgICogPiBBbGwgbmF0aXZlIGNlbGwgZWRpdG9ycyBhcmUgXCJwcmVyZWdpc3RlcmVkXCIgaW4gYGVkaXRvcnNgLi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbbmFtZV0gLSBDYXNlLWluc2Vuc2l0aXZlIGVkaXRvciBrZXkuIElmIG5vdCBnaXZlbiwgYFlvdXJDZWxsRWRpdG9yLnByb3RvdHlwZS4kJENMQVNTX05BTUVgIGlzIHVzZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1lvdXJDZWxsRWRpdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcn0gQ29uc3RydWN0b3IgLSBBIGNvbnN0cnVjdG9yLCB0eXBpY2FsbHkgZXh0ZW5kZWQgZnJvbSBgQ2VsbEVkaXRvcmAgKG9yIGEgZGVzY2VuZGFudCB0aGVyZWZyb20pLlxuICAgICAqXG4gICAgICogPiBOb3RlOiBgJCRDTEFTU19OQU1FYCBjYW4gYmUgZWFzaWx5IHNldCB1cCBieSBwcm92aWRpbmcgYSBzdHJpbmcgYXMgdGhlIChvcHRpb25hbCkgZmlyc3QgcGFyYW1ldGVyIChgYWxpYXNgKSBpbiB5b3VyIHtAbGluayBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9leHRlbmQtbWV8Q2VsbEVkaXRvci5leHRlbmR9IGNhbGwuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Q2VsbEVkaXRvcn0gQSBuZXdseSByZWdpc3RlcmVkIGNvbnN0cnVjdG9yIGV4dGVuZGVkIGZyb20ge0BsaW5rIENlbGxFZGl0b3J9LlxuICAgICAqXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpjZWxsRWRpdG9yc1xuICAgICAqL1xuICAgIGFkZDogZnVuY3Rpb24obmFtZSwgQ29uc3RydWN0b3IpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBDb25zdHJ1Y3RvciA9IG5hbWU7XG4gICAgICAgICAgICBuYW1lID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgbmFtZSA9IG5hbWUgfHwgQ29uc3RydWN0b3IucHJvdG90eXBlLiQkQ0xBU1NfTkFNRTtcbiAgICAgICAgbmFtZSA9IG5hbWUgJiYgbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB0aGlzLmVkaXRvcnNbbmFtZV0gPSBDb25zdHJ1Y3RvcjtcbiAgICAgICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBSZWdpc3RlciBhIHN5bm9ueW0gZm9yIGFuIGV4aXN0aW5nIGNlbGwgZWRpdG9yIGNvbnN0cnVjdG9yLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzeW5vbnltTmFtZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBleGlzdGluZ05hbWVcbiAgICAgKiBAcmV0dXJucyB7Q2VsbEVkaXRvcn0gVGhlIHByZXZpb3VzbHkgcmVnaXN0ZXJlZCBjb25zdHJ1Y3RvciB0aGlzIG5ldyBzeW5vbnltIHBvaW50cyB0by5cbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEVkaXRvcnMucHJvdG90eXBlXG4gICAgICovXG4gICAgYWRkU3lub255bTogZnVuY3Rpb24oc3lub255bU5hbWUsIGV4aXN0aW5nTmFtZSkge1xuICAgICAgICB2YXIgY2VsbEVkaXRvciA9IHRoaXMuZ2V0KGV4aXN0aW5nTmFtZSk7XG4gICAgICAgIHJldHVybiAodGhpcy5lZGl0b3JzW3N5bm9ueW1OYW1lXSA9IGNlbGxFZGl0b3IpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIE5hbWUgb2YgYSByZWdpc3RlcmVkIGVkaXRvci5cbiAgICAgKiBAcmV0dXJucyB7Q2VsbEVkaXRvcn0gQSByZWdpc3RlcmVkIGNvbnN0cnVjdG9yIGV4dGVuZGVkIGZyb20ge0BsaW5rIENlbGxFZGl0b3J9LlxuICAgICAqIEBtZW1iZXJPZiBDZWxsRWRpdG9ycy5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWRpdG9yc1tuYW1lICYmIG5hbWUudG9Mb3dlckNhc2UoKV07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IExvb2t1cCByZWdpc3RlcmVkIGNlbGwgZWRpdG9yIGFuZCByZXR1cm4gYSBuZXcgaW5zdGFuY2UgdGhlcmVvZi5cbiAgICAgKiBAZGVzYyBOb3RlOiBNdXN0IGJlIGNhbGxlZCB3aXRoIHRoZSBIeXBlcmdyaWQgb2JqZWN0IGFzIGNvbnRleHQhXG4gICAgICogQHJldHVybnMge0NlbGxFZGl0b3J9IE5ldyBpbnN0YW5jZSBvZiB0aGUgbmFtZWQgY2VsbCBlZGl0b3IuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBOYW1lIG9mIGEgcmVnaXN0ZXJlZCBlZGl0b3IuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zXSAtIFByb3BlcnRpZXMgdG8gYWRkIHRvIHRoZSBpbnN0YW50aWF0ZWQgZWRpdG9yIHByaW1hcmlseSBmb3IgbXVzdGFjaGUncyB1c2UuXG4gICAgICogQG1lbWJlck9mIENlbGxFZGl0b3JzLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGNyZWF0ZTogZnVuY3Rpb24obmFtZSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgY2VsbEVkaXRvcixcbiAgICAgICAgICAgIENvbnN0cnVjdG9yID0gdGhpcy5nZXQobmFtZSk7XG5cbiAgICAgICAgaWYgKENvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICBpZiAoQ29uc3RydWN0b3IuYWJzdHJhY3QpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnQXR0ZW1wdCB0byBpbnN0YW50aWF0ZSBhbiBcImFic3RyYWN0XCIgY2VsbCBlZGl0b3IgY2xhc3MuJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNlbGxFZGl0b3IgPSBuZXcgQ29uc3RydWN0b3IodGhpcy5ncmlkLCBvcHRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjZWxsRWRpdG9yO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgY2VsbCBlZGl0b3IgcmVnaXN0cnkgY29udGFpbmluZyBhbGwgdGhlIFwicHJlcmVnaXN0ZXJlZFwiIGNlbGwgZWRpdG9yIGNvbnN0cnVjdG9ycy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBtZW1iZXJPZiBDZWxsRWRpdG9ycy5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBlZGl0b3JzOiB7fVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDZWxsRWRpdG9ycztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIENlbGxSZW5kZXJlciA9IHJlcXVpcmUoJy4vQ2VsbFJlbmRlcmVyJyk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBDZWxsUmVuZGVyZXJcbiAqL1xudmFyIEJ1dHRvbiA9IENlbGxSZW5kZXJlci5leHRlbmQoJ0J1dHRvbicsIHtcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IFRoZSBkZWZhdWx0IGNlbGwgcmVuZGVyaW5nIGZ1bmN0aW9uIGZvciBhIGJ1dHRvbiBjZWxsLlxuICAgICAqIEBwYXJhbSB7Q2FudmFzR3JhcGhpY3NDb250ZXh0fSBnY1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjb25maWdcbiAgICAgKiBAcGFyYW0ge1JlY3RhbmdsZX0gY29uZmlnLmJvdW5kcyAtIFRoZSBjbGlwcGluZyByZWN0IG9mIHRoZSBjZWxsIHRvIGJlIHJlbmRlcmVkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb25maWcueCAtIHRoZSBcInRyYW5zbGF0ZWRcIiBpbmRleCBpbnRvIHRoZSBgYmVoYXZpb3IuYWxsQ29sdW1uc2AgYXJyYXlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29uZmlnLm5vcm1hbGl6ZWRZIC0gdGhlIHZlcnRpY2FsIGdyaWQgY29vcmRpbmF0ZSBub3JtYWxpemVkIHRvIGZpcnN0IGRhdGEgcm93XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbmZpZy51bnRyYW5zbGF0ZWRYIC0gdGhlIGhvcml6b250YWwgZ3JpZCBjb29yZGluYXRlIG1lYXN1cmVkIGZyb20gZmlyc3QgZGF0YSBjb2x1bW5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29uZmlnLnkgLSB0aGUgdmVydGljYWwgZ3JpZCBjb29yZGluYXRlIG1lYXN1cmVkIGZyb20gdG9wIGhlYWRlciByb3dcbiAgICAgKi9cbiAgICBwYWludDogZnVuY3Rpb24oZ2MsIGNvbmZpZykge1xuICAgICAgICB2YXIgdmFsID0gY29uZmlnLnZhbHVlO1xuICAgICAgICB2YXIgYyA9IGNvbmZpZy54O1xuICAgICAgICB2YXIgciA9IGNvbmZpZy55O1xuICAgICAgICB2YXIgYm91bmRzID0gY29uZmlnLmJvdW5kcztcbiAgICAgICAgdmFyIHggPSBib3VuZHMueCArIDI7XG4gICAgICAgIHZhciB5ID0gYm91bmRzLnkgKyAyO1xuICAgICAgICB2YXIgd2lkdGggPSBib3VuZHMud2lkdGggLSAzO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gYm91bmRzLmhlaWdodCAtIDM7XG4gICAgICAgIHZhciByYWRpdXMgPSBoZWlnaHQgLyAyO1xuICAgICAgICB2YXIgYXJjR3JhZGllbnQgPSBnYy5jcmVhdGVMaW5lYXJHcmFkaWVudCh4LCB5LCB4LCB5ICsgaGVpZ2h0KTtcbiAgICAgICAgaWYgKGNvbmZpZy5tb3VzZURvd24pIHtcbiAgICAgICAgICAgIGFyY0dyYWRpZW50LmFkZENvbG9yU3RvcCgwLCAnI0I1Q0JFRCcpO1xuICAgICAgICAgICAgYXJjR3JhZGllbnQuYWRkQ29sb3JTdG9wKDEsICcjNGQ3NGVhJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhcmNHcmFkaWVudC5hZGRDb2xvclN0b3AoMCwgJyNmZmZmZmYnKTtcbiAgICAgICAgICAgIGFyY0dyYWRpZW50LmFkZENvbG9yU3RvcCgxLCAnI2FhYWFhYScpO1xuICAgICAgICB9XG4gICAgICAgIGdjLmZpbGxTdHlsZSA9IGFyY0dyYWRpZW50O1xuICAgICAgICBnYy5zdHJva2VTdHlsZSA9ICcjMDAwMDAwJztcbiAgICAgICAgdGhpcy5yb3VuZFJlY3QoZ2MsIHgsIHksIHdpZHRoLCBoZWlnaHQsIHJhZGl1cywgYXJjR3JhZGllbnQsIHRydWUpO1xuXG4gICAgICAgIHZhciBveCA9ICh3aWR0aCAtIGNvbmZpZy5nZXRUZXh0V2lkdGgoZ2MsIHZhbCkpIC8gMjtcbiAgICAgICAgdmFyIG95ID0gKGhlaWdodCAtIGNvbmZpZy5nZXRUZXh0SGVpZ2h0KGdjLmZvbnQpLmRlc2NlbnQpIC8gMjtcblxuICAgICAgICBpZiAoZ2MudGV4dEJhc2VsaW5lICE9PSAnbWlkZGxlJykge1xuICAgICAgICAgICAgZ2MudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgICAgIH1cblxuICAgICAgICBnYy5maWxsU3R5bGUgPSAnIzAwMDAwMCc7XG5cbiAgICAgICAgY29uZmlnLmJhY2tncm91bmRDb2xvciA9ICdyZ2JhKDAsMCwwLDApJztcbiAgICAgICAgZ2MuZmlsbFRleHQodmFsLCB4ICsgb3gsIHkgKyBveSk7XG5cbiAgICAgICAgLy9pZGVudGlmeSB0aGF0IHdlIGFyZSBhIGJ1dHRvblxuICAgICAgICBjb25maWcuYnV0dG9uQ2VsbHNbYyArICcsJyArIHJdID0gdHJ1ZTtcbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBCdXR0b247XG5cblxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQmFzZSA9IHJlcXVpcmUoJy4vLi4vbGliL0Jhc2UnKTtcblxuLyoqIEBjb25zdHJ1Y3RvclxuICogQGRlc2MgSW5zdGFuY2VzIG9mIGBDZWxsUmVuZGVyZXJgIGFyZSB1c2VkIHRvIHJlbmRlciB0aGUgMkQgZ3JhcGhpY3MgY29udGV4dCB3aXRoaW4gdGhlIGJvdW5kIG9mIGEgY2VsbC4gRXh0ZW5kIHRoaXMgYmFzZSBjbGFzcyB0byBpbXBsZW1lbnQgeW91ciBvd24gY2VsbCByZW5kZXJlclxuICpcbiAqXG4gKiBTZWUgYWxzbyB7QHR1dG9yaWFsIGNlbGwtcmVuZGVyZXJ9LlxuICovXG52YXIgQ2VsbFJlbmRlcmVyID0gQmFzZS5leHRlbmQoJ0NlbGxSZW5kZXJlcicsIHtcbiAgICAvKipcbiAgICAgKiBAZGVzYyBBbiBlbXB0eSBpbXBsZW1lbnRhdGlvbiBvZiBhIGNlbGwgcmVuZGVyZXIsIHNlZSBbdGhlIG51bGwgb2JqZWN0IHBhdHRlcm5dKGh0dHA6Ly9jMi5jb20vY2dpL3dpa2k/TnVsbE9iamVjdCkuXG4gICAgICogQHBhcmFtIHtDYW52YXNHcmFwaGljc0NvbnRleHR9IGdjXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7UmVjdGFuZ2xlfSBjb25maWcuYm91bmRzIC0gVGhlIGNsaXBwaW5nIHJlY3Qgb2YgdGhlIGNlbGwgdG8gYmUgcmVuZGVyZWQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbmZpZy54IC0gdGhlIFwidHJhbnNsYXRlZFwiIGluZGV4IGludG8gdGhlIGBiZWhhdmlvci5hbGxDb2x1bW5zYCBhcnJheVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb25maWcubm9ybWFsaXplZFkgLSB0aGUgdmVydGljYWwgZ3JpZCBjb29yZGluYXRlIG5vcm1hbGl6ZWQgdG8gZmlyc3QgZGF0YSByb3dcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29uZmlnLnVudHJhbnNsYXRlZFggLSB0aGUgaG9yaXpvbnRhbCBncmlkIGNvb3JkaW5hdGUgbWVhc3VyZWQgZnJvbSBmaXJzdCBkYXRhIGNvbHVtblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb25maWcueSAtIHRoZSB2ZXJ0aWNhbCBncmlkIGNvb3JkaW5hdGUgbWVhc3VyZWQgZnJvbSB0b3AgaGVhZGVyIHJvd1xuICAgICAqIEBtZW1iZXJPZiBDZWxsUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICovXG4gICAgcGFpbnQ6IGZ1bmN0aW9uKGdjLCBjb25maWcpIHt9LFxuXG4gICAgLyoqXG4gICAgICogQGRlc2MgQSBzaW1wbGUgaW1wbGVtZW50YXRpb24gb2Ygcm91bmRpbmcgYSBjZWxsLlxuICAgICAqIEBwYXJhbSB7Q2FudmFzR3JhcGhpY3NDb250ZXh0fSBnY1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gdGhlIHggZ3JpZCBjb29yZGluYXRlIG9mIG15IG9yaWdpblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gdGhlIHkgZ3JpZCBjb29yZGluYXRlIG9mIG15IG9yaWdpblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCAtIHRoZSB3aWR0aCBJJ20gYWxsb3dlZCB0byBkcmF3IHdpdGhpblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgLSB0aGUgaGVpZ2h0IEknbSBhbGxvd2VkIHRvIGRyYXcgd2l0aGluXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1c1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBmaWxsXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0cm9rZVxuICAgICAqIEBtZW1iZXJPZiBDZWxsUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICovXG4gICAgcm91bmRSZWN0OiBmdW5jdGlvbihnYywgeCwgeSwgd2lkdGgsIGhlaWdodCwgcmFkaXVzLCBmaWxsLCBzdHJva2UpIHtcblxuICAgICAgICBpZiAoIXN0cm9rZSkge1xuICAgICAgICAgICAgc3Ryb2tlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJhZGl1cykge1xuICAgICAgICAgICAgcmFkaXVzID0gNTtcbiAgICAgICAgfVxuICAgICAgICBnYy5iZWdpblBhdGgoKTtcbiAgICAgICAgZ2MubW92ZVRvKHggKyByYWRpdXMsIHkpO1xuICAgICAgICBnYy5saW5lVG8oeCArIHdpZHRoIC0gcmFkaXVzLCB5KTtcbiAgICAgICAgZ2MucXVhZHJhdGljQ3VydmVUbyh4ICsgd2lkdGgsIHksIHggKyB3aWR0aCwgeSArIHJhZGl1cyk7XG4gICAgICAgIGdjLmxpbmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQgLSByYWRpdXMpO1xuICAgICAgICBnYy5xdWFkcmF0aWNDdXJ2ZVRvKHggKyB3aWR0aCwgeSArIGhlaWdodCwgeCArIHdpZHRoIC0gcmFkaXVzLCB5ICsgaGVpZ2h0KTtcbiAgICAgICAgZ2MubGluZVRvKHggKyByYWRpdXMsIHkgKyBoZWlnaHQpO1xuICAgICAgICBnYy5xdWFkcmF0aWNDdXJ2ZVRvKHgsIHkgKyBoZWlnaHQsIHgsIHkgKyBoZWlnaHQgLSByYWRpdXMpO1xuICAgICAgICBnYy5saW5lVG8oeCwgeSArIHJhZGl1cyk7XG4gICAgICAgIGdjLnF1YWRyYXRpY0N1cnZlVG8oeCwgeSwgeCArIHJhZGl1cywgeSk7XG4gICAgICAgIGdjLmNsb3NlUGF0aCgpO1xuICAgICAgICBpZiAoc3Ryb2tlKSB7XG4gICAgICAgICAgICBnYy5zdHJva2UoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmlsbCkge1xuICAgICAgICAgICAgZ2MuZmlsbCgpO1xuICAgICAgICB9XG4gICAgICAgIGdjLmNsb3NlUGF0aCgpO1xuICAgIH1cbn0pO1xuXG5DZWxsUmVuZGVyZXIuYWJzdHJhY3QgPSB0cnVlOyAvLyBkb24ndCBpbnN0YW50aWF0ZSBkaXJlY3RseVxuXG5tb2R1bGUuZXhwb3J0cyA9IENlbGxSZW5kZXJlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIENlbGxSZW5kZXJlciA9IHJlcXVpcmUoJy4vQ2VsbFJlbmRlcmVyJyk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBDZWxsUmVuZGVyZXJcbiAqL1xudmFyIEVycm9yQ2VsbCA9IENlbGxSZW5kZXJlci5leHRlbmQoJ0Vycm9yQ2VsbCcsIHtcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IFdyaXRlcyBlcnJvciBtZXNzYWdlIGludG8gY2VsbC5cbiAgICAgKlxuICAgICAqIEBkZXNjIFRoaXMgZnVuY3Rpb24gaXMgZ3VhcmFudGVlZCB0byBiZSBjYWxsZWQgYXMgZm9sbG93czpcbiAgICAgKlxuICAgICAqIGBgYGphdmFzY3JpcHRcbiAgICAgKiBnYy5zYXZlKCk7XG4gICAgICogZ2MuYmVnaW5QYXRoKCk7XG4gICAgICogZ2MucmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgKiBnYy5jbGlwKCk7XG4gICAgICogYmVoYXZpb3IuZ2V0Q2VsbFByb3ZpZGVyKCkucmVuZGVyQ2VsbEVycm9yKGdjLCBtZXNzYWdlLCB4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgKiBnYy5yZXN0b3JlKCk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBCZWZvcmUgZG9pbmcgYW55dGhpbmcgZWxzZSwgdGhpcyBmdW5jdGlvbiBzaG91bGQgY2xlYXIgdGhlIGNlbGwgYnkgc2V0dGluZyBgZ2MuZmlsbFN0eWxlYCBhbmQgY2FsbGluZyBgZ2MuZmlsbCgpYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzR3JhcGhpY3NDb250ZXh0fSBnY1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjb25maWdcbiAgICAgKiBAcGFyYW0ge1JlY3RhbmdsZX0gY29uZmlnLmJvdW5kcyAtIFRoZSBjbGlwcGluZyByZWN0IG9mIHRoZSBjZWxsIHRvIGJlIHJlbmRlcmVkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb25maWcueCAtIHRoZSBcInRyYW5zbGF0ZWRcIiBpbmRleCBpbnRvIHRoZSBgYmVoYXZpb3IuYWxsQ29sdW1uc2AgYXJyYXlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29uZmlnLm5vcm1hbGl6ZWRZIC0gdGhlIHZlcnRpY2FsIGdyaWQgY29vcmRpbmF0ZSBub3JtYWxpemVkIHRvIGZpcnN0IGRhdGEgcm93XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbmZpZy51bnRyYW5zbGF0ZWRYIC0gdGhlIGhvcml6b250YWwgZ3JpZCBjb29yZGluYXRlIG1lYXN1cmVkIGZyb20gZmlyc3QgZGF0YSBjb2x1bW5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29uZmlnLnkgLSB0aGUgdmVydGljYWwgZ3JpZCBjb29yZGluYXRlIG1lYXN1cmVkIGZyb20gdG9wIGhlYWRlciByb3dcbiAgICAgKiBAbWVtYmVyT2YgRXJyb3JDZWxsLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHBhaW50OiBmdW5jdGlvbihnYywgY29uZmlnLCBtZXNzYWdlKSB7XG4gICAgICAgIC8vdmFyIGltYWdlcyA9IHJlcXVpcmUoJy4uLy4uL2ltYWdlcy9pbmRleCcpO1xuICAgICAgICB2YXIgeCA9IGNvbmZpZy5ib3VuZHMueCxcbiAgICAgICAgICAgIHkgPSBjb25maWcuYm91bmRzLnksXG4gICAgICAgICAgICB3aWR0aCA9IGNvbmZpZy5ib3VuZHMud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQgPSBjb25maWcuYm91bmRzLmhlaWdodDtcblxuICAgICAgICAvLyBjbGVhciB0aGUgY2VsbFxuICAgICAgICAvLyAodGhpcyBtYWtlcyB1c2Ugb2YgdGhlIHJlY3QgcGF0aCBkZWZpbmVkIGJ5IHRoZSBjYWxsZXIpXG4gICAgICAgIGdjLmZpbGxTdHlsZSA9ICcjRkZENTAwJztcbiAgICAgICAgZ2MuZmlsbCgpO1xuICAgICAgICAvLyByZW5kZXIgY2VsbCBib3JkZXJcbiAgICAgICAgLy9nYy5zdHJva2VTdHlsZSA9IGdjLmNyZWF0ZVBhdHRlcm4oaW1hZ2VzLmNhdXRpb24sICdyZXBlYXQnKTsgLy8gQ2F1c2VzIEVycm9yXG4gICAgICAgIGdjLmxpbmVXaWR0aCA9IDU7XG4gICAgICAgIGdjLmJlZ2luUGF0aCgpO1xuICAgICAgICBnYy5tb3ZlVG8oeCwgeSk7IC8vIGNhdXRpb246IGRvIG5vdCB1c2UgcmVjdCgpIGhlcmUgYmVjYXVzZSBDaHJvbWUgZG9lcyBub3QgY2xpcCBpdHMgc3Ryb2tlIHByb3Blcmx5XG4gICAgICAgIGdjLmxpbmVUbyh4ICsgd2lkdGgsIHkpO1xuICAgICAgICBnYy5saW5lVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0KTtcbiAgICAgICAgZ2MubGluZVRvKHgsIHkgKyBoZWlnaHQpO1xuICAgICAgICBnYy5saW5lVG8oeCwgeSk7XG4gICAgICAgIGdjLnN0cm9rZSgpO1xuICAgICAgICAvLyBhZGp1c3QgY2xpcCByZWdpb24gdG8gcHJldmVudCB0ZXh0IGZyb20gcmVuZGVyaW5nIG92ZXIgcmlnaHQgYm9yZGVyIHNob3VsZCBpdCBvdmVyZmxvd1xuICAgICAgICBnYy5iZWdpblBhdGgoKTtcbiAgICAgICAgZ2MucmVjdCh4LCB5LCB3aWR0aCAtIDIsIGhlaWdodCk7XG4gICAgICAgIGdjLmNsaXAoKTtcbiAgICAgICAgLy8gcmVuZGVyIG1lc3NhZ2UgdGV4dFxuICAgICAgICBnYy5maWxsU3R5bGUgPSAnI0EwMCc7XG4gICAgICAgIGdjLnRleHRBbGlnbiA9ICdzdGFydCc7XG4gICAgICAgIGdjLnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgICAgICBnYy5mb250ID0gJ2JvbGQgNnB0IFwiYXJpYWwgbmFycm93XCIsIHZlcmRhbmEsIGdlbmV2YSc7XG4gICAgICAgIGdjLmZpbGxUZXh0KG1lc3NhZ2UsIHggKyA0LCB5ICsgaGVpZ2h0IC8gMiArIDAuNSk7XG4gICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gRXJyb3JDZWxsO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ2VsbFJlbmRlcmVyID0gcmVxdWlyZSgnLi9DZWxsUmVuZGVyZXInKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIENlbGxSZW5kZXJlclxuICovXG52YXIgTGFzdFNlbGVjdGlvbiA9IENlbGxSZW5kZXJlci5leHRlbmQoJ0xhc3RTZWxlY3Rpb24nLCB7XG5cbiAgICAvKipcbiAgICAgKiBAZGVzYyBBIHJlbmRlcmluZyBvZiB0aGUgbGFzdCBTZWxlY3Rpb24gTW9kZWxcbiAgICAgKiBAcGFyYW0ge0NhbnZhc0dyYXBoaWNzQ29udGV4dH0gZ2NcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY29uZmlnXG4gICAgICogQHBhcmFtIHtSZWN0YW5nbGV9IGNvbmZpZy5ib3VuZHMgLSBUaGUgY2xpcHBpbmcgcmVjdCBvZiB0aGUgY2VsbCB0byBiZSByZW5kZXJlZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29uZmlnLnggLSB0aGUgXCJ0cmFuc2xhdGVkXCIgaW5kZXggaW50byB0aGUgYGJlaGF2aW9yLmFsbENvbHVtbnNgIGFycmF5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbmZpZy5ub3JtYWxpemVkWSAtIHRoZSB2ZXJ0aWNhbCBncmlkIGNvb3JkaW5hdGUgbm9ybWFsaXplZCB0byBmaXJzdCBkYXRhIHJvd1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb25maWcudW50cmFuc2xhdGVkWCAtIHRoZSBob3Jpem9udGFsIGdyaWQgY29vcmRpbmF0ZSBtZWFzdXJlZCBmcm9tIGZpcnN0IGRhdGEgY29sdW1uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbmZpZy55IC0gdGhlIHZlcnRpY2FsIGdyaWQgY29vcmRpbmF0ZSBtZWFzdXJlZCBmcm9tIHRvcCBoZWFkZXIgcm93XG4gICAgICogQG1lbWJlck9mIExhc3RTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICovXG4gICAgcGFpbnQ6IGZ1bmN0aW9uKGdjLCBjb25maWcpIHtcbiAgICAgICAgdmFyIHggPSBjb25maWcuYm91bmRzLngsXG4gICAgICAgICAgICB5ID0gY29uZmlnLmJvdW5kcy55LFxuICAgICAgICAgICAgd2lkdGggPSBjb25maWcuYm91bmRzLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0ID0gY29uZmlnLmJvdW5kcy5oZWlnaHQ7XG5cbiAgICAgICAgLy8gdmFyIGZvY3VzTGluZVN0ZXAgPSAgW1xuICAgICAgICAvLyAgICAgWzUsIDVdLFxuICAgICAgICAvLyAgICAgWzAsIDEsIDUsIDRdLFxuICAgICAgICAvLyAgICAgWzAsIDIsIDUsIDNdLFxuICAgICAgICAvLyAgICAgWzAsIDMsIDUsIDJdLFxuICAgICAgICAvLyAgICAgWzAsIDQsIDUsIDFdLFxuICAgICAgICAvLyAgICAgWzAsIDUsIDUsIDBdLFxuICAgICAgICAvLyAgICAgWzEsIDUsIDQsIDBdLFxuICAgICAgICAvLyAgICAgWzIsIDUsIDMsIDBdLFxuICAgICAgICAvLyAgICAgWzMsIDUsIDIsIDBdLFxuICAgICAgICAvLyAgICAgWzQsIDUsIDEsIDBdXG4gICAgICAgIC8vIF07XG4gICAgICAgIGdjLnJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIGdjLmZpbGxTdHlsZSA9IGNvbmZpZy5zZWxlY3Rpb25SZWdpb25PdmVybGF5Q29sb3I7XG4gICAgICAgIGdjLmZpbGwoKTtcbiAgICAgICAgZ2MubGluZVdpZHRoID0gMTtcbiAgICAgICAgZ2Muc3Ryb2tlU3R5bGUgPSBjb25maWcuc2VsZWN0aW9uUmVnaW9uT3V0bGluZUNvbG9yO1xuXG4gICAgICAgIC8vIGFuaW1hdGUgdGhlIGRhc2hlZCBsaW5lIGEgYml0IGhlcmUgZm9yIGZ1blxuXG4gICAgICAgIGdjLnN0cm9rZSgpO1xuXG4gICAgICAgIC8vIGdjLnJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIC8vXG4gICAgICAgIC8vIGdjLnN0cm9rZVN0eWxlID0gJ3doaXRlJztcbiAgICAgICAgLy9cbiAgICAgICAgLy8gLy9hbmltYXRlIHRoZSBkYXNoZWQgbGluZSBhIGJpdCBoZXJlIGZvciBmdW5cbiAgICAgICAgLy8gZ2Muc2V0TGluZURhc2goZm9jdXNMaW5lU3RlcFtNYXRoLmZsb29yKDEwICogKERhdGUubm93KCkgLyAzMDAgJSAxKSkgJSBmb2N1c0xpbmVTdGVwLmxlbmd0aF0pO1xuICAgICAgICAvL1xuICAgICAgICAvLyBnYy5zdHJva2UoKTtcbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBMYXN0U2VsZWN0aW9uO1xuXG5cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIENlbGxSZW5kZXJlciA9IHJlcXVpcmUoJy4vQ2VsbFJlbmRlcmVyJyk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBDZWxsUmVuZGVyZXJcbiAqL1xudmFyIFNpbXBsZUNlbGwgPSBDZWxsUmVuZGVyZXIuZXh0ZW5kKCdTaW1wbGVDZWxsJywge1xuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgVGhlIGRlZmF1bHQgY2VsbCByZW5kZXJpbmcgZnVuY3Rpb24gZm9yIHJlbmRlcmluZyBhIHZhbmlsbGEgY2VsbC5cbiAgICAgKiBAZGVzYyBHcmVhdCBjYXJlIGhhcyBiZWVuIHRha2VuIGluIGNyYWZ0aW5nIHRoaXMgZnVuY3Rpb24gYXMgaXQgbmVlZHMgdG8gcGVyZm9ybSBleHRyZW1lbHkgZmFzdC4gUmVhZHMgb24gdGhlIGdjIG9iamVjdCBhcmUgZXhwZW5zaXZlIGJ1dCBub3QgcXVpdGUgYXMgZXhwZW5zaXZlIGFzIHdyaXRlcyB0byBpdC4gV2UgZG8gb3VyIGJlc3QgdG8gYXZvaWQgd3JpdGVzLCB0aGVuIGF2b2lkIHJlYWRzLiBDbGlwcGluZyBib3VuZHMgYXJlIG5vdCBzZXQgaGVyZSBhcyB0aGlzIGlzIGFsc28gYW4gZXhwZW5zaXZlIG9wZXJhdGlvbi4gSW5zdGVhZCwgd2UgdHJ1bmNhdGUgb3ZlcmZsb3dpbmcgdGV4dCBhbmQgY29udGVudCBieSBmaWxsaW5nIGEgcmVjdGFuZ2xlIHdpdGggYmFja2dyb3VuZCBjb2xvciBjb2x1bW4gYnkgY29sdW1uIGluc3RlYWQgb2YgY2VsbCBieSBjZWxsLiAgVGhpcyBjb2x1bW4gYnkgY29sdW1uIGZpbGwgaGFwcGVucyBoaWdoZXIgdXAgb24gdGhlIHN0YWNrIGluIGEgY2FsbGluZyBmdW5jdGlvbiBmcm9tIGZpbi1oeXBlcmdyaWQtcmVuZGVyZXIuICBUYWtlIG5vdGUgd2UgZG8gbm90IGRvIGNlbGwgYnkgY2VsbCBib3JkZXIgcmVuZGVyZXJpbmcgYXMgdGhhdCBpcyBleHBlbnNpdmUuICBJbnN0ZWFkIHdlIHJlbmRlciBtYW55IGZld2VyIGdyaWRsaW5lcyBhZnRlciBhbGwgY2VsbHMgYXJlIHJlbmRlcmVkLlxuICAgICAqIEBwYXJhbSB7Q2FudmFzR3JhcGhpY3NDb250ZXh0fSBnY1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjb25maWdcbiAgICAgKiBAcGFyYW0ge1JlY3RhbmdsZX0gY29uZmlnLmJvdW5kcyAtIFRoZSBjbGlwcGluZyByZWN0IG9mIHRoZSBjZWxsIHRvIGJlIHJlbmRlcmVkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb25maWcueCAtIHRoZSBcInRyYW5zbGF0ZWRcIiBpbmRleCBpbnRvIHRoZSBgYmVoYXZpb3IuYWxsQ29sdW1uc2AgYXJyYXlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29uZmlnLm5vcm1hbGl6ZWRZIC0gdGhlIHZlcnRpY2FsIGdyaWQgY29vcmRpbmF0ZSBub3JtYWxpemVkIHRvIGZpcnN0IGRhdGEgcm93XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbmZpZy51bnRyYW5zbGF0ZWRYIC0gdGhlIGhvcml6b250YWwgZ3JpZCBjb29yZGluYXRlIG1lYXN1cmVkIGZyb20gZmlyc3QgZGF0YSBjb2x1bW5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29uZmlnLnkgLSB0aGUgdmVydGljYWwgZ3JpZCBjb29yZGluYXRlIG1lYXN1cmVkIGZyb20gdG9wIGhlYWRlciByb3dcbiAgICAgKiBAbWVtYmVyT2YgU2ltcGxlQ2VsbC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBwYWludDogZnVuY3Rpb24oZ2MsIGNvbmZpZykge1xuICAgICAgICB2YXIgdmFsID0gY29uZmlnLnZhbHVlLFxuICAgICAgICAgICAgeCA9IGNvbmZpZy5ib3VuZHMueCxcbiAgICAgICAgICAgIHkgPSBjb25maWcuYm91bmRzLnksXG4gICAgICAgICAgICB3aWR0aCA9IGNvbmZpZy5ib3VuZHMud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQgPSBjb25maWcuYm91bmRzLmhlaWdodCxcbiAgICAgICAgICAgIHdyYXBIZWFkZXJzID0gY29uZmlnLmhlYWRlclRleHRXcmFwcGluZyxcbiAgICAgICAgICAgIGxlZnRQYWRkaW5nID0gMiwgLy9UT0RPOiBmaXggdGhpc1xuICAgICAgICAgICAgaXNIZWFkZXIgPSBjb25maWcueSA9PT0gMDtcblxuICAgICAgICB2YXIgbGVmdEljb24sIHJpZ2h0SWNvbiwgY2VudGVySWNvbiwgaXhvZmZzZXQsIGl5b2Zmc2V0LCBmb250O1xuXG4gICAgICAgIC8vIHNldHRpbmcgZ2MgcHJvcGVydGllcyBhcmUgZXhwZW5zaXZlLCBsZXQncyBub3QgZG8gaXQgbmVlZGxlc3NseVxuXG4gICAgICAgIGlmICh2YWwgJiYgdmFsLmNvbnN0cnVjdG9yID09PSBBcnJheSkge1xuICAgICAgICAgICAgbGVmdEljb24gPSB2YWxbMF07XG4gICAgICAgICAgICByaWdodEljb24gPSB2YWxbMl07XG4gICAgICAgICAgICB2YWwgPSB2YWxbMV07XG4gICAgICAgICAgICBpZiAodmFsICYmIHR5cGVvZiB2YWwgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbC5jb25zdHJ1Y3Rvci5uYW1lID09PSAnSFRNTEltYWdlRWxlbWVudCcpIHsgLy8gbXVzdCBiZSBhbiBpbWFnZVxuICAgICAgICAgICAgICAgICAgICBjZW50ZXJJY29uID0gdmFsO1xuICAgICAgICAgICAgICAgICAgICB2YWwgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsZWZ0SWNvbiAmJiBsZWZ0SWNvbi5ub2RlTmFtZSAhPT0gJ0lNRycpIHtcbiAgICAgICAgICAgICAgICBsZWZ0SWNvbiA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmlnaHRJY29uICYmIHJpZ2h0SWNvbi5ub2RlTmFtZSAhPT0gJ0lNRycpIHtcbiAgICAgICAgICAgICAgICByaWdodEljb24gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNlbnRlckljb24gJiYgY2VudGVySWNvbi5ub2RlTmFtZSAhPT0gJ0lNRycpIHtcbiAgICAgICAgICAgICAgICBjZW50ZXJJY29uID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhbCA9IHZhbE9yRnVuYyh2YWwsIGNvbmZpZyk7XG4gICAgICAgIHZhbCA9IGNvbmZpZy5mb3JtYXRWYWx1ZSh2YWwpO1xuXG4gICAgICAgIGZvbnQgPSBjb25maWcuaXNTZWxlY3RlZCA/IGNvbmZpZy5mb3JlZ3JvdW5kU2VsZWN0aW9uRm9udCA6IGNvbmZpZy5mb250O1xuXG4gICAgICAgIGlmIChnYy5mb250ICE9PSBmb250KSB7XG4gICAgICAgICAgICBnYy5mb250ID0gZm9udDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ2MudGV4dEFsaWduICE9PSAnbGVmdCcpIHtcbiAgICAgICAgICAgIGdjLnRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ2MudGV4dEJhc2VsaW5lICE9PSAnbWlkZGxlJykge1xuICAgICAgICAgICAgZ2MudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmaWxsIGJhY2tncm91bmQgb25seSBpZiBvdXIgYmdDb2xvciBpcyBwb3B1bGF0ZWQgb3Igd2UgYXJlIGEgc2VsZWN0ZWQgY2VsbFxuICAgICAgICB2YXIgYmFja2dyb3VuZENvbG9yLCBob3ZlciwgaG92ZXJDb2xvciwgc2VsZWN0Q29sb3IsXG4gICAgICAgICAgICBjb2xvcnMgPSBbXTtcblxuICAgICAgICBpZiAoY29uZmlnLmlzQ2VsbEhvdmVyZWQgJiYgY29uZmlnLmhvdmVyQ2VsbEhpZ2hsaWdodC5lbmFibGVkKSB7XG4gICAgICAgICAgICBob3ZlckNvbG9yID0gY29uZmlnLmhvdmVyQ2VsbEhpZ2hsaWdodC5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgIH0gZWxzZSBpZiAoY29uZmlnLmlzUm93SG92ZXJlZCAmJiAoaG92ZXIgPSBjb25maWcuaG92ZXJSb3dIaWdobGlnaHQpLmVuYWJsZWQpIHtcbiAgICAgICAgICAgIGhvdmVyQ29sb3IgPSBjb25maWcuaXNHcmlkQ29sdW1uIHx8ICFob3Zlci5oZWFkZXIgfHwgaG92ZXIuaGVhZGVyLmJhY2tncm91bmRDb2xvciA9PT0gdW5kZWZpbmVkID8gaG92ZXIuYmFja2dyb3VuZENvbG9yIDogaG92ZXIuaGVhZGVyLmJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgfSBlbHNlIGlmIChjb25maWcuaXNDb2x1bW5Ib3ZlcmVkICYmIChob3ZlciA9IGNvbmZpZy5ob3ZlckNvbHVtbkhpZ2hsaWdodCkuZW5hYmxlZCkge1xuICAgICAgICAgICAgaG92ZXJDb2xvciA9IGNvbmZpZy5pc0dyaWRSb3cgfHwgIWhvdmVyLmhlYWRlciB8fCBob3Zlci5oZWFkZXIuYmFja2dyb3VuZENvbG9yID09PSB1bmRlZmluZWQgPyBob3Zlci5iYWNrZ3JvdW5kQ29sb3IgOiBob3Zlci5oZWFkZXIuYmFja2dyb3VuZENvbG9yO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbHBoYShob3ZlckNvbG9yKSA8IDEpIHtcbiAgICAgICAgICAgIGlmIChjb25maWcuaXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgIHNlbGVjdENvbG9yID0gdmFsT3JGdW5jKGNvbmZpZy5iYWNrZ3JvdW5kU2VsZWN0aW9uQ29sb3IsIGNvbmZpZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWxwaGEoc2VsZWN0Q29sb3IpIDwgMSkge1xuICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvciA9IHZhbE9yRnVuYyhjb25maWcuYmFja2dyb3VuZENvbG9yLCBjb25maWcpO1xuICAgICAgICAgICAgICAgIGlmIChhbHBoYShiYWNrZ3JvdW5kQ29sb3IpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb2xvcnMucHVzaChiYWNrZ3JvdW5kQ29sb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxlY3RDb2xvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29sb3JzLnB1c2goc2VsZWN0Q29sb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChob3ZlckNvbG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbG9ycy5wdXNoKGhvdmVyQ29sb3IpO1xuICAgICAgICB9XG4gICAgICAgIGxheWVyQ29sb3JzKGdjLCBjb2xvcnMsIHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgICAgIC8vIGRyYXcgdGV4dFxuICAgICAgICB2YXIgdGhlQ29sb3IgPSB2YWxPckZ1bmMoY29uZmlnLmlzU2VsZWN0ZWQgPyBjb25maWcuZm9yZWdyb3VuZFNlbGVjdGlvbkNvbG9yIDogY29uZmlnLmNvbG9yLCBjb25maWcpO1xuICAgICAgICBpZiAoZ2MuZmlsbFN0eWxlICE9PSB0aGVDb2xvcikge1xuICAgICAgICAgICAgZ2MuZmlsbFN0eWxlID0gdGhlQ29sb3I7XG4gICAgICAgICAgICBnYy5zdHJva2VTdHlsZSA9IHRoZUNvbG9yO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzSGVhZGVyICYmIHdyYXBIZWFkZXJzKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlck11bHRpTGluZVRleHQoZ2MsIGNvbmZpZywgdmFsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyU2luZ2xlTGluZVRleHQoZ2MsIGNvbmZpZywgdmFsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpY29uV2lkdGggPSAwO1xuICAgICAgICBpZiAobGVmdEljb24pIHtcbiAgICAgICAgICAgIGl5b2Zmc2V0ID0gTWF0aC5yb3VuZCgoaGVpZ2h0IC0gbGVmdEljb24uaGVpZ2h0KSAvIDIpO1xuICAgICAgICAgICAgZ2MuZHJhd0ltYWdlKGxlZnRJY29uLCB4ICsgbGVmdFBhZGRpbmcsIHkgKyBpeW9mZnNldCk7XG4gICAgICAgICAgICBpY29uV2lkdGggPSBNYXRoLm1heChsZWZ0SWNvbi53aWR0aCArIDIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyaWdodEljb24gJiYgd2lkdGggPiAxLjc1ICogaGVpZ2h0KSB7XG4gICAgICAgICAgICBpeW9mZnNldCA9IE1hdGgucm91bmQoKGhlaWdodCAtIHJpZ2h0SWNvbi5oZWlnaHQpIC8gMik7XG4gICAgICAgICAgICB2YXIgcmlnaHRYID0geCArIHdpZHRoIC0gcmlnaHRJY29uLndpZHRoO1xuICAgICAgICAgICAgaWYgKGJhY2tncm91bmRDb2xvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbGF5ZXJDb2xvcnMoZ2MsIGNvbG9ycywgcmlnaHRYLCB5LCByaWdodEljb24ud2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGdjLmNsZWFyUmVjdChyaWdodFgsIHksIHJpZ2h0SWNvbi53aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdjLmRyYXdJbWFnZShyaWdodEljb24sIHJpZ2h0WCwgeSArIGl5b2Zmc2V0KTtcbiAgICAgICAgICAgIGljb25XaWR0aCA9IE1hdGgubWF4KHJpZ2h0SWNvbi53aWR0aCArIDIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjZW50ZXJJY29uKSB7XG4gICAgICAgICAgICBpeW9mZnNldCA9IE1hdGgucm91bmQoKGhlaWdodCAtIGNlbnRlckljb24uaGVpZ2h0KSAvIDIpO1xuICAgICAgICAgICAgaXhvZmZzZXQgPSBNYXRoLnJvdW5kKCh3aWR0aCAtIGNlbnRlckljb24ud2lkdGgpIC8gMik7XG4gICAgICAgICAgICBnYy5kcmF3SW1hZ2UoY2VudGVySWNvbiwgeCArIHdpZHRoIC0gaXhvZmZzZXQgLSBjZW50ZXJJY29uLndpZHRoLCB5ICsgaXlvZmZzZXQpO1xuICAgICAgICAgICAgaWNvbldpZHRoID0gTWF0aC5tYXgoY2VudGVySWNvbi53aWR0aCArIDIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25maWcuY2VsbEJvcmRlclRoaWNrbmVzcykge1xuICAgICAgICAgICAgZ2MuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBnYy5yZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgZ2MubGluZVdpZHRoID0gY29uZmlnLmNlbGxCb3JkZXJUaGlja25lc3M7XG4gICAgICAgICAgICBnYy5zdHJva2VTdHlsZSA9IGNvbmZpZy5jZWxsQm9yZGVyU3R5bGU7XG5cbiAgICAgICAgICAgIC8vIGFuaW1hdGUgdGhlIGRhc2hlZCBsaW5lIGEgYml0IGhlcmUgZm9yIGZ1blxuXG4gICAgICAgICAgICBnYy5zdHJva2UoKTtcbiAgICAgICAgICAgIGdjLmNsb3NlUGF0aCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbmZpZy5taW5XaWR0aCA9IGNvbmZpZy5taW5XaWR0aCArIDIgKiAoaWNvbldpZHRoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgUmVuZGVycyBzaW5nbGUgbGluZSB0ZXh0LlxuICAgICAqIEBwYXJhbSB7Q2FudmFzR3JhcGhpY3NDb250ZXh0fSBnY1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjb25maWdcbiAgICAgKiBAcGFyYW0ge1JlY3RhbmdsZX0gY29uZmlnLmJvdW5kcyAtIFRoZSBjbGlwcGluZyByZWN0IG9mIHRoZSBjZWxsIHRvIGJlIHJlbmRlcmVkLlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsIC0gVGhlIHRleHQgdG8gcmVuZGVyIGluIHRoZSBjZWxsLlxuICAgICAqIEBtZW1iZXJPZiBTaW1wbGVDZWxsLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHJlbmRlck11bHRpTGluZVRleHQ6IGZ1bmN0aW9uKGdjLCBjb25maWcsIHZhbCkge1xuICAgICAgICB2YXIgeCA9IGNvbmZpZy5ib3VuZHMueCxcbiAgICAgICAgICAgIHkgPSBjb25maWcuYm91bmRzLnksXG4gICAgICAgICAgICB3aWR0aCA9IGNvbmZpZy5ib3VuZHMud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQgPSBjb25maWcuYm91bmRzLmhlaWdodDtcbiAgICAgICAgdmFyIGxpbmVzID0gZml0VGV4dChnYywgY29uZmlnLCB2YWwsIHdpZHRoKTtcbiAgICAgICAgaWYgKGxpbmVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyU2luZ2xlTGluZVRleHQoZ2MsIGNvbmZpZywgc3F1ZWV6ZSh2YWwpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb2xIRWRnZU9mZnNldCA9IGNvbmZpZy5jZWxsUGFkZGluZyxcbiAgICAgICAgICAgIGhhbGlnbk9mZnNldCA9IDAsXG4gICAgICAgICAgICB2YWxpZ25PZmZzZXQgPSBjb25maWcudm9mZnNldCxcbiAgICAgICAgICAgIGhhbGlnbiA9IGNvbmZpZy5oYWxpZ24sXG4gICAgICAgICAgICB0ZXh0SGVpZ2h0ID0gY29uZmlnLmdldFRleHRIZWlnaHQoY29uZmlnLmZvbnQpLmhlaWdodDtcblxuICAgICAgICBzd2l0Y2ggKGhhbGlnbikge1xuICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgICAgIGhhbGlnbk9mZnNldCA9IHdpZHRoIC0gY29sSEVkZ2VPZmZzZXQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICAgICAgICAgIGhhbGlnbk9mZnNldCA9IHdpZHRoIC8gMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgICAgICAgIGhhbGlnbk9mZnNldCA9IGNvbEhFZGdlT2Zmc2V0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGhNaW4gPSAwLCB2TWluID0gTWF0aC5jZWlsKHRleHRIZWlnaHQgLyAyKTtcblxuICAgICAgICB2YWxpZ25PZmZzZXQgKz0gTWF0aC5jZWlsKChoZWlnaHQgLSAobGluZXMubGVuZ3RoIC0gMSkgKiB0ZXh0SGVpZ2h0KSAvIDIpO1xuXG4gICAgICAgIGhhbGlnbk9mZnNldCA9IE1hdGgubWF4KGhNaW4sIGhhbGlnbk9mZnNldCk7XG4gICAgICAgIHZhbGlnbk9mZnNldCA9IE1hdGgubWF4KHZNaW4sIHZhbGlnbk9mZnNldCk7XG5cbiAgICAgICAgZ2Muc2F2ZSgpOyAvLyBkZWZpbmUgYSBjbGlwcGluZyByZWdpb24gZm9yIGNlbGxcbiAgICAgICAgZ2MuYmVnaW5QYXRoKCk7XG4gICAgICAgIGdjLnJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIGdjLmNsaXAoKTtcblxuICAgICAgICBnYy50ZXh0QWxpZ24gPSBoYWxpZ247XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZ2MuZmlsbFRleHQobGluZXNbaV0sIHggKyBoYWxpZ25PZmZzZXQsIHkgKyB2YWxpZ25PZmZzZXQgKyAoaSAqIHRleHRIZWlnaHQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdjLnJlc3RvcmUoKTsgLy8gZGlzY2FyZCBjbGlwcGluZyByZWdpb25cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgUmVuZGVycyBzaW5nbGUgbGluZSB0ZXh0LlxuICAgICAqIEBwYXJhbSB7Q2FudmFzR3JhcGhpY3NDb250ZXh0fSBnY1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjb25maWdcbiAgICAgKiBAcGFyYW0ge1JlY3RhbmdsZX0gY29uZmlnLmJvdW5kcyAtIFRoZSBjbGlwcGluZyByZWN0IG9mIHRoZSBjZWxsIHRvIGJlIHJlbmRlcmVkLlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsIC0gVGhlIHRleHQgdG8gcmVuZGVyIGluIHRoZSBjZWxsLlxuICAgICAqIEBtZW1iZXJPZiBTaW1wbGVDZWxsLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHJlbmRlclNpbmdsZUxpbmVUZXh0OiBmdW5jdGlvbihnYywgY29uZmlnLCB2YWwpIHtcbiAgICAgICAgdmFyIHggPSBjb25maWcuYm91bmRzLngsXG4gICAgICAgICAgICB5ID0gY29uZmlnLmJvdW5kcy55LFxuICAgICAgICAgICAgd2lkdGggPSBjb25maWcuYm91bmRzLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0ID0gY29uZmlnLmJvdW5kcy5oZWlnaHQ7XG4gICAgICAgIHZhciBjb2xIRWRnZU9mZnNldCA9IGNvbmZpZy5jZWxsUGFkZGluZyxcbiAgICAgICAgICAgIGhhbGlnbk9mZnNldCA9IDAsXG4gICAgICAgICAgICB2YWxpZ25PZmZzZXQgPSBjb25maWcudm9mZnNldCxcbiAgICAgICAgICAgIGhhbGlnbiA9IGNvbmZpZy5oYWxpZ24sXG4gICAgICAgICAgICBpc0NlbGxIb3ZlcmVkID0gY29uZmlnLmlzQ2VsbEhvdmVyZWQsXG4gICAgICAgICAgICBpc0xpbmsgPSBjb25maWcubGluaztcblxuICAgICAgICB2YXIgZm9udE1ldHJpY3MgPSBjb25maWcuZ2V0VGV4dEhlaWdodChjb25maWcuZm9udCk7XG4gICAgICAgIHZhciB0ZXh0V2lkdGggPSBjb25maWcuZ2V0VGV4dFdpZHRoKGdjLCB2YWwpO1xuXG4gICAgICAgIC8vd2UgbXVzdCBzZXQgdGhpcyBpbiBvcmRlciB0byBjb21wdXRlIHRoZSBtaW5pbXVtIHdpZHRoXG4gICAgICAgIC8vZm9yIGNvbHVtbiBhdXRvc2l6aW5nIHB1cnBvc2VzXG4gICAgICAgIGNvbmZpZy5taW5XaWR0aCA9IHRleHRXaWR0aCArICgyICogY29sSEVkZ2VPZmZzZXQpO1xuXG4gICAgICAgIHN3aXRjaCAoaGFsaWduKSB7XG4gICAgICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgICAgICAgLy90ZXh0V2lkdGggPSBjb25maWcuZ2V0VGV4dFdpZHRoKGdjLCBjb25maWcudmFsdWUpO1xuICAgICAgICAgICAgICAgIGhhbGlnbk9mZnNldCA9IHdpZHRoIC0gY29sSEVkZ2VPZmZzZXQgLSB0ZXh0V2lkdGg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICAgICAgICAgIC8vdGV4dFdpZHRoID0gY29uZmlnLmdldFRleHRXaWR0aChnYywgY29uZmlnLnZhbHVlKTtcbiAgICAgICAgICAgICAgICBoYWxpZ25PZmZzZXQgPSAod2lkdGggLSB0ZXh0V2lkdGgpIC8gMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgICAgICAgIGhhbGlnbk9mZnNldCA9IGNvbEhFZGdlT2Zmc2V0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaGFsaWduT2Zmc2V0ID0gTWF0aC5tYXgoMCwgaGFsaWduT2Zmc2V0KTtcbiAgICAgICAgdmFsaWduT2Zmc2V0ID0gdmFsaWduT2Zmc2V0ICsgTWF0aC5jZWlsKGhlaWdodCAvIDIpO1xuXG4gICAgICAgIGlmICh2YWwgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGdjLmZpbGxUZXh0KHZhbCwgeCArIGhhbGlnbk9mZnNldCwgeSArIHZhbGlnbk9mZnNldCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNDZWxsSG92ZXJlZCkge1xuICAgICAgICAgICAgZ2MuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBpZiAoaXNMaW5rKSB7XG4gICAgICAgICAgICAgICAgdW5kZXJsaW5lKGNvbmZpZywgZ2MsIHZhbCwgeCArIGhhbGlnbk9mZnNldCwgeSArIHZhbGlnbk9mZnNldCArIE1hdGguZmxvb3IoZm9udE1ldHJpY3MuaGVpZ2h0IC8gMiksIDEpO1xuICAgICAgICAgICAgICAgIGdjLnN0cm9rZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2MuY2xvc2VQYXRoKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbmZpZy5zdHJpa2VUaHJvdWdoID09PSB0cnVlKSB7XG4gICAgICAgICAgICBnYy5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIHN0cmlrZVRocm91Z2goY29uZmlnLCBnYywgdmFsLCB4ICsgaGFsaWduT2Zmc2V0LCB5ICsgdmFsaWduT2Zmc2V0ICsgTWF0aC5mbG9vcihmb250TWV0cmljcy5oZWlnaHQgLyAyKSwgMSk7XG4gICAgICAgICAgICBnYy5zdHJva2UoKTtcbiAgICAgICAgICAgIGdjLmNsb3NlUGF0aCgpO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cblxuZnVuY3Rpb24gZml0VGV4dChnYywgY29uZmlnLCBzdHJpbmcsIHdpZHRoKSB7XG4gICAgcmV0dXJuIGZpbmRMaW5lcyhnYywgY29uZmlnLCBzcXVlZXplKHN0cmluZykuc3BsaXQoJyAnKSwgd2lkdGgpO1xufVxuXG5mdW5jdGlvbiBmaW5kTGluZXMoZ2MsIGNvbmZpZywgd29yZHMsIHdpZHRoKSB7XG5cbiAgICBpZiAod29yZHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiB3b3JkcztcbiAgICB9XG5cbiAgICAvLyBzdGFydGluZyB3aXRoIGp1c3QgdGhlIGZpcnN0IHdvcmTigKZcbiAgICB2YXIgc3RpbGxGaXRzLCBsaW5lID0gW3dvcmRzLnNoaWZ0KCldO1xuICAgIHdoaWxlIChcbiAgICAgICAgLy8gc28gbG9uZSBhcyBsaW5lIHN0aWxsIGZpdHMgd2l0aGluIGN1cnJlbnQgY29sdW1u4oCmXG4gICAgKHN0aWxsRml0cyA9IGNvbmZpZy5nZXRUZXh0V2lkdGgoZ2MsIGxpbmUuam9pbignICcpKSA8IHdpZHRoKVxuICAgIC8vIOKApkFORCB0aGVyZSBhcmUgbW9yZSB3b3JkcyBhdmFpbGFibGXigKZcbiAgICAmJiB3b3Jkcy5sZW5ndGhcbiAgICAgICAgKSB7XG4gICAgICAgIC8vIOKApmFkZCBhbm90aGVyIHdvcmQgdG8gZW5kIG9mIGxpbmUgYW5kIHJldGVzdFxuICAgICAgICBsaW5lLnB1c2god29yZHMuc2hpZnQoKSk7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgICAhc3RpbGxGaXRzIC8vIGlmIGxpbmUgaXMgbm93IHRvbyBsb25n4oCmXG4gICAgICAgICYmIGxpbmUubGVuZ3RoID4gMSAvLyDigKZBTkQgaXMgbXVsdGlwbGUgd29yZHPigKZcbiAgICApIHtcbiAgICAgICAgd29yZHMudW5zaGlmdChsaW5lLnBvcCgpKTsgLy8g4oCmYmFjayBvZmYgYnkgKGkuZS4sIHJlbW92ZSkgb25lIHdvcmRcbiAgICB9XG5cbiAgICBsaW5lID0gW2xpbmUuam9pbignICcpXTtcblxuICAgIGlmICh3b3Jkcy5sZW5ndGgpIHsgLy8gaWYgdGhlcmUncyBhbnl0aGluZyBsZWZ04oCmXG4gICAgICAgIGxpbmUgPSBsaW5lLmNvbmNhdChmaW5kTGluZXMoZ2MsIGNvbmZpZywgd29yZHMsIHdpZHRoKSk7IC8vIOKApmJyZWFrIGl0IHVwIGFzIHdlbGxcbiAgICB9XG5cbiAgICByZXR1cm4gbGluZTtcbn1cblxuLy8gdHJpbSBzdHJpbmc7IHRoZW4gcmVkdWNlIGFsbCBydW5zIG9mIG11bHRpcGxlIHNwYWNlcyB0byBhIHNpbmdsZSBzcGFjZVxuZnVuY3Rpb24gc3F1ZWV6ZShzdHJpbmcpIHtcbiAgICByZXR1cm4gKHN0cmluZyArICcnKS50cmltKCkucmVwbGFjZSgvXFxzXFxzKy9nLCAnICcpO1xufVxuXG5mdW5jdGlvbiBzdHJpa2VUaHJvdWdoKGNvbmZpZywgZ2MsIHRleHQsIHgsIHksIHRoaWNrbmVzcykge1xuICAgIHZhciBmb250TWV0cmljcyA9IGNvbmZpZy5nZXRUZXh0SGVpZ2h0KGNvbmZpZy5mb250KTtcbiAgICB2YXIgd2lkdGggPSBjb25maWcuZ2V0VGV4dFdpZHRoKGdjLCB0ZXh0KTtcbiAgICB5ID0geSAtIChmb250TWV0cmljcy5oZWlnaHQgKiAwLjQpO1xuXG4gICAgc3dpdGNoIChnYy50ZXh0QWxpZ24pIHtcbiAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgICAgIHggLT0gKHdpZHRoIC8gMik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgeCAtPSB3aWR0aDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vZ2MuYmVnaW5QYXRoKCk7XG4gICAgZ2MubGluZVdpZHRoID0gdGhpY2tuZXNzO1xuICAgIGdjLm1vdmVUbyh4ICsgMC41LCB5ICsgMC41KTtcbiAgICBnYy5saW5lVG8oeCArIHdpZHRoICsgMC41LCB5ICsgMC41KTtcbn1cblxuZnVuY3Rpb24gdW5kZXJsaW5lKGNvbmZpZywgZ2MsIHRleHQsIHgsIHksIHRoaWNrbmVzcykge1xuICAgIHZhciB3aWR0aCA9IGNvbmZpZy5nZXRUZXh0V2lkdGgoZ2MsIHRleHQpO1xuXG4gICAgc3dpdGNoIChnYy50ZXh0QWxpZ24pIHtcbiAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgICAgIHggLT0gKHdpZHRoIC8gMik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgeCAtPSB3aWR0aDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vZ2MuYmVnaW5QYXRoKCk7XG4gICAgZ2MubGluZVdpZHRoID0gdGhpY2tuZXNzO1xuICAgIGdjLm1vdmVUbyh4ICsgMC41LCB5ICsgMC41KTtcbiAgICBnYy5saW5lVG8oeCArIHdpZHRoICsgMC41LCB5ICsgMC41KTtcbn1cblxuZnVuY3Rpb24gbGF5ZXJDb2xvcnMoZ2MsIGNvbG9ycywgeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgIGNvbG9ycy5mb3JFYWNoKGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgICAgIGdjLmZpbGxTdHlsZSA9IGNvbG9yO1xuICAgICAgICBnYy5maWxsUmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gdmFsT3JGdW5jKHZmLCBjb25maWcpIHtcbiAgICB2YXIgcmVzdWx0ID0gY29uZmlnLmlzR3JpZENvbHVtbiAmJiBjb25maWcuaXNHcmlkUm93ICYmICh0eXBlb2YgdmYpWzBdID09PSAnZidcbiAgICAgICAgPyB2Zihjb25maWcuZGF0YVJvdywgY29uZmlnLmNvbHVtbk5hbWUpXG4gICAgICAgIDogdmY7XG4gICAgcmV0dXJuIHJlc3VsdCB8fCByZXN1bHQgPT09IDAgfHwgcmVzdWx0ID09PSBmYWxzZSA/IHJlc3VsdCA6ICcnO1xufVxuXG5mdW5jdGlvbiBhbHBoYShjc3NDb2xvclNwZWMpIHtcbiAgICBpZiAoY3NzQ29sb3JTcGVjID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gdW5kZWZpbmVkIHNvIG5vdCB2aXNpYmxlOyB0cmVhdCBhcyB0cmFuc3BhcmVudFxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICB2YXIgbWF0Y2hlcyA9IGNzc0NvbG9yU3BlYy5tYXRjaChhbHBoYS5yZWdleCk7XG5cbiAgICBpZiAobWF0Y2hlcyA9PT0gbnVsbCkge1xuICAgICAgICAvLyBhbiBvcGFxdWUgY29sb3IgKGEgY29sb3Igc3BlYyB3aXRoIG5vIGFscGhhIGNoYW5uZWwpXG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cblxuICAgIHZhciBBID0gbWF0Y2hlc1s0XTtcblxuICAgIGlmIChBID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gY3NzQ29sb3JTcGVjIG11c3QgaGF2ZSBiZWVuICd0cmFuc3BhcmVudCdcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIE51bWJlcihBKTtcbn1cblxuYWxwaGEucmVnZXggPSAvXih0cmFuc3BhcmVudHwoKFJHQnxIU0wpQVxcKC4qLFxccyooW1xcZFxcLl0rKVxcKSkpJC9pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNpbXBsZUNlbGw7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBDZWxsUmVuZGVyZXIgPSByZXF1aXJlKCcuL0NlbGxSZW5kZXJlcicpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQ2VsbFJlbmRlcmVyXG4gKi9cbnZhciBTbGlkZXIgPSBDZWxsUmVuZGVyZXIuZXh0ZW5kKCdTbGlkZXInLCB7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0NhbnZhc0dyYXBoaWNzQ29udGV4dH0gZ2NcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY29uZmlnXG4gICAgICogQHBhcmFtIHtSZWN0YW5nbGV9IGNvbmZpZy5ib3VuZHMgLSBUaGUgY2xpcHBpbmcgcmVjdCBvZiB0aGUgY2VsbCB0byBiZSByZW5kZXJlZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29uZmlnLnggLSB0aGUgXCJ0cmFuc2xhdGVkXCIgaW5kZXggaW50byB0aGUgYGJlaGF2aW9yLmFsbENvbHVtbnNgIGFycmF5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbmZpZy5ub3JtYWxpemVkWSAtIHRoZSB2ZXJ0aWNhbCBncmlkIGNvb3JkaW5hdGUgbm9ybWFsaXplZCB0byBmaXJzdCBkYXRhIHJvd1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb25maWcudW50cmFuc2xhdGVkWCAtIHRoZSBob3Jpem9udGFsIGdyaWQgY29vcmRpbmF0ZSBtZWFzdXJlZCBmcm9tIGZpcnN0IGRhdGEgY29sdW1uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbmZpZy55IC0gdGhlIHZlcnRpY2FsIGdyaWQgY29vcmRpbmF0ZSBtZWFzdXJlZCBmcm9tIHRvcCBoZWFkZXIgcm93XG4gICAgICogQG1lbWJlck9mIFNsaWRlci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBFbWVyc29uJ3MgcGFpbnQgZnVuY3Rpb24gZm9yIGEgc2xpZGVyIGJ1dHRvbi4gY3VycmVudGx5IHRoZSB1c2VyIGNhbm5vdCBpbnRlcmFjdCB3aXRoIGl0XG4gICAgICovXG4gICAgcGFpbnQ6IGZ1bmN0aW9uKGdjLCBjb25maWcpIHtcbiAgICAgICAgdmFyIHggPSBjb25maWcuYm91bmRzLngsXG4gICAgICAgICAgICB5ID0gY29uZmlnLmJvdW5kcy55LFxuICAgICAgICAgICAgd2lkdGggPSBjb25maWcuYm91bmRzLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0ID0gY29uZmlnLmJvdW5kcy5oZWlnaHQ7XG4gICAgICAgIGdjLnN0cm9rZVN0eWxlID0gJ3doaXRlJztcbiAgICAgICAgdmFyIHZhbCA9IHRoaXMuY29uZmlnLnZhbHVlO1xuICAgICAgICB2YXIgcmFkaXVzID0gaGVpZ2h0IC8gMjtcbiAgICAgICAgdmFyIG9mZnNldCA9IHdpZHRoICogdmFsO1xuICAgICAgICB2YXIgYmdDb2xvciA9IHRoaXMuY29uZmlnLmlzU2VsZWN0ZWQgPyB0aGlzLmNvbmZpZy5iYWNrZ3JvdW5kQ29sb3IgOiAnIzMzMzMzMyc7XG4gICAgICAgIHZhciBidG5HcmFkaWVudCA9IGdjLmNyZWF0ZUxpbmVhckdyYWRpZW50KHgsIHksIHgsIHkgKyBoZWlnaHQpO1xuICAgICAgICBidG5HcmFkaWVudC5hZGRDb2xvclN0b3AoMCwgYmdDb2xvcik7XG4gICAgICAgIGJ0bkdyYWRpZW50LmFkZENvbG9yU3RvcCgxLCAnIzY2NjY2NicpO1xuICAgICAgICB2YXIgYXJjR3JhZGllbnQgPSBnYy5jcmVhdGVMaW5lYXJHcmFkaWVudCh4LCB5LCB4LCB5ICsgaGVpZ2h0KTtcbiAgICAgICAgYXJjR3JhZGllbnQuYWRkQ29sb3JTdG9wKDAsICcjYWFhYWFhJyk7XG4gICAgICAgIGFyY0dyYWRpZW50LmFkZENvbG9yU3RvcCgxLCAnIzc3Nzc3NycpO1xuICAgICAgICBnYy5maWxsU3R5bGUgPSBidG5HcmFkaWVudDtcbiAgICAgICAgdGhpcy5yb3VuZFJlY3QoZ2MsIHgsIHksIHdpZHRoLCBoZWlnaHQsIHJhZGl1cywgYnRuR3JhZGllbnQpO1xuICAgICAgICBpZiAodmFsIDwgMS4wKSB7XG4gICAgICAgICAgICBnYy5maWxsU3R5bGUgPSBhcmNHcmFkaWVudDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdjLmZpbGxTdHlsZSA9ICcjZWVlZWVlJztcbiAgICAgICAgfVxuICAgICAgICBnYy5iZWdpblBhdGgoKTtcbiAgICAgICAgZ2MuYXJjKHggKyBNYXRoLm1heChvZmZzZXQgLSByYWRpdXMsIHJhZGl1cyksIHkgKyByYWRpdXMsIHJhZGl1cywgMCwgMiAqIE1hdGguUEkpO1xuICAgICAgICBnYy5maWxsKCk7XG4gICAgICAgIGdjLmNsb3NlUGF0aCgpO1xuICAgICAgICB0aGlzLmNvbmZpZy5taW5XaWR0aCA9IDEwMDtcbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBTbGlkZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBDZWxsUmVuZGVyZXIgPSByZXF1aXJlKCcuL0NlbGxSZW5kZXJlcicpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQ2VsbFJlbmRlcmVyXG4gKi9cbnZhciBTcGFya0JhciA9IENlbGxSZW5kZXJlci5leHRlbmQoJ1NwYXJrQmFyJywge1xuXG4gICAgLyoqXG4gICAgICogQGRlc2MgQSBzaW1wbGUgaW1wbGVtZW50YXRpb24gb2YgYSBzcGFya2xpbmUsIGJlY2F1c2UgaXQncyBhIGJhcmNoYXJ0IHdlJ3ZlIGNoYW5nZWQgdGhlIG5hbWUgOykuXG4gICAgICogQHBhcmFtIHtDYW52YXNHcmFwaGljc0NvbnRleHR9IGdjXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7UmVjdGFuZ2xlfSBjb25maWcuYm91bmRzIC0gVGhlIGNsaXBwaW5nIHJlY3Qgb2YgdGhlIGNlbGwgdG8gYmUgcmVuZGVyZWQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbmZpZy54IC0gdGhlIFwidHJhbnNsYXRlZFwiIGluZGV4IGludG8gdGhlIGBiZWhhdmlvci5hbGxDb2x1bW5zYCBhcnJheVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb25maWcubm9ybWFsaXplZFkgLSB0aGUgdmVydGljYWwgZ3JpZCBjb29yZGluYXRlIG5vcm1hbGl6ZWQgdG8gZmlyc3QgZGF0YSByb3dcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29uZmlnLnVudHJhbnNsYXRlZFggLSB0aGUgaG9yaXpvbnRhbCBncmlkIGNvb3JkaW5hdGUgbWVhc3VyZWQgZnJvbSBmaXJzdCBkYXRhIGNvbHVtblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb25maWcueSAtIHRoZSB2ZXJ0aWNhbCBncmlkIGNvb3JkaW5hdGUgbWVhc3VyZWQgZnJvbSB0b3AgaGVhZGVyIHJvd1xuICAgICAqIEBtZW1iZXJPZiBTcGFya0Jhci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBwYWludDogZnVuY3Rpb24oZ2MsIGNvbmZpZykge1xuICAgICAgICB2YXIgeCA9IGNvbmZpZy5ib3VuZHMueCxcbiAgICAgICAgICAgIHkgPSBjb25maWcuYm91bmRzLnksXG4gICAgICAgICAgICB3aWR0aCA9IGNvbmZpZy5ib3VuZHMud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQgPSBjb25maWcuYm91bmRzLmhlaWdodDtcblxuICAgICAgICBnYy5iZWdpblBhdGgoKTtcbiAgICAgICAgdmFyIHZhbCA9IHRoaXMuY29uZmlnLnZhbHVlO1xuICAgICAgICBpZiAoIXZhbCB8fCAhdmFsLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb3VudCA9IHZhbC5sZW5ndGg7XG4gICAgICAgIHZhciBlV2lkdGggPSB3aWR0aCAvIGNvdW50O1xuICAgICAgICB2YXIgZmdDb2xvciA9IHRoaXMuY29uZmlnLmlzU2VsZWN0ZWQgPyB0aGlzLmNvbmZpZy5mb3JlZ3JvdW5kU2VsZWN0aW9uQ29sb3IgOiB0aGlzLmNvbmZpZy5jb2xvcjtcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLmJhY2tncm91bmRDb2xvciB8fCB0aGlzLmNvbmZpZy5pc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICBnYy5maWxsU3R5bGUgPSB0aGlzLmNvbmZpZy5pc1NlbGVjdGVkID8gJ2JsdWUnIDogdGhpcy5jb25maWcuYmFja2dyb3VuZENvbG9yO1xuICAgICAgICAgICAgZ2MuZmlsbFJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgZ2MuZmlsbFN0eWxlID0gZmdDb2xvcjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBiYXJoZWlnaHQgPSB2YWxbaV0gLyAxMTAgKiBoZWlnaHQ7XG4gICAgICAgICAgICBnYy5maWxsUmVjdCh4ICsgNSwgeSArIGhlaWdodCAtIGJhcmhlaWdodCwgZVdpZHRoICogMC42NjY2LCBiYXJoZWlnaHQpO1xuICAgICAgICAgICAgeCA9IHggKyBlV2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgZ2MuY2xvc2VQYXRoKCk7XG4gICAgICAgIHRoaXMuY29uZmlnLm1pbldpZHRoID0gY291bnQgKiAxMDtcbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBTcGFya0JhcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIENlbGxSZW5kZXJlciA9IHJlcXVpcmUoJy4vQ2VsbFJlbmRlcmVyJyk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBDZWxsUmVuZGVyZXJcbiAqL1xudmFyIFNwYXJrTGluZSA9IENlbGxSZW5kZXJlci5leHRlbmQoJ1NwYXJrTGluZScsIHtcblxuICAgIC8qKlxuICAgICAqIEBkZXNjIEEgc2ltcGxlIGltcGxlbWVudGF0aW9uIG9mIGEgc3BhcmtsaW5lLiAgc2VlIFtFZHdhcmQgVHVmdGUgc3BhcmtsaW5lXShodHRwOi8vd3d3LmVkd2FyZHR1ZnRlLmNvbS9iYm9hcmQvcS1hbmQtYS1mZXRjaC1tc2c/bXNnX2lkPTAwMDFPUilcbiAgICAgKiBAcGFyYW0ge0NhbnZhc0dyYXBoaWNzQ29udGV4dH0gZ2NcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY29uZmlnXG4gICAgICogQHBhcmFtIHtSZWN0YW5nbGV9IGNvbmZpZy5ib3VuZHMgLSBUaGUgY2xpcHBpbmcgcmVjdCBvZiB0aGUgY2VsbCB0byBiZSByZW5kZXJlZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29uZmlnLnggLSB0aGUgXCJ0cmFuc2xhdGVkXCIgaW5kZXggaW50byB0aGUgYGJlaGF2aW9yLmFsbENvbHVtbnNgIGFycmF5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbmZpZy5ub3JtYWxpemVkWSAtIHRoZSB2ZXJ0aWNhbCBncmlkIGNvb3JkaW5hdGUgbm9ybWFsaXplZCB0byBmaXJzdCBkYXRhIHJvd1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb25maWcudW50cmFuc2xhdGVkWCAtIHRoZSBob3Jpem9udGFsIGdyaWQgY29vcmRpbmF0ZSBtZWFzdXJlZCBmcm9tIGZpcnN0IGRhdGEgY29sdW1uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbmZpZy55IC0gdGhlIHZlcnRpY2FsIGdyaWQgY29vcmRpbmF0ZSBtZWFzdXJlZCBmcm9tIHRvcCBoZWFkZXIgcm93XG4gICAgICogQG1lbWJlck9mIFNwYXJrTGluZS5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBwYWludDogZnVuY3Rpb24oZ2MsIGNvbmZpZykge1xuICAgICAgICB2YXIgeCA9IGNvbmZpZy5ib3VuZHMueCxcbiAgICAgICAgICAgIHkgPSBjb25maWcuYm91bmRzLnksXG4gICAgICAgICAgICB3aWR0aCA9IGNvbmZpZy5ib3VuZHMud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQgPSBjb25maWcuYm91bmRzLmhlaWdodDtcblxuICAgICAgICBnYy5iZWdpblBhdGgoKTtcbiAgICAgICAgdmFyIHZhbCA9IHRoaXMuY29uZmlnLnZhbHVlO1xuICAgICAgICBpZiAoIXZhbCB8fCAhdmFsLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb3VudCA9IHZhbC5sZW5ndGg7XG4gICAgICAgIHZhciBlV2lkdGggPSB3aWR0aCAvIGNvdW50O1xuXG4gICAgICAgIHZhciBmZ0NvbG9yID0gdGhpcy5jb25maWcuaXNTZWxlY3RlZCA/IHRoaXMuY29uZmlnLmZvcmVncm91bmRTZWxlY3Rpb25Db2xvciA6IHRoaXMuY29uZmlnLmNvbG9yO1xuICAgICAgICBpZiAodGhpcy5jb25maWcuYmFja2dyb3VuZENvbG9yIHx8IHRoaXMuY29uZmlnLmlzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIGdjLmZpbGxTdHlsZSA9IHRoaXMuY29uZmlnLmlzU2VsZWN0ZWQgPyB0aGlzLmNvbmZpZy5iYWNrZ3JvdW5kU2VsZWN0aW9uQ29sb3IgOiB0aGlzLmNvbmZpZy5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgICAgICBnYy5maWxsUmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBnYy5zdHJva2VTdHlsZSA9IGZnQ29sb3I7XG4gICAgICAgIGdjLmZpbGxTdHlsZSA9IGZnQ29sb3I7XG4gICAgICAgIGdjLmJlZ2luUGF0aCgpO1xuICAgICAgICB2YXIgcHJldjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBiYXJoZWlnaHQgPSB2YWxbaV0gLyAxMTAgKiBoZWlnaHQ7XG4gICAgICAgICAgICBpZiAoIXByZXYpIHtcbiAgICAgICAgICAgICAgICBwcmV2ID0gYmFyaGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2MubGluZVRvKHggKyA1LCB5ICsgaGVpZ2h0IC0gYmFyaGVpZ2h0KTtcbiAgICAgICAgICAgIGdjLmFyYyh4ICsgNSwgeSArIGhlaWdodCAtIGJhcmhlaWdodCwgMSwgMCwgMiAqIE1hdGguUEksIGZhbHNlKTtcbiAgICAgICAgICAgIHggPSB4ICsgZVdpZHRoO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29uZmlnLm1pbldpZHRoID0gY291bnQgKiAxMDtcbiAgICAgICAgZ2Muc3Ryb2tlKCk7XG4gICAgICAgIGdjLmNsb3NlUGF0aCgpO1xuICAgIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNwYXJrTGluZTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIENlbGxSZW5kZXJlciA9IHJlcXVpcmUoJy4vQ2VsbFJlbmRlcmVyJyk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBDZWxsUmVuZGVyZXJcbiAqL1xudmFyIFRyZWVDZWxsID0gQ2VsbFJlbmRlcmVyLmV4dGVuZCgnVHJlZUNlbGwnLCB7XG5cbiAgICAvKipcbiAgICAgKiBAZGVzYyBBIHNpbXBsZSBpbXBsZW1lbnRhdGlvbiBvZiBhIHRyZWUgY2VsbCByZW5kZXJlciBmb3IgdXNlIG1haW5seSB3aXRoIHRoZSBxdHJlZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29uZmlnLnggLSB0aGUgXCJ0cmFuc2xhdGVkXCIgaW5kZXggaW50byB0aGUgYGJlaGF2aW9yLmFsbENvbHVtbnNgIGFycmF5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbmZpZy5ub3JtYWxpemVkWSAtIHRoZSB2ZXJ0aWNhbCBncmlkIGNvb3JkaW5hdGUgbm9ybWFsaXplZCB0byBmaXJzdCBkYXRhIHJvd1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb25maWcudW50cmFuc2xhdGVkWCAtIHRoZSBob3Jpem9udGFsIGdyaWQgY29vcmRpbmF0ZSBtZWFzdXJlZCBmcm9tIGZpcnN0IGRhdGEgY29sdW1uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbmZpZy55IC0gdGhlIHZlcnRpY2FsIGdyaWQgY29vcmRpbmF0ZSBtZWFzdXJlZCBmcm9tIHRvcCBoZWFkZXIgcm93XG4gICAgICogQG1lbWJlck9mIFRyZWVDZWxsLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHBhaW50OiBmdW5jdGlvbihnYywgY29uZmlnKSB7XG4gICAgICAgIHZhciB4ID0gY29uZmlnLmJvdW5kcy54LFxuICAgICAgICAgICAgeSA9IGNvbmZpZy5ib3VuZHMueSxcbiAgICAgICAgICAgIHdpZHRoID0gY29uZmlnLmJvdW5kcy53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodCA9IGNvbmZpZy5ib3VuZHMuaGVpZ2h0O1xuXG4gICAgICAgIHZhciB2YWwgPSB0aGlzLmNvbmZpZy52YWx1ZS5kYXRhO1xuICAgICAgICB2YXIgaW5kZW50ID0gdGhpcy5jb25maWcudmFsdWUuaW5kZW50O1xuICAgICAgICB2YXIgaWNvbiA9IHRoaXMuY29uZmlnLnZhbHVlLmljb247XG5cbiAgICAgICAgLy9maWxsIGJhY2tncm91bmQgb25seSBpZiBvdXIgYmdDb2xvciBpcyBwb3B1bGF0ZWQgb3Igd2UgYXJlIGEgc2VsZWN0ZWQgY2VsbFxuICAgICAgICBpZiAodGhpcy5jb25maWcuYmFja2dyb3VuZENvbG9yIHx8IHRoaXMuY29uZmlnLmlzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIGdjLmZpbGxTdHlsZSA9IHRoaXMuY29uZmlnLmlzU2VsZWN0ZWQgPyB0aGlzLmNvbmZpZy5iYWNrZ3JvdW5kQ29sb3IgOiB0aGlzLmNvbmZpZy5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgICAgICBnYy5maWxsUmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdmFsIHx8ICF2YWwubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZhbGlnbk9mZnNldCA9IE1hdGguY2VpbChoZWlnaHQgLyAyKTtcblxuICAgICAgICBnYy5maWxsU3R5bGUgPSB0aGlzLmNvbmZpZy5pc1NlbGVjdGVkID8gdGhpcy5jb25maWcuYmFja2dyb3VuZENvbG9yIDogdGhpcy5jb25maWcuYmFja2dyb3VuZENvbG9yO1xuICAgICAgICBnYy5maWxsVGV4dChpY29uICsgdmFsLCB4ICsgaW5kZW50LCB5ICsgdmFsaWduT2Zmc2V0KTtcblxuICAgICAgICB2YXIgdGV4dFdpZHRoID0gdGhpcy5jb25maWcuZ2V0VGV4dFdpZHRoKGdjLCBpY29uICsgdmFsKTtcbiAgICAgICAgdmFyIG1pbldpZHRoID0geCArIGluZGVudCArIHRleHRXaWR0aCArIDEwO1xuICAgICAgICB0aGlzLmNvbmZpZy5taW5XaWR0aCA9IG1pbldpZHRoO1xuICAgIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyZWVDZWxsO1xuIiwiLyoqXG4gKiBAc3VtbWFyeSBBUEkgb2YgY2VsbCByZW5kZXJlciBvYmplY3QgY29uc3RydWN0b3JzLCBwbHVzIHNvbWUgYWNjZXNzIG1ldGhvZHMuXG4gKiBAbW9kdWxlIGNlbGxSZW5kZXJlcnNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQHBhcmFtIHtib29sZWFufSBbcHJpdmF0ZVJlZ2lzdHJ5PWZhbHNlXSAtIFRoaXMgaW5zdGFuY2Ugd2lsbCB1c2UgYSBwcml2YXRlIHJlZ2lzdHJ5LlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIENlbGxSZW5kZXJlcnMocHJpdmF0ZVJlZ2lzdHJ5KSB7XG4gICAgaWYgKHByaXZhdGVSZWdpc3RyeSkge1xuICAgICAgICB0aGlzLnNpbmdsZXRvbnMgPSB7fTtcbiAgICB9XG5cbiAgICAvLyBwcmVyZWdpc3RlciB0aGUgc3RhbmRhcmQgY2VsbCByZW5kZXJlcnNcbiAgICBpZiAocHJpdmF0ZVJlZ2lzdHJ5IHx8ICF0aGlzLmdldCgnZW1wdHljZWxsJykpIHtcbiAgICAgICAgdGhpcy5hZGQoJ0VtcHR5Q2VsbCcsIHJlcXVpcmUoJy4vQ2VsbFJlbmRlcmVyJykpO1xuICAgICAgICB0aGlzLmFkZChyZXF1aXJlKCcuL0J1dHRvbicpKTtcbiAgICAgICAgdGhpcy5hZGQocmVxdWlyZSgnLi9TaW1wbGVDZWxsJykpO1xuICAgICAgICB0aGlzLmFkZChyZXF1aXJlKCcuL1NsaWRlckNlbGwnKSk7XG4gICAgICAgIHRoaXMuYWRkKHJlcXVpcmUoJy4vU3BhcmtCYXInKSk7XG4gICAgICAgIHRoaXMuYWRkKHJlcXVpcmUoJy4vTGFzdFNlbGVjdGlvbicpKTtcbiAgICAgICAgdGhpcy5hZGQocmVxdWlyZSgnLi9TcGFya0xpbmUnKSk7XG4gICAgICAgIHRoaXMuYWRkKHJlcXVpcmUoJy4vRXJyb3JDZWxsJykpO1xuICAgICAgICB0aGlzLmFkZChyZXF1aXJlKCcuL1RyZWVDZWxsJykpO1xuICAgIH1cbn1cblxuQ2VsbFJlbmRlcmVycy5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IENlbGxSZW5kZXJlcnMucHJvdG90eXBlLmNvbnN0cnVjdG9yLCAvLyBwcmVzZXJ2ZSBjb25zdHJ1Y3RvclxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgUmVnaXN0ZXIgYW5kIGluc3RhbnRpYXRlIGEgY2VsbCByZW5kZXJlciBzaW5nbGV0b24uXG4gICAgICogQGRlc2MgQWRkcyBhIGN1c3RvbSBjZWxsIHJlbmRlcmVyIHRvIHRoZSBgc2luZ2xldG9uc2AgaGFzaCB1c2luZyB0aGUgcHJvdmlkZWQgbmFtZSAob3IgdGhlIGNsYXNzIG5hbWUpLCBjb252ZXJ0ZWQgdG8gYWxsIGxvd2VyIGNhc2UuXG4gICAgICpcbiAgICAgKiA+IEFsbCBuYXRpdmUgY2VsbCByZW5kZXJlcnMgYXJlIFwicHJlcmVnaXN0ZXJlZFwiIGluIGBzaW5nbGV0b25zYC4gQWRkIG1vcmUgYnkgY2FsbGluZyBgZ2V0YC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbbmFtZV0gLSBDYXNlLWluc2Vuc2l0aXZlIHJlbmRlcmVyIGtleS4gSWYgbm90IGdpdmVuLCBgWW91ckNlbGxSZW5kZXJlci5wcm90b3R5cGUuJCRDTEFTU19OQU1FYCBpcyB1c2VkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDZWxsUmVuZGVyZXJ9IENvbnN0cnVjdG9yIC0gQSBjb25zdHJ1Y3RvciwgdHlwaWNhbGx5IGV4dGVuZGVkIGZyb20gYENlbGxSZW5kZXJlcmAgKG9yIGEgZGVzY2VuZGFudCB0aGVyZWZyb20pLlxuICAgICAqXG4gICAgICogPiBOb3RlOiBgJCRDTEFTU19OQU1FYCBjYW4gYmUgZWFzaWx5IHNldCB1cCBieSBwcm92aWRpbmcgYSBzdHJpbmcgYXMgdGhlIChvcHRpb25hbCkgZmlyc3QgcGFyYW1ldGVyIChgYWxpYXNgKSBpbiB5b3VyIHtAbGluayBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9leHRlbmQtbWV8Q2VsbEVkaXRvci5leHRlbmR9IGNhbGwuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Q2VsbFJlbmRlcmVyc30gQSBuZXdseSByZWdpc3RlcmVkIGNvbnN0cnVjdG9yIGV4dGVuZGVkIGZyb20ge0BsaW5rIENlbGxSZW5kZXJlcnN9LlxuICAgICAqXG4gICAgICogQG1lbWJlck9mIENlbGxSZW5kZXJlcnMucHJvdG90eXBlXG4gICAgICovXG4gICAgYWRkOiBmdW5jdGlvbihuYW1lLCBDb25zdHJ1Y3Rvcikge1xuICAgICAgICBpZiAodHlwZW9mIG5hbWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIENvbnN0cnVjdG9yID0gbmFtZTtcbiAgICAgICAgICAgIG5hbWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBuYW1lID0gbmFtZSB8fCBDb25zdHJ1Y3Rvci5wcm90b3R5cGUuJCRDTEFTU19OQU1FO1xuICAgICAgICBuYW1lID0gbmFtZSAmJiBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHJldHVybiAodGhpcy5zaW5nbGV0b25zW25hbWVdID0gbmV3IENvbnN0cnVjdG9yKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgUmVnaXN0ZXIgYSBzeW5vbnltIGZvciBhbiBleGlzdGluZyBjZWxsIHJlbmRlcmVyIHNpbmdsZXRvbi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3lub255bU5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXhpc3RpbmdOYW1lXG4gICAgICogQHJldHVybnMge0NlbGxSZW5kZXJlcnN9IFRoZSBwcmV2aW91c2x5IHJlZ2lzdGVyZWQgY29uc3RydWN0b3IgdGhpcyBuZXcgc3lub255bSBwb2ludHMgdG8uXG4gICAgICogQG1lbWJlck9mIENlbGxSZW5kZXJlcnMucHJvdG90eXBlXG4gICAgICovXG4gICAgYWRkU3lub255bTogZnVuY3Rpb24oc3lub255bU5hbWUsIGV4aXN0aW5nTmFtZSkge1xuICAgICAgICB2YXIgY2VsbFJlbmRlcmVyID0gdGhpcy5nZXQoZXhpc3RpbmdOYW1lKTtcbiAgICAgICAgcmV0dXJuICh0aGlzLnNpbmdsZXRvbnNbc3lub255bU5hbWVdID0gY2VsbFJlbmRlcmVyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmV0Y2ggYSByZWdpc3RlcmVkIGNlbGwgcmVuZGVyZXIgc2luZ2xldG9uLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHJldHVybnMge0NlbGxSZW5kZXJlcnN9IEEgcmVnaXN0ZXJlZCBjb25zdHJ1Y3RvciBleHRlbmRlZCBmcm9tIHtAbGluayBDZWxsUmVuZGVyZXJzfS5cbiAgICAgKiBAbWVtYmVyT2YgQ2VsbFJlbmRlcmVycy5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2luZ2xldG9uc1tuYW1lICYmIG5hbWUudG9Mb3dlckNhc2UoKV07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBjZWxsIGVkaXRvciByZWdpc3RyeSBjb250YWluaW5nIGFsbCB0aGUgXCJwcmVyZWdpc3RlcmVkXCIgY2VsbCByZW5kZXJlciBzaW5nbGV0b25zLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG1lbWJlck9mIENlbGxSZW5kZXJlcnMucHJvdG90eXBlXG4gICAgICovXG4gICAgc2luZ2xldG9uczoge31cbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBDZWxsUmVuZGVyZXJzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQmFzZSA9IHJlcXVpcmUoJy4uL2xpYi9CYXNlJyk7XG5cbnZhciBBID0gJ0EnLmNoYXJDb2RlQXQoMCk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBEYXRhTW9kZWwgPSBCYXNlLmV4dGVuZCgnRGF0YU1vZGVsJywge1xuXG4gICAgbmV4dDogbnVsbCxcblxuICAgIGdyaWQ6IG51bGwsXG5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIHRoaXMuZ3JpZCA9IGdyaWQ7XG4gICAgfSxcblxuICAgIGNoYW5nZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmdyaWQuYmVoYXZpb3IuY2hhbmdlZCgpO1xuICAgIH0sXG5cbiAgICBnZXRQcml2YXRlU3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ncmlkLmdldFByaXZhdGVTdGF0ZSgpO1xuICAgIH0sXG5cbiAgICBhcHBseVN0YXRlOiBmdW5jdGlvbigpIHtcblxuICAgIH0sXG5cbiAgICBhbHBoYUZvcjogZnVuY3Rpb24oaSkge1xuICAgICAgICAvLyBOYW1lIHRoZSBjb2x1bW4gaGVhZGVycyBpbiBBLCAuLiwgQUEsIEFCLCBBQywgLi4sIEFaIGZvcm1hdFxuICAgICAgICAvLyBxdW90aWVudC9yZW1haW5kZXJcbiAgICAgICAgLy92YXIgcXVvID0gTWF0aC5mbG9vcihjb2wvMjcpO1xuICAgICAgICB2YXIgcXVvID0gTWF0aC5mbG9vcihpIC8gMjYpO1xuICAgICAgICB2YXIgcmVtID0gaSAlIDI2O1xuICAgICAgICB2YXIgY29kZSA9ICcnO1xuICAgICAgICBpZiAocXVvID4gMCkge1xuICAgICAgICAgICAgY29kZSArPSB0aGlzLmFscGhhKHF1byAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIGNvZGUgKz0gdGhpcy5hbHBoYShyZW0pO1xuICAgICAgICByZXR1cm4gY29kZTtcbiAgICB9LFxuXG4gICAgYWxwaGE6IGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoQSArIGkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY29uZmlnXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRlY2xhcmVkUmVuZGVyZXJOYW1lIC0gVGhlIHByb3Bvc2VkIGNlbGwgcmVuZGVyZXIgbmFtZSAoZm9ybSB0aGUgcmVuZGVyIHByb3BlcnRpZXMpLlxuICAgICAqIEByZXR1cm5zIHtDZWxsUmVuZGVyZXJ9XG4gICAgICogQG1lbWJlck9mIERhdGFNb2RlbC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBnZXRDZWxsOiBmdW5jdGlvbihjb25maWcsIGRlY2xhcmVkUmVuZGVyZXJOYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyaWQuY2VsbFJlbmRlcmVycy5nZXQoZGVjbGFyZWRSZW5kZXJlck5hbWUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBJbnN0YW50aWF0ZSBhIG5ldyBjZWxsIGVkaXRvci5cbiAgICAgKiBAZGVzYyBUaGUgYXBwbGljYXRpb24gZGV2ZWxvcGVyIG1heSBvdmVycmlkZSB0aGlzIG1ldGhvZCB0bzpcbiAgICAgKiAqIEluc3RhbnRpYXRlIGFuZCByZXR1cm4gYW4gYXJiaXRyYXJ5IGNlbGwgZWRpdG9yLiBUaGUgZ2VuZXJpYyBpbXBsZW1lbnRhdGlvbiBoZXJlIHNpbXBseSByZXR1cm5zIHRoZSBkZWNsYXJlZCBjZWxsIGVkaXRvci4gVGhpcyBpcyBgdW5kZWZpbmVkYCB3aGVuIHRoZXJlIHdhcyBubyBzdWNoIGRlY2xhcmF0aW9uLCBvciBpZiB0aGUgbmFtZWQgY2VsbCBlZGl0b3Igd2FzIG5vdCByZWdpc3RlcmVkLlxuICAgICAqICogUmV0dXJuIGB1bmRlZmluZWRgIGZvciBubyBjZWxsIGVkaXRvciBhdCBhbGwuIFRoZSBjZWxsIHdpbGwgbm90IGJlIGVkaXRhYmxlLlxuICAgICAqICogU2V0IHByb3BlcnRpZXMgb24gdGhlIGluc3RhbmNlIGJ5IHBhc3NpbmcgdGhlbSBpbiB0aGUgYG9wdGlvbnNgIG9iamVjdC4gVGhlc2UgYXJlIGFwcGxpZWQgdG8gdGhlIG5ldyBjZWxsIGVkaXRvciBvYmplY3QgYWZ0ZXIgaW5zdGFudGlhdGlvbiBidXQgYmVmb3JlIHJlbmRlcmluZy5cbiAgICAgKiAqIE1hbmlwdWxhdGUgdGhlIGNlbGwgZWRpdG9yIG9iamVjdCAoaW5jbHVkaW5nIGl0cyBET00gZWxlbWVudHMpIGFmdGVyIHJlbmRlcmluZyBidXQgYmVmb3JlIERPTSBpbnNlcnRpb24uXG4gICAgICpcbiAgICAgKiBPdmVycmlkaW5nIHRoaXMgbWV0aG9kIHdpdGggYSBudWxsIGZ1bmN0aW9uICh0aGF0IGFsd2F5cyByZXR1cm5zIGB1bmRlZmluZWRgKSB3aWxsIGhhdmUgdGhlIGVmZmVjdCBvZiBtYWtpbmcgYWxsIGNlbGxzIHVuZWRpdGFibGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sdW1uSW5kZXggLSBBYnNvbHV0ZSBjb2x1bW4gaW5kZXguIEkuZS4sIHRoZSBwb3NpdGlvbiBvZiB0aGUgY29sdW1uIGluIHRoZSBkYXRhIHNvdXJjZSdzIG9yaWdpbmFsIGBmaWVsZHNgIGFycmF5LCBhcyBlY2hvZWQgaW4gYGJlaGF2aW9yLmFsbENvbHVtbnNbXWAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJvd0luZGV4IC0gUm93IGluZGV4IG9mIHRoZSBkYXRhIHJvdyBpbiB0aGUgY3VycmVudGx5IGZpbHRlcmVkIGFuZCBzb3J0ZWQgbGlzdCBvZiByb3dzLCByZWdhcmRsZXNzIG9mIHZlcnRpY2FsIHNjcm9sbCBwb3NpdGlvbiwgb2Zmc2V0IGJ5IHRoZSBudW1iZXIgb2YgaGVhZGVyIHJvd3MgKGFsbCB0aGUgcm93cyBhYm92ZSB0aGUgZmlyc3QgZGF0YSByb3cgaW5jbHVkaW5nIHRoZSBmaWx0ZXIgcm93KS4gSS5lLiwgYWZ0ZXIgc3VidHJhY3Rpbmcgb3V0IHRoZSBudW1iZXIgb2YgaGVhZGVyIHJvd3MsIHRoaXMgaXMgdGhlIHBvc2l0aW9uIG9mIHRoZSBkYXRhIHJvdyBpbiB0aGUgYGluZGV4YCBhcnJheSBvZiB0aGUgZGF0YSBzb3VyY2UgKGkuZS4sIHRoZSBsYXN0IGRhdGEgc291cmNlIHBpcGVsaW5lKS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGVjbGFyZWRFZGl0b3JOYW1lIC0gVGhlIHByb3Bvc2VkIGNlbGwgZWRpdG9yIG5hbWUgKGZyb20gdGhlIHJlbmRlciBwcm9wZXJ0aWVzKS5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIFByb3BlcnRpZXMgdG8gY29weSB0byB0aGUgbmV3IGNlbGwgZWRpdG9yIHByaW1hcmlseSBmb3IgbXVzdGFjaGUncyB1c2UuIEFkZGl0aW9uYWxseSwgYWx3YXlzIGluY2x1ZGVzIHRoZSBmb2xsb3dpbmc6XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuZm9ybWF0IC0gVGhlIHZhbHVlIG9mIHRoZSBgZm9ybWF0YCByZW5kZXIgcHJvcC4gTWF5IGJlIGB1bmRlZmluZWRgLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLmNvbHVtbiAtIEZvciBjb252ZW5pZW5jZSwgdGhlIGNvbHVtbiBvYmplY3QgaW4gYGJlaGF2aW9yLmFsbENvbHVtbnNbXWAgdG8gd2hpY2ggYGNvbHVtbkluZGV4YCByZWZlcnMuXG4gICAgICogQHBhcmFtIHtQb2ludH0gb3B0aW9ucy5lZGl0UG9pbnQgLSBUaGUgZ3JpZCBjb29yZGluYXRlcyBvZiB0aGUgY2VsbCB0byBlZGl0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLmVkaXRQb2ludC54IC0gVGhlIGhvcml6b250YWwgbW9kZWwgY29vcmRpbmF0ZSBvZiB0aGUgY2VsbCB0byBlZGl0LiBUaGlzIGlzIHRoZSBncmlkIGNvb3JkaW5hdGUgcmVnYXJkbGVzcyBvZiBob3Jpem9udGFsIHNjcm9sbCBwb3NpdGlvbi4gSS5lLiwgdGhlIHBvc2l0aW9uIG9mIHRoZSBjb2x1bW4gaW4gdGhlIG9yZGVyZWQgbGlzdCBvZiBzZWxlY3RlZCBjb2x1bW5zIChgYmVoYXZpb3IuY29sdW1uc1tdYCkuIChUaGlzIGlzIHRoZSBjb29yZGluYXRlIHJlcXVpcmVkIGJ5IHtAbGluayBIeXBlcmdyaWQjZWRpdEF0fGVkaXRBdH0uKVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLmVkaXRQb2ludC55IC0gU2FtZSBhcyBgcm93SW5kZXhgLlxuICAgICAqXG4gICAgICogQHJldHVybnMge3VuZGVmaW5lZHxDZWxsRWRpdG9yfSBBbiBvYmplY3QgaW5zdGFudGlhdGVkIGZyb20gdGhlIHJlZ2lzdGVyZWQgY2VsbCBlZGl0b3IgY29uc3RydWN0b3IgbmFtZWQgaW4gYGRlY2xhcmVkRWRpdG9yTmFtZWAuIEEgZmFsc3kgcmV0dXJuIG1lYW5zIHRoZSBjZWxsIGlzIG5vdCBlZGl0YWJsZSBiZWNhdXNlIHRoZSBgZGVjbGFyZWRFZGl0b3JOYW1lYCB3YXMgbm90IHJlZ2lzdGVyZWQuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgRGF0YU1vZGVsLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGdldENlbGxFZGl0b3JBdDogZnVuY3Rpb24oY29sdW1uSW5kZXgsIHJvd0luZGV4LCBkZWNsYXJlZEVkaXRvck5hbWUsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JpZC5jZWxsRWRpdG9ycy5jcmVhdGUoZGVjbGFyZWRFZGl0b3JOYW1lLCBvcHRpb25zKTtcbiAgICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGFNb2RlbDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIERhdGFNb2RlbCA9IHJlcXVpcmUoJy4vRGF0YU1vZGVsJyk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBEYXRhTW9kZWxcbiAqL1xudmFyIERlZmF1bHQgPSBEYXRhTW9kZWwuZXh0ZW5kKCdEZWZhdWx0Jywge1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKiBAbWVtYmVyT2YgRGVmYXVsdC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBkYXRhVXBkYXRlczoge30sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGVmYXVsdC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBUaGlzIGlzIHRoZSBtb3N0IGltcG9ydGFudCBiZWhhdmlvciBmdW5jdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBEYXRhIHBvaW50IGF0IHRoZSBnaXZlbiBjb29yZGluYXRlcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCAtIHRoZSBob3Jpem9udGFsIGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCAtIHRoZSB2ZXJ0aWNhbCBjb29yZGluYXRlXG4gICAgICovXG4gICAgZ2V0VmFsdWU6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgdmFyIG92ZXJyaWRlID0gdGhpcy5kYXRhVXBkYXRlc1sncF8nICsgeCArICdfJyArIHldO1xuICAgICAgICBpZiAob3ZlcnJpZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBvdmVycmlkZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeCA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKHkgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWxwaGFGb3IoeCAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoeCAtIDEpICsgJywgJyArIHRoaXMuYWxwaGEoKHkgLSAxKSAlIDI2KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERlZmF1bHQucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAqL1xuICAgIHNldFZhbHVlOiBmdW5jdGlvbih4LCB5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmRhdGFVcGRhdGVzWydwXycgKyB4ICsgJ18nICsgeV0gPSB2YWx1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERlZmF1bHQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXRDb2x1bW5Db3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAyNztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERlZmF1bHQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXRSb3dDb3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vamVlcGVycyBiYXRtYW4gYSBxdWFkcmlsbGlvbiByb3dzIVxuICAgICAgICByZXR1cm4gNTM7XG4gICAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBEZWZhdWx0O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRGF0YU1vZGVsID0gcmVxdWlyZSgnLi9EYXRhTW9kZWwnKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIERhdGFNb2RlbFxuICovXG52YXIgSW5NZW1vcnkgPSBEYXRhTW9kZWwuZXh0ZW5kKCdJbk1lbW9yeScsIHtcblxuICAgIGRhdGFVcGRhdGVzOiB7fSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBJbk1lbW9yeS5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBUaGlzIGlzIHRoZSBtb3N0IGltcG9ydGFudCBiZWhhdmlvciBmdW5jdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBEYXRhIHBvaW50IGF0IHRoZSBnaXZlbiBjb29yZGluYXRlcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCAtIHRoZSB4IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCAtIHRoZSB5IGNvb3JkaW5hdGVcbiAgICAgKi9cbiAgICBnZXRWYWx1ZTogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICB2YXIgb3ZlcnJpZGUgPSB0aGlzLmRhdGFVcGRhdGVzWydwXycgKyB4ICsgJ18nICsgeV07XG4gICAgICAgIGlmIChvdmVycmlkZSkge1xuICAgICAgICAgICAgcmV0dXJuIG92ZXJyaWRlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh4ID09PSAwKSB7XG4gICAgICAgICAgICBpZiAoeSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB5O1xuICAgICAgICB9XG4gICAgICAgIGlmICh5ID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hbHBoYUZvcih4IC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICh4IC0gMSkgKyAnLCAnICsgdGhpcy5hbHBoYSgoeSAtIDEpICUgMjYpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSW5NZW1vcnkucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAqL1xuICAgIHNldFZhbHVlOiBmdW5jdGlvbih4LCB5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmRhdGFVcGRhdGVzWydwXycgKyB4ICsgJ18nICsgeV0gPSB2YWx1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEluTWVtb3J5LnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0Q29sdW1uQ291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gMjc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBJbk1lbW9yeS5wcm90b3R5cGV7bnVtYmVyfVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0Um93Q291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvL2plZXBlcnMgYmF0bWFuIGEgcXVhZHJpbGxpb24gcm93cyFcbiAgICAgICAgcmV0dXJuIDUzO1xuICAgIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gSW5NZW1vcnk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBhbmFseXRpY3MgPSByZXF1aXJlKCcuLi9TaGFyZWQuanMnKS5hbmFseXRpY3M7XG52YXIgRGF0YU1vZGVsID0gcmVxdWlyZSgnLi9EYXRhTW9kZWwnKTtcbnZhciBpbWFnZXMgPSByZXF1aXJlKCcuLi8uLi9pbWFnZXMnKTtcblxudmFyIFVQV0FSRFNfQkxBQ0tfQVJST1cgPSAnXFx1MjViMicsIC8vIGFrYSAn4payJ1xuICAgIERPV05XQVJEU19CTEFDS19BUlJPVyA9ICdcXHUyNWJjJzsgLy8gYWthICfilrwnXG5cbnZhciBudWxsRGF0YVNvdXJjZSA9IHtcbiAgICBpc051bGxPYmplY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIGdldEZpZWxkczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9LFxuICAgIGdldEhlYWRlcnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfSxcbiAgICBnZXRDb2x1bW5Db3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH0sXG4gICAgZ2V0Um93Q291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9LFxuICAgIGdldEFnZ3JlZ2F0ZVRvdGFsczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9LFxuICAgIGhhc0FnZ3JlZ2F0ZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICBoYXNHcm91cHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICBnZXRSb3c6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuXG4gICAgdmlld01ha2VzU2Vuc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICBzZXRBZ2dyZWdhdGVzOiBmdW5jdGlvbigpIHt9LFxuICAgIHNldEdyb3VwQnlzOiBmdW5jdGlvbigpIHt9LFxuICAgIGdyb3VwQnlzOiBbXSxcblxufTtcblxuLyoqXG4gKiBAbmFtZSBkYXRhTW9kZWxzLkpTT05cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgRGF0YU1vZGVsXG4gKi9cbnZhciBKU09OID0gRGF0YU1vZGVsLmV4dGVuZCgnZGF0YU1vZGVscy5KU09OJywge1xuXG4gICAgLy9udWxsIG9iamVjdCBwYXR0ZXJuIGZvciB0aGUgc291cmNlIG9iamVjdFxuICAgIHJlc2V0U291cmNlczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc291cmNlcyA9IHtcbiAgICAgICAgICAgIHNvdXJjZTogbnVsbERhdGFTb3VyY2UsXG4gICAgICAgICAgICBhZ2dyZWdhdG9yOiBudWxsRGF0YVNvdXJjZSxcbiAgICAgICAgICAgIGdsb2JhbGZpbHRlcjogbnVsbERhdGFTb3VyY2UsXG4gICAgICAgICAgICBzb3J0ZXJjb21wb3NpdGU6IG51bGxEYXRhU291cmNlXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZGF0YVNvdXJjZSA9IHVuZGVmaW5lZDtcbiAgICB9LFxuXG4gICAgdG9wVG90YWxzOiBbXSxcbiAgICBib3R0b21Ub3RhbHM6IFtdLFxuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMucmVzZXRTb3VyY2VzKCk7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWREYXRhID0gW107XG4gICAgfSxcblxuICAgIGNsZWFyU2VsZWN0ZWREYXRhOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RlZERhdGEubGVuZ3RoID0gMDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtjb2x1bW5JbmRleF0gSWYgZ2l2ZW4sIGFsc28gY2hlY2tzIHRoYXQgdGhlIGNvbHVtbiBjbGlja2VkIGlzIHRoZSB0cmVlIGNvbHVtbi5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGhhc0FnZ3JlZ2F0ZXM6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnNvdXJjZXMuYWdncmVnYXRvci5oYXNBZ2dyZWdhdGVzKCk7XG4gICAgICAgIGlmIChyZXN1bHQgJiYgZXZlbnQpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGV2ZW50LmdyaWRDZWxsLnggPT09IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBoYXNHcm91cHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2VzLmFnZ3JlZ2F0b3IuaGFzR3JvdXBzKCk7XG4gICAgfSxcblxuICAgIGdldERhdGFTb3VyY2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZXByZWNhdGVkKCdnZXREYXRhU291cmNlKCknLCAnZGF0YVNvdXJjZScsICcxLjAuNycpO1xuICAgIH0sXG5cbiAgICBnZXRHbG9iYWxGaWx0ZXJEYXRhU291cmNlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlcy5nbG9iYWxmaWx0ZXI7XG4gICAgfSxcblxuICAgIGdldERhdGE6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2VzLnNvdXJjZS5kYXRhO1xuICAgIH0sXG5cbiAgICBnZXRGaWx0ZXJlZERhdGE6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZHMgPSB0aGlzLmRhdGFTb3VyY2U7XG4gICAgICAgIHZhciBjb3VudCA9IGRzLmdldFJvd0NvdW50KCk7XG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgQXJyYXkoY291bnQpO1xuICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IGNvdW50OyB5KyspIHtcbiAgICAgICAgICAgIHJlc3VsdFt5XSA9IGRzLmdldFJvdyh5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBnZXRWYWx1ZTogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICB2YXIgaGFzSGllcmFyY2h5Q29sdW1uID0gdGhpcy5oYXNIaWVyYXJjaHlDb2x1bW4oKTtcbiAgICAgICAgdmFyIGhlYWRlclJvd0NvdW50ID0gdGhpcy5ncmlkLmdldEhlYWRlclJvd0NvdW50KCk7XG4gICAgICAgIHZhciB2YWx1ZTtcblxuICAgICAgICBpZiAoaGFzSGllcmFyY2h5Q29sdW1uKSB7XG4gICAgICAgICAgICBpZiAoeCA9PT0gLTIpIHtcbiAgICAgICAgICAgICAgICB4ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmhhc0FnZ3JlZ2F0ZXMoKSkge1xuICAgICAgICAgICAgeCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmICh5IDwgaGVhZGVyUm93Q291bnQpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5nZXRIZWFkZXJSb3dWYWx1ZSh4LCB5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGlmIChoYXNIaWVyYXJjaHlDb2x1bW4pIHtcbiAgICAgICAgICAgIC8vICAgICB5ICs9IDE7XG4gICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMuZGF0YVNvdXJjZS5nZXRWYWx1ZSh4LCB5IC0gaGVhZGVyUm93Q291bnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuXG4gICAgZ2V0RGF0YUluZGV4OiBmdW5jdGlvbih5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFTb3VyY2UuZ2V0RGF0YUluZGV4KHkgLSB0aGlzLmdyaWQuZ2V0SGVhZGVyUm93Q291bnQoKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAtIG5lZ2F0aXZlIHZhbHVlcyByZWZlciB0byBfYm90dG9tIHRvdGFsc18gcm93c1xuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGdldEhlYWRlclJvd1ZhbHVlOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgaWYgKHkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmdldEhlYWRlcnMoKVtNYXRoLm1heCh4LCAwKV07XG4gICAgICAgIH0gZWxzZSBpZiAoeSA8IDApIHsgLy8gYm90dG9tIHRvdGFscyByb3dzXG4gICAgICAgICAgICB2YXIgYm90dG9tVG90YWxzID0gdGhpcy5nZXRCb3R0b21Ub3RhbHMoKTtcbiAgICAgICAgICAgIHZhbHVlID0gYm90dG9tVG90YWxzW2JvdHRvbVRvdGFscy5sZW5ndGggKyB5XVt4XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBpc0ZpbHRlclJvdyA9IHRoaXMuZ3JpZC5pc1Nob3dGaWx0ZXJSb3coKSxcbiAgICAgICAgICAgICAgICBpc0hlYWRlclJvdyA9IHRoaXMuZ3JpZC5pc1Nob3dIZWFkZXJSb3coKSxcbiAgICAgICAgICAgICAgICB0b3BUb3RhbHNPZmZzZXQgPSAoaXNGaWx0ZXJSb3cgPyAxIDogMCkgKyAoaXNIZWFkZXJSb3cgPyAxIDogMCk7XG4gICAgICAgICAgICBpZiAoeSA+PSB0b3BUb3RhbHNPZmZzZXQpIHsgLy8gdG9wIHRvdGFscyByb3dzXG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmdldFRvcFRvdGFscygpW3kgLSB0b3BUb3RhbHNPZmZzZXRdW3hdO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc0hlYWRlclJvdyAmJiB5ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmdldEhlYWRlcnMoKVt4XTtcbiAgICAgICAgICAgICAgICB2YXIgc29ydFN0cmluZyA9IHRoaXMuZ2V0U29ydEltYWdlRm9yQ29sdW1uKHgpO1xuICAgICAgICAgICAgICAgIGlmIChzb3J0U3RyaW5nKSB7IHZhbHVlID0gc29ydFN0cmluZyArIHZhbHVlOyB9XG4gICAgICAgICAgICB9IGVsc2UgeyAvLyBtdXN0IGJlIGZpbHRlciByb3dcbiAgICAgICAgICAgICAgICB2YXIgZmlsdGVyID0gdGhpcy5nZXRHbG9iYWxGaWx0ZXIoKTtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGZpbHRlciAmJiBmaWx0ZXIuZ2V0Q29sdW1uRmlsdGVyU3RhdGUodGhpcy5nZXRGaWVsZHMoKVt4XSkgfHwgJyc7XG4gICAgICAgICAgICAgICAgdmFyIGljb24gPSBpbWFnZXMuZmlsdGVyKHZhbHVlLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtudWxsLCB2YWx1ZSwgaWNvbl07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgKi9cbiAgICBzZXRWYWx1ZTogZnVuY3Rpb24oeCwgeSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGhhc0hpZXJhcmNoeUNvbHVtbiA9IHRoaXMuaGFzSGllcmFyY2h5Q29sdW1uKCk7XG4gICAgICAgIHZhciBoZWFkZXJSb3dDb3VudCA9IHRoaXMuZ3JpZC5nZXRIZWFkZXJSb3dDb3VudCgpO1xuICAgICAgICBpZiAoaGFzSGllcmFyY2h5Q29sdW1uKSB7XG4gICAgICAgICAgICBpZiAoeCA9PT0gLTIpIHtcbiAgICAgICAgICAgICAgICB4ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmhhc0FnZ3JlZ2F0ZXMoKSkge1xuICAgICAgICAgICAgeCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmICh5IDwgaGVhZGVyUm93Q291bnQpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0SGVhZGVyUm93VmFsdWUoeCwgeSwgdmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kYXRhU291cmNlLnNldFZhbHVlKHgsIHkgLSBoZWFkZXJSb3dDb3VudCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hhbmdlZCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBzZXRIZWFkZXJSb3dWYWx1ZTogZnVuY3Rpb24oeCwgeSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zZXRIZWFkZXIoeCwgeSk7IC8vIHkgaXMgcmVhbGx5IHRoZSB2YWx1ZVxuICAgICAgICB9XG4gICAgICAgIHZhciBpc0ZpbHRlclJvdyA9IHRoaXMuZ3JpZC5pc1Nob3dGaWx0ZXJSb3coKTtcbiAgICAgICAgdmFyIGlzSGVhZGVyUm93ID0gdGhpcy5ncmlkLmlzU2hvd0hlYWRlclJvdygpO1xuICAgICAgICB2YXIgdG9wVG90YWxzT2Zmc2V0ID0gKGlzRmlsdGVyUm93ID8gMSA6IDApICsgKGlzSGVhZGVyUm93ID8gMSA6IDApO1xuICAgICAgICBpZiAoeSA+PSB0b3BUb3RhbHNPZmZzZXQpIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0VG9wVG90YWxzKClbeSAtIHRvcFRvdGFsc09mZnNldF1beF0gPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIGlmICh4ID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuOyAvLyBjYW4ndCBjaGFuZ2UgdGhlIHJvdyBudW1iZXJzIGhlYWRlclxuICAgICAgICB9IGVsc2UgaWYgKGlzSGVhZGVyUm93ICYmIHkgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zZXRIZWFkZXIoeCwgdmFsdWUpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRmlsdGVyUm93KSB7XG4gICAgICAgICAgICB0aGlzLnNldEZpbHRlcih4LCB2YWx1ZSwgeyBhbGVydDogdHJ1ZSB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zZXRIZWFkZXIoeCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sSW5kZXhcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBnZXRDb2x1bW5Qcm9wZXJ0aWVzOiBmdW5jdGlvbihjb2xJbmRleCkge1xuICAgICAgICAvL2FjY2VzcyBkaXJlY3RseSBiZWNhdXNlIHdlIHdhbnQgaXQgb3JkZXJlZFxuICAgICAgICB2YXIgY29sdW1uID0gdGhpcy5ncmlkLmJlaGF2aW9yLmdldENvbHVtbihjb2xJbmRleCk7XG4gICAgICAgIGlmIChjb2x1bW4pIHtcbiAgICAgICAgICAgIHJldHVybiBjb2x1bW4uZ2V0UHJvcGVydGllcygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXRDb2x1bW5Db3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzaG93VHJlZSA9IHRoaXMuZ3JpZC5yZXNvbHZlUHJvcGVydHkoJ3Nob3dUcmVlQ29sdW1uJykgPT09IHRydWU7XG4gICAgICAgIHZhciBoYXNBZ2dyZWdhdGVzID0gdGhpcy5oYXNBZ2dyZWdhdGVzKCk7XG4gICAgICAgIHZhciBvZmZzZXQgPSAoaGFzQWdncmVnYXRlcyAmJiAhc2hvd1RyZWUpID8gLTEgOiAwO1xuICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2VzLmFnZ3JlZ2F0b3IuZ2V0Q29sdW1uQ291bnQoKSArIG9mZnNldDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldFJvd0NvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNvdW50ID0gdGhpcy5kYXRhU291cmNlLmdldFJvd0NvdW50KCk7XG4gICAgICAgIGNvdW50ICs9IHRoaXMuZ3JpZC5nZXRIZWFkZXJSb3dDb3VudCgpO1xuICAgICAgICByZXR1cm4gY291bnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge3N0cmluZ1tdfVxuICAgICAqL1xuICAgIGdldEhlYWRlcnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2VzLmFnZ3JlZ2F0b3IuZ2V0SGVhZGVycygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IGhlYWRlcnNcbiAgICAgKi9cbiAgICBzZXRIZWFkZXJzOiBmdW5jdGlvbihoZWFkZXJzKSB7XG4gICAgICAgIHRoaXMuZGF0YVNvdXJjZS5zZXRIZWFkZXJzKGhlYWRlcnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IGZpZWxkc1xuICAgICAqL1xuICAgIHNldEZpZWxkczogZnVuY3Rpb24oZmllbGRzKSB7XG4gICAgICAgIHRoaXMuZGF0YVNvdXJjZS5zZXRGaWVsZHMoZmllbGRzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nW119XG4gICAgICovXG4gICAgZ2V0RmllbGRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVNvdXJjZS5nZXRGaWVsZHMoKTtcbiAgICB9LFxuXG4gICAgLyoqIEB0eXBlZGVmIHtvYmplY3R9IGRhdGFTb3VyY2VQaXBlbGluZU9iamVjdFxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IERhdGFTb3VyY2UgLSBBIGBoeXBlci1hbmFseXRpY3NgLXN0eWxlICBcImRhdGEgc291cmNlXCIgY29uc3RydWN0b3IuXG4gICAgICogQHByb3BlcnR5IHsqfSBbb3B0aW9uc10gLSBXaGVuIGRlZmluZWQsIHBhc3NlZCBhcyAybmQgYXJndW1lbnQgdG8gY29uc3RydWN0b3IuXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtwYXJlbnRdIC0gRGVmaW5lcyBhIGJyYW5jaCBvZmYgdGhlIG1haW4gc2VxdWVuY2UuXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7ZGF0YVNvdXJjZVBpcGVsaW5lT2JqZWN0W119XG4gICAgICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBwaXBlbGluZTogW1xuICAgICAgICB7IHR5cGU6ICdKU0RhdGFTb3VyY2UnIH0sXG4gICAgICAgIHsgdHlwZTogJ0RhdGFTb3VyY2VBZ2dyZWdhdG9yJywgdGVzdDogJ2hhc0FnZ3JlZ2F0ZXMnIH0sXG4gICAgICAgIHsgdHlwZTogJ0RhdGFTb3VyY2VHbG9iYWxGaWx0ZXInIH0sXG4gICAgICAgIHsgdHlwZTogJ0RhdGFTb3VyY2VTb3J0ZXJDb21wb3NpdGUnIH0sXG4gICAgICAgIHsgdHlwZTogJ0RhdGFOb2RlR3JvdXBTb3J0ZXInLCBwYXJlbnQ6ICdEYXRhU291cmNlQWdncmVnYXRvcicgfVxuICAgIF0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBJbnN0YW50aWF0ZXMgdGhlIGRhdGEgc291cmNlIHBpcGVsaW5lLlxuICAgICAqIEBkZXNjIEVhY2ggbmV3IHBpcGUgaXMgY3JlYXRlZCB1c2luZyB0aGUgc3VwcGxpZWQgY29uc3RydWN0b3IgYW5kIGEgcmVmZXJlbmNlIHRvIHRoZSBwcmV2aW91cyBkYXRhIHNvdXJjZSBpbiB0aGUgcGlwZWxpbmUuIEEgcmVmZXJlbmNlIHRvIGVhY2ggbmV3IHBpcGUgaXMgYWRkZWQgdG8gYHRoaXNgIGRhdGFNb2RlbCBhcyBhIHByb3BlcnR5IHVzaW5nIHRoZSBwaXBlJ3MgYG5hbWVgLlxuICAgICAqXG4gICAgICogVGhlIGZpcnN0IHBpcGUgbXVzdCBoYXZlIGEgYEBAQ0xBU1NfTkFNRWAgb2YgYCdEYXRhU291cmNlJ2AuIEhlbmNlLCB0aGUgc3RhcnQgb2YgdGhlIHBpcGVsaW5lIGlzIGB0aGlzLnNvdXJjZWAuIFRoZSBsYXN0IHBpcGUgaXMgYXNzaWduZWQgdGhlIHN5bm9ueW0gYHRoaXMuZGF0YVNvdXJjZWAuXG4gICAgICpcbiAgICAgKiBCcmFuY2hlcyBhcmUgY3JlYXRlZCB3aGVuIGEgcGlwZSBzcGVjaWZpZXMgYSBuYW1lIGluIGBwYXJlbnRgLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0W119IGRhdGFTb3VyY2UgLSBBcnJheSBvZiB1bmlmb3JtIG9iamVjdHMgY29udGFpbmluZyB0aGUgZ3JpZCBkYXRhLlxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICovXG4gICAgc2V0RGF0YTogZnVuY3Rpb24oZGF0YVNvdXJjZSkge1xuICAgICAgICB0aGlzLnJlc2V0U291cmNlcygpO1xuXG4gICAgICAgIHRoaXMucGlwZWxpbmUuZm9yRWFjaChmdW5jdGlvbihzb3VyY2VzLCBwaXBlLCBpbmRleCkge1xuICAgICAgICAgICAgdmFyIERhdGFTb3VyY2UgPSBhbmFseXRpY3NbcGlwZS50eXBlXTtcblxuICAgICAgICAgICAgcGlwZS5uYW1lID0gcGlwZS5uYW1lIHx8IGdldERhdGFTb3VyY2VOYW1lKHBpcGUudHlwZSk7XG5cbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gMCAmJiBwaXBlLm5hbWUgIT09ICdzb3VyY2UnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ0V4cGVjdGVkIHBpcGVsaW5lIHRvIGJlZ2luIHdpdGggc291cmNlLic7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwaXBlLnBhcmVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YVNvdXJjZSA9IHRoaXMuZGF0YVNvdXJjZSB8fCBkYXRhU291cmNlOyAvLyB0aXAgb2YgbWFpbiB0cnVuayBvbiBmaXJzdCBkaXZlcnNpb25cbiAgICAgICAgICAgICAgICBkYXRhU291cmNlID0gc291cmNlc1tnZXREYXRhU291cmNlTmFtZShwaXBlLnBhcmVudCldO1xuICAgICAgICAgICAgICAgIGlmICghZGF0YVNvdXJjZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyAnUGFyZW50IGRhdGEgc291cmNlIG5vdCBpbiBwaXBlbGluZS4nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGF0YVNvdXJjZSA9IHBpcGUub3B0aW9ucyA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBuZXcgRGF0YVNvdXJjZShkYXRhU291cmNlKVxuICAgICAgICAgICAgICAgIDogbmV3IERhdGFTb3VyY2UoZGF0YVNvdXJjZSwgcGlwZS5vcHRpb25zKTtcblxuICAgICAgICAgICAgc291cmNlc1twaXBlLm5hbWVdID0gZGF0YVNvdXJjZTtcbiAgICAgICAgfS5iaW5kKHRoaXMsIHRoaXMuc291cmNlcykpO1xuXG4gICAgICAgIHRoaXMuc291cmNlID0gdGhpcy5zb3VyY2VzLnNvdXJjZTtcbiAgICAgICAgdGhpcy5kYXRhU291cmNlID0gdGhpcy5kYXRhU291cmNlIHx8IGRhdGFTb3VyY2U7IC8vIHRpcCBvZiBtYWluIHRydW5rIGlmIG5ldmVyIGJyYW5jaGVkXG5cbiAgICAgICAgdGhpcy5hcHBseUFuYWx5dGljcygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGQgYSBwaXBlIHRvIHRoZSBkYXRhIHNvdXJjZSBwaXBlbGluZS5cbiAgICAgKiBAZGVzYyBOby1vcCBpZiBhbHJlYWR5IGFkZGVkLlxuICAgICAqIEBwYXJhbSB7ZGF0YVNvdXJjZVBpcGVsaW5lT2JqZWN0fSBuZXdQaXBlIC0gVGhlIG5ldyBwaXBlbGluZSBwaXBlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcmVmZXJlbmNlUGlwZV0gLSBPbmUgb2Y6XG4gICAgICogKiBOYW1lIG9mIGFuIGV4aXN0aW5nIHBpcGVsaW5lIHBpcGUgYWZ0ZXIgd2hpY2ggdGhlIG5ldyBwaXBlIHdpbGwgYmUgYWRkZWQuIElmIGBudWxsYCwgaW5zZXJ0cyBhdCBiZWdpbm5pbmcuIElmIG5vdCBmb3VuZCAob3IgYHVuZGVmaW5lZGAgb3Igb21pdHRlZCksIGFkZHMgdG8gZW5kLlxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICovXG4gICAgYWRkUGlwZTogZnVuY3Rpb24obmV3UGlwZSwgcmVmZXJlbmNlUGlwZSkge1xuICAgICAgICB2YXIgcmVmZXJlbmNlSW5kZXgsXG4gICAgICAgICAgICBhZGRlZCA9IHRoaXMucGlwZWxpbmUuZmluZChmdW5jdGlvbihwaXBlKSB7IHJldHVybiBwaXBlLnR5cGUgPT09IG5ld1BpcGUudHlwZTsgfSk7XG5cbiAgICAgICAgaWYgKCFhZGRlZCkge1xuICAgICAgICAgICAgaWYgKHJlZmVyZW5jZVBpcGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZWZlcmVuY2VJbmRleCA9IDA7IC8vIGFkZCB0byBiZWdpbm5pbmdcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgIXRoaXMucGlwZWxpbmUuZmluZChmdW5jdGlvbihwaXBlLCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2VJbmRleCA9IGluZGV4ICsgMTsgLy8gYWRkIGFmdGVyIGZvdW5kIHBpcGVcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBpcGUudHlwZSA9PT0gcmVmZXJlbmNlUGlwZTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmVmZXJlbmNlSW5kZXggPSB0aGlzLnBpcGVsaW5lLmxlbmd0aDsgLy8gbm90IGZvdW5kOiBhZGQgdG8gZW5kXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnBpcGVsaW5lLnNwbGljZShyZWZlcmVuY2VJbmRleCwgMCwgbmV3UGlwZSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0FycmF5PEFycmF5Pn0gdG90YWxSb3dzXG4gICAgICovXG4gICAgc2V0VG9wVG90YWxzOiBmdW5jdGlvbih0b3RhbFJvd3MpIHtcbiAgICAgICAgdGhpcy50b3BUb3RhbHMgPSB0b3RhbFJvd3M7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge0FycmF5PEFycmF5Pn1cbiAgICAgKi9cbiAgICBnZXRUb3BUb3RhbHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oYXNBZ2dyZWdhdGVzKCkgPyB0aGlzLmRhdGFTb3VyY2UuZ2V0R3JhbmRUb3RhbHMoKSA6IHRoaXMudG9wVG90YWxzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7QXJyYXk8QXJyYXk+fSB0b3RhbFJvd3NcbiAgICAgKi9cbiAgICBzZXRCb3R0b21Ub3RhbHM6IGZ1bmN0aW9uKHRvdGFsUm93cykge1xuICAgICAgICB0aGlzLmJvdHRvbVRvdGFscyA9IHRvdGFsUm93cztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7QXJyYXk8QXJyYXk+fVxuICAgICAqL1xuICAgIGdldEJvdHRvbVRvdGFsczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhc0FnZ3JlZ2F0ZXMoKSA/IHRoaXMuZGF0YVNvdXJjZS5nZXRHcmFuZFRvdGFscygpIDogdGhpcy5ib3R0b21Ub3RhbHM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICogQHBhcmFtIGdyb3Vwc1xuICAgICAqL1xuICAgIHNldEdyb3VwczogZnVuY3Rpb24oZ3JvdXBzKSB7XG4gICAgICAgIHRoaXMuc291cmNlcy5hZ2dyZWdhdG9yLnNldEdyb3VwQnlzKGdyb3Vwcyk7XG4gICAgICAgIHRoaXMuYXBwbHlBbmFseXRpY3MoKTtcbiAgICAgICAgdGhpcy5ncmlkLmZpcmVTeW50aGV0aWNHcm91cHNDaGFuZ2VkRXZlbnQodGhpcy5nZXRHcm91cHMoKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge29iamVjdFtdfVxuICAgICAqL1xuICAgIGdldEdyb3VwczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBoZWFkZXJzID0gdGhpcy5nZXRIZWFkZXJzKCkuc2xpY2UoMCk7XG4gICAgICAgIHZhciBmaWVsZHMgPSB0aGlzLmdldEZpZWxkcygpLnNsaWNlKDApO1xuICAgICAgICB2YXIgZ3JvdXBCeXMgPSB0aGlzLnNvdXJjZXMuYWdncmVnYXRvci5ncm91cEJ5cztcbiAgICAgICAgdmFyIGdyb3VwcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyb3VwQnlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZmllbGQgPSBoZWFkZXJzW2dyb3VwQnlzW2ldXTtcbiAgICAgICAgICAgIGdyb3Vwcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBpZDogZ3JvdXBCeXNbaV0sXG4gICAgICAgICAgICAgICAgbGFiZWw6IGZpZWxkLFxuICAgICAgICAgICAgICAgIGZpZWxkOiBmaWVsZHNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBncm91cHM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge29iamVjdFtdfVxuICAgICAqL1xuICAgIGdldEF2YWlsYWJsZUdyb3VwczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBoZWFkZXJzID0gdGhpcy5zb3VyY2VzLnNvdXJjZS5nZXRIZWFkZXJzKCkuc2xpY2UoMCk7XG4gICAgICAgIHZhciBncm91cEJ5cyA9IHRoaXMuc291cmNlcy5hZ2dyZWdhdG9yLmdyb3VwQnlzO1xuICAgICAgICB2YXIgZ3JvdXBzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGVhZGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGdyb3VwQnlzLmluZGV4T2YoaSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZpZWxkID0gaGVhZGVyc1tpXTtcbiAgICAgICAgICAgICAgICBncm91cHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBpLFxuICAgICAgICAgICAgICAgICAgICBsYWJlbDogZmllbGQsXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkOiBmaWVsZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBncm91cHM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge29iamVjdFtdfVxuICAgICAqL1xuICAgIGdldEFjdGl2ZUNvbHVtbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ncmlkLmJlaGF2aW9yLmNvbHVtbnMuZmlsdGVyKGZ1bmN0aW9uKGNvbHVtbikge1xuICAgICAgICAgICAgcmV0dXJuIGNvbHVtbi5uYW1lICE9PSAndHJlZSc7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgZ2V0VmlzaWJsZUNvbHVtbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZXByZWNhdGVkKCdnZXRWaXNpYmxlQ29sdW1ucygpJywgJ2dldEFjdGl2ZUNvbHVtbnMoKScsICcxLjAuNicsIGFyZ3VtZW50cyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge29iamVjdFtdfVxuICAgICAqL1xuICAgIGdldEhpZGRlbkNvbHVtbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdmlzaWJsZSA9IHRoaXMuZ3JpZC5iZWhhdmlvci5jb2x1bW5zO1xuICAgICAgICB2YXIgYWxsID0gdGhpcy5ncmlkLmJlaGF2aW9yLmFsbENvbHVtbnM7XG4gICAgICAgIHZhciBoaWRkZW4gPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh2aXNpYmxlLmluZGV4T2YoYWxsW2ldKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBoaWRkZW4ucHVzaChhbGxbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGhpZGRlbi5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBhLmhlYWRlciA8IGIuaGVhZGVyO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGhpZGRlbjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0gYWdncmVnYXRpb25zXG4gICAgICovXG4gICAgc2V0QWdncmVnYXRlczogZnVuY3Rpb24oYWdncmVnYXRpb25zKSB7XG4gICAgICAgIHRoaXMuc291cmNlcy5hZ2dyZWdhdG9yLnNldEFnZ3JlZ2F0ZXMoYWdncmVnYXRpb25zKTtcbiAgICAgICAgdGhpcy5hcHBseUFuYWx5dGljcygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGhhc0hpZXJhcmNoeUNvbHVtbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzaG93VHJlZSA9IHRoaXMuZ3JpZC5yZXNvbHZlUHJvcGVydHkoJ3Nob3dUcmVlQ29sdW1uJykgPT09IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzLmhhc0FnZ3JlZ2F0ZXMoKSAmJiB0aGlzLmhhc0dyb3VwcygpICYmIHNob3dUcmVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGFwcGx5QW5hbHl0aWNzOiBmdW5jdGlvbihkb250QXBwbHlBZ2dyZWdhdG9yKSB7XG4gICAgICAgIHNlbGVjdGVkRGF0YVJvd3NCYWNraW5nU2VsZWN0ZWRHcmlkUm93cy5jYWxsKHRoaXMpO1xuXG4gICAgICAgIHRoaXMucGlwZWxpbmUuZm9yRWFjaChmdW5jdGlvbihzb3VyY2VzLCBwaXBlKSB7XG4gICAgICAgICAgICB2YXIgZGF0YVNvdXJjZSA9IHNvdXJjZXNbcGlwZS5uYW1lXTtcblxuICAgICAgICAgICAgc3dpdGNoIChwaXBlLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdEYXRhU291cmNlQWdncmVnYXRvcic6XG4gICAgICAgICAgICAgICAgICAgIGlmIChkb250QXBwbHlBZ2dyZWdhdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhU291cmNlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnRGF0YVNvdXJjZVNvcnRlckNvbXBvc2l0ZSc6XG4gICAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2VzLmFnZ3JlZ2F0b3IgJiYgc291cmNlcy5hZ2dyZWdhdG9yLnZpZXdNYWtlc1NlbnNlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFTb3VyY2UgPSBzb3VyY2VzLmdyb3Vwc29ydGVyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRhdGFTb3VyY2Uuc2V0U29ydHModGhpcy5nZXRQcml2YXRlU3RhdGUoKS5zb3J0cyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGF0YVNvdXJjZSAmJiBkYXRhU291cmNlLmFwcGx5KSB7XG4gICAgICAgICAgICAgICAgZGF0YVNvdXJjZS5hcHBseSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LmJpbmQodGhpcywgdGhpcy5zb3VyY2VzKSk7XG5cbiAgICAgICAgcmVzZWxlY3RHcmlkUm93c0JhY2tlZEJ5U2VsZWN0ZWREYXRhUm93cy5jYWxsKHRoaXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2xJbmRleFxuICAgICAqIEBwYXJhbSBrZXlzXG4gICAgICovXG4gICAgdG9nZ2xlU29ydDogZnVuY3Rpb24oY29sSW5kZXgsIGtleXMpIHtcbiAgICAgICAgdGhpcy5pbmNyZW1lbnRTb3J0U3RhdGUoY29sSW5kZXgsIGtleXMpO1xuICAgICAgICB0aGlzLmFwcGx5QW5hbHl0aWNzKHRydWUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2xJbmRleFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZGVmZXJyZWRcbiAgICAgKi9cbiAgICB1blNvcnRDb2x1bW46IGZ1bmN0aW9uKGNvbHVtbkluZGV4LCBkZWZlcnJlZCkge1xuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLmdldFByaXZhdGVTdGF0ZSgpLFxuICAgICAgICAgICAgc29ydHMgPSBzdGF0ZS5zb3J0cyA9IHN0YXRlLnNvcnRzIHx8IFtdLFxuICAgICAgICAgICAgc29ydFBvc2l0aW9uO1xuXG4gICAgICAgIGlmIChzb3J0cy5maW5kKGZ1bmN0aW9uKHNvcnRTcGVjLCBpbmRleCkge1xuICAgICAgICAgICAgc29ydFBvc2l0aW9uID0gaW5kZXg7XG4gICAgICAgICAgICByZXR1cm4gc29ydFNwZWMuY29sdW1uSW5kZXggPT09IGNvbHVtbkluZGV4O1xuICAgICAgICB9KSkge1xuICAgICAgICAgICAgc29ydHMuc3BsaWNlKHNvcnRQb3NpdGlvbiwgMSk7XG4gICAgICAgICAgICBpZiAoIWRlZmVycmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hcHBseUFuYWx5dGljcyh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGdldFNvcnRlZENvbHVtbkluZGV4ZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuZ2V0UHJpdmF0ZVN0YXRlKCkuc29ydHMgfHwgW10pLnNsaWNlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbEluZGV4XG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0ga2V5c1xuICAgICAqL1xuICAgIGluY3JlbWVudFNvcnRTdGF0ZTogZnVuY3Rpb24oY29sdW1uSW5kZXgsIGtleXMpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5nZXRQcml2YXRlU3RhdGUoKSxcbiAgICAgICAgICAgIHNvcnRzID0gc3RhdGUuc29ydHMgPSBzdGF0ZS5zb3J0cyB8fCBbXSxcbiAgICAgICAgICAgIHNvcnRQb3NpdGlvbixcbiAgICAgICAgICAgIHNvcnRTcGVjID0gc29ydHMuZmluZChmdW5jdGlvbihzcGVjLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIHNvcnRQb3NpdGlvbiA9IGluZGV4O1xuICAgICAgICAgICAgICAgIHJldHVybiBzcGVjLmNvbHVtbkluZGV4ID09PSBjb2x1bW5JbmRleDtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghc29ydFNwZWMpIHsgLy8gd2FzIHVuc29ydGVkXG4gICAgICAgICAgICBpZiAoa2V5cy5pbmRleE9mKCdDVFJMJykgPCAwKSB7IHNvcnRzLmxlbmd0aCA9IDA7IH1cbiAgICAgICAgICAgIHNvcnRzLnVuc2hpZnQoeyBjb2x1bW5JbmRleDogY29sdW1uSW5kZXgsIGRpcmVjdGlvbjogMSB9KTsgLy8gc28gbWFrZSBhc2NlbmRpbmdcbiAgICAgICAgfSBlbHNlIGlmIChzb3J0U3BlYy5kaXJlY3Rpb24gPiAwKSB7IC8vIHdhcyBhc2NlbmRpbmdcbiAgICAgICAgICAgIHNvcnRTcGVjLmRpcmVjdGlvbiA9IC0xOyAvLyBzbyBtYWtlIGRlc2NlbmRpbmdcbiAgICAgICAgfSBlbHNlIHsgLy8gd2FzIGRlc2NlbmRpbmdcbiAgICAgICAgICAgIHNvcnRzLnNwbGljZShzb3J0UG9zaXRpb24sIDEpOyAvLyBzbyBtYWtlIHVuc29ydGVkXG4gICAgICAgIH1cblxuICAgICAgICAvL01pbm9yIGltcHJvdmVtZW50LCBidXQgdGhpcyBjaGVjayBjYW4gaGFwcGUgbiBlYXJsaWVyIGFuZCB0ZXJtaW5hdGUgZWFybGllclxuICAgICAgICBpZiAoc29ydHMubGVuZ3RoID4gMykge1xuICAgICAgICAgICAgc29ydHMubGVuZ3RoID0gMztcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSBpbmRleFxuICAgICAqIEBwYXJhbSByZXR1cm5Bc1N0cmluZ1xuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGdldFNvcnRJbWFnZUZvckNvbHVtbjogZnVuY3Rpb24oY29sdW1uSW5kZXgpIHtcbiAgICAgICAgdmFyIHNvcnRzID0gdGhpcy5nZXRQcml2YXRlU3RhdGUoKS5zb3J0cyB8fCBbXSxcbiAgICAgICAgICAgIHNvcnRQb3NpdGlvbixcbiAgICAgICAgICAgIHNvcnRTcGVjID0gc29ydHMuZmluZChmdW5jdGlvbihzcGVjLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIHNvcnRQb3NpdGlvbiA9IGluZGV4O1xuICAgICAgICAgICAgICAgIHJldHVybiBzcGVjLmNvbHVtbkluZGV4ID09PSBjb2x1bW5JbmRleDtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgcmVzdWx0ID0gbnVsbDtcblxuICAgICAgICBpZiAoc29ydFNwZWMpIHtcbiAgICAgICAgICAgIHZhciByYW5rID0gc29ydHMubGVuZ3RoIC0gc29ydFBvc2l0aW9uLFxuICAgICAgICAgICAgICAgIGFycm93ID0gc29ydFNwZWMuZGlyZWN0aW9uID4gMCA/IFVQV0FSRFNfQkxBQ0tfQVJST1cgOiBET1dOV0FSRFNfQkxBQ0tfQVJST1c7XG4gICAgICAgICAgICByZXN1bHQgPSByYW5rICsgYXJyb3cgKyAnICc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBpc0RyaWxsRG93bjogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGlwZWxpbmUuZmluZChmdW5jdGlvbihwaXBlKSB7XG4gICAgICAgICAgICB2YXIgdGVzdCA9IHBpcGUudGVzdCxcbiAgICAgICAgICAgICAgICB0eXBlID0gdHlwZW9mIHRlc3Q7XG5cbiAgICAgICAgICAgIHRlc3QgPSB0eXBlID09PSAnZnVuY3Rpb24nICYmIHBpcGUudGVzdCB8fFxuICAgICAgICAgICAgICAgIHR5cGUgPT09ICdzdHJpbmcnICYmIHRoaXNbcGlwZS50ZXN0XTtcblxuICAgICAgICAgICAgcmV0dXJuIHRlc3QgJiYgdGVzdC5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGNlbGxcbiAgICAgKiBAcGFyYW0gZXZlbnRcbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGNlbGxDbGlja2VkOiBmdW5jdGlvbihjZWxsLCBldmVudCkge1xuICAgICAgICBpZiAodGhpcy5pc0RyaWxsRG93bihldmVudCkpIHtcbiAgICAgICAgICAgIHZhciB5ID0gZXZlbnQuZ3JpZENlbGwueSAtIHRoaXMuZ3JpZC5nZXRIZWFkZXJSb3dDb3VudCgpO1xuICAgICAgICAgICAgdGhpcy50b2dnbGVSb3coeSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgVG9nZ2xlIHRoZSBkcmlsbC1kb3duIGNvbnRyb2wgb2YgYSB0aGUgc3BlY2lmaWVkIHJvdy5cbiAgICAgKiBAZGVzYyBPcGVyYXRlcyBvbmx5IG9uIHRoZSBmb2xsb3dpbmcgcm93czpcbiAgICAgKiAqIEV4cGFuZGFibGUgcm93cyAtIFJvd3Mgd2l0aCBhIGRyaWxsLWRvd24gY29udHJvbC5cbiAgICAgKiAqIFJldmVhbGVkIHJvd3MgLSBSb3dzIG5vdCBoaWRkZW4gaW5zaWRlIG9mIGNvbGxhcHNlZCBkcmlsbC1kb3ducy5cbiAgICAgKiBAcGFyYW0geSAtIFJldmVhbGVkIHJvdyBudW1iZXIuIChUaGlzIGlzIG5vdCB0aGUgcm93IElELilcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtleHBhbmRdIC0gT25lIG9mOlxuICAgICAqICogYHRydWVgIC0gRXhwYW5kIHJvdy5cbiAgICAgKiAqIGBmYWxzZWAgLSBDb2xsYXBzZSByb3cuXG4gICAgICogKiBgdW5kZWZpbmVkYCAob3Igb21pdHRlZCkgLSBUb2dnbGUgc3RhdGUgb2Ygcm93LlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufHVuZGVmaW5lZH0gSWYgYW55IHJvd3MgZXhwYW5kZWQgb3IgY29sbGFwc2VkOyBgdW5kZWZpbmVkYCBtZWFucyByb3cgaGFkIG5vIGRyaWxsLWRvd24gY29udHJvbC5cbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHRvZ2dsZVJvdzogZnVuY3Rpb24oeSwgZXhwYW5kKSB7XG4gICAgICAgIHZhciBjaGFuZ2VkO1xuICAgICAgICBpZiAodGhpcy5pc0RyaWxsRG93bigpKSB7XG4gICAgICAgICAgICBjaGFuZ2VkID0gdGhpcy5kYXRhU291cmNlLmNsaWNrKHksIGV4cGFuZCk7XG4gICAgICAgICAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwbHlBbmFseXRpY3ModHJ1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoYW5nZWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fVxuICAgICAqL1xuICAgIGdldFJvdzogZnVuY3Rpb24oeSkge1xuICAgICAgICB2YXIgaGVhZGVyUm93Q291bnQgPSB0aGlzLmdyaWQuZ2V0SGVhZGVyUm93Q291bnQoKTtcbiAgICAgICAgaWYgKHkgPCBoZWFkZXJSb3dDb3VudCAmJiAhdGhpcy5oYXNBZ2dyZWdhdGVzKCkpIHtcbiAgICAgICAgICAgIHZhciB0b3BUb3RhbHMgPSB0aGlzLmdldFRvcFRvdGFscygpO1xuICAgICAgICAgICAgcmV0dXJuIHRvcFRvdGFsc1t5IC0gKGhlYWRlclJvd0NvdW50IC0gdG9wVG90YWxzLmxlbmd0aCldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFTb3VyY2UuZ2V0Um93KHkgLSBoZWFkZXJSb3dDb3VudCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fVxuICAgICAqL1xuICAgIGJ1aWxkUm93OiBmdW5jdGlvbih5KSB7XG4gICAgICAgIHZhciBjb2xDb3VudCA9IHRoaXMuZ2V0Q29sdW1uQ291bnQoKTtcbiAgICAgICAgdmFyIGZpZWxkcyA9IFtdLmNvbmNhdCh0aGlzLmdldEZpZWxkcygpKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICBpZiAodGhpcy5oYXNBZ2dyZWdhdGVzKCkpIHtcbiAgICAgICAgICAgIHJlc3VsdC50cmVlID0gdGhpcy5nZXRWYWx1ZSgtMiwgeSk7XG4gICAgICAgICAgICBmaWVsZHMuc2hpZnQoKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbENvdW50OyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdFtmaWVsZHNbaV1dID0gdGhpcy5nZXRWYWx1ZShpLCB5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICogQHJldHVybnMge29iamVjdH1cbiAgICAgKi9cbiAgICBnZXRDb21wdXRlZFJvdzogZnVuY3Rpb24oeSkge1xuICAgICAgICB2YXIgcmNmID0gdGhpcy5nZXRSb3dDb250ZXh0RnVuY3Rpb24oW3ldKTtcbiAgICAgICAgdmFyIGZpZWxkcyA9IHRoaXMuZ2V0RmllbGRzKCk7XG4gICAgICAgIHZhciByb3cgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWVsZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBmaWVsZCA9IGZpZWxkc1tpXTtcbiAgICAgICAgICAgIHJvd1tmaWVsZF0gPSByY2YoZmllbGQpWzBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByb3c7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkTmFtZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZ2V0VmFsdWVCeUZpZWxkOiBmdW5jdGlvbihmaWVsZE5hbWUsIHkpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5nZXRGaWVsZHMoKS5pbmRleE9mKGZpZWxkTmFtZSk7XG4gICAgICAgIGlmICh0aGlzLmhhc0FnZ3JlZ2F0ZXMoKSkge1xuICAgICAgICAgICAgeSArPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFTb3VyY2UuZ2V0VmFsdWUoaW5kZXgsIHkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBHZXQgYSByZWZlcmVuY2UgdG8gdGhlIGZpbHRlciBhdHRhY2hlZCB0byB0aGUgSHlwZXJncmlkLlxuICAgICAqIEByZXR1cm5zIHtGaWx0ZXJUcmVlfVxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICovXG4gICAgZ2V0R2xvYmFsRmlsdGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0R2xvYmFsRmlsdGVyRGF0YVNvdXJjZSgpLmdldCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBBdHRhY2gvZGV0YWNoIGEgZmlsdGVyIHRvIGEgSHlwZXJncmlkLlxuICAgICAqIEBwYXJhbSB7RmlsdGVyVHJlZX0gW2ZpbHRlcl0gLSBUaGUgZmlsdGVyIG9iamVjdC4gSWYgdW5kZWZpbmVkLCBhbnkgYXR0YWNoZWQgZmlsdGVyIGlzIHJlbW92ZWQsIHR1cm5pbmcgZmlsdGVyaW5nIE9GRi5cbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHNldEdsb2JhbEZpbHRlcjogZnVuY3Rpb24oZmlsdGVyKSB7XG4gICAgICAgIHRoaXMuZ2V0R2xvYmFsRmlsdGVyRGF0YVNvdXJjZSgpLnNldChmaWx0ZXIpO1xuICAgICAgICB0aGlzLmFwcGx5QW5hbHl0aWNzKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IFNldCB0aGUgY2FzZSBzZW5zaXRpdml0eSBvZiBmaWx0ZXIgdGVzdHMgYWdhaW5zdCBkYXRhLlxuICAgICAqIEBkZXNjIENhc2Ugc2Vuc2l0aXZpdHkgcGVydGFpbnMgdG8gc3RyaW5nIGNvbXBhcmVzIG9ubHkuIFRoaXMgaW5jbHVkZXMgdW50eXBlZCBjb2x1bW5zLCBjb2x1bW5zIHR5cGVkIGFzIHN0cmluZ3MsIHR5cGVkIGNvbHVtbnMgY29udGFpbmluZyBkYXRhIHRoYXQgY2Fubm90IGJlIGNvZXJjZWQgdG8gdHlwZSBvciB3aGVuIHRoZSBmaWx0ZXIgZXhwcmVzc2lvbiBvcGVyYW5kIGNhbm5vdCBiZSBjb2VyY2VkLlxuICAgICAqXG4gICAgICogTk9URTogVGhpcyBpcyBhIHNoYXJlZCBwcm9wZXJ0eSBhbmQgYWZmZWN0cyBhbGwgZ3JpZCBtYW5hZ2VkIGJ5IHRoaXMgaW5zdGFuY2Ugb2YgdGhlIGFwcC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzU2Vuc2l0aXZlXG4gICAgICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBzZXRHbG9iYWxGaWx0ZXJDYXNlU2Vuc2l0aXZpdHk6IGZ1bmN0aW9uKGlzU2Vuc2l0aXZlKSB7XG4gICAgICAgIHRoaXMuZ2V0R2xvYmFsRmlsdGVyKCkuc2V0Q2FzZVNlbnNpdGl2aXR5KGlzU2Vuc2l0aXZlKTtcbiAgICAgICAgdGhpcy5hcHBseUFuYWx5dGljcygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBHZXQgYSBwYXJ0aWN1bGFyIGNvbHVtbiBmaWx0ZXIncyBzdGF0ZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sdW1uTmFtZVxuICAgICAqIEBwYXJhbSB7RmlsdGVyVHJlZUdldFN0YXRlT3B0aW9uc09iamVjdH0gW29wdGlvbnNdIC0gUGFzc2VkIHRvIHRoZSBmaWx0ZXIncyB7QGxpbmsgRGVmYXVsdEZpbHRlciNnZXRTdGF0ZXxnZXRTdGF0ZX0gbWV0aG9kLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuc3ludGF4PSdDUUwnXSAtIFRoZSBzeW50YXggdG8gdXNlIHRvIGRlc2NyaWJlIHRoZSBmaWx0ZXIgc3RhdGUuIE5vdGUgdGhhdCBgZ2V0RmlsdGVyYCdzIGRlZmF1bHQgc3ludGF4LCBgJ0NRTCdgLCBkaWZmZXJzIGZyb20gdGhlIG90aGVyIGdldCBzdGF0ZSBtZXRob2RzLlxuICAgICAqIEByZXR1cm5zIHtGaWx0ZXJUcmVlU3RhdGVPYmplY3R9XG4gICAgICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBnZXRGaWx0ZXI6IGZ1bmN0aW9uKGNvbHVtbkluZGV4T3JOYW1lLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBpc0luZGV4ID0gIWlzTmFOKE51bWJlcihjb2x1bW5JbmRleE9yTmFtZSkpLFxuICAgICAgICAgICAgY29sdW1uTmFtZSA9IGlzSW5kZXggPyB0aGlzLmdldEZpZWxkcygpW2NvbHVtbkluZGV4T3JOYW1lXSA6IGNvbHVtbkluZGV4T3JOYW1lO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmdldEdsb2JhbEZpbHRlcigpLmdldENvbHVtbkZpbHRlclN0YXRlKGNvbHVtbk5hbWUsIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBTZXQgYSBwYXJ0aWN1bGFyIGNvbHVtbiBmaWx0ZXIncyBzdGF0ZS5cbiAgICAgKiBAZGVzYyBBZnRlciBzZXR0aW5nIHRoZSBuZXcgZmlsdGVyIHN0YXRlLCByZWFwcGxpZXMgdGhlIGZpbHRlciB0byB0aGUgZGF0YSBzb3VyY2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBjb2x1bW5JbmRleE9yTmFtZSAtIFRoZSBfY29sdW1uIGZpbHRlcl8gdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gW3N0YXRlXSAtIEEgZmlsdGVyIHRyZWUgb2JqZWN0IG9yIGEgSlNPTiwgU1FMLCBvciBDUUwgc3ViZXhwcmVzc2lvbiBzdHJpbmcgdGhhdCBkZXNjcmliZXMgdGhlIGEgbmV3IHN0YXRlIGZvciB0aGUgbmFtZWQgY29sdW1uIGZpbHRlci4gVGhlIGV4aXN0aW5nIGNvbHVtbiBmaWx0ZXIgc3ViZXhwcmVzc2lvbiBpcyByZXBsYWNlZCB3aXRoIGEgbmV3IG5vZGUgYmFzZWQgb24gdGhpcyBzdGF0ZS4gSWYgaXQgZG9lcyBub3QgZXhpc3QsIHRoZSBuZXcgc3ViZXhwcmVzc2lvbiBpcyBhZGRlZCB0byB0aGUgY29sdW1uIGZpbHRlcnMgc3VidHJlZSAoYGZpbHRlci5jb2x1bW5GaWx0ZXJzYCkuXG4gICAgICpcbiAgICAgKiBJZiB1bmRlZmluZWQsIHJlbW92ZXMgdGhlIGVudGlyZSBjb2x1bW4gZmlsdGVyIHN1YmV4cHJlc3Npb24gZnJvbSB0aGUgY29sdW1uIGZpbHRlcnMgc3VidHJlZS5cbiAgICAgKiBAcGFyYW0ge0ZpbHRlclRyZWVTZXRTdGF0ZU9wdGlvbnNPYmplY3R9IFtvcHRpb25zXSAtIFBhc3NlZCB0byB0aGUgZmlsdGVyJ3MgW3NldFN0YXRlXXtAbGluayBodHRwOi8vam9uZWl0LmdpdGh1Yi5pby9maWx0ZXItdHJlZS9GaWx0ZXJUcmVlLmh0bWwjc2V0U3RhdGV9IG1ldGhvZC4gWW91IG1heSBtaXggaW4gbWVtYmVycyBvZiB0aGUge0BsaW5rIGh0dHA6Ly9qb25laXQuZ2l0aHViLmlvL2ZpbHRlci10cmVlL2dsb2JhbC5odG1sI0ZpbHRlclRyZWVWYWxpZGF0aW9uT3B0aW9uc09iamVjdHxGaWx0ZXJUcmVlVmFsaWRhdGlvbk9wdGlvbnNPYmplY3R9XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnN5bnRheD0nQ1FMJ10gLSBUaGUgc3ludGF4IHRvIHVzZSB0byBkZXNjcmliZSB0aGUgZmlsdGVyIHN0YXRlLiBOb3RlIHRoYXQgYHNldEZpbHRlcmAncyBkZWZhdWx0IHN5bnRheCwgYCdDUUwnYCwgZGlmZmVycyBmcm9tIHRoZSBvdGhlciBnZXQgc3RhdGUgbWV0aG9kcy5cbiAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfEVycm9yfHN0cmluZ30gYHVuZGVmaW5lZGAgaW5kaWNhdGVzIHN1Y2Nlc3MuXG4gICAgICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBzZXRGaWx0ZXI6IGZ1bmN0aW9uKGNvbHVtbkluZGV4T3JOYW1lLCBzdGF0ZSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgaXNJbmRleCA9ICFpc05hTihOdW1iZXIoY29sdW1uSW5kZXhPck5hbWUpKSxcbiAgICAgICAgICAgIGNvbHVtbk5hbWUgPSBpc0luZGV4ID8gdGhpcy5nZXRGaWVsZHMoKVtjb2x1bW5JbmRleE9yTmFtZV0gOiBjb2x1bW5JbmRleE9yTmFtZTtcblxuICAgICAgICB0aGlzLmdldEdsb2JhbEZpbHRlcigpLnNldENvbHVtbkZpbHRlclN0YXRlKGNvbHVtbk5hbWUsIHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5ncmlkLmZpcmVTeW50aGV0aWNGaWx0ZXJBcHBsaWVkRXZlbnQoKTtcbiAgICAgICAgdGhpcy5hcHBseUFuYWx5dGljcygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0ZpbHRlclRyZWVHZXRTdGF0ZU9wdGlvbnNPYmplY3R9IFtvcHRpb25zXSAtIFBhc3NlZCB0byB0aGUgZmlsdGVyJ3Mge0BsaW5rIERlZmF1bHRGaWx0ZXIjZ2V0U3RhdGV8Z2V0U3RhdGV9IG1ldGhvZC5cbiAgICAgKiBAcmV0dXJucyB7RmlsdGVyVHJlZVN0YXRlT2JqZWN0fVxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICovXG4gICAgZ2V0RmlsdGVyczogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRHbG9iYWxGaWx0ZXIoKS5nZXRDb2x1bW5GaWx0ZXJzU3RhdGUob3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7RmlsdGVyVHJlZVN0YXRlT2JqZWN0fSBzdGF0ZVxuICAgICAqIEBwYXJhbSB7RmlsdGVyVHJlZVNldFN0YXRlT3B0aW9uc09iamVjdH0gW29wdGlvbnNdIC0gUGFzc2VkIHRvIHRoZSBmaWx0ZXIncyBbc2V0U3RhdGVde0BsaW5rIGh0dHA6Ly9qb25laXQuZ2l0aHViLmlvL2ZpbHRlci10cmVlL0ZpbHRlclRyZWUuaHRtbCNzZXRTdGF0ZX0gbWV0aG9kLiBZb3UgbWF5IG1peCBpbiBtZW1iZXJzIG9mIHRoZSB7QGxpbmsgaHR0cDovL2pvbmVpdC5naXRodWIuaW8vZmlsdGVyLXRyZWUvZ2xvYmFsLmh0bWwjRmlsdGVyVHJlZVZhbGlkYXRpb25PcHRpb25zT2JqZWN0fEZpbHRlclRyZWVWYWxpZGF0aW9uT3B0aW9uc09iamVjdH1cbiAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfEVycm9yfHN0cmluZ30gYHVuZGVmaW5lZGAgaW5kaWNhdGVzIHN1Y2Nlc3MuXG4gICAgICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBzZXRGaWx0ZXJzOiBmdW5jdGlvbihzdGF0ZSwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLmdldEdsb2JhbEZpbHRlcigpLnNldENvbHVtbkZpbHRlcnNTdGF0ZShzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuZ3JpZC5maXJlU3ludGhldGljRmlsdGVyQXBwbGllZEV2ZW50KCk7XG4gICAgICAgIHRoaXMuYXBwbHlBbmFseXRpY3MoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtGaWx0ZXJUcmVlR2V0U3RhdGVPcHRpb25zT2JqZWN0fSBbb3B0aW9uc10gLSBQYXNzZWQgdG8gdGhlIGZpbHRlcidzIHtAbGluayBEZWZhdWx0RmlsdGVyI2dldFN0YXRlfGdldFN0YXRlfSBtZXRob2QuXG4gICAgICogQHJldHVybnMge0ZpbHRlclRyZWVTdGF0ZU9iamVjdH1cbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGdldFRhYmxlRmlsdGVyOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEdsb2JhbEZpbHRlcigpLmdldFRhYmxlRmlsdGVyU3RhdGUob3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IFNldCBhIHRoZSB0YWJsZSBmaWx0ZXIgc3RhdGUuXG4gICAgICogQHBhcmFtIHtGaWx0ZXJUcmVlU3RhdGVPYmplY3R9IHN0YXRlXG4gICAgICogQHBhcmFtIHtGaWx0ZXJUcmVlU2V0U3RhdGVPcHRpb25zT2JqZWN0fSBbb3B0aW9uc10gLSBQYXNzZWQgdG8gdGhlIGZpbHRlcidzIFtzZXRTdGF0ZV17QGxpbmsgaHR0cDovL2pvbmVpdC5naXRodWIuaW8vZmlsdGVyLXRyZWUvRmlsdGVyVHJlZS5odG1sI3NldFN0YXRlfSBtZXRob2QuIFlvdSBtYXkgbWl4IGluIG1lbWJlcnMgb2YgdGhlIHtAbGluayBodHRwOi8vam9uZWl0LmdpdGh1Yi5pby9maWx0ZXItdHJlZS9nbG9iYWwuaHRtbCNGaWx0ZXJUcmVlVmFsaWRhdGlvbk9wdGlvbnNPYmplY3R8RmlsdGVyVHJlZVZhbGlkYXRpb25PcHRpb25zT2JqZWN0fVxuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR8RXJyb3J8c3RyaW5nfSBgdW5kZWZpbmVkYCBpbmRpY2F0ZXMgc3VjY2Vzcy5cbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHNldFRhYmxlRmlsdGVyOiBmdW5jdGlvbihzdGF0ZSwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLmdldEdsb2JhbEZpbHRlcigpLnNldFRhYmxlRmlsdGVyU3RhdGUoc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmdyaWQuZmlyZVN5bnRoZXRpY0ZpbHRlckFwcGxpZWRFdmVudCgpO1xuICAgICAgICB0aGlzLmFwcGx5QW5hbHl0aWNzKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICovXG4gICAgYXBwbHlTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuYXBwbHlBbmFseXRpY3MoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAgICAgKi9cbiAgICByZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc2V0RGF0YShbXSk7XG4gICAgfSxcblxuICAgIGdldFVuZmlsdGVyZWRWYWx1ZTogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2VzLnNvdXJjZS5nZXRWYWx1ZSh4LCB5KTtcbiAgICB9LFxuXG4gICAgZ2V0VW5maWx0ZXJlZFJvd0NvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlcy5zb3VyY2UuZ2V0Um93Q291bnQoKTtcbiAgICB9XG59KTtcblxuLy8gTE9DQUwgTUVUSE9EUyAtLSB0byBiZSBjYWxsZWQgd2l0aCBgLmNhbGwodGhpc2BcblxuLyoqXG4gKiBBY2N1bXVsYXRlIGFjdHVhbCBkYXRhIHJvdyBvYmplY3RzIGJhY2tpbmcgY3VycmVudCBncmlkIHJvdyBzZWxlY3Rpb25zLlxuICogVGhpcyBjYWxsIHNob3VsZCBiZSBwYWlyZWQgd2l0aCBhIHN1YnNlcXVlbnQgY2FsbCB0byBgcmVzZWxlY3RHcmlkUm93c0JhY2tlZEJ5U2VsZWN0ZWREYXRhUm93c2AuXG4gKiBAcHJpdmF0ZVxuICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAqL1xuZnVuY3Rpb24gc2VsZWN0ZWREYXRhUm93c0JhY2tpbmdTZWxlY3RlZEdyaWRSb3dzKCkge1xuICAgIHZhciBzZWxlY3RlZERhdGEgPSB0aGlzLnNlbGVjdGVkRGF0YSxcbiAgICAgICAgaGFzUm93U2VsZWN0aW9ucyA9IHRoaXMuZ3JpZC5zZWxlY3Rpb25Nb2RlbC5oYXNSb3dTZWxlY3Rpb25zKCksXG4gICAgICAgIG5lZWRGaWx0ZXJlZERhdGFMaXN0ID0gc2VsZWN0ZWREYXRhLmxlbmd0aCB8fCBoYXNSb3dTZWxlY3Rpb25zO1xuXG4gICAgaWYgKG5lZWRGaWx0ZXJlZERhdGFMaXN0KSB7XG4gICAgICAgIHZhciBmaWx0ZXJlZERhdGEgPSB0aGlzLmdldEZpbHRlcmVkRGF0YSgpO1xuICAgIH1cblxuICAgIC8vIFNURVAgMTogUmVtb3ZlIGFueSBmaWx0ZXJlZCBkYXRhIHJvd3MgZnJvbSB0aGUgcmVjZW50bHkgc2VsZWN0ZWQgbGlzdC5cbiAgICBzZWxlY3RlZERhdGEuZm9yRWFjaChmdW5jdGlvbihkYXRhUm93LCBpbmRleCkge1xuICAgICAgICBpZiAoZmlsdGVyZWREYXRhLmluZGV4T2YoZGF0YVJvdykgPj0gMCkge1xuICAgICAgICAgICAgZGVsZXRlIHNlbGVjdGVkRGF0YVtpbmRleF07XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFNURVAgMjogQWNjdW11bGF0ZSB0aGUgZGF0YSByb3dzIGJhY2tpbmcgYW55IGN1cnJlbnRseSBzZWxlY3RlZCBncmlkIHJvd3MgaW4gYHRoaXMuc2VsZWN0ZWREYXRhYC5cbiAgICBpZiAoaGFzUm93U2VsZWN0aW9ucykgeyAvLyBhbnkgY3VycmVudCBncmlkIHJvdyBzZWxlY3Rpb25zP1xuICAgICAgICB0aGlzLmdyaWQuZ2V0U2VsZWN0ZWRSb3dzKCkuZm9yRWFjaChmdW5jdGlvbihzZWxlY3RlZFJvd0luZGV4KSB7XG4gICAgICAgICAgICB2YXIgZGF0YVJvdyA9IGZpbHRlcmVkRGF0YVtzZWxlY3RlZFJvd0luZGV4XTtcbiAgICAgICAgICAgIGlmIChzZWxlY3RlZERhdGEuaW5kZXhPZihkYXRhUm93KSA8IDApIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZERhdGEucHVzaChkYXRhUm93KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vKipcbiAqIFJlLWVzdGFibGlzaCBncmlkIHJvdyBzZWxlY3Rpb25zIGJhc2VkIG9uIGFjdHVhbCBkYXRhIHJvdyBvYmplY3RzIGFjY3VtdWxhdGVkIGJ5IGBzZWxlY3RlZERhdGFSb3dzQmFja2luZ1NlbGVjdGVkR3JpZFJvd3NgIHdoaWNoIHNob3VsZCBiZSBjYWxsZWQgZmlyc3QuXG4gKiBAcHJpdmF0ZVxuICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAqL1xuZnVuY3Rpb24gcmVzZWxlY3RHcmlkUm93c0JhY2tlZEJ5U2VsZWN0ZWREYXRhUm93cygpIHtcbiAgICBpZiAodGhpcy5zZWxlY3RlZERhdGEubGVuZ3RoKSB7IC8vIGFueSBkYXRhIHJvdyBvYmplY3RzIGFkZGVkIGZyb20gcHJldmlvdXMgZ3JpZCByb3cgc2VsZWN0aW9ucz9cbiAgICAgICAgdmFyIHNlbGVjdGlvbk1vZGVsID0gdGhpcy5ncmlkLnNlbGVjdGlvbk1vZGVsLFxuICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5ncmlkLmdldEhlYWRlclJvd0NvdW50KCksXG4gICAgICAgICAgICBmaWx0ZXJlZERhdGEgPSB0aGlzLmdldEZpbHRlcmVkRGF0YSgpO1xuXG4gICAgICAgIHNlbGVjdGlvbk1vZGVsLmNsZWFyUm93U2VsZWN0aW9uKCk7XG5cbiAgICAgICAgdGhpcy5zZWxlY3RlZERhdGEuZm9yRWFjaChmdW5jdGlvbihkYXRhUm93KSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBmaWx0ZXJlZERhdGEuaW5kZXhPZihkYXRhUm93KTtcbiAgICAgICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uTW9kZWwuc2VsZWN0Um93KG9mZnNldCArIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnZXREYXRhU291cmNlTmFtZShuYW1lKSB7XG4gICAgbmFtZSA9IGFuYWx5dGljc1tuYW1lXS5wcm90b3R5cGUuJCRDTEFTU19OQU1FIHx8IG5hbWU7XG4gICAgcmV0dXJuIG5hbWUucmVwbGFjZSgvXkRhdGEoU291cmNlfE5vZGUpLywgJycpLnRvTG93ZXJDYXNlKCkgfHwgJ3NvdXJjZSc7XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSBKU09OO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBEYXRhTW9kZWw6IHJlcXVpcmUoJy4vRGF0YU1vZGVsJyksIC8vIGFic3RyYWN0IGJhc2UgY2xhc3NcbiAgICBEZWZhdWx0OiByZXF1aXJlKCcuL0RlZmF1bHQnKSxcbiAgICBJbk1lbW9yeTogcmVxdWlyZSgnLi9Jbk1lbW9yeScpLFxuICAgIEpTT046IHJlcXVpcmUoJy4vSlNPTicpXG59OyIsIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBMUlVDYWNoZSA9IHJlcXVpcmUoJ2xydS1jYWNoZScpO1xuXG5cbi8qKlxuICogVGhpcyBtb2R1bGUgbGlzdHMgdGhlIHByb3BlcnRpZXMgdGhhdCBjYW4gYmUgc2V0IG9uIGEge0BsaW5rIEh5cGVyZ3JpZH0gYWxvbmcgd2l0aCB0aGVpciBkZWZhdWx0IHZhbHVlcy5cbiAqIEVkaXQgdGhpcyBmaWxlIHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0cy5cbiAqIEBtb2R1bGUgZGVmYXVsdHNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICAgIC8qKlxuICAgICAqIFRoZSBmb250IGZvciBkYXRhIGNlbGxzLlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge2Nzc0ZvbnR9XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgbm9EYXRhTWVzc2FnZTogJ25vIGRhdGEgdG8gZGlzcGxheScsXG5cblxuICAgIC8qKlxuICAgICAqIFRoZSBmb250IGZvciBkYXRhIGNlbGxzLlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge2Nzc0ZvbnR9XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgZm9udDogJzEzcHggVGFob21hLCBHZW5ldmEsIHNhbnMtc2VyaWYnLFxuXG4gICAgLyoqXG4gICAgICogRm9udCBjb2xvciBmb3IgZGF0YSBjZWxscy5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgY29sb3I6ICdyZ2IoMjUsIDI1LCAyNSknLFxuXG4gICAgLyoqXG4gICAgICogQmFja2dyb3VuZCBjb2xvciBmb3IgZGF0YSBjZWxscy5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgYmFja2dyb3VuZENvbG9yOiAncmdiKDI0MSwgMjQxLCAyNDEpJyxcblxuICAgIC8qKlxuICAgICAqIEZvbnQgc3R5bGUgZm9yIHNlbGVjdGVkIGNlbGwocykuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIGZvcmVncm91bmRTZWxlY3Rpb25Gb250OiAnYm9sZCAxM3B4IFRhaG9tYSwgR2VuZXZhLCBzYW5zLXNlcmlmJyxcblxuICAgIC8qKlxuICAgICAqIEZvbnQgY29sb3IgZm9yIHNlbGVjdGVkIGNlbGwocykuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIGZvcmVncm91bmRTZWxlY3Rpb25Db2xvcjogJ3JnYigwLCAwLCAxMjgpJyxcbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHNvcnRPbkhpZGRlbkNvbHVtbnM6IHRydWUsXG4gICAgLyoqXG4gICAgICogQmFja2dyb3VuZCBjb2xvciBmb3Igc2VsZWN0ZWQgY2VsbChzKS5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgYmFja2dyb3VuZFNlbGVjdGlvbkNvbG9yOiAncmdiYSgxNDcsIDE4NSwgMjU1LCAwLjYyNSknLFxuXG5cbiAgICAvKioqKioqKioqKiBTRUNUSU9OOiBDT0xVTU4gSEVBREVSIENPTE9SUyAqKioqKioqKioqL1xuXG4gICAgLy8gSU1QT1JUQU5UIENBVkVBVDogVGhlIGNvZGUgaXMgaW5jb25zaXN0ZW50IHJlZ2FyZGluZyB0aGUgdGVybWlub2xvZ3kuIElzIHRoZSBcImNvbHVtbiBoZWFkZXJcIiBzZWN0aW9uIF90aGUgcm93XyBvZiBjZWxscyBhdCB0aGUgdG9wICh0aGF0IGFjdCBhcyBoZWFkZXJzIGZvciBlYWNoIGNvbHVtbikgb3IgaXMgaXQgX3RoZSBjb2x1bW5fIG9mIGNlbGxzICh0aGF0IGFjdCBhcyBoZWFkZXJzIGZvciBlYWNoIHJvdyk/IE9oIG15LlxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Y3NzRm9udH1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBjb2x1bW5IZWFkZXJGb250OiAnMTJweCBUYWhvbWEsIEdlbmV2YSwgc2Fucy1zZXJpZicsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtjc3NDb2xvcn1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBjb2x1bW5IZWFkZXJDb2xvcjogJ3JnYigyNSwgMjUsIDI1KScsXG5cbiAgICAvKipcbiAgICAgKiBGb250IHN0eWxlIGZvciBzZWxlY3RlZCBjb2x1bW5zJyBoZWFkZXJzLlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBjb2x1bW5IZWFkZXJGb3JlZ3JvdW5kU2VsZWN0aW9uRm9udDogJ2JvbGQgMTJweCBUYWhvbWEsIEdlbmV2YSwgc2Fucy1zZXJpZicsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtjc3NDb2xvcn1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBjb2x1bW5IZWFkZXJCYWNrZ3JvdW5kQ29sb3I6ICdyZ2IoMjIzLCAyMjcsIDIzMiknLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Y3NzQ29sb3J9XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgY29sdW1uSGVhZGVyRm9yZWdyb3VuZFNlbGVjdGlvbkNvbG9yOiAncmdiKDgwLCA4MCwgODApJyxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge2Nzc0NvbG9yfVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIGNvbHVtbkhlYWRlckJhY2tncm91bmRTZWxlY3Rpb25Db2xvcjogJ3JnYmEoMjU1LCAyMjAsIDk3LCAwLjQ1KScsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtjc3NDb2xvcn1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBjb2x1bW5IZWFkZXJGb3JlZ3JvdW5kQ29sdW1uU2VsZWN0aW9uQ29sb3I6ICdyZ2IoMjUsIDI1LCAyNSknLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Y3NzQ29sb3J9XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgY29sdW1uSGVhZGVyQmFja2dyb3VuZENvbHVtblNlbGVjdGlvbkNvbG9yOiAncmdiKDI1NSwgMTgwLCAwKScsXG5cblxuICAgIC8qKioqKioqKioqIFNFQ1RJT046IFJPVyBIRUFERVIgQ09MT1JTICoqKioqKioqKiovXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtjc3NGb250fVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHJvd0hlYWRlckZvbnQ6ICcxMnB4IFRhaG9tYSwgR2VuZXZhLCBzYW5zLXNlcmlmJyxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge2Nzc0NvbG9yfVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHJvd0hlYWRlckNvbG9yOiAncmdiKDI1LCAyNSwgMjUpJyxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge2Nzc0NvbG9yfVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHJvd0hlYWRlckJhY2tncm91bmRDb2xvcjogJ3JnYigyMjMsIDIyNywgMjMyKScsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtjc3NDb2xvcn1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICByb3dIZWFkZXJGb3JlZ3JvdW5kU2VsZWN0aW9uQ29sb3I6ICdyZ2IoODAsIDgwLCA4MCknLFxuXG4gICAgLyoqXG4gICAgICogRm9udCBzdHlsZSBmb3Igc2VsZWN0ZWQgcm93cycgaGVhZGVycy5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgcm93SGVhZGVyRm9yZWdyb3VuZFNlbGVjdGlvbkZvbnQ6ICdib2xkIDEycHggVGFob21hLCBHZW5ldmEsIHNhbnMtc2VyaWYnLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Y3NzQ29sb3J9XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgcm93SGVhZGVyQmFja2dyb3VuZFNlbGVjdGlvbkNvbG9yOiAncmdiYSgyNTUsIDIyMCwgOTcsIDAuNDUpJyxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge2Nzc0NvbG9yfVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHJvd0hlYWRlckZvcmVncm91bmRSb3dTZWxlY3Rpb25Db2xvcjogJ3JnYigyNSwgMjUsIDI1KScsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtjc3NDb2xvcn1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICByb3dIZWFkZXJCYWNrZ3JvdW5kUm93U2VsZWN0aW9uQ29sb3I6ICdyZ2IoMjU1LCAxODAsIDApJyxcblxuXG4gICAgLyoqKioqKioqKiogU0VDVElPTjogRklMVEVSIFJPVyBDT0xPUlMgKioqKioqKioqKi9cblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge2Nzc0ZvbnR9XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgZmlsdGVyRm9udDogJzEycHggVGFob21hLCBHZW5ldmEsIHNhbnMtc2VyaWYnLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Y3NzQ29sb3J9XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgZmlsdGVyQ29sb3I6ICdyZ2IoMjUsIDI1LCAyNSknLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Y3NzQ29sb3J9XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgZmlsdGVyQmFja2dyb3VuZENvbG9yOiAnd2hpdGUnLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Y3NzQ29sb3J9XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgZmlsdGVyRm9yZWdyb3VuZFNlbGVjdGlvbkNvbG9yOiAncmdiKDI1LCAyNSwgMjUpJyxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge2Nzc0NvbG9yfVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIGZpbHRlckJhY2tncm91bmRTZWxlY3Rpb25Db2xvcjogJ3JnYigyNTUsIDIyMCwgOTcpJyxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge2Nzc0NvbG9yfVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIGZpbHRlckNlbGxCb3JkZXJTdHlsZTogJ3JnYmEoMCwwLDAsMC44KScsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgZmlsdGVyQ2VsbEJvcmRlclRoaWNrbmVzczogMC40LFxuICAgIC8qKioqKioqKioqIFNFQ1RJT046IFRSRUUgQ09MVU1OIENPTE9SUyAqKioqKioqKioqL1xuICAgIC8vIFRoZSBcInRyZWUgY29sdW1uXCIgY29udGFpbnMgdGhlIGhpZXJhcmNoaWNhbCBkcmlsbC1kb3duIGNvbnRyb2xzLlxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Y3NzRm9udH1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0cmVlQ29sdW1uRm9udDogJzEycHggVGFob21hLCBHZW5ldmEsIHNhbnMtc2VyaWYnLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Y3NzQ29sb3J9XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgdHJlZUNvbHVtbkNvbG9yOiAncmdiKDI1LCAyNSwgMjUpJyxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge2Nzc0NvbG9yfVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRyZWVDb2x1bW5CYWNrZ3JvdW5kQ29sb3I6ICdyZ2IoMjIzLCAyMjcsIDIzMiknLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Y3NzQ29sb3J9XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgdHJlZUNvbHVtbkZvcmVncm91bmRTZWxlY3Rpb25Db2xvcjogJ3JnYigyNSwgMjUsIDI1KScsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtjc3NDb2xvcn1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0cmVlQ29sdW1uQmFja2dyb3VuZFNlbGVjdGlvbkNvbG9yOiAncmdiYSgyNTUsIDIyMCwgOTcsIDAuNDUpJyxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge2Nzc0NvbG9yfVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRyZWVDb2x1bW5Gb3JlZ3JvdW5kQ29sdW1uU2VsZWN0aW9uQ29sb3I6ICdyZ2IoMjUsIDI1LCAyNSknLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Y3NzQ29sb3J9XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgdHJlZUNvbHVtbkJhY2tncm91bmRDb2x1bW5TZWxlY3Rpb25Db2xvcjogJ3JnYigyNTUsIDE4MCwgMCknLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Y3NzQ29sb3J9XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgYmFja2dyb3VuZENvbG9yMjogJ3JnYigyMDEsIDIwMSwgMjAxKScsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgdm9mZnNldDogMCxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBzY3JvbGxiYXJIb3Zlck92ZXI6ICd2aXNpYmxlJyxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBzY3JvbGxiYXJIb3Zlck9mZjogJ2hpZGRlbicsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHNjcm9sbGluZ0VuYWJsZWQ6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgdlNjcm9sbGJhckNsYXNzUHJlZml4OiAnJyxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBoU2Nyb2xsYmFyQ2xhc3NQcmVmaXg6ICcnLFxuXG4gICAgLy90aGVzZSB1c2VkIHRvIGJlIGluIHRoZSBjb25zdGFudHMgZWxlbWVudFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIGZpeGVkUm93QWxpZ246ICdjZW50ZXInLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIGZpeGVkQ29sQWxpZ246ICdjZW50ZXInLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIGNlbGxQYWRkaW5nOiA1LFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBncmlkTGluZXNIOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBncmlkTGluZXNWOiB0cnVlLFxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgZ3JpZExpbmVzVk92ZXJmbG93OiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge2Nzc0NvbG9yfVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIGxpbmVDb2xvcjogJ3JnYigxOTksIDE5OSwgMTk5KScsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgbGluZVdpZHRoOiAwLjQsXG5cblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBkZWZhdWx0Um93SGVpZ2h0OiAxNSxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBkZWZhdWx0Q29sdW1uV2lkdGg6IDEwMCxcblxuICAgIC8vZm9yIGltbWVkaWF0ZSBwYWludGluZywgc2V0IHRoZXNlIHZhbHVlcyB0byAwLCB0cnVlIHJlc3BlY3RpdmVseVxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHJlcGFpbnRJbnRlcnZhbFJhdGU6IDYwLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICByZXBhaW50SW1tZWRpYXRlbHk6IGZhbHNlLFxuXG4gICAgLy9lbmFibGUgb3IgZGlzYWJsZSBkb3VibGUgYnVmZmVyaW5nXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHVzZUJpdEJsaXQ6IGZhbHNlLFxuXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHVzZUhpRFBJOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHQgWydhbHQnLCAnZXNjJ11cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIGVkaXRvckFjdGl2YXRpb25LZXlzOiBbJ2FsdCcsICdlc2MnXSxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgcmVhZE9ubHk6IGZhbHNlLFxuXG4gICAgLy8gaW5oZXJpdGVkIGJ5IGNlbGwgcmVuZGVyZXJzXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdCBgZ2V0VGV4dFdpZHRoYFxuICAgICAqIEB0eXBlIHtmdW5jdGlvbn1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBnZXRUZXh0V2lkdGg6IGdldFRleHRXaWR0aCxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0IGBnZXRUZXh0SGVpZ2h0YFxuICAgICAqIEB0eXBlIHtmdW5jdGlvbn1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBnZXRUZXh0SGVpZ2h0OiBnZXRUZXh0SGVpZ2h0LFxuXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgZml4ZWRDb2x1bW5Db3VudDogMCxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBmaXhlZFJvd0NvdW50OiAwLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIGhlYWRlckNvbHVtbkNvdW50OiAwLFxuXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHNob3dSb3dOdW1iZXJzOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBzaG93VHJlZUNvbHVtbjogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgc2hvd0hlYWRlclJvdzogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgc2hvd0ZpbHRlclJvdzogdHJ1ZSxcblxuXG4gICAgLyoqIENsaWNraW5nIGluIGEgY2VsbCBcInNlbGVjdHNcIiBpdDsgaXQgaXMgYWRkZWQgdG8gdGhlIHNlbGVjdCByZWdpb24gYW5kIHJlcGFpbnRlZCB3aXRoIFwiY2VsbCBzZWxlY3Rpb25cIiBjb2xvcnMuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBjZWxsU2VsZWN0aW9uOiB0cnVlLFxuXG4gICAgLyoqIENsaWNraW5nIGluIGEgcm93IGhlYWRlciAobGVmdG1vc3QgY29sdW1uKSBcInNlbGVjdHNcIiB0aGUgcm93OyB0aGUgZW50aXJlIHJvdyBpcyBhZGRlZCB0byB0aGUgc2VsZWN0IHJlZ2lvbiBhbmQgcmVwYWludGVkIHdpdGggXCJyb3cgc2VsZWN0aW9uXCIgY29sb3JzLlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgY29sdW1uU2VsZWN0aW9uOiB0cnVlLFxuXG4gICAgLyoqIENsaWNraW5nIGluIGEgY29sdW1uIGhlYWRlciAodG9wIHJvdykgXCJzZWxlY3RzXCIgdGhlIGNvbHVtbjsgdGhlIGVudGlyZSBjb2x1bW4gaXMgYWRkZWQgdG8gdGhlIHNlbGVjdCByZWdpb24gYW5kIHJlcGFpbnRlZCB3aXRoIFwiY29sdW1uIHNlbGVjdGlvblwiIGNvbG9ycy5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHJvd1NlbGVjdGlvbjogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgc2luZ2xlUm93U2VsZWN0aW9uTW9kZTogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge2Nzc0NvbG9yfVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHNlbGVjdGlvblJlZ2lvbk92ZXJsYXlDb2xvcjogJ3JnYmEoMCwgMCwgNDgsIDAuMiknLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHNlbGVjdGlvblJlZ2lvbk91dGxpbmVDb2xvcjogJ2JsYWNrJyxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgY29sdW1uQXV0b3NpemluZzogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgcm93TnVtYmVyQXV0b3NpemluZzogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgaGVhZGVyVGV4dFdyYXBwaW5nOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgcm93UmVzaXplOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgZWRpdGFibGU6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIGVkaXRPbkRvdWJsZUNsaWNrOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIGRvdWJsZUNsaWNrRGVsYXk6IDMyNSxcblxuICAgIC8qKlxuICAgICAqIEdyaWQtbGV2ZWwgcHJvcGVydHkuXG4gICAgICogV2hlbiB1c2VyIHByZXNzZXMgYSBwcmludGFibGUgY2hhcmFjdGVyIGtleSBfb3JfIEJBQ0tTUEFDRSBfb3JfIERFTEVURTpcbiAgICAgKiAxLiBBY3RpdmF0ZSBjZWxsIGVkaXRvciBvbiBjdXJyZW50IGNlbGwgKGkuZS4sIG9yaWdpbiBvZiBtb3N0IHJlY2VudCBzZWxlY3Rpb24pLlxuICAgICAqIDIuIElmIGNlbGwgZWRpdG9yIGlzIGEgdGV4dCBlZGl0b3I6XG4gICAgICogICAgMS4gUmVwbGFjZSBjdXJyZW50IHZhbHVlIHdpdGggdGhlIGNoYXJhY3RlciB0aGUgdXNlciB0eXBlZDsgb3JcbiAgICAgKiAgICAyLiBDbGVhciBpdCBvbiBCQUNLU1BBQ0UsIERFTEVURSwgb3Igb3RoZXIgaW52YWxpZCBjaGFyYWN0ZXIgKF9lLmcuXyB3aGVuIHVzZXIgdHlwZXMgYSBsZXR0ZXIgYnV0IHRoZSBjZWxsIGVkaXRvciBvbmx5IGFjY2VwdHMgZGlnaXRzKS5cbiAgICAgKlxuICAgICAqID4gSW4gaW52b2tlZCwgdXNlciBoYXMgdGhlIG9wdGlvbiB0byBiYWNrIG91dCBieSBwcmVzc2luZyB0aGUgRVNDQVBFIGtleS5cbiAgICAgKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgZWRpdE9uS2V5ZG93bjogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgY2hlY2tib3hPbmx5Um93U2VsZWN0aW9uczogZmFsc2UsXG5cbiAgICAvKiogQHN1bW1hcnkgTmFtZSBvZiBhIGZvcm1hdHRlciBmb3IgY2VsbCB0ZXh0LlxuICAgICAqIFRoZSBkZWZhdWx0IChgdW5kZWZpbmVkYCkgZmFsbHMgYmFjayB0byBgY29sdW1uLnR5cGVgLlxuICAgICAqIFRoZSB2YWx1ZSBgbnVsbGAgZG9lcyBubyBmb3JtYXR0aW5nLlxuICAgICAqIEBkZWZhdWx0IHVuZGVmaW5lZFxuICAgICAqIEB0eXBlIHt1bmRlZmluZWR8bnVsbHxzdHJpbmd9XG4gICAgICogQHR1dG9yaWFsIGxvY2FsaXphdGlvblxuICAgICAqL1xuICAgIGZvcm1hdDogdW5kZWZpbmVkLFxuXG4gICAgLyoqIEBzdW1tYXJ5IE5hbWUgb2YgYSBjZWxsIGVkaXRvciBmcm9tIHRoZSB7QGxpbmsgbW9kdWxlOmNlbGxFZGl0b3JzfGNlbGxFZGl0b3JzIEFQSX0uLlxuICAgICAqIEBkZXNjIE5vdCBlZGl0YWJsZSBpZiBuYW1lZCBlZGl0b3IgaXMgZG9lcyBub3QgZXhpc3QuXG4gICAgICogQGRlZmF1bHQgdW5kZWZpbmVkXG4gICAgICogQHR5cGUge3VuZGVmaW5lZHxudWxsfHN0cmluZ31cbiAgICAgKiBAdHV0b3JpYWwgY2VsbC1lZGl0b3JzXG4gICAgICovXG4gICAgZWRpdG9yOiB1bmRlZmluZWQsXG5cbiAgICAvKipcbiAgICAgKiBOYW1lIG9mIGNlbGwgcmVuZGVyZXIgZnJvbSB0aGUge0BsaW5rIG1vZHVsZTpjZWxsUmVuZGVyZXJzfGNlbGxSZW5kZXJlcnMgQVBJfS5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgcmVuZGVyZXI6ICdTaW1wbGVDZWxsJyxcblxuICAgIC8qKioqKioqKioqIEhPVkVSIENPTE9SUyAqKioqKioqKioqL1xuXG4gICAgLyoqIEB0eXBlZGVmIGhvdmVyQ29sb3JzXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbZW5hYmxlPWZhbHNlXSAtIGBmYWxzZWAgbWVhbnMgbm90IGhpbGl0ZSBvbiBob3ZlclxuICAgICAqIEBwcm9wZXJ0eSB7Y3NzQ29sb3J9IGJhY2tncm91bmRDb2xvciAtIGNlbGwsIHJvdywgb3IgY29sdW1uIGJhY2tncm91bmQgY29sb3IuIEFscGhhIGNoYW5uZWwgd2lsbCBiZSByZXNwZWN0ZWQgYW5kIGlmIGdpdmVuIHdpbGwgYmUgcGFpbnRlZCBvdmVyIHRoZSBjZWxscyBwcmVkZXRlcm1pbmVkIGNvbG9yLlxuICAgICAqIEBwcm9wZXJ0eSB7Y3NzQ29sb3J9IFtoZWFkZXIuYmFja2dyb3VuZENvbG9yPWJhY2tncm91bmRDb2xvcl0gLSBmb3IgY29sdW1ucyBhbmQgcm93cywgdGhpcyBpcyB0aGUgYmFja2dyb3VuZCBjb2xvciBvZiB0aGUgY29sdW1uIG9yIHJvdyBcImhhbmRsZVwiIChoZWFkZXIgcm93cyBvciBjb2x1bW5zLCByZXNwZWN0aXZlbHkpLiAoTm90IHVzZWQgZm9yIGNlbGxzLilcbiAgICAgKi9cblxuICAgIC8qKiBPbiBtb3VzZSBob3Zlciwgd2hldGhlciB0byByZXBhaW50IHRoZSBjZWxsIGJhY2tncm91bmQgYW5kIGhvdy5cbiAgICAgKiBAdHlwZSB7aG92ZXJDb2xvcnN9XG4gICAgICogQGRlZmF1bHQgJ3sgZW5hYmxlZDogdHJ1ZSwgYmFja2dyb3VuZDogcmdiYSgxNjAsIDE2MCwgNDAsIDAuMzApIH0nXG4gICAgICovXG4gICAgaG92ZXJDZWxsSGlnaGxpZ2h0OiB7XG4gICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3JnYmEoMTYwLCAxNjAsIDQwLCAwLjQ1KSdcbiAgICB9LFxuXG4gICAgLyoqIE9uIG1vdXNlIGhvdmVyLCB3aGV0aGVyIHRvIHJlcGFpbnQgdGhlIHJvdyBiYWNrZ3JvdW5kIGFuZCBob3cuXG4gICAgICogQHR5cGUge2hvdmVyQ29sb3JzfVxuICAgICAqIEBkZWZhdWx0ICd7IGVuYWJsZWQ6IHRydWUsIGJhY2tncm91bmQ6IHJnYmEoMTAwLCAxMDAsIDI1LCAwLjE1KSB9J1xuICAgICAqL1xuICAgIGhvdmVyUm93SGlnaGxpZ2h0OiB7XG4gICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3JnYmEoMTAwLCAxMDAsIDI1LCAwLjMwKSdcblxuICAgIH0sXG5cbiAgICAvKiogT24gbW91c2UgaG92ZXIsIHdoZXRoZXIgdG8gcmVwYWludCB0aGUgY29sdW1uIGJhY2tncm91bmQgYW5kIGhvdy5cbiAgICAgKiBAdHlwZSB7aG92ZXJDb2xvcnN9XG4gICAgICogQGRlZmF1bHQgJ3sgZW5hYmxlZDogdHJ1ZSwgYmFja2dyb3VuZDogcmdiYSg2MCwgNjAsIDE1LCAwLjE1KSB9J1xuICAgICAqL1xuICAgIGhvdmVyQ29sdW1uSGlnaGxpZ2h0OiB7XG4gICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3JnYmEoNjAsIDYwLCAxNSwgMC4xNSknXG4gICAgfSxcblxuXG4gICAgLyoqIERpc3BsYXkgY2VsbCBmb250IHdpdGggdW5kZXItc2NvcmUgbGluZSBkcmF3biBvdmVyIGl0LlxuICAgICAqID4gSW1wbGVtZW50YXRpb24gb2YgbGlua3MgcmlnaHQgbm93IGlzIG5vdCBhdXRvbWF0aWM7IHlvdSBtdXN0IGF0dGFjaCBhICdmaW4tY2xpY2snIGxpc3RlbmVyIHRvIHRoZSBoeXBlcmdyaWQgb2JqZWN0LCBldGMuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBsaW5rOiBmYWxzZSxcblxuICAgIC8qKiBEaXNwbGF5IGNlbGwgZm9udCB3aXRoIHN0cmlrZS10aHJvdWdoIGxpbmUgZHJhd24gb3ZlciBpdC5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHN0cmlrZVRocm91Z2g6IGZhbHNlLFxuXG59O1xuXG4vKiogQHR5cGVkZWYge3N0cmluZ30gY3NzQ29sb3JcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL2NvbG9yX3ZhbHVlXG4gKi9cbi8qKiBAdHlwZWRlZiB7c3RyaW5nfSBjc3NGb250XG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9mb250XG4gKi9cblxudmFyIHRleHRXaWR0aENhY2hlID0gbmV3IExSVUNhY2hlKDIwMDApO1xuXG5mdW5jdGlvbiBnZXRUZXh0V2lkdGgoZ2MsIHN0cmluZykge1xuICAgIGlmIChzdHJpbmcgPT09IG51bGwgfHwgc3RyaW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHN0cmluZyA9IHN0cmluZyArICcnO1xuICAgIGlmIChzdHJpbmcubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICB2YXIga2V5ID0gZ2MuZm9udCArIHN0cmluZztcbiAgICB2YXIgd2lkdGggPSB0ZXh0V2lkdGhDYWNoZS5nZXQoa2V5KTtcbiAgICBpZiAoIXdpZHRoKSB7XG4gICAgICAgIHdpZHRoID0gZ2MubWVhc3VyZVRleHQoc3RyaW5nKS53aWR0aDtcbiAgICAgICAgdGV4dFdpZHRoQ2FjaGUuc2V0KGtleSwgd2lkdGgpO1xuICAgIH1cbiAgICByZXR1cm4gd2lkdGg7XG59XG5cbnZhciBmb250RGF0YSA9IHt9O1xuXG5mdW5jdGlvbiBnZXRUZXh0SGVpZ2h0KGZvbnQpIHtcbiAgICB2YXIgcmVzdWx0ID0gZm9udERhdGFbZm9udF07XG5cbiAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICByZXN1bHQgPSB7fTtcblxuICAgICAgICB2YXIgdGV4dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgdGV4dC50ZXh0Q29udGVudCA9ICdIZyc7XG4gICAgICAgIHRleHQuc3R5bGUuZm9udCA9IGZvbnQ7XG5cbiAgICAgICAgdmFyIGJsb2NrID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGJsb2NrLnN0eWxlLmRpc3BsYXkgPSAnaW5saW5lLWJsb2NrJztcbiAgICAgICAgYmxvY2suc3R5bGUud2lkdGggPSAnMXB4JztcbiAgICAgICAgYmxvY2suc3R5bGUuaGVpZ2h0ID0gJzBweCc7XG5cbiAgICAgICAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBkaXYuYXBwZW5kQ2hpbGQodGV4dCk7XG4gICAgICAgIGRpdi5hcHBlbmRDaGlsZChibG9jayk7XG5cbiAgICAgICAgZGl2LnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkaXYpO1xuXG4gICAgICAgIHRyeSB7XG5cbiAgICAgICAgICAgIGJsb2NrLnN0eWxlLnZlcnRpY2FsQWxpZ24gPSAnYmFzZWxpbmUnO1xuXG4gICAgICAgICAgICB2YXIgYmxvY2tSZWN0ID0gYmxvY2suZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICB2YXIgdGV4dFJlY3QgPSB0ZXh0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICAgICAgICByZXN1bHQuYXNjZW50ID0gYmxvY2tSZWN0LnRvcCAtIHRleHRSZWN0LnRvcDtcblxuICAgICAgICAgICAgYmxvY2suc3R5bGUudmVydGljYWxBbGlnbiA9ICdib3R0b20nO1xuICAgICAgICAgICAgcmVzdWx0LmhlaWdodCA9IGJsb2NrUmVjdC50b3AgLSB0ZXh0UmVjdC50b3A7XG5cbiAgICAgICAgICAgIHJlc3VsdC5kZXNjZW50ID0gcmVzdWx0LmhlaWdodCAtIHJlc3VsdC5hc2NlbnQ7XG5cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZGl2KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0LmhlaWdodCAhPT0gMCkge1xuICAgICAgICAgICAgZm9udERhdGFbZm9udF0gPSByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuIiwiLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIExpc3REcmFnb24gPSByZXF1aXJlKCdsaXN0LWRyYWdvbicpO1xuXG52YXIgRGlhbG9nID0gcmVxdWlyZSgnLi9EaWFsb2cnKTtcbnZhciBzdHlsZXNoZWV0ID0gcmVxdWlyZSgnLi4vbGliL3N0eWxlc2hlZXQnKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIERpYWxvZ1xuICovXG52YXIgQ29sdW1uUGlja2VyID0gRGlhbG9nLmV4dGVuZCgnQ29sdW1uUGlja2VyJywge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAtIE1heSBpbmNsdWRlIGBEaWFsb2dgIG9wdGlvbnMuXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oZ3JpZCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgYmVoYXZpb3IgPSBncmlkLmJlaGF2aW9yO1xuXG4gICAgICAgIHRoaXMuZ3JpZCA9IGdyaWQ7XG5cbiAgICAgICAgaWYgKGJlaGF2aW9yLmlzQ29sdW1uUmVvcmRlcmFibGUoKSkge1xuICAgICAgICAgICAgLy8gZ3JhYiB0aGUgbGlzdHMgZnJvbSB0aGUgYmVoYXZpb3JcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRHcm91cHMgPSB7XG4gICAgICAgICAgICAgICAgdGl0bGU6ICdHcm91cHMnLFxuICAgICAgICAgICAgICAgIG1vZGVsczogYmVoYXZpb3IuZ2V0R3JvdXBzKClcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRoaXMuYXZhaWxhYmxlR3JvdXBzID0ge1xuICAgICAgICAgICAgICAgIHRpdGxlOiAnQXZhaWxhYmxlIEdyb3VwcycsXG4gICAgICAgICAgICAgICAgbW9kZWxzOiBiZWhhdmlvci5nZXRBdmFpbGFibGVHcm91cHMoKVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdGhpcy5pbmFjdGl2ZUNvbHVtbnMgPSB7XG4gICAgICAgICAgICAgICAgdGl0bGU6ICdJbmFjdGl2ZSBDb2x1bW5zJyxcbiAgICAgICAgICAgICAgICBtb2RlbHM6IGJlaGF2aW9yLmdldEhpZGRlbkNvbHVtbnMoKS5zb3J0KGNvbXBhcmVCeU5hbWUpXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0aGlzLmFjdGl2ZUNvbHVtbnMgPSB7XG4gICAgICAgICAgICAgICAgdGl0bGU6ICdBY3RpdmUgQ29sdW1ucycsXG4gICAgICAgICAgICAgICAgbW9kZWxzOiBiZWhhdmlvci5nZXRBY3RpdmVDb2x1bW5zKClcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRoaXMuc29ydE9uSGlkZGVuQ29sdW1ucyA9IHRoaXMud2FzU29ydE9uSGlkZGVuQ29sdW1ucyA9IGdyaWQucmVzb2x2ZVByb3BlcnR5KCdzb3J0T25IaWRkZW5Db2x1bW5zJyk7XG5cbiAgICAgICAgICAgIC8vIHBhcnNlICYgYWRkIHRoZSBkcmFnLWFuZC1kcm9wIHN0eWxlc2hlZXQgYWRkZW5kdW1cbiAgICAgICAgICAgIHZhciBzdHlsZXNoZWV0QWRkZW5kdW0gPSBzdHlsZXNoZWV0LmluamVjdCgnbGlzdC1kcmFnb24tYWRkZW5kdW0nKTtcblxuICAgICAgICAgICAgLy8gY3JlYXRlIGRyYWctYW5kLWRyb3Agc2V0cyBmcm9tIHRoZSBsaXN0c1xuICAgICAgICAgICAgdmFyIGxpc3RTZXRzID0gW1xuICAgICAgICAgICAgICAgIG5ldyBMaXN0RHJhZ29uKFtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEdyb3VwcyxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdmFpbGFibGVHcm91cHNcbiAgICAgICAgICAgICAgICBdLCB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFkZCB0aGUgbGlzdC1kcmFnb24tYmFzZSBzdHlsZXNoZWV0IHJpZ2h0IGJlZm9yZSB0aGUgYWRkZW5kdW1cbiAgICAgICAgICAgICAgICAgICAgY3NzU3R5bGVzaGVldFJlZmVyZW5jZUVsZW1lbnQ6IHN0eWxlc2hlZXRBZGRlbmR1bVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIG5ldyBMaXN0RHJhZ29uKFtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmFjdGl2ZUNvbHVtbnMsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlQ29sdW1uc1xuICAgICAgICAgICAgICAgIF0sIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlc2UgbW9kZWxzIGhhdmUgYSBoZWFkZXIgcHJvcGVydHkgYXMgdGhlaXIgbGFiZWxzXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsOiAne2hlYWRlcn0nXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIF07XG5cbiAgICAgICAgICAgIC8vIGFkZCB0aGUgZHJhZy1hbmQtZHJvcCBzZXRzIHRvIHRoZSBkaWFsb2dcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIGxpc3RTZXRzLmZvckVhY2goZnVuY3Rpb24obGlzdFNldCkge1xuICAgICAgICAgICAgICAgIGxpc3RTZXQubW9kZWxMaXN0cy5mb3JFYWNoKGZ1bmN0aW9uKGxpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5hcHBlbmQobGlzdC5jb250YWluZXIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvL0xpc3RlbiB0byB0aGUgdmlzaWJsZSBjb2x1bW4gY2hhbmdlc1xuICAgICAgICAgICAgbGlzdFNldHNbMV0ubW9kZWxMaXN0c1sxXS5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2xpc3RjaGFuZ2VkJywgZnVuY3Rpb24oZSl7XG4gICAgICAgICAgICAgICAgZ3JpZC5maXJlU3ludGhldGljT25Db2x1bW5zQ2hhbmdlZEV2ZW50KCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhpcy5zb3J0T25IaWRkZW5Db2x1bW5zID0gdGhpcy5ncmlkLnJlc29sdmVQcm9wZXJ0eSgnc29ydE9uSGlkZGVuQ29sdW1ucycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgZGl2LnN0eWxlLnRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICAgICAgZGl2LnN0eWxlLm1hcmdpblRvcCA9ICcyZW0nO1xuICAgICAgICAgICAgZGl2LmlubmVySFRNTCA9ICdUaGUgc2VsZWN0aW9uIG9mIHZpc2libGUgY29sdW1ucyBpbiB0aGUgZ3JpZCBtYXkgbm90IGJlIGNoYW5nZWQuJztcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kKGRpdik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGQgY2hlY2tib3ggdG8gY29udHJvbCBwYW5lbCBmb3Igc29ydGluZyBvbiBoaWRkZW4gZmllbGRzXG4gICAgICAgIHZhciBsYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJyk7XG4gICAgICAgIGxhYmVsLmlubmVySFRNTCA9ICc8aW5wdXQgdHlwZT1cImNoZWNrYm94XCI+IEFsbG93IHNvcnRpbmcgb24gaGlkZGVuIGNvbHVtbnMnO1xuICAgICAgICBsYWJlbC5zdHlsZS5mb250V2VpZ2h0ID0gJ25vcm1hbCc7XG4gICAgICAgIGxhYmVsLnN0eWxlLm1hcmdpblJpZ2h0ID0gJzJlbSc7XG5cbiAgICAgICAgdmFyIGNoZWNrYm94ID0gbGFiZWwucXVlcnlTZWxlY3RvcignaW5wdXQnKTtcbiAgICAgICAgY2hlY2tib3guY2hlY2tlZCA9IHRoaXMuc29ydE9uSGlkZGVuQ29sdW1ucztcbiAgICAgICAgY2hlY2tib3guYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbihlKXtcbiAgICAgICAgICAgIHNlbGYuc29ydE9uSGlkZGVuQ29sdW1ucyA9IGNoZWNrYm94LmNoZWNrZWQ7XG4gICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgcGFuZWwgPSB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoJy5oeXBlcmdyaWQtZGlhbG9nLWNvbnRyb2wtcGFuZWwnKTtcbiAgICAgICAgcGFuZWwuaW5zZXJ0QmVmb3JlKGxhYmVsLCBwYW5lbC5maXJzdENoaWxkKTtcblxuICAgICAgICAvLyBhZGQgdGhlIGRpYWxvZyB0byB0aGUgRE9NXG4gICAgICAgIHRoaXMub3BlbihvcHRpb25zLmNvbnRhaW5lcik7XG4gICAgfSxcblxuICAgIG9uQ2xvc2VkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlQ29sdW1ucykge1xuICAgICAgICAgICAgdmFyIGJlaGF2aW9yID0gdGhpcy5ncmlkLmJlaGF2aW9yLFxuICAgICAgICAgICAgICAgIGNvbHVtbnMgPSBiZWhhdmlvci5jb2x1bW5zLFxuICAgICAgICAgICAgICAgIHRyZWUgPSBjb2x1bW5zWzBdO1xuXG4gICAgICAgICAgICAvLyBUT0RPOiBicmVha2luZyBlbmNhcHN1bGF0aW9uOyBzaG91bGQgYmUgdXNpbmcgc2V0dGVycyBhbmQgZ2V0dGVycyBvbiB0aGUgYmVoYXZpb3JcbiAgICAgICAgICAgIGNvbHVtbnMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIGlmICh0cmVlICYmIHRyZWUubGFiZWwgPT09ICdUcmVlJykge1xuICAgICAgICAgICAgICAgIGNvbHVtbnMucHVzaCh0cmVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYWN0aXZlQ29sdW1ucy5tb2RlbHMuZm9yRWFjaChmdW5jdGlvbihjb2x1bW4pIHtcbiAgICAgICAgICAgICAgICBjb2x1bW5zLnB1c2goY29sdW1uKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIGdyb3VwQnlzID0gdGhpcy5zZWxlY3RlZEdyb3Vwcy5tb2RlbHMubWFwKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZS5pZDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYmVoYXZpb3IuZGF0YU1vZGVsLnNldEdyb3Vwcyhncm91cEJ5cyk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnNvcnRPbkhpZGRlbkNvbHVtbnMgIT09IHRoaXMud2FzU29ydE9uSGlkZGVuQ29sdW1ucykge1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JpZC5hZGRQcm9wZXJ0aWVzKHsgc29ydE9uSGlkZGVuQ29sdW1uczogdGhpcy5zb3J0T25IaWRkZW5Db2x1bW5zIH0pO1xuICAgICAgICAgICAgICAgIGJlaGF2aW9yLnNvcnRDaGFuZ2VkKHRoaXMuaW5hY3RpdmVDb2x1bW5zLm1vZGVscyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJlaGF2aW9yLmNoYW5nZWQoKTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5mdW5jdGlvbiBjb21wYXJlQnlOYW1lKGEsIGIpIHtcbiAgICBhID0gYS5oZWFkZXIudG9TdHJpbmcoKS50b1VwcGVyQ2FzZSgpO1xuICAgIGIgPSBiLmhlYWRlci50b1N0cmluZygpLnRvVXBwZXJDYXNlKCk7XG4gICAgcmV0dXJuIGEgPCBiID8gLTEgOiBhID4gYiA/ICsxIDogMDtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IENvbHVtblBpY2tlcjtcbiIsIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBhdXRvbWF0ID0gcmVxdWlyZSgnYXV0b21hdCcpO1xuXG52YXIgQmFzZSA9IHJlcXVpcmUoJy4uL2xpYi9CYXNlJyk7XG52YXIgbWFya3VwID0gcmVxdWlyZSgnLi4vLi4vaHRtbCcpO1xudmFyIGltYWdlcyA9IHJlcXVpcmUoJy4uLy4uL2ltYWdlcycpO1xudmFyIGVsZm9yID0gcmVxdWlyZSgnLi4vbGliL2VsZm9yJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbmQgc2VydmljZXMgYSBET00gZWxlbWVudCB1c2VkIGFzIGEgY250YWluZXIgZm9yIGEgZGlhbG9nLiBUaGUgc3RhbmRhcmQgYG1hcmt1cC5kaWFsb2dgIGlzIHNpbXBseSBhIGRpdiB3aXRoIGEgX2NvbnRyb2wgcGFuZWxfIGNvbnRhaW5pbmcgYSBjbG9zZSBib3ggYW5kIGEgc2V0dGluZ3MgZ2VhciBpY29uLlxuICpcbiAqIFlvdSBjYW4gc3VwcGx5IGFuIGFsdGVybmF0aXZlIGRpYWxvZyB0ZW1wbGF0ZS4gVGhlIGludGVyZmFjZSBpczpcbiAqICogQ2xhc3MgbmFtZSBgaHlwZXJncmlkLWRpYWxvZ2AuXG4gKiAqIEF0IGxlYXN0IG9uZSBjaGlsZCBlbGVtZW50LiBDb250ZW50IHdpbGwgYmUgaW5zZXJ0ZWQgYmVmb3JlIHRoaXMgZmlyc3QgY2hpbGQuXG4gKiAqIFR5cGljYWxseSBjb250YWlucyBhIGNsb3NlLWJveCBlbGVtZW50IHdpdGggY2xhc3MgbmFtZSBgaHlwZXJncmlkLWRpYWxvZy1jbG9zZWAgYW5kIHBvc3NpYmx5IG90aGVyIGNvbnRyb2xzIHdpdGggY2xhc3MgbmFtZSBgaHlwZXJncmlkLWRpYWxvZy14eHh4YCAod2hlcmUgX3h4eHhfIGlzIGEgdW5pcXVlIG5hbWUgZm9yIHlvdXIgY29udHJvbCkuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBEaWFsb2cgPSBCYXNlLmV4dGVuZCgnRGlhbG9nJywge1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGJhc2ljIGRpYWxvZyBib3ggaW4gYHRoaXMuZWxgLlxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfGZ1bmN0aW9ufSBbb3B0aW9ucy5kaWFsb2dUZW1wbGF0ZV0gLSBBbiBhbHRlcm5hdGUgZGlhbG9nIHRlbXBsYXRlLiBUaGUgbGFzdCBjaGlsZCBlbGVtZW50IG11c3QgYmUgdGhlIFwiY29udHJvbCBwYW5lbC5cIlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuc2V0dGluZ3M9dHJ1ZV0gLSBDb250cm9sIGJveCBoYXMgc2V0dGluZ3MgaWNvbi4gKFNldHRpbmdzIGljb24gbXVzdCBiZSBpbmNsdWRlZCBpbiB0ZW1wbGF0ZS4gVGhpcyBvcHRpb24gcmVtb3ZlcyBpdC4gVGhhdCBpcywgaWYgZXhwbGljaXRseSBgZmFsc2VgIF9hbmRfIHRoZXJlIGlzIGEgc2V0dGluZ3MgY29udHJvbCwgcmVtb3ZlIGl0LilcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xib29sZWFufSBbb3B0aW9ucy5iYWNrZ3JvdW5kSW1hZ2U9aW1hZ2VzLmRpYWxvZy5zcmNdIC0gQSBVUkkgZm9yIGEgYmFja2dyb3VuZCBpbWFnZS4gSWYgZXhwbGljaXRseSBgZmFsc2VgLCBiYWNrZ3JvdW5kIGltYWdlIGlzIHN1cHByZXNzZWQuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gW3Rlcm1pbmF0ZV1cbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihncmlkLCBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIHRoaXMuZ3JpZCA9IGdyaWQ7XG5cbiAgICAgICAgLy8gY3JlYXRlIHRoZSBiYWNrZHJvcDsgaXQgaXMgYWJzb2x1dGUtcG9zaXRpb25lZCBhbmQgc3RyZXRjaGVkXG4gICAgICAgIHRoaXMuZWwgPSBhdXRvbWF0LmZpcnN0Q2hpbGQob3B0aW9ucy5kaWFsb2dUZW1wbGF0ZSB8fCBtYXJrdXAuZGlhbG9nLCBvcHRpb25zLmRpYWxvZ1JlcGxhY2VtZW50cyk7XG5cbiAgICAgICAgdGhpcy5vcmlnaW5hbEZpcnN0Q2hpbGQgPSB0aGlzLmVsLmZpcnN0RWxlbWVudENoaWxkO1xuXG4gICAgICAgIGlmIChvcHRpb25zLnNldHRpbmdzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdmFyIHNldHRpbmdzID0gdGhpcy5lbC5xdWVyeVNlbGVjdG9yKCcuaHlwZXJncmlkLWRpYWxvZy1zZXR0aW5ncycpO1xuICAgICAgICAgICAgaWYgKHNldHRpbmdzKSB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3MucmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgYmFja2dyb3VuZCBpbWFnZVxuICAgICAgICBpZiAob3B0aW9ucy5iYWNrZ3JvdW5kSW1hZ2UgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aGlzLmVsLnN0eWxlLmJhY2tncm91bmRJbWFnZSA9ICd1cmwoXFwnJyArIChvcHRpb25zLmJhY2tncm91bmRJbWFnZSB8fCBpbWFnZXMuZGlhbG9nLnNyYykgKyAnXFwnKSc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBsaXN0ZW4gZm9yIGNsaWNrc1xuICAgICAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgb25DbGljay5iaW5kKHRoaXMpKTtcblxuICAgICAgICBpZiAob3B0aW9ucy50ZXJtaW5hdGUpIHtcbiAgICAgICAgICAgIHRoaXMudGVybWluYXRlID0gb3B0aW9ucy50ZXJtaW5hdGU7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgQWRkcyBET00gYE5vZGVgcyB0byBkaWFsb2cuXG4gICAgICogQGRlc2MgSW5wdXQgY2FuIGJlIG5vZGVzIG9yIGEgdGVtcGxhdGUgZnJvbSB3aGljaCB0byBjcmVhdGUgbm9kZXMuIFRoZSBub2RlcyBhcmUgaW5zZXJ0ZWQgaW50byB0aGUgZGlhbG9nJ3MgRE9NIChgdGhpcy5lbGApLCByaWdodCBiZWZvcmUgdGhlIFwiY29udHJvbCBwYW5lbC5cIlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfGZ1bmN0aW9ufE5vZGV8Tm9kZVtdfSBub2RlcyAtIFNlZSBgYXV0b21hdGAuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbcmVwbGFjZW1lbnRzXSAtIFNlZSBgYXV0b21hdGAuXG4gICAgICovXG4gICAgYXBwZW5kOiBmdW5jdGlvbihub2RlcywgcmVwbGFjZW1lbnRzLyouLi4qLykge1xuICAgICAgICB2YXIgZWwgPSB0aGlzLmVsO1xuXG4gICAgICAgIGlmICh0eXBlb2Ygbm9kZXMgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBub2RlcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgYXJncy5zcGxpY2UoMSwgMCwgZWwsIHRoaXMub3JpZ2luYWxGaXJzdENoaWxkKTtcbiAgICAgICAgICAgIGF1dG9tYXQuYXBwZW5kLmFwcGx5KG51bGwsIGFyZ3MpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoJ2xlbmd0aCcgaW4gbm9kZXMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBlbC5pbnNlcnRCZWZvcmUobm9kZXNbaV0sIHRoaXMub3JpZ2luYWxGaXJzdENoaWxkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWwuaW5zZXJ0QmVmb3JlKG5vZGVzLCB0aGlzLm9yaWdpbmFsRmlyc3RDaGlsZCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW5zZXJ0IGRpYWxvZyBpbnRvIERPTS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IFtjb250YWluZXJdIC0gSWYgdW5kZWZpbmVkLCBkaWFsb2cgaXMgYXBwZW5kZWQgdG8gYm9keS5cbiAgICAgKlxuICAgICAqIElmIGRlZmluZWQsIGRpYWxvZyBpcyBhcHBlbmRlZCB0byBjb250YWluZXIuIFdoZW4gY29udGFpbmVyIGlzIG5vdCBib2R5LCBpdCB3aWxsIGJlOlxuICAgICAqICMgbWFkZSB2aXNpYmxlIGJlZm9yZSBhcHBlbmQgKGl0IHNob3VsZCBpbml0aWFsbHkgYmUgaGlkZGVuKVxuICAgICAqICMgbWFkZSBoaWRkZW4gYWZ0ZXIgcmVtb3ZlXG4gICAgICovXG4gICAgb3BlbjogZnVuY3Rpb24oY29udGFpbmVyKSB7XG4gICAgICAgIHZhciBlcnJvcjtcblxuICAgICAgICBpZiAoISh0aGlzLm9wZW5lZCB8fCB0aGlzLm9wZW5pbmcgfHwgdGhpcy5jbG9zZWQgfHwgdGhpcy5jbG9zaW5nKSkge1xuICAgICAgICAgICAgZXJyb3IgPSB0aGlzLm9uT3BlbigpO1xuXG4gICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsID0gdGhpcy5lbDtcblxuICAgICAgICAgICAgICAgIHRoaXMub3BlbmluZyA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICBjb250YWluZXIgPSBjb250YWluZXIgfHwgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignYm9keScpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNvbnRhaW5lci50YWdOYW1lICE9PSAnQk9EWScpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHkgPSAndmlzaWJsZSc7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gaW5zZXJ0IHRoZSBuZXcgZGlhbG9nIG1hcmt1cCBpbnRvIHRoZSBET01cbiAgICAgICAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZWwpO1xuXG4gICAgICAgICAgICAgICAgLy8gc2NoZWR1bGUgaXQgZm9yIGEgc2hvdyB0cmFuc2l0aW9uXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsgZWwuY2xhc3NMaXN0LmFkZCgnaHlwZXJncmlkLWRpYWxvZy12aXNpYmxlJyk7IH0sIDUwKTtcblxuICAgICAgICAgICAgICAgIC8vIGF0IGVuZCBvZiBzaG93IHRyYW5zaXRpb24sIGhpZGUgYWxsIHRoZSBoeXBlcmdyaWRzIGJlaGluZCBpdCB0byBwcmV2ZW50IGFueSBrZXkvbW91c2UgZXZlbnRzIGZyb20gZ2V0dGluZyB0byB0aGVtXG4gICAgICAgICAgICAgICAgLy8gdG9kbzogcGF1c2UgYWxsIGh5cGVyZ3JpZHMgc28gdGhleSBkb24ndCBzcGluIHVzZWxlc3NseVxuICAgICAgICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCB0aGlzLmhpZGVBcHBCb3VuZCA9IGhpZGVBcHAuYmluZCh0aGlzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBkaWFsb2cgZnJvbSBET00uXG4gICAgICovXG4gICAgY2xvc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZXJyb3I7XG5cbiAgICAgICAgaWYgKHRoaXMub3BlbmVkICYmICEodGhpcy5jbG9zZWQgfHwgdGhpcy5jbG9zaW5nKSkge1xuICAgICAgICAgICAgZXJyb3IgPSB0aGlzLm9uQ2xvc2UoKTtcblxuICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICAgIHZhciBlbCA9IHRoaXMuZWw7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmNsb3NpbmcgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgLy8gdW5oaWRlIGFsbCB0aGUgaHlwZXJncmlkcyBiZWhpbmQgdGhlIGRpYWxvZ1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwVmlzaWJsZSgndmlzaWJsZScpO1xuXG4gICAgICAgICAgICAgICAgLy8gc3RhcnQgYSBoaWRlIHRyYW5zaXRpb24gb2YgZGlhbG9nIHJldmVhbGluZyBncmlkcyBiZWhpbmQgaXRcbiAgICAgICAgICAgICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKCdoeXBlcmdyaWQtZGlhbG9nLXZpc2libGUnKTtcblxuICAgICAgICAgICAgICAgIC8vIGF0IGVuZCBvZiBoaWRlIHRyYW5zaXRpb24sIHJlbW92ZSBkaWFsb2cgZnJvbSB0aGUgRE9NXG4gICAgICAgICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIHRoaXMucmVtb3ZlRGlhbG9nQm91bmQgPSByZW1vdmVEaWFsb2cuYmluZCh0aGlzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgfSxcblxuICAgIGFwcFNlbGVjdG9yOiAnY2FudmFzLmh5cGVyZ3JpZCcsXG4gICAgYXBwVmlzaWJsZTogZnVuY3Rpb24odmlzaWJpbGl0eSkge1xuICAgICAgICBlbGZvci5lYWNoKHRoaXMuYXBwU2VsZWN0b3IsIGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgICAgICBlbC5zdHlsZS52aXNpYmlsaXR5ID0gdmlzaWJpbGl0eTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIG9uT3BlbjogbnVsbFBhdHRlcm4sXG4gICAgb25PcGVuZWQ6IG51bGxQYXR0ZXJuLFxuICAgIG9uQ2xvc2U6IG51bGxQYXR0ZXJuLFxuICAgIG9uQ2xvc2VkOiBudWxsUGF0dGVybixcbiAgICB0ZXJtaW5hdGU6IG51bGxQYXR0ZXJuXG59KTtcblxuZnVuY3Rpb24gbnVsbFBhdHRlcm4oKSB7fVxuXG5mdW5jdGlvbiByZW1vdmVEaWFsb2coZXZ0KSB7XG4gICAgaWYgKGV2dC50YXJnZXQgPT09IHRoaXMuZWwgJiYgZXZ0LnByb3BlcnR5TmFtZSA9PT0gJ29wYWNpdHknKSB7XG4gICAgICAgIGlmICh0aGlzLmVsLnBhcmVudEVsZW1lbnQudGFnTmFtZSAhPT0gJ0JPRFknKSB7XG4gICAgICAgICAgICB0aGlzLmVsLnBhcmVudEVsZW1lbnQuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWwucmVtb3ZlKCk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmVsO1xuXG4gICAgICAgIHRoaXMub25DbG9zZWQoKTtcbiAgICAgICAgdGhpcy50ZXJtaW5hdGUoKTtcbiAgICAgICAgdGhpcy5jbG9zaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2xvc2VkID0gdHJ1ZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGhpZGVBcHAoZXZ0KSB7XG4gICAgaWYgKGV2dC50YXJnZXQgPT09IHRoaXMuZWwgJiYgZXZ0LnByb3BlcnR5TmFtZSA9PT0gJ29wYWNpdHknKSB7XG4gICAgICAgIHRoaXMuYXBwVmlzaWJsZSgnaGlkZGVuJyk7XG4gICAgICAgIHRoaXMuZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIHRoaXMuaGlkZUFwcEJvdW5kKTtcbiAgICAgICAgdGhpcy5vbk9wZW5lZCgpO1xuICAgICAgICB0aGlzLm9wZW5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vcGVuZWQgPSB0cnVlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gb25DbGljayhldnQpIHtcbiAgICBpZiAodGhpcykge1xuICAgICAgICBpZiAoZXZ0LnRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ2h5cGVyZ3JpZC1kaWFsb2ctY2xvc2UnKSkge1xuICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7IC8vIGlnbm9yZSBocmVmXG4gICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChldnQudGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygnaHlwZXJncmlkLWRpYWxvZy1zZXR0aW5ncycpKSB7XG4gICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTsgLy8gaWdub3JlIGhyZWZcbiAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzKSB7IHRoaXMuc2V0dGluZ3MoKTsgfVxuXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5vbkNsaWNrICYmICF0aGlzLm9uQ2xpY2suY2FsbCh0aGlzLCBldnQpICYmIGV2dC50YXJnZXQudGFnTmFtZSA9PT0gJ0EnKSB7XG4gICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTsgLy8gaWdub3JlIGhyZWYgb2YgaGFuZGxlZCBldmVudFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpOyAvLyB0aGUgY2xpY2sgc3RvcHMgaGVyZSwgaGFuZGxlZCBvciBub3Rcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBEaWFsb2c7XG4iLCIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgVGFieiA9IHJlcXVpcmUoJ3RhYnonKTtcbnZhciBwb3BNZW51ID0gcmVxdWlyZSgncG9wLW1lbnUnKTtcbnZhciBhdXRvbWF0ID0gcmVxdWlyZSgnYXV0b21hdCcpO1xuXG52YXIgRGlhbG9nID0gcmVxdWlyZSgnLi9EaWFsb2cnKTtcbnZhciBtYXJrdXAgPSByZXF1aXJlKCcuLi8uLi9odG1sJyk7XG52YXIgY29weUlucHV0ID0gcmVxdWlyZSgnLi4vbGliL2NvcHktaW5wdXQnKTtcblxudmFyIHRhYlByb3BlcnRpZXMgPSB7XG4gICAgdGFibGVRQjoge1xuICAgICAgICBpc1RhYmxlRmlsdGVyOiB0cnVlXG4gICAgfSxcbiAgICB0YWJsZVNRTDoge1xuICAgICAgICBpc1RhYmxlRmlsdGVyOiB0cnVlLFxuICAgICAgICBsYW5ndWFnZTogJ1NRTCdcbiAgICB9LFxuICAgIGNvbHVtbnNRQjoge1xuICAgICAgICBpc0NvbHVtbkZpbHRlcjogdHJ1ZVxuICAgIH0sXG4gICAgY29sdW1uc1NRTDoge1xuICAgICAgICBpc0NvbHVtbkZpbHRlcjogdHJ1ZSxcbiAgICAgICAgbGFuZ3VhZ2U6ICdTUUwnXG4gICAgfSxcbiAgICBjb2x1bW5zQ1FMOiB7XG4gICAgICAgIGlzQ29sdW1uRmlsdGVyOiB0cnVlLFxuICAgICAgICBsYW5ndWFnZTogJ0NRTCdcbiAgICB9XG59O1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgRGlhbG9nXG4gKi9cbnZhciBNYW5hZ2VGaWx0ZXJzID0gRGlhbG9nLmV4dGVuZCgnTWFuYWdlRmlsdGVycycsIHtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAtIE1heSBpbmNsdWRlIGBEaWFsb2dgIG9wdGlvbnMuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gW29wdGlvbnMuY29udGFpbmVyPWRvY3VtZW50LmJvZHldXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oZ3JpZCwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLmZpbHRlciA9IGdyaWQuZ2V0R2xvYmFsRmlsdGVyKCk7XG5cbiAgICAgICAgdGhpcy5hcHBlbmQobWFya3VwLmZpbHRlclRyZWVzKTtcblxuICAgICAgICAvLyBpbml0aWFsaXplIHRoZSBmb2xkZXIgdGFic1xuICAgICAgICB2YXIgdGFieiA9IHRoaXMudGFieiA9IG5ldyBUYWJ6KHtcbiAgICAgICAgICAgIHJvb3Q6IHRoaXMuZWwsXG4gICAgICAgICAgICBvbkVuYWJsZTogcmVuZGVyRm9sZGVyLmJpbmQodGhpcyksXG4gICAgICAgICAgICBvbkRpc2FibGU6IHNhdmVGb2xkZXJzLmJpbmQodGhpcywgbnVsbCkgLy8gbnVsbCBvcHRpb25zXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHdpcmUtdXAgdGhlIE5ldyBDb2x1bW4gZHJvcC1kb3duXG4gICAgICAgIHZhciBuZXdDb2x1bW5Ecm9wRG93biA9IHRoaXMuZWwucXVlcnlTZWxlY3RvcignI2FkZC1jb2x1bW4tZmlsdGVyLXN1YmV4cHJlc3Npb24nKTtcbiAgICAgICAgbmV3Q29sdW1uRHJvcERvd24ub25tb3VzZWRvd24gPSBvbk5ld0NvbHVtbk1vdXNlRG93bi5iaW5kKHRoaXMpO1xuICAgICAgICBuZXdDb2x1bW5Ecm9wRG93bi5vbmNoYW5nZSA9IG9uTmV3Q29sdW1uQ2hhbmdlLmJpbmQodGhpcyk7XG5cbiAgICAgICAgLy8gcHV0IHRoZSB0d28gc3VidHJlZXMgaW4gdGhlIHR3byBwYW5lbHNcbiAgICAgICAgdGFiei5mb2xkZXIoJyN0YWJsZVFCJykuYXBwZW5kQ2hpbGQodGhpcy5maWx0ZXIudGFibGVGaWx0ZXIuZWwpO1xuICAgICAgICB0YWJ6LmZvbGRlcignI2NvbHVtbnNRQicpLmFwcGVuZENoaWxkKHRoaXMuZmlsdGVyLmNvbHVtbkZpbHRlcnMuZWwpO1xuXG4gICAgICAgIC8vIGNvcHkgdGhlIFNRTCBtb3JlLWluZm8gYmxvY2sgZnJvbSB0aGUgdGFibGUgdG8gdGhlIGNvbHVtbnMgdGFiXG4gICAgICAgIHZhciBjb2x1bW5TcWxFbCA9IHRhYnouZm9sZGVyKCcjY29sdW1uc1NRTCcpO1xuICAgICAgICB2YXIgbW9yZVNxbEluZm8gPSB0YWJ6LmZvbGRlcignI3RhYmxlU1FMJykuZmlyc3RFbGVtZW50Q2hpbGQuY2xvbmVOb2RlKHRydWUpO1xuICAgICAgICBjb2x1bW5TcWxFbC5pbnNlcnRCZWZvcmUobW9yZVNxbEluZm8sIGNvbHVtblNxbEVsLmZpcnN0Q2hpbGQpO1xuXG4gICAgICAgIC8vIGFkZCBpdCB0byB0aGUgRE9NXG4gICAgICAgIHRoaXMub3BlbihvcHRpb25zLmNvbnRhaW5lcik7XG5cbiAgICAgICAgLy8gZm9sbG93aW5nIG5lZWRlZCBmb3IgdW5jbGVhciByZWFzb25zIHRvIGdldCBkcm9wLWRvd24gdG8gZGlzcGxheSBjb3JyZWN0bHlcbiAgICAgICAgbmV3Q29sdW1uRHJvcERvd24uc2VsZWN0ZWRJbmRleCA9IDA7XG4gICAgfSxcblxuICAgIG9uQ2xvc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gc2F2ZUZvbGRlcnMuY2FsbCh0aGlzKTtcbiAgICB9LFxuXG4gICAgb25DbG9zZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYmVoYXZpb3IgPSB0aGlzLmdyaWQuYmVoYXZpb3I7XG4gICAgICAgIGJlaGF2aW9yLmFwcGx5QW5hbHl0aWNzKCk7XG4gICAgICAgIGJlaGF2aW9yLmNoYW5nZWQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3VzdG9tIGNsaWNrIGhhbmRsZXJzOyBjYWxsZWQgYnkgY3VydGFpbi5vbmNsaWNrIGluIGNvbnRleHRcbiAgICAgKiBAcGFyYW0gZXZ0XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgb25DbGljazogZnVuY3Rpb24oZXZ0KSB7IC8vIHRvIGJlIGNhbGxlZCB3aXRoIGZpbHRlciBvYmplY3QgYXMgc3ludGF4XG4gICAgICAgIHZhciBjdHJsID0gZXZ0LnRhcmdldDtcblxuICAgICAgICBpZiAoY3RybC5jbGFzc0xpc3QuY29udGFpbnMoJ21vcmUtaW5mbycpKSB7XG4gICAgICAgICAgICAvLyBmaW5kIGFsbCBtb3JlLWluZm8gbGlua3MgYW5kIHRoZWlyIGFkamFjZW50IGJsb2NrcyAoYmxvY2tzIGFsd2F5cyBmb2xsb3cgbGlua3MpXG4gICAgICAgICAgICB2YXIgZWxzID0gdGhpcy5lbC5xdWVyeVNlbGVjdG9yQWxsKCcubW9yZS1pbmZvJyk7XG5cbiAgICAgICAgICAgIC8vIGhpZGUgYWxsIG1vcmUtaW5mbyBibG9ja3MgZXhjZXB0IHRoZSBvbmUgZm9sbG93aW5nIHRoaXMgbGluayAodW5sZXNzIGl0J3MgYWxyZWFkeSB2aXNpYmxlIGluIHdoaWNoIGNhc2UgaGlkZSBpdCB0b28pLlxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgZWwgPSBlbHNbaV07XG4gICAgICAgICAgICAgICAgaWYgKGVsLnRhZ05hbWUgPT09ICdBJykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZm91bmQgPSBlbCA9PT0gY3RybDtcbiAgICAgICAgICAgICAgICAgICAgZWwuY2xhc3NMaXN0W2ZvdW5kID8gJ3RvZ2dsZScgOiAncmVtb3ZlJ10oJ2hpZGUtaW5mbycpO1xuICAgICAgICAgICAgICAgICAgICBlbCA9IGVsc1tpICsgMV07XG4gICAgICAgICAgICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBmb3VuZCAmJiBlbC5zdHlsZS5kaXNwbGF5ICE9PSAnYmxvY2snID8gJ2Jsb2NrJyA6ICdub25lJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIGlmIChjdHJsLmNsYXNzTGlzdC5jb250YWlucygnZmlsdGVyLWNvcHknKSkge1xuICAgICAgICAgICAgdmFyIGlzQ29weUFsbCA9IGN0cmwuY2hpbGROb2Rlcy5sZW5ndGg7IC8vIGNvbnRhaW5zIFwiQWxsXCJcbiAgICAgICAgICAgIGlmIChpc0NvcHlBbGwpIHtcbiAgICAgICAgICAgICAgICBjdHJsID0gdGhpcy50YWJ6LmZvbGRlcihjdHJsKS5xdWVyeVNlbGVjdG9yKGNvcHlJbnB1dC5zZWxlY3RvclRleHRDb250cm9scyk7XG4gICAgICAgICAgICAgICAgY29weUlucHV0KGN0cmwsIHRoaXMuZmlsdGVyLmNvbHVtbkZpbHRlcnMuZ2V0U3RhdGUoeyBzeW50YXg6ICdTUUwnIH0pKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29weUlucHV0KGN0cmwucGFyZW50RWxlbWVudC5xdWVyeVNlbGVjdG9yKGNvcHlJbnB1dC5zZWxlY3RvclRleHRDb250cm9scykpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gbWVhbnMgdW5oYW5kbGVkXG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuLyoqXG4gKiBAcGFyYW0gb3B0aW9uc1xuICogQHBhcmFtIHRhYlxuICogQHBhcmFtIGZvbGRlclxuICogQHBhcmFtIFtwYW5lbF0gUGFuZWwgdG8gc2F2ZSAoZnJvbSB0YWIgY2xpY2spLiBJZiBvbWl0dGVkLCBzYXZlIGJvdGggcGFuZWxzIChmcm9tIG9uY2xvc2UpLlxuICogQHJldHVybnMge2Jvb2xlYW58dW5kZWZpbmVkfHN0cmluZ31cbiAqL1xuZnVuY3Rpb24gc2F2ZUZvbGRlcnMob3B0aW9ucywgdGFiLCBmb2xkZXIsIHBhbmVsKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgKCFwYW5lbCB8fCBwYW5lbC5pZCA9PT0gJ3RhYmxlRmlsdGVyUGFuZWwnKSAmJiBzYXZlRm9sZGVyLmNhbGwodGhpcywgdGhpcy5maWx0ZXIudGFibGVGaWx0ZXIsIG9wdGlvbnMpIHx8XG4gICAgICAgICghcGFuZWwgfHwgcGFuZWwuaWQgPT09ICdjb2x1bW5GaWx0ZXJzUGFuZWwnKSAmJiBzYXZlRm9sZGVyLmNhbGwodGhpcywgdGhpcy5maWx0ZXIuY29sdW1uRmlsdGVycywgb3B0aW9ucylcbiAgICApO1xufVxuXG4vKipcbiAqIEB0aGlzIEZpbHRlclxuICogQHBhcmFtIHtEZWZhdWx0RmlsdGVyfSBzdWJ0cmVlXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnM9e2FsZXJ0OnRydWUsZm9jdXM6dHJ1ZX1dIC0gU2lkZSBlZmZlY3RzIGFzIHBlciBgRmlsdGVyVHJlZS5wcm90b3R5cGUuaW52YWxpZGAncyBgb3B0aW9uc2AnIHBhcmFtZXRlci5cbiAqIEByZXR1cm5zIHt1bmRlZmluZWR8c3RyaW5nfSAtIFZhbGlkYXRpb24gZXJyb3IgdGV4dDsgZmFsc3kgbWVhbnMgdmFsaWQgKG5vIGVycm9yKS5cbiAqL1xuZnVuY3Rpb24gc2F2ZUZvbGRlcihzdWJ0cmVlLCBvcHRpb25zKSB7IC8vIHRvIGJlIGNhbGxlZCB3aXRoIGZpbHRlciBvYmplY3QgYXMgc3ludGF4XG4gICAgdmFyIGlzQ29sdW1uRmlsdGVycyA9IHN1YnRyZWUgPT09IHRoaXMuZmlsdGVyLmNvbHVtbkZpbHRlcnMsXG4gICAgICAgIHRhYlF1ZXJ5QnVpbGRlciA9IHRoaXMudGFiei50YWIoaXNDb2x1bW5GaWx0ZXJzID8gJyNjb2x1bW5zUUInIDogJyN0YWJsZVFCJyksXG4gICAgICAgIHRhYiA9IHRoaXMudGFiei5lbmFibGVkVGFiKHRhYlF1ZXJ5QnVpbGRlciksXG4gICAgICAgIGZvbGRlciA9IHRoaXMudGFiei5mb2xkZXIodGFiKSxcbiAgICAgICAgaXNRdWVyeUJ1aWxkZXIgPSB0YWIgPT09IHRhYlF1ZXJ5QnVpbGRlcixcbiAgICAgICAgZGVmYXVsdGVkT3B0aW9ucyA9IG9wdGlvbnMgfHwge1xuICAgICAgICAgICAgYWxlcnQ6IHRydWUsXG4gICAgICAgICAgICBmb2N1czogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBlbmhhbmNlZE9wdGlvbnMgPSB7XG4gICAgICAgICAgICBhbGVydDogZGVmYXVsdGVkT3B0aW9ucy5hbGVydCxcbiAgICAgICAgICAgIGZvY3VzOiBkZWZhdWx0ZWRPcHRpb25zLmZvY3VzICYmIGlzUXVlcnlCdWlsZGVyXG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yLCBjdHJsO1xuXG4gICAgaWYgKGlzQ29sdW1uRmlsdGVycyB8fCBpc1F1ZXJ5QnVpbGRlcikge1xuICAgICAgICBlcnJvciA9IHN1YnRyZWUuaW52YWxpZChlbmhhbmNlZE9wdGlvbnMpO1xuICAgIH0gZWxzZSB7IC8vIHRhYmxlIGZpbHRlciBTUUwgdGFiXG4gICAgICAgIGN0cmwgPSBmb2xkZXIucXVlcnlTZWxlY3RvcigndGV4dGFyZWEnKTtcbiAgICAgICAgZXJyb3IgPSB0aGlzLmZpbHRlci5zZXRUYWJsZUZpbHRlclN0YXRlKGN0cmwudmFsdWUsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIGlmIChlcnJvciAmJiAhaXNRdWVyeUJ1aWxkZXIpIHtcbiAgICAgICAgLy8gSWYgdGhlcmUgd2FzIGEgdmFsaWRhdGlvbiBlcnJvciwgbW92ZSB0aGUgZm9jdXMgZnJvbSB0aGUgcXVlcnkgYnVpbGRlciBjb250cm9sIHRvIHRoZSB0ZXh0IGJveCBjb250cm9sLlxuICAgICAgICBpZiAoaXNDb2x1bW5GaWx0ZXJzKSB7XG4gICAgICAgICAgICAvLyBXZSdyZSBpbiBTUUwgb3IgQ1FMIHRhYiBzbyBmaW5kIHRleHQgYm94IHRoYXQgZ29lcyB3aXRoIHRoaXMgc3ViZXhwcmVzc2lvbiBhbmQgZm9jdXMgb24gaXQgaW5zdGVhZCBvZiBRQiBjb250cm9sLlxuICAgICAgICAgICAgdmFyIGVycmFudENvbHVtbk5hbWUgPSBlcnJvci5ub2RlLmVsLnBhcmVudEVsZW1lbnQucXVlcnlTZWxlY3RvcignaW5wdXQnKS52YWx1ZTtcbiAgICAgICAgICAgIGN0cmwgPSBmb2xkZXIucXVlcnlTZWxlY3RvcignW25hbWU9XCInICsgZXJyYW50Q29sdW1uTmFtZSArICdcIl0nKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjdHJsKSB7XG4gICAgICAgIGRlY29yYXRlRmlsdGVySW5wdXQoY3RybCwgZXJyb3IpO1xuICAgIH1cblxuICAgIHJldHVybiBlcnJvcjtcbn1cblxuZnVuY3Rpb24gZGVjb3JhdGVGaWx0ZXJJbnB1dChjdHJsLCBlcnJvcikge1xuICAgIGN0cmwuY2xhc3NMaXN0LnRvZ2dsZSgnZmlsdGVyLXRyZWUtZXJyb3InLCAhIWVycm9yKTtcblxuICAgIGN0cmwuZm9jdXMoKTtcblxuICAgIC8vIGZpbmQgdGhlIG5lYXJieSB3YXJuaW5nIGVsZW1lbnRcbiAgICB2YXIgd2FybmluZ0VsO1xuICAgIGRvIHtcbiAgICAgICAgY3RybCA9IGN0cmwucGFyZW50RWxlbWVudDtcbiAgICAgICAgd2FybmluZ0VsID0gY3RybC5xdWVyeVNlbGVjdG9yKCcuZmlsdGVyLXRyZWUtd2FybicpO1xuICAgIH0gd2hpbGUgKCF3YXJuaW5nRWwpO1xuXG4gICAgLy8gc2hvdyBvciBoaWRlIHRoZSBlcnJvclxuICAgIHdhcm5pbmdFbC5pbm5lckhUTUwgPSBlcnJvci5tZXNzYWdlIHx8IGVycm9yIHx8ICcnO1xufVxuXG5mdW5jdGlvbiBvbk5ld0NvbHVtbk1vdXNlRG93bihldnQpIHsgLy8gdG8gYmUgY2FsbGVkIHdpdGggZmlsdGVyIG9iamVjdCBhcyBzeW50YXhcbiAgICBpZiAoc2F2ZUZvbGRlci5jYWxsKHRoaXMsIHRoaXMuZmlsdGVyLmNvbHVtbkZpbHRlcnMpKSB7XG4gICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpOyAvLyBkbyBub3QgZHJvcCBkb3duXG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gKHJlKWJ1aWxkIHRoZSBkcm9wLWRvd24gY29udGVudHMsIHdpdGggc2FtZSBwcm9tcHQsIGJ1dCBleGNsdWRpbmcgY29sdW1ucyB3aXRoIGFjdGl2ZSBmaWx0ZXIgc3ViZXhwcmVzc2lvbnNcbiAgICAgICAgdmFyIGN0cmwgPSBldnQudGFyZ2V0LFxuICAgICAgICAgICAgcHJvbXB0ID0gY3RybC5vcHRpb25zWzBdLnRleHQucmVwbGFjZSgn4oCmJywgJycpLCAvLyB1c2Ugb3JpZ2luYWwgYnV0IHcvbyBlbGxpcHNpcyBhcyAuYnVpbGQoKSBhcHBlbmRzIG9uZVxuICAgICAgICAgICAgYmxhY2tsaXN0ID0gdGhpcy5maWx0ZXIuY29sdW1uRmlsdGVycy5jaGlsZHJlbi5tYXAoZnVuY3Rpb24oY29sdW1uRmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbHVtbkZpbHRlci5jaGlsZHJlbi5sZW5ndGggJiYgY29sdW1uRmlsdGVyLmNoaWxkcmVuWzBdLmNvbHVtbjtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICBwcm9tcHQ6IHByb21wdCxcbiAgICAgICAgICAgICAgICBibGFja2xpc3Q6IGJsYWNrbGlzdFxuICAgICAgICAgICAgfTtcblxuICAgICAgICBwb3BNZW51LmJ1aWxkKGN0cmwsIHRoaXMuZmlsdGVyLnJvb3Quc2NoZW1hLCBvcHRpb25zKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIG9uTmV3Q29sdW1uQ2hhbmdlKGV2dCkge1xuICAgIHZhciBjdHJsID0gZXZ0LnRhcmdldCxcbiAgICAgICAgdGFiQ29sdW1uUUIgPSB0aGlzLnRhYnouZm9sZGVyKCcjdGFibGVRQicpLFxuICAgICAgICB0YWIgPSB0aGlzLnRhYnouZW5hYmxlZFRhYih0YWJDb2x1bW5RQi5wYXJlbnRFbGVtZW50KSxcbiAgICAgICAgaXNRdWVyeUJ1aWxkZXIgPSB0YWIgPT09IHRhYkNvbHVtblFCLFxuICAgICAgICB0YWJQcm9wcyA9IHRhYlByb3BlcnRpZXNbdGFiLmlkXTtcblxuICAgIHRoaXMuZmlsdGVyLmNvbHVtbkZpbHRlcnMuYWRkKHtcbiAgICAgICAgc3RhdGU6IHtcbiAgICAgICAgICAgIHR5cGU6ICdjb2x1bW5GaWx0ZXInLFxuICAgICAgICAgICAgY2hpbGRyZW46IFsgeyBjb2x1bW46IGN0cmwudmFsdWUgfSBdXG4gICAgICAgIH0sXG4gICAgICAgIGZvY3VzOiBpc1F1ZXJ5QnVpbGRlclxuICAgIH0pO1xuXG4gICAgaWYgKHRhYlByb3BzLmlzQ29sdW1uRmlsdGVyICYmIHRhYlByb3BzLmxhbnVnYWdlKSB7XG4gICAgICAgIHJlbmRlckZvbGRlci5jYWxsKHRoaXMsIHRhYik7XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIGFsbCBidXQgdGhlIHByb21wdCBvcHRpb24gKGZpcnN0IGNoaWxkKVxuICAgIGN0cmwuc2VsZWN0ZWRJbmRleCA9IDA7XG4gICAgd2hpbGUgKGN0cmwubGFzdENoaWxkICE9PSBjdHJsLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgY3RybC5yZW1vdmVDaGlsZChjdHJsLmxhc3RDaGlsZCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiByZW5kZXJGb2xkZXIodGFiKSB7IC8vIHRvIGJlIGNhbGxlZCB3aXRoIGZpbHRlciBvYmplY3QgYXMgc3ludGF4XG4gICAgdmFyIHRhYlByb3BzID0gdGFiUHJvcGVydGllc1t0YWIuaWRdLFxuICAgICAgICBxdWVyeUxhbmd1YWdlID0gdGFiUHJvcHMubGFuZ3VhZ2U7XG5cbiAgICBpZiAocXVlcnlMYW5ndWFnZSkge1xuICAgICAgICB2YXIgZ2xvYmFsRmlsdGVyID0gdGhpcy5maWx0ZXIsXG4gICAgICAgICAgICBmb2xkZXIgPSB0aGlzLnRhYnouZm9sZGVyKHRhYik7XG5cbiAgICAgICAgaWYgKHRhYlByb3BzLmlzVGFibGVGaWx0ZXIpIHtcblxuICAgICAgICAgICAgZm9sZGVyLnF1ZXJ5U2VsZWN0b3IoJ3RleHRhcmVhJykudmFsdWUgPSBnbG9iYWxGaWx0ZXIudGFibGVGaWx0ZXIuZ2V0U3RhdGUoeyBzeW50YXg6ICdTUUwnIH0pO1xuXG4gICAgICAgIH0gZWxzZSB7IC8vIGNvbHVtbiBmaWx0ZXJcblxuICAgICAgICAgICAgdmFyIGNvbHVtbkZpbHRlcnMgPSBnbG9iYWxGaWx0ZXIuY29sdW1uRmlsdGVycy5jaGlsZHJlbixcbiAgICAgICAgICAgICAgICBlbCA9IGZvbGRlci5sYXN0RWxlbWVudENoaWxkLFxuICAgICAgICAgICAgICAgIG1zZ0VsID0gZWwucXVlcnlTZWxlY3Rvcignc3BhbicpLFxuICAgICAgICAgICAgICAgIGxpc3RFbCA9IGVsLnF1ZXJ5U2VsZWN0b3IoJ29sJyksXG4gICAgICAgICAgICAgICAgY29weUFsbExpbmsgPSBlbC5xdWVyeVNlbGVjdG9yKCdhOmZpcnN0LW9mLXR5cGUnKTtcblxuICAgICAgICAgICAgbXNnRWwuaW5uZXJIVE1MID0gYWN0aXZlRmlsdGVyc01lc3NhZ2UoY29sdW1uRmlsdGVycy5sZW5ndGgpO1xuICAgICAgICAgICAgbGlzdEVsLmlubmVySFRNTCA9ICcnO1xuXG4gICAgICAgICAgICAvLyBmb3IgZWFjaCBjb2x1bW4gZmlsdGVyIHN1YnRyZWUsIGFwcGVuZCBhbiA8bGk+Li4uPC9saT4gZWxlbWVudCBjb250YWluaW5nOlxuICAgICAgICAgICAgLy8gY29sdW1uIHRpdGxlLCBcIihjb3B5KVwiIGxpbmssIGFuZCBlZGl0YWJsZSB0ZXh0IGlucHV0IGJveCBjb250YWluaW5nIHRoZSBzdWJleHByZXNzaW9uXG4gICAgICAgICAgICBjb2x1bW5GaWx0ZXJzLmZvckVhY2goZnVuY3Rpb24oZmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbmRpdGlvbmFsID0gZmlsdGVyLmNoaWxkcmVuWzBdLFxuICAgICAgICAgICAgICAgICAgICBpdGVtID0gY29uZGl0aW9uYWwuc2NoZW1hWzBdLFxuICAgICAgICAgICAgICAgICAgICBuYW1lID0gY29uZGl0aW9uYWwuY29sdW1uLFxuICAgICAgICAgICAgICAgICAgICBhbGlhcyA9IGl0ZW0uYWxpYXMgfHwgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbiA9IGZpbHRlci5nZXRTdGF0ZSh7IHN5bnRheDogcXVlcnlMYW5ndWFnZSB9KSxcbiAgICAgICAgICAgICAgICAgICAgaXNOdWxsID0gZXhwcmVzc2lvbiA9PT0gJyhOVUxMIElTIE5VTEwpJyB8fCBleHByZXNzaW9uID09PSAnJyxcbiAgICAgICAgICAgICAgICAgICAgY29udGVudCA9IGlzTnVsbCA/ICcnIDogZXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lID0gaXNOdWxsID8gJ2ZpbHRlci10cmVlLWVycm9yJyA6ICcnLFxuICAgICAgICAgICAgICAgICAgICBsaSA9IGF1dG9tYXQuZmlyc3RDaGlsZChtYXJrdXBbcXVlcnlMYW5ndWFnZV0sIGFsaWFzLCBuYW1lLCBjb250ZW50LCBjbGFzc05hbWUpO1xuXG4gICAgICAgICAgICAgICAgbGlzdEVsLmFwcGVuZENoaWxkKGxpKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBmb2xkZXIub25rZXl1cCA9IHNldENvbHVtbkZpbHRlclN0YXRlLmJpbmQodGhpcywgcXVlcnlMYW5ndWFnZSk7XG5cbiAgICAgICAgICAgIGlmIChjb3B5QWxsTGluaykge1xuICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlJ3MgYSBcIihjb3B5IGFsbClcIiBsaW5rLCBoaWRlIGl0IGlmIG9ubHkgMCBvciAxIHN1YmV4cHJlc3Npb25zXG4gICAgICAgICAgICAgICAgY29weUFsbExpbmsuc3R5bGUuZGlzcGxheSA9IGNvbHVtbkZpbHRlcnMubGVuZ3RoID4gMSA/ICdibG9jaycgOiAnbm9uZSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH1cbn1cblxuLy92YXIgUkVUVVJOX0tFWSA9IDB4MGQsIEVTQ0FQRV9LRVkgPSAweDFiO1xuLyoqXG4gKiBDYWxsZWQgZnJvbSBrZXktdXAgZXZlbnRzIGZyb20gYCNjb2x1bW5TUUxgIGFuZCBgI2NvbHVtbkNRTGAgdGFicy5cbiAqIEB0aGlzIEZpbHRlclxuICogQHBhcmFtIHtzdHJpbmd9IHF1ZXJ5TGFuZ3VhZ2VcbiAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZXZ0XG4gKi9cbmZ1bmN0aW9uIHNldENvbHVtbkZpbHRlclN0YXRlKHF1ZXJ5TGFuZ3VhZ2UsIGV2dCkge1xuICAgIHZhciBjdHJsID0gZXZ0LnRhcmdldDtcblxuICAgIC8vIE9ubHkgaGFuZGxlIGlmIGtleSB3YXMgcHJlc3NlZCBpbnNpZGUgYSB0ZXh0IGJveC5cbiAgICBpZiAoY3RybC5jbGFzc0xpc3QuY29udGFpbnMoJ2ZpbHRlci10ZXh0LWJveCcpKSB7XG4gICAgICAgIC8vc3dpdGNoIChldnQua2V5Q29kZSkge1xuICAgICAgICAvLyAgICBjYXNlIEVTQ0FQRV9LRVk6XG4gICAgICAgIC8vICAgICAgICBjdHJsLnZhbHVlID0gb2xkQXJnO1xuICAgICAgICAvLyAgICBjYXNlIFJFVFVSTl9LRVk6IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZmFsbHRocm91Z2hcbiAgICAgICAgLy8gICAgICAgIGN0cmwuYmx1cigpO1xuICAgICAgICAvLyAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vICAgIGRlZmF1bHQ6XG4gICAgICAgIHZhciBlcnJvcixcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7IHN5bnRheDogcXVlcnlMYW5ndWFnZSwgYWxlcnQ6IHRydWUgfTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZXJyb3IgPSB0aGlzLmZpbHRlci5zZXRDb2x1bW5GaWx0ZXJTdGF0ZShjdHJsLm5hbWUsIGN0cmwudmFsdWUsIG9wdGlvbnMpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGVycm9yID0gZXJyO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVjb3JhdGVGaWx0ZXJJbnB1dChjdHJsLCBlcnJvcik7XG4gICAgICAgIC8vfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gYWN0aXZlRmlsdGVyc01lc3NhZ2Uobikge1xuICAgIHZhciByZXN1bHQ7XG5cbiAgICBzd2l0Y2ggKG4pIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgcmVzdWx0ID0gJ1RoZXJlIGFyZSBubyBhY3RpdmUgY29sdW1uIGZpbHRlcnMuJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICByZXN1bHQgPSAnVGhlcmUgaXMgMSBhY3RpdmUgY29sdW1uIGZpbHRlcjonO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXN1bHQgPSAnVGhlcmUgYXJlICcgKyBuICsgJyBhY3RpdmUgY29sdW1uIGZpbHRlcnM6JztcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gTWFuYWdlRmlsdGVycztcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMuQ29sdW1uUGlja2VyID0gcmVxdWlyZSgnLi9Db2x1bW5QaWNrZXInKTtcbm1vZHVsZS5leHBvcnRzLk1hbmFnZUZpbHRlcnMgPSByZXF1aXJlKCcuL01hbmFnZUZpbHRlcnMnKTtcbiIsIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qIE5PVEVcbiAqXG4gKiBXaGF0IHRoaXMgZmlsZSBpczpcbiAqICogVGhpcyBmaWxlIGlzIGJyb3dzZXJpZnkncyBlbnRyeSBwb2ludC5cbiAqICogVGhpcyBmaWxlIGNyZWF0ZXMgdGhlIGB3aW5kb3cuZmluLkh5cGVyZ3JpZGAgb2JqZWN0LlxuICpcbiAqIFdoYXQgdGhpcyBmaWxlIGlzIG5vdDpcbiAqICogVGhpcyBmaWxlIGlzIG5vdCBhIG5vZGUgbW9kdWxlOyBpdCBoYXMgbm8gcmVmZXJlbmNlIHRvIGBtb2R1bGUuZXhwb3J0c2Agb3IgYGV4cG9ydHNgOyBpdCBjYW5ub3QgYmUgXCJyZXF1aXJlZFwiIGJ5IGFueSBvdGhlciBmaWxlLlxuICogKiBUaGlzIGZpbGUgaXMgYmxhY2tsaXN0ZWQgaW4gLm5wbWlnbm9yZSBhbmQgaXMgbm90IHB1Ymxpc2hlZCB0byBucG0uXG4gKlxuICogTm90ZTogVGhlIG5wbSBcIm1haW5cIiBlbnRyeSBwb2ludCAoYXMgbm90ZWQgaW4gcGFja2FnZS5qc29uKSBpcyBzcmMvSHlwZXJncmlkLmpzLlxuICovXG5cbnZhciBIeXBlcmdyaWQgPSByZXF1aXJlKCcuL0h5cGVyZ3JpZCcpO1xuXG4vLyBFeHBvc2Ugc29tZSBuYW1lc3BhY2VzIHRvIHVzZXJzIG9mIHRoZSBoeXBlcmdyaWQuanMgZmlsZSB0aHJvdWdoIGBmaW4uSHlwZXJncmlkYDpcbkh5cGVyZ3JpZC5KU09OID0gcmVxdWlyZSgnLi9saWIvanNvbicpO1xuSHlwZXJncmlkLmltYWdlcyA9IHJlcXVpcmUoJy4uL2ltYWdlcycpO1xuSHlwZXJncmlkLmJlaGF2aW9ycyA9IHJlcXVpcmUoJy4vYmVoYXZpb3JzJyk7XG5IeXBlcmdyaWQuZGF0YU1vZGVscyA9IHJlcXVpcmUoJy4vZGF0YU1vZGVscycpO1xuSHlwZXJncmlkLmZlYXR1cmVzID0gcmVxdWlyZSgnLi9mZWF0dXJlcycpO1xuSHlwZXJncmlkLmFuYWx5dGljcyA9IHJlcXVpcmUoJy4vU2hhcmVkLmpzJykuYW5hbHl0aWNzO1xuSHlwZXJncmlkLkRlZmF1bHRGaWx0ZXIgPSByZXF1aXJlKCcuL2ZpbHRlci9EZWZhdWx0RmlsdGVyJyk7XG5IeXBlcmdyaWQuQ29sdW1uU2NoZW1hRmFjdG9yeSA9IHJlcXVpcmUoJy4vZmlsdGVyL0NvbHVtblNjaGVtYUZhY3RvcnknKTtcbkh5cGVyZ3JpZC5GaWx0ZXJUcmVlID0gcmVxdWlyZSgnLi9TaGFyZWQnKS5GaWx0ZXJUcmVlO1xuSHlwZXJncmlkLnJlY3Rhbmd1bGFyID0gcmVxdWlyZSgncmVjdGFuZ3VsYXInKTtcblxuLy8gQ3JlYXRlIHRoZSBgZmluYCBhbmQgaW4gcGFydGljdWxhciB0aGUgYGZpbi5IeXBlcmdyaWRgIG9iamVjdHM6XG4od2luZG93LmZpbiA9IHdpbmRvdy5maW4gfHwge30pLkh5cGVyZ3JpZCA9IEh5cGVyZ3JpZDtcblxuLy8gTm90ZSB0aGF0IHdoaWxlIHVzZXJzIG9mIHRoZSBucG0gbW9kdWxlIGNhbiBhbHNvIGFjY2VzcyB0aGUgYWJvdmUgbmFtZXNwYWNlcyB0aHJvdWdoIHRoZSBIeXBlcmdyaWQgb2JqZWN0LCBpbiByZWFsaXR5IHRoZXkgYWxzbyBoYXZlIGFjY2VzcyB0byBhbnkgbmFtZXNwYWNlIHRocm91Z2ggYHJlcXVpcmVgLCBmb3IgZXhhbXBsZTpcbi8vIHZhciBiZWhhdmlvckpTT04gPSByZXF1aXJlKCdmaW4taHlwZXJncmlkL3NyYy9iZWhhdmlvcnMvSlNPTicpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRmVhdHVyZSA9IHJlcXVpcmUoJy4vRmVhdHVyZS5qcycpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgRmVhdHVyZVxuICovXG52YXIgQ2VsbENsaWNrID0gRmVhdHVyZS5leHRlbmQoJ0NlbGxDbGljaycsIHtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsQ2xpY2sucHJvdG90eXBlXG4gICAgICogQGRlc2MgSGFuZGxlIHRoaXMgZXZlbnQgZG93biB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVDbGljazogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgZXZlbnQuZ3JpZENlbGwueSA+PSBncmlkLmJlaGF2aW9yLmdldEhlYWRlclJvd0NvdW50KCkgJiZcbiAgICAgICAgICAgIGV2ZW50LmdyaWRDZWxsLnggPj0gZ3JpZC5iZWhhdmlvci5nZXRIZWFkZXJDb2x1bW5Db3VudCgpXG4gICAgICAgICkge1xuICAgICAgICAgICAgZ3JpZC5jZWxsQ2xpY2tlZChldmVudCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlQ2xpY2soZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ2VsbENsaWNrO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRmVhdHVyZSA9IHJlcXVpcmUoJy4vRmVhdHVyZS5qcycpO1xudmFyIENlbGxFZGl0b3IgPSByZXF1aXJlKCcuLi9jZWxsRWRpdG9ycy9DZWxsRWRpdG9yJyk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBGZWF0dXJlXG4gKi9cbnZhciBDZWxsRWRpdGluZyA9IEZlYXR1cmUuZXh0ZW5kKCdDZWxsRWRpdGluZycsIHtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsRWRpdGluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudCBkb3duIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZURvdWJsZUNsaWNrOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICB2YXIgaXNEb3VibGVDbGlja0VkaXRvckFjdGl2YXRpb24gPSBncmlkLnJlc29sdmVQcm9wZXJ0eSgnZWRpdE9uRG91YmxlQ2xpY2snKTtcbiAgICAgICAgaWYgKHRoaXMuY2hlY2tBY3RpdmF0ZUVkaXRvcihncmlkLCBldmVudCwgaXNEb3VibGVDbGlja0VkaXRvckFjdGl2YXRpb24pKSB7XG4gICAgICAgICAgICBncmlkLm9uRWRpdG9yQWN0aXZhdGUoZXZlbnQpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZURvdWJsZUNsaWNrKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBoYW5kbGVDbGljazogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgdmFyIGlzRG91YmxlQ2xpY2tFZGl0b3JBY3RpdmF0aW9uID0gZ3JpZC5yZXNvbHZlUHJvcGVydHkoJ2VkaXRPbkRvdWJsZUNsaWNrJyk7XG4gICAgICAgIGlmICh0aGlzLmNoZWNrQWN0aXZhdGVFZGl0b3IoZ3JpZCwgZXZlbnQsICFpc0RvdWJsZUNsaWNrRWRpdG9yQWN0aXZhdGlvbikpIHtcbiAgICAgICAgICAgIGdyaWQub25FZGl0b3JBY3RpdmF0ZShldmVudCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlQ2xpY2soZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGNoZWNrQWN0aXZhdGVFZGl0b3I6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50LCBpc0RvdWJsZUNsaWNrRWRpdG9yQWN0aXZhdGlvbikge1xuICAgICAgICB2YXIgaGVhZGVyUm93Q291bnQgPSBncmlkLmJlaGF2aW9yLmdldEhlYWRlclJvd0NvdW50KCk7XG4gICAgICAgIHZhciBoZWFkZXJDb2x1bW5Db3VudCA9IGdyaWQuYmVoYXZpb3IuZ2V0SGVhZGVyQ29sdW1uQ291bnQoKTtcbiAgICAgICAgdmFyIGdyaWRDZWxsID0gZXZlbnQuZ3JpZENlbGw7XG4gICAgICAgIHZhciBpc0ZpbHRlclJvdyA9IGdyaWQuaXNGaWx0ZXJSb3coZ3JpZENlbGwueSk7XG5cbiAgICAgICAgcmV0dXJuIGlzRG91YmxlQ2xpY2tFZGl0b3JBY3RpdmF0aW9uICYmXG4gICAgICAgICAgICBncmlkQ2VsbC54ID49IGhlYWRlckNvbHVtbkNvdW50ICYmXG4gICAgICAgICAgICAoaXNGaWx0ZXJSb3cgfHwgZ3JpZENlbGwueSA+PSBoZWFkZXJSb3dDb3VudCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBkZXNjIEhhbmRsZSB0aGlzIGV2ZW50IGRvd24gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHkuXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqIEBtZW1iZXJPZiBLZXlQYWdpbmcucHJvdG90eXBlXG4gICAgICovXG4gICAgaGFuZGxlS2V5RG93bjogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgdmFyIGNoYXIsIGlzVmlzaWJsZUNoYXIsIGlzRGVsZXRlQ2hhciwgY3VycmVudENlbGwsIGVkaXRvcjtcblxuICAgICAgICBpZiAoXG4gICAgICAgICAgICBncmlkLnJlc29sdmVQcm9wZXJ0eSgnZWRpdE9uS2V5ZG93bicpICYmXG4gICAgICAgICAgICAhZ3JpZC5jZWxsRWRpdG9yICYmXG4gICAgICAgICAgICAoXG4gICAgICAgICAgICAgICAgKGNoYXIgPSBldmVudC5kZXRhaWwuY2hhcikgPT09ICdGMicgfHxcbiAgICAgICAgICAgICAgICAoaXNWaXNpYmxlQ2hhciA9IGNoYXIubGVuZ3RoID09PSAxICYmICEoZXZlbnQuZGV0YWlsLm1ldGEgfHwgZXZlbnQuZGV0YWlsLmN0cmwpKSB8fFxuICAgICAgICAgICAgICAgIChpc0RlbGV0ZUNoYXIgPSBjaGFyID09PSAnREVMRVRFJyB8fCBjaGFyID09PSAnQkFDS1NQQUNFJylcbiAgICAgICAgICAgIClcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBjdXJyZW50Q2VsbCA9IGdyaWQuc2VsZWN0aW9uTW9kZWwuZ2V0TGFzdFNlbGVjdGlvbigpO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRDZWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBzZXVkb0V2ZW50ID0geyBncmlkQ2VsbDogY3VycmVudENlbGwub3JpZ2luIH07XG4gICAgICAgICAgICAgICAgZWRpdG9yID0gZ3JpZC5vbkVkaXRvckFjdGl2YXRlKHBzZXVkb0V2ZW50KTtcbiAgICAgICAgICAgICAgICBpZiAoZWRpdG9yIGluc3RhbmNlb2YgQ2VsbEVkaXRvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNWaXNpYmxlQ2hhcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yLnNldEVkaXRvclZhbHVlKGNoYXIpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzRGVsZXRlQ2hhcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yLnNldEVkaXRvclZhbHVlKCcnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBldmVudC5kZXRhaWwucHJpbWl0aXZlRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlS2V5RG93bihncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENlbGxFZGl0aW5nO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRmVhdHVyZSA9IHJlcXVpcmUoJy4vRmVhdHVyZS5qcycpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgRmVhdHVyZVxuICovXG52YXIgQ2VsbFNlbGVjdGlvbiA9IEZlYXR1cmUuZXh0ZW5kKCdDZWxsU2VsZWN0aW9uJywge1xuXG4gICAgLyoqXG4gICAgICogVGhlIHBpeGVsIGxvY2F0aW9uIG9mIHRoZSBtb3VzZSBwb2ludGVyIGR1cmluZyBhIGRyYWcgb3BlcmF0aW9uLlxuICAgICAqIEB0eXBlIHt3aW5kb3cuZmluLnJlY3Rhbmd1bGFyLlBvaW50fVxuICAgICAqIEBtZW1iZXJPZiBDZWxsU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGN1cnJlbnREcmFnOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogdGhlIGNlbGwgY29vcmRpbmF0ZXMgb2YgdGhlIHdoZXJlIHRoZSBtb3VzZSBwb2ludGVyIGlzIGR1cmluZyBhIGRyYWcgb3BlcmF0aW9uXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAbWVtYmVyT2YgQ2VsbFNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBsYXN0RHJhZ0NlbGw6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBhIG1pbGxpc2Vjb25kIHZhbHVlIHJlcHJlc2VudGluZyB0aGUgcHJldmlvdXMgdGltZSBhbiBhdXRvc2Nyb2xsIHN0YXJ0ZWRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbFNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBzYkxhc3RBdXRvOiAwLFxuXG4gICAgLyoqXG4gICAgICogYSBtaWxsaXNlY29uZCB2YWx1ZSByZXByZXNlbnRpbmcgdGhlIHRpbWUgdGhlIGN1cnJlbnQgYXV0b3Njcm9sbCBzdGFydGVkXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICogQG1lbWJlck9mIENlbGxTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICovXG4gICAgc2JBdXRvU3RhcnQ6IDAsXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbFNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBIYW5kbGUgdGhpcyBldmVudCBkb3duIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5LlxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVNb3VzZVVwOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAodGhpcy5kcmFnZ2luZykge1xuICAgICAgICAgICAgdGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVNb3VzZVVwKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbFNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBIYW5kbGUgdGhpcyBldmVudCBkb3duIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5LlxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVNb3VzZURvd246IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIHZhciBpc1JpZ2h0Q2xpY2sgPSBldmVudC5wcmltaXRpdmVFdmVudC5kZXRhaWwuaXNSaWdodENsaWNrO1xuICAgICAgICB2YXIgY2VsbCA9IGV2ZW50LmdyaWRDZWxsO1xuICAgICAgICB2YXIgdmlld0NlbGwgPSBldmVudC52aWV3UG9pbnQ7XG4gICAgICAgIHZhciBkeCA9IGNlbGwueDtcbiAgICAgICAgdmFyIGR5ID0gY2VsbC55O1xuICAgICAgICB2YXIgaGVhZGVyUm93Q291bnQgPSBncmlkLmJlaGF2aW9yLmdldEhlYWRlclJvd0NvdW50KCk7XG4gICAgICAgIHZhciBoZWFkZXJDb2x1bW5Db3VudCA9IGdyaWQuYmVoYXZpb3IuZ2V0SGVhZGVyQ29sdW1uQ291bnQoKTtcbiAgICAgICAgdmFyIGNvbHVtbkNvdW50ID0gZ3JpZC5nZXRDb2x1bW5Db3VudCgpO1xuICAgICAgICB2YXIgaXNPdXRzaWRlID0gdmlld0NlbGwueCA+PSBjb2x1bW5Db3VudDtcblxuICAgICAgICB2YXIgaXNIZWFkZXIgPSBkeSA8IGhlYWRlclJvd0NvdW50IHx8IGR4IDwgaGVhZGVyQ29sdW1uQ291bnQ7XG5cbiAgICAgICAgaWYgKCFncmlkLmlzQ2VsbFNlbGVjdGlvbigpIHx8IGlzUmlnaHRDbGljayB8fCBpc0hlYWRlciB8fCBpc091dHNpZGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlTW91c2VEb3duKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBudW1GaXhlZENvbHVtbnMgPSBncmlkLmdldEZpeGVkQ29sdW1uQ291bnQoKTtcbiAgICAgICAgICAgIHZhciBudW1GaXhlZFJvd3MgPSBncmlkLmdldEZpeGVkUm93Q291bnQoKTtcblxuICAgICAgICAgICAgLy9pZiB3ZSBhcmUgaW4gdGhlIGZpeGVkIGFyZWEgZG8gbm90IGFwcGx5IHRoZSBzY3JvbGwgdmFsdWVzXG4gICAgICAgICAgICAvL2NoZWNrIGJvdGggeCBhbmQgeSB2YWx1ZXMgaW5kZXBlbmRlbnRseVxuICAgICAgICAgICAgaWYgKHZpZXdDZWxsLnggPCBudW1GaXhlZENvbHVtbnMpIHtcbiAgICAgICAgICAgICAgICBkeCA9IHZpZXdDZWxsLng7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh2aWV3Q2VsbC55IDwgbnVtRml4ZWRSb3dzKSB7XG4gICAgICAgICAgICAgICAgZHkgPSB2aWV3Q2VsbC55O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZENlbGwgPSBncmlkLm5ld1BvaW50KGR4LCBkeSk7XG5cbiAgICAgICAgICAgIHZhciBwcmltRXZlbnQgPSBldmVudC5wcmltaXRpdmVFdmVudDtcbiAgICAgICAgICAgIHZhciBrZXlzID0gcHJpbUV2ZW50LmRldGFpbC5rZXlzO1xuICAgICAgICAgICAgdGhpcy5kcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmV4dGVuZFNlbGVjdGlvbihncmlkLCBkQ2VsbCwga2V5cyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgSGFuZGxlIHRoaXMgZXZlbnQgZG93biB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eS5cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlTW91c2VEcmFnOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICB2YXIgaXNSaWdodENsaWNrID0gZXZlbnQucHJpbWl0aXZlRXZlbnQuZGV0YWlsLmlzUmlnaHRDbGljaztcblxuICAgICAgICBpZiAoIWdyaWQuaXNDZWxsU2VsZWN0aW9uKCkgfHwgaXNSaWdodENsaWNrIHx8ICF0aGlzLmRyYWdnaW5nKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZU1vdXNlRHJhZyhncmlkLCBldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIHZhciBudW1GaXhlZENvbHVtbnMgPSBncmlkLmdldEZpeGVkQ29sdW1uQ291bnQoKTtcbiAgICAgICAgICAgIHZhciBudW1GaXhlZFJvd3MgPSBncmlkLmdldEZpeGVkUm93Q291bnQoKTtcblxuICAgICAgICAgICAgdmFyIGNlbGwgPSBldmVudC5ncmlkQ2VsbDtcbiAgICAgICAgICAgIHZhciB2aWV3Q2VsbCA9IGV2ZW50LnZpZXdQb2ludDtcbiAgICAgICAgICAgIHZhciBkeCA9IGNlbGwueDtcbiAgICAgICAgICAgIHZhciBkeSA9IGNlbGwueTtcblxuICAgICAgICAgICAgLy9pZiB3ZSBhcmUgaW4gdGhlIGZpeGVkIGFyZWEgZG8gbm90IGFwcGx5IHRoZSBzY3JvbGwgdmFsdWVzXG4gICAgICAgICAgICAvL2NoZWNrIGJvdGggeCBhbmQgeSB2YWx1ZXMgaW5kZXBlbmRlbnRseVxuICAgICAgICAgICAgaWYgKHZpZXdDZWxsLnggPCBudW1GaXhlZENvbHVtbnMpIHtcbiAgICAgICAgICAgICAgICBkeCA9IHZpZXdDZWxsLng7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh2aWV3Q2VsbC55IDwgbnVtRml4ZWRSb3dzKSB7XG4gICAgICAgICAgICAgICAgZHkgPSB2aWV3Q2VsbC55O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZENlbGwgPSBncmlkLm5ld1BvaW50KGR4LCBkeSk7XG5cbiAgICAgICAgICAgIHZhciBwcmltRXZlbnQgPSBldmVudC5wcmltaXRpdmVFdmVudDtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudERyYWcgPSBwcmltRXZlbnQuZGV0YWlsLm1vdXNlO1xuICAgICAgICAgICAgdGhpcy5sYXN0RHJhZ0NlbGwgPSBkQ2VsbDtcblxuICAgICAgICAgICAgdGhpcy5jaGVja0RyYWdTY3JvbGwoZ3JpZCwgdGhpcy5jdXJyZW50RHJhZyk7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZU1vdXNlRHJhZ0NlbGxTZWxlY3Rpb24oZ3JpZCwgZENlbGwsIHByaW1FdmVudC5kZXRhaWwua2V5cyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgSGFuZGxlIHRoaXMgZXZlbnQgZG93biB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eS5cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlS2V5RG93bjogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgdmFyIGhhbmRsZXI7XG4gICAgICAgIGlmICgoaGFuZGxlciA9IHRoaXNbJ2hhbmRsZScgKyBldmVudC5kZXRhaWwuY2hhcl0pKSB7XG4gICAgICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgZ3JpZCwgZXZlbnQuZGV0YWlsKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVLZXlEb3duKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbFNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBIYW5kbGUgYSBtb3VzZWRyYWcgc2VsZWN0aW9uLlxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1vdXNlIC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBrZXlzIC0gYXJyYXkgb2YgdGhlIGtleXMgdGhhdCBhcmUgY3VycmVudGx5IHByZXNzZWQgZG93blxuICAgICAqL1xuICAgIGhhbmRsZU1vdXNlRHJhZ0NlbGxTZWxlY3Rpb246IGZ1bmN0aW9uKGdyaWQsIGdyaWRDZWxsLCBrZXlzKSB7XG5cbiAgICAgICAgdmFyIGhlYWRlclJvd0NvdW50ID0gZ3JpZC5iZWhhdmlvci5nZXRIZWFkZXJSb3dDb3VudCgpO1xuICAgICAgICB2YXIgaGVhZGVyQ29sdW1uQ291bnQgPSBncmlkLmJlaGF2aW9yLmdldEhlYWRlckNvbHVtbkNvdW50KCk7XG4gICAgICAgIHZhciB4ID0gZ3JpZENlbGwueDtcbiAgICAgICAgdmFyIHkgPSBncmlkQ2VsbC55O1xuICAgICAgICB4ID0gTWF0aC5tYXgoaGVhZGVyQ29sdW1uQ291bnQsIHgpO1xuICAgICAgICB5ID0gTWF0aC5tYXgoaGVhZGVyUm93Q291bnQsIHkpO1xuXG4gICAgICAgIHZhciBwcmV2aW91c0RyYWdFeHRlbnQgPSBncmlkLmdldERyYWdFeHRlbnQoKTtcbiAgICAgICAgdmFyIG1vdXNlRG93biA9IGdyaWQuZ2V0TW91c2VEb3duKCk7XG5cbiAgICAgICAgLy92YXIgc2Nyb2xsaW5nTm93ID0gZ3JpZC5pc1Njcm9sbGluZ05vdygpO1xuXG4gICAgICAgIHZhciBuZXdYID0geCAtIG1vdXNlRG93bi54O1xuICAgICAgICB2YXIgbmV3WSA9IHkgLSBtb3VzZURvd24ueTtcblxuICAgICAgICBpZiAocHJldmlvdXNEcmFnRXh0ZW50LnggPT09IG5ld1ggJiYgcHJldmlvdXNEcmFnRXh0ZW50LnkgPT09IG5ld1kpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGdyaWQuY2xlYXJNb3N0UmVjZW50U2VsZWN0aW9uKCk7XG5cbiAgICAgICAgZ3JpZC5zZWxlY3QobW91c2VEb3duLngsIG1vdXNlRG93bi55LCBuZXdYLCBuZXdZKTtcbiAgICAgICAgZ3JpZC5zZXREcmFnRXh0ZW50KGdyaWQubmV3UG9pbnQobmV3WCwgbmV3WSkpO1xuXG4gICAgICAgIGdyaWQucmVwYWludCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbFNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyB0aGlzIGNoZWNrcyB3aGlsZSB3ZXJlIGRyYWdnaW5nIGlmIHdlIGdvIG91dHNpZGUgdGhlIHZpc2libGUgYm91bmRzLCBpZiBzbywga2ljayBvZmYgdGhlIGV4dGVybmFsIGF1dG9zY3JvbGwgY2hlY2sgZnVuY3Rpb24gKGFib3ZlKVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1vdXNlIC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBjaGVja0RyYWdTY3JvbGw6IGZ1bmN0aW9uKGdyaWQsIG1vdXNlKSB7XG4gICAgICAgIGlmICghZ3JpZC5yZXNvbHZlUHJvcGVydHkoJ3Njcm9sbGluZ0VuYWJsZWQnKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBiID0gZ3JpZC5nZXREYXRhQm91bmRzKCk7XG4gICAgICAgIHZhciBpbnNpZGUgPSBiLmNvbnRhaW5zKG1vdXNlKTtcbiAgICAgICAgaWYgKGluc2lkZSkge1xuICAgICAgICAgICAgaWYgKGdyaWQuaXNTY3JvbGxpbmdOb3coKSkge1xuICAgICAgICAgICAgICAgIGdyaWQuc2V0U2Nyb2xsaW5nTm93KGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghZ3JpZC5pc1Njcm9sbGluZ05vdygpKSB7XG4gICAgICAgICAgICBncmlkLnNldFNjcm9sbGluZ05vdyh0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsRHJhZyhncmlkKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbFNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyB0aGlzIGZ1bmN0aW9uIG1ha2VzIHN1cmUgdGhhdCB3aGlsZSB3ZSBhcmUgZHJhZ2dpbmcgb3V0c2lkZSBvZiB0aGUgZ3JpZCB2aXNpYmxlIGJvdW5kcywgd2Ugc3Jjcm9sbCBhY2NvcmRpbmdseVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICovXG4gICAgc2Nyb2xsRHJhZzogZnVuY3Rpb24oZ3JpZCkge1xuXG4gICAgICAgIGlmICghZ3JpZC5pc1Njcm9sbGluZ05vdygpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZHJhZ1N0YXJ0ZWRJbkhlYWRlckFyZWEgPSBncmlkLmlzTW91c2VEb3duSW5IZWFkZXJBcmVhKCk7XG4gICAgICAgIHZhciBsYXN0RHJhZ0NlbGwgPSB0aGlzLmxhc3REcmFnQ2VsbDtcbiAgICAgICAgdmFyIGIgPSBncmlkLmdldERhdGFCb3VuZHMoKTtcbiAgICAgICAgdmFyIHhPZmZzZXQgPSAwO1xuICAgICAgICB2YXIgeU9mZnNldCA9IDA7XG5cbiAgICAgICAgdmFyIG51bUZpeGVkQ29sdW1ucyA9IGdyaWQuZ2V0Rml4ZWRDb2x1bW5Db3VudCgpO1xuICAgICAgICB2YXIgbnVtRml4ZWRSb3dzID0gZ3JpZC5nZXRGaXhlZFJvd0NvdW50KCk7XG5cbiAgICAgICAgdmFyIGRyYWdFbmRJbkZpeGVkQXJlYVggPSBsYXN0RHJhZ0NlbGwueCA8IG51bUZpeGVkQ29sdW1ucztcbiAgICAgICAgdmFyIGRyYWdFbmRJbkZpeGVkQXJlYVkgPSBsYXN0RHJhZ0NlbGwueSA8IG51bUZpeGVkUm93cztcblxuICAgICAgICBpZiAoIWRyYWdTdGFydGVkSW5IZWFkZXJBcmVhKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50RHJhZy54IDwgYi5vcmlnaW4ueCkge1xuICAgICAgICAgICAgICAgIHhPZmZzZXQgPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnREcmFnLnkgPCBiLm9yaWdpbi55KSB7XG4gICAgICAgICAgICAgICAgeU9mZnNldCA9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnREcmFnLnggPiBiLm9yaWdpbi54ICsgYi5leHRlbnQueCkge1xuICAgICAgICAgICAgeE9mZnNldCA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY3VycmVudERyYWcueSA+IGIub3JpZ2luLnkgKyBiLmV4dGVudC55KSB7XG4gICAgICAgICAgICB5T2Zmc2V0ID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkcmFnQ2VsbE9mZnNldFggPSB4T2Zmc2V0O1xuICAgICAgICB2YXIgZHJhZ0NlbGxPZmZzZXRZID0geU9mZnNldDtcblxuICAgICAgICBpZiAoZHJhZ0VuZEluRml4ZWRBcmVhWCkge1xuICAgICAgICAgICAgZHJhZ0NlbGxPZmZzZXRYID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkcmFnRW5kSW5GaXhlZEFyZWFZKSB7XG4gICAgICAgICAgICBkcmFnQ2VsbE9mZnNldFkgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5sYXN0RHJhZ0NlbGwgPSBsYXN0RHJhZ0NlbGwucGx1c1hZKGRyYWdDZWxsT2Zmc2V0WCwgZHJhZ0NlbGxPZmZzZXRZKTtcbiAgICAgICAgZ3JpZC5zY3JvbGxCeSh4T2Zmc2V0LCB5T2Zmc2V0KTtcbiAgICAgICAgdGhpcy5oYW5kbGVNb3VzZURyYWdDZWxsU2VsZWN0aW9uKGdyaWQsIGxhc3REcmFnQ2VsbCwgW10pOyAvLyB1cGRhdGUgdGhlIHNlbGVjdGlvblxuICAgICAgICBncmlkLnJlcGFpbnQoKTtcbiAgICAgICAgc2V0VGltZW91dCh0aGlzLnNjcm9sbERyYWcuYmluZCh0aGlzLCBncmlkKSwgMjUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbFNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBleHRlbmQgYSBzZWxlY3Rpb24gb3IgY3JlYXRlIG9uZSBpZiB0aGVyZSBpc250IHlldFxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGdyaWRDZWxsIC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBrZXlzIC0gYXJyYXkgb2YgdGhlIGtleXMgdGhhdCBhcmUgY3VycmVudGx5IHByZXNzZWQgZG93blxuICAgICAqL1xuICAgIGV4dGVuZFNlbGVjdGlvbjogZnVuY3Rpb24oZ3JpZCwgZ3JpZENlbGwsIGtleXMpIHtcbiAgICAgICAgdmFyIGhhc0NUUkwgPSBrZXlzLmluZGV4T2YoJ0NUUkwnKSA+PSAwO1xuICAgICAgICB2YXIgaGFzU0hJRlQgPSBrZXlzLmluZGV4T2YoJ1NISUZUJykgPj0gMDtcbiAgICAgICAgLy8gdmFyIHNjcm9sbFRvcCA9IGdyaWQuZ2V0VlNjcm9sbFZhbHVlKCk7XG4gICAgICAgIC8vIHZhciBzY3JvbGxMZWZ0ID0gZ3JpZC5nZXRIU2Nyb2xsVmFsdWUoKTtcblxuICAgICAgICAvLyB2YXIgbnVtRml4ZWRDb2x1bW5zID0gMDsvL2dyaWQuZ2V0Rml4ZWRDb2x1bW5Db3VudCgpO1xuICAgICAgICAvLyB2YXIgbnVtRml4ZWRSb3dzID0gMDsvL2dyaWQuZ2V0Rml4ZWRSb3dDb3VudCgpO1xuXG4gICAgICAgIHZhciBtb3VzZVBvaW50ID0gZ3JpZC5nZXRNb3VzZURvd24oKTtcbiAgICAgICAgdmFyIHggPSBncmlkQ2VsbC54OyAvLyAtIG51bUZpeGVkQ29sdW1ucyArIHNjcm9sbExlZnQ7XG4gICAgICAgIHZhciB5ID0gZ3JpZENlbGwueTsgLy8gLSBudW1GaXhlZFJvd3MgKyBzY3JvbGxUb3A7XG5cbiAgICAgICAgLy93ZXJlIG91dHNpZGUgb2YgdGhlIGdyaWQgZG8gbm90aGluZ1xuICAgICAgICBpZiAoeCA8IDAgfHwgeSA8IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vd2UgaGF2ZSByZXBlYXRlZCBhIGNsaWNrIGluIHRoZSBzYW1lIHNwb3QgZGVzbGVjdCB0aGUgdmFsdWUgZnJvbSBsYXN0IHRpbWVcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgaGFzQ1RSTCAmJlxuICAgICAgICAgICAgeCA9PT0gbW91c2VQb2ludC54ICYmXG4gICAgICAgICAgICB5ID09PSBtb3VzZVBvaW50LnlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBncmlkLmNsZWFyTW9zdFJlY2VudFNlbGVjdGlvbigpO1xuICAgICAgICAgICAgZ3JpZC5wb3BNb3VzZURvd24oKTtcbiAgICAgICAgICAgIGdyaWQucmVwYWludCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFoYXNDVFJMICYmICFoYXNTSElGVCkge1xuICAgICAgICAgICAgZ3JpZC5jbGVhclNlbGVjdGlvbnMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNTSElGVCkge1xuICAgICAgICAgICAgZ3JpZC5jbGVhck1vc3RSZWNlbnRTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIGdyaWQuc2VsZWN0KG1vdXNlUG9pbnQueCwgbW91c2VQb2ludC55LCB4IC0gbW91c2VQb2ludC54ICsgMSwgeSAtIG1vdXNlUG9pbnQueSArIDEpO1xuICAgICAgICAgICAgZ3JpZC5zZXREcmFnRXh0ZW50KGdyaWQubmV3UG9pbnQoeCAtIG1vdXNlUG9pbnQueCArIDEsIHkgLSBtb3VzZVBvaW50LnkpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdyaWQuc2VsZWN0KHgsIHksIDAsIDApO1xuICAgICAgICAgICAgZ3JpZC5zZXRNb3VzZURvd24oZ3JpZC5uZXdQb2ludCh4LCB5KSk7XG4gICAgICAgICAgICBncmlkLnNldERyYWdFeHRlbnQoZ3JpZC5uZXdQb2ludCgwLCAwKSk7XG4gICAgICAgIH1cbiAgICAgICAgZ3JpZC5yZXBhaW50KCk7XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnRcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqL1xuICAgIGhhbmRsZURPV05TSElGVDogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICB0aGlzLm1vdmVTaGlmdFNlbGVjdChncmlkLCAwLCAxKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnRcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlVVBTSElGVDogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICB0aGlzLm1vdmVTaGlmdFNlbGVjdChncmlkLCAwLCAtMSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZUxFRlRTSElGVDogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICB0aGlzLm1vdmVTaGlmdFNlbGVjdChncmlkLCAtMSwgMCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZVJJR0hUU0hJRlQ6IGZ1bmN0aW9uKGdyaWQpIHtcbiAgICAgICAgdGhpcy5tb3ZlU2hpZnRTZWxlY3QoZ3JpZCwgMSwgMCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZURPV046IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIC8va2VlcCB0aGUgYnJvd3NlciB2aWV3cG9ydCBmcm9tIGF1dG8gc2Nyb2xsaW5nIG9uIGtleSBldmVudFxuICAgICAgICBldmVudC5wcmltaXRpdmVFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIHZhciBjb3VudCA9IHRoaXMuZ2V0QXV0b1Njcm9sbEFjY2VsZXJhdGlvbigpO1xuICAgICAgICB0aGlzLm1vdmVTaW5nbGVTZWxlY3QoZ3JpZCwgMCwgY291bnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbFNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudFxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVVUDogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgLy9rZWVwIHRoZSBicm93c2VyIHZpZXdwb3J0IGZyb20gYXV0byBzY3JvbGxpbmcgb24ga2V5IGV2ZW50XG4gICAgICAgIGV2ZW50LnByaW1pdGl2ZUV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgdmFyIGNvdW50ID0gdGhpcy5nZXRBdXRvU2Nyb2xsQWNjZWxlcmF0aW9uKCk7XG4gICAgICAgIHRoaXMubW92ZVNpbmdsZVNlbGVjdChncmlkLCAwLCAtY291bnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbFNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudFxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVMRUZUOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIHRoaXMubW92ZVNpbmdsZVNlbGVjdChncmlkLCAtMSwgMCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZVJJR0hUOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIHRoaXMubW92ZVNpbmdsZVNlbGVjdChncmlkLCAxLCAwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgSWYgd2UgYXJlIGhvbGRpbmcgZG93biB0aGUgc2FtZSBuYXZpZ2F0aW9uIGtleSwgYWNjZWxlcmF0ZSB0aGUgaW5jcmVtZW50IHdlIHNjcm9sbFxuICAgICAqICMjIyMgcmV0dXJuczogaW50ZWdlclxuICAgICAqL1xuICAgIGdldEF1dG9TY3JvbGxBY2NlbGVyYXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY291bnQgPSAxO1xuICAgICAgICB2YXIgZWxhcHNlZCA9IHRoaXMuZ2V0QXV0b1Njcm9sbER1cmF0aW9uKCkgLyAyMDAwO1xuICAgICAgICBjb3VudCA9IE1hdGgubWF4KDEsIE1hdGguZmxvb3IoZWxhcHNlZCAqIGVsYXBzZWQgKiBlbGFwc2VkICogZWxhcHNlZCkpO1xuICAgICAgICByZXR1cm4gY291bnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHNldCB0aGUgc3RhcnQgdGltZSB0byByaWdodCBub3cgd2hlbiB3ZSBpbml0aWF0ZSBhbiBhdXRvIHNjcm9sbFxuICAgICAqL1xuICAgIHNldEF1dG9TY3JvbGxTdGFydFRpbWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnNiQXV0b1N0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgdXBkYXRlIHRoZSBhdXRvc2Nyb2xsIHN0YXJ0IHRpbWUgaWYgd2UgaGF2ZW4ndCBhdXRvc2Nyb2xsZWQgd2l0aGluIHRoZSBsYXN0IDUwMG1zIG90aGVyd2lzZSB1cGRhdGUgdGhlIGN1cnJlbnQgYXV0b3Njcm9sbCB0aW1lXG4gICAgICovXG4gICAgcGluZ0F1dG9TY3JvbGw6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgaWYgKG5vdyAtIHRoaXMuc2JMYXN0QXV0byA+IDUwMCkge1xuICAgICAgICAgICAgdGhpcy5zZXRBdXRvU2Nyb2xsU3RhcnRUaW1lKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zYkxhc3RBdXRvID0gRGF0ZS5ub3coKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgYW5zd2VyIGhvdyBsb25nIHdlIGhhdmUgYmVlbiBhdXRvIHNjcm9sbGluZ1xuICAgICAqICMjIyMgcmV0dXJuczogaW50ZWdlclxuICAgICAqL1xuICAgIGdldEF1dG9TY3JvbGxEdXJhdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChEYXRlLm5vdygpIC0gdGhpcy5zYkxhc3RBdXRvID4gNTAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRGF0ZS5ub3coKSAtIHRoaXMuc2JBdXRvU3RhcnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIEF1Z21lbnQgdGhlIG1vc3QgcmVjZW50IHNlbGVjdGlvbiBleHRlbnQgYnkgKG9mZnNldFgsb2Zmc2V0WSkgYW5kIHNjcm9sbCBpZiBuZWNlc3NhcnkuXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0WCAtIHggY29vcmRpbmF0ZSB0byBzdGFydCBhdFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRZIC0geSBjb29yZGluYXRlIHRvIHN0YXJ0IGF0XG4gICAgICovXG4gICAgbW92ZVNoaWZ0U2VsZWN0OiBmdW5jdGlvbihncmlkLCBvZmZzZXRYLCBvZmZzZXRZKSB7XG5cbiAgICAgICAgdmFyIG1heENvbHVtbnMgPSBncmlkLmdldENvbHVtbkNvdW50KCkgLSAxO1xuICAgICAgICB2YXIgbWF4Um93cyA9IGdyaWQuZ2V0Um93Q291bnQoKSAtIDE7XG5cbiAgICAgICAgdmFyIG1heFZpZXdhYmxlQ29sdW1ucyA9IGdyaWQuZ2V0VmlzaWJsZUNvbHVtbnMoKSAtIDE7XG4gICAgICAgIHZhciBtYXhWaWV3YWJsZVJvd3MgPSBncmlkLmdldFZpc2libGVSb3dzKCkgLSAxO1xuXG4gICAgICAgIGlmICghZ3JpZC5yZXNvbHZlUHJvcGVydHkoJ3Njcm9sbGluZ0VuYWJsZWQnKSkge1xuICAgICAgICAgICAgbWF4Q29sdW1ucyA9IE1hdGgubWluKG1heENvbHVtbnMsIG1heFZpZXdhYmxlQ29sdW1ucyk7XG4gICAgICAgICAgICBtYXhSb3dzID0gTWF0aC5taW4obWF4Um93cywgbWF4Vmlld2FibGVSb3dzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvcmlnaW4gPSBncmlkLmdldE1vdXNlRG93bigpO1xuICAgICAgICB2YXIgZXh0ZW50ID0gZ3JpZC5nZXREcmFnRXh0ZW50KCk7XG5cbiAgICAgICAgdmFyIG5ld1ggPSBleHRlbnQueCArIG9mZnNldFg7XG4gICAgICAgIHZhciBuZXdZID0gZXh0ZW50LnkgKyBvZmZzZXRZO1xuXG4gICAgICAgIG5ld1ggPSBNYXRoLm1pbihtYXhDb2x1bW5zIC0gb3JpZ2luLngsIE1hdGgubWF4KC1vcmlnaW4ueCwgbmV3WCkpO1xuICAgICAgICBuZXdZID0gTWF0aC5taW4obWF4Um93cyAtIG9yaWdpbi55LCBNYXRoLm1heCgtb3JpZ2luLnksIG5ld1kpKTtcblxuICAgICAgICBncmlkLmNsZWFyTW9zdFJlY2VudFNlbGVjdGlvbigpO1xuICAgICAgICBncmlkLnNlbGVjdChvcmlnaW4ueCwgb3JpZ2luLnksIG5ld1gsIG5ld1kpO1xuXG4gICAgICAgIGdyaWQuc2V0RHJhZ0V4dGVudChncmlkLm5ld1BvaW50KG5ld1gsIG5ld1kpKTtcblxuICAgICAgICBpZiAoZ3JpZC5pbnN1cmVNb2RlbENvbElzVmlzaWJsZShuZXdYICsgb3JpZ2luLngsIG9mZnNldFgpKSB7XG4gICAgICAgICAgICB0aGlzLnBpbmdBdXRvU2Nyb2xsKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdyaWQuaW5zdXJlTW9kZWxSb3dJc1Zpc2libGUobmV3WSArIG9yaWdpbi55LCBvZmZzZXRZKSkge1xuICAgICAgICAgICAgdGhpcy5waW5nQXV0b1Njcm9sbCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZ3JpZC5yZXBhaW50KCk7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgUmVwbGFjZSB0aGUgbW9zdCByZWNlbnQgc2VsZWN0aW9uIHdpdGggYSBzaW5nbGUgY2VsbCBzZWxlY3Rpb24gdGhhdCBpcyBtb3ZlZCAob2Zmc2V0WCxvZmZzZXRZKSBmcm9tIHRoZSBwcmV2aW91cyBzZWxlY3Rpb24gZXh0ZW50LlxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFggLSB4IGNvb3JkaW5hdGUgdG8gc3RhcnQgYXRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0WSAtIHkgY29vcmRpbmF0ZSB0byBzdGFydCBhdFxuICAgICAqL1xuICAgIG1vdmVTaW5nbGVTZWxlY3Q6IGZ1bmN0aW9uKGdyaWQsIG9mZnNldFgsIG9mZnNldFkpIHtcblxuICAgICAgICB2YXIgbWF4Q29sdW1ucyA9IGdyaWQuZ2V0Q29sdW1uQ291bnQoKSAtIDE7XG4gICAgICAgIHZhciBtYXhSb3dzID0gZ3JpZC5nZXRSb3dDb3VudCgpIC0gMTtcblxuICAgICAgICB2YXIgbWF4Vmlld2FibGVDb2x1bW5zID0gZ3JpZC5nZXRWaXNpYmxlQ29sdW1uc0NvdW50KCkgLSAxO1xuICAgICAgICB2YXIgbWF4Vmlld2FibGVSb3dzID0gZ3JpZC5nZXRWaXNpYmxlUm93c0NvdW50KCkgLSAxO1xuXG4gICAgICAgIHZhciBtaW5Sb3dzID0gZ3JpZC5nZXRIZWFkZXJSb3dDb3VudCgpO1xuICAgICAgICB2YXIgbWluQ29scyA9IGdyaWQuZ2V0SGVhZGVyQ29sdW1uQ291bnQoKTtcblxuICAgICAgICBpZiAoIWdyaWQucmVzb2x2ZVByb3BlcnR5KCdzY3JvbGxpbmdFbmFibGVkJykpIHtcbiAgICAgICAgICAgIG1heENvbHVtbnMgPSBNYXRoLm1pbihtYXhDb2x1bW5zLCBtYXhWaWV3YWJsZUNvbHVtbnMpO1xuICAgICAgICAgICAgbWF4Um93cyA9IE1hdGgubWluKG1heFJvd3MsIG1heFZpZXdhYmxlUm93cyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbW91c2VDb3JuZXIgPSBncmlkLmdldE1vdXNlRG93bigpLnBsdXMoZ3JpZC5nZXREcmFnRXh0ZW50KCkpO1xuXG4gICAgICAgIHZhciBuZXdYID0gbW91c2VDb3JuZXIueCArIG9mZnNldFg7XG4gICAgICAgIHZhciBuZXdZID0gbW91c2VDb3JuZXIueSArIG9mZnNldFk7XG5cbiAgICAgICAgbmV3WCA9IE1hdGgubWluKG1heENvbHVtbnMsIE1hdGgubWF4KG1pbkNvbHMsIG5ld1gpKTtcbiAgICAgICAgbmV3WSA9IE1hdGgubWluKG1heFJvd3MsIE1hdGgubWF4KG1pblJvd3MsIG5ld1kpKTtcblxuICAgICAgICBncmlkLmNsZWFyU2VsZWN0aW9ucygpO1xuICAgICAgICBncmlkLnNlbGVjdChuZXdYLCBuZXdZLCAwLCAwKTtcbiAgICAgICAgZ3JpZC5zZXRNb3VzZURvd24oZ3JpZC5uZXdQb2ludChuZXdYLCBuZXdZKSk7XG4gICAgICAgIGdyaWQuc2V0RHJhZ0V4dGVudChncmlkLm5ld1BvaW50KDAsIDApKTtcblxuICAgICAgICBncmlkLnNlbGVjdENlbGxBbmRTY3JvbGxUb01ha2VWaXNpYmxlKG5ld1gsIG5ld1kpO1xuXG4gICAgICAgIC8vIGlmIChncmlkLmluc3VyZU1vZGVsQ29sSXNWaXNpYmxlKG5ld1gsIG9mZnNldFgpKSB7XG4gICAgICAgIC8vICAgICB0aGlzLnBpbmdBdXRvU2Nyb2xsKCk7XG4gICAgICAgIC8vIH1cbiAgICAgICAgLy8gaWYgKGdyaWQuaW5zdXJlTW9kZWxSb3dJc1Zpc2libGUobmV3WSwgb2Zmc2V0WSkpIHtcbiAgICAgICAgLy8gICAgIHRoaXMucGluZ0F1dG9TY3JvbGwoKTtcbiAgICAgICAgLy8gfVxuXG4gICAgICAgIGdyaWQucmVwYWludCgpO1xuXG4gICAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBDZWxsU2VsZWN0aW9uO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRmVhdHVyZSA9IHJlcXVpcmUoJy4vRmVhdHVyZS5qcycpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgRmVhdHVyZVxuICovXG52YXIgQ29sdW1uQXV0b3NpemluZyA9IEZlYXR1cmUuZXh0ZW5kKCdDb2x1bW5BdXRvc2l6aW5nJywge1xuXG4gICAgLyoqXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnQgZG93biB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uQXV0b3NpemluZy5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBoYW5kbGVEb3VibGVDbGljazogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgdmFyIGhlYWRlclJvd0NvdW50ID0gZ3JpZC5nZXRIZWFkZXJSb3dDb3VudCgpO1xuICAgICAgICAvL3ZhciBoZWFkZXJDb2xDb3VudCA9IGdyaWQuZ2V0SGVhZGVyQ29sdW1uQ291bnQoKTtcbiAgICAgICAgdmFyIGdyaWRDZWxsID0gZXZlbnQuZ3JpZENlbGw7XG4gICAgICAgIGlmIChncmlkQ2VsbC55IDw9IGhlYWRlclJvd0NvdW50KSB7XG4gICAgICAgICAgICBncmlkLmF1dG9zaXplQ29sdW1uKGdyaWRDZWxsLngpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZURvdWJsZUNsaWNrKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ29sdW1uQXV0b3NpemluZztcbiIsIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuLyogZ2xvYmFsIHJlcXVlc3RBbmltYXRpb25GcmFtZSAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIFRoaXMgZmVhdHVyZSBpcyByZXNwb25zaWJsZSBmb3IgY29sdW1uIGRyYWcgYW5kIGRyb3AgcmVvcmRlcmluZy5cbi8vIFRoaXMgb2JqZWN0IGlzIGEgbWVzcyBhbmQgZGVzcGVyYXRlbHkgbmVlZHMgYSBjb21wbGV0ZSByZXdyaXRlLi4uLi5cblxudmFyIEZlYXR1cmUgPSByZXF1aXJlKCcuL0ZlYXR1cmUuanMnKTtcblxudmFyIGNvbHVtbkFuaW1hdGlvblRpbWUgPSAxNTA7XG52YXIgZHJhZ2dlcjtcbnZhciBkcmFnZ2VyQ1RYO1xudmFyIGZsb2F0Q29sdW1uO1xudmFyIGZsb2F0Q29sdW1uQ1RYO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgRmVhdHVyZVxuICovXG52YXIgQ29sdW1uTW92aW5nID0gRmVhdHVyZS5leHRlbmQoJ0NvbHVtbk1vdmluZycsIHtcblxuICAgIC8qKlxuICAgICAqIHF1ZXVlIHVwIHRoZSBhbmltYXRpb25zIHRoYXQgbmVlZCB0byBwbGF5IHNvIHRoZXkgYXJlIGRvbmUgc3luY2hyb25vdXNseVxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKiBAbWVtYmVyT2YgQ2VsbE1vdmluZy5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBmbG9hdGVyQW5pbWF0aW9uUXVldWU6IFtdLFxuXG4gICAgLyoqXG4gICAgICogYW0gSSBjdXJyZW50bHkgYXV0byBzY3JvbGxpbmcgcmlnaHRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAbWVtYmVyT2YgQ2VsbE1vdmluZy5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBjb2x1bW5EcmFnQXV0b1Njcm9sbGluZ1JpZ2h0OiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIGFtIEkgY3VycmVudGx5IGF1dG8gc2Nyb2xsaW5nIGxlZnRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAbWVtYmVyT2YgQ2VsbE1vdmluZy5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBjb2x1bW5EcmFnQXV0b1Njcm9sbGluZ0xlZnQ6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogaXMgdGhlIGRyYWcgbWVjaGFuaXNtIGN1cnJlbnRseSBlbmFibGVkIChcImFybWVkXCIpXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQG1lbWJlck9mIENlbGxNb3ZpbmcucHJvdG90eXBlXG4gICAgICovXG4gICAgZHJhZ0FybWVkOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIGFtIEkgZHJhZ2dpbmcgcmlnaHQgbm93XG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQG1lbWJlck9mIENlbGxNb3ZpbmcucHJvdG90eXBlXG4gICAgICovXG4gICAgZHJhZ2dpbmc6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogdGhlIGNvbHVtbiBpbmRleCBvZiB0aGUgY3VycmVudGx5IGRyYWdnZWQgY29sdW1uXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAbWVtYmVyT2YgQ2VsbE1vdmluZy5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBkcmFnQ29sOiAtMSxcblxuICAgIC8qKlxuICAgICAqIGFuIG9mZnNldCB0byBwb3NpdGlvbiB0aGUgZHJhZ2dlZCBpdGVtIGZyb20gdGhlIGN1cnNvclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQG1lbWJlck9mIENlbGxNb3ZpbmcucHJvdG90eXBlXG4gICAgICovXG4gICAgZHJhZ09mZnNldDogMCxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsTW92aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGdpdmUgbWUgYW4gb3Bwb3J0dW5pdHkgdG8gaW5pdGlhbGl6ZSBzdHVmZiBvbiB0aGUgZ3JpZFxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZU9uOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIHRoaXMuaXNGbG9hdGluZ05vdyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmluaXRpYWxpemVBbmltYXRpb25TdXBwb3J0KGdyaWQpO1xuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaW5pdGlhbGl6ZU9uKGdyaWQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsTW92aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGluaXRpYWxpemUgYW5pbWF0aW9uIHN1cHBvcnQgb24gdGhlIGdyaWRcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqL1xuICAgIGluaXRpYWxpemVBbmltYXRpb25TdXBwb3J0OiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIGlmICghZHJhZ2dlcikge1xuICAgICAgICAgICAgZHJhZ2dlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICAgICAgZHJhZ2dlci5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgJzBweCcpO1xuICAgICAgICAgICAgZHJhZ2dlci5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsICcwcHgnKTtcblxuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkcmFnZ2VyKTtcbiAgICAgICAgICAgIGRyYWdnZXJDVFggPSBkcmFnZ2VyLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFmbG9hdENvbHVtbikge1xuICAgICAgICAgICAgZmxvYXRDb2x1bW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICAgIGZsb2F0Q29sdW1uLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCAnMHB4Jyk7XG4gICAgICAgICAgICBmbG9hdENvbHVtbi5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsICcwcHgnKTtcblxuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChmbG9hdENvbHVtbik7XG4gICAgICAgICAgICBmbG9hdENvbHVtbkNUWCA9IGZsb2F0Q29sdW1uLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBnZXRDYW5EcmFnQ3Vyc29yTmFtZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAnLXdlYmtpdC1ncmFiJztcbiAgICB9LFxuXG4gICAgZ2V0RHJhZ2dpbmdDdXJzb3JOYW1lOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICctd2Via2l0LWdyYWJiaW5nJztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxNb3ZpbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnRcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlTW91c2VEcmFnOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuXG4gICAgICAgIHZhciBncmlkQ2VsbCA9IGV2ZW50LmdyaWRDZWxsO1xuICAgICAgICB2YXIgeDtcbiAgICAgICAgLy92YXIgeTtcblxuICAgICAgICB2YXIgZGlzdGFuY2UgPSBNYXRoLmFicyhldmVudC5wcmltaXRpdmVFdmVudC5kZXRhaWwuZHJhZ3N0YXJ0LnggLSBldmVudC5wcmltaXRpdmVFdmVudC5kZXRhaWwubW91c2UueCk7XG5cbiAgICAgICAgaWYgKGRpc3RhbmNlIDwgMTAgfHwgdGhpcy5pc0ZpeGVkQ29sdW1uKGdyaWQsIGV2ZW50KSkge1xuICAgICAgICAgICAgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVNb3VzZURyYWcoZ3JpZCwgZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuaXNIZWFkZXJSb3coZ3JpZCwgZXZlbnQpICYmIHRoaXMuZHJhZ0FybWVkICYmICF0aGlzLmRyYWdnaW5nKSB7XG4gICAgICAgICAgICB0aGlzLmRyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZHJhZ0NvbCA9IGdyaWRDZWxsLng7XG4gICAgICAgICAgICB0aGlzLmRyYWdPZmZzZXQgPSBldmVudC5tb3VzZVBvaW50Lng7XG4gICAgICAgICAgICB0aGlzLmRldGFjaENoYWluKCk7XG4gICAgICAgICAgICB4ID0gZXZlbnQucHJpbWl0aXZlRXZlbnQuZGV0YWlsLm1vdXNlLnggLSB0aGlzLmRyYWdPZmZzZXQ7XG4gICAgICAgICAgICAvL3kgPSBldmVudC5wcmltaXRpdmVFdmVudC5kZXRhaWwubW91c2UueTtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlRHJhZ0NvbHVtbihncmlkLCB4LCB0aGlzLmRyYWdDb2wpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZU1vdXNlRHJhZyhncmlkLCBldmVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5kcmFnZ2luZykge1xuICAgICAgICAgICAgeCA9IGV2ZW50LnByaW1pdGl2ZUV2ZW50LmRldGFpbC5tb3VzZS54IC0gdGhpcy5kcmFnT2Zmc2V0O1xuICAgICAgICAgICAgLy95ID0gZXZlbnQucHJpbWl0aXZlRXZlbnQuZGV0YWlsLm1vdXNlLnk7XG4gICAgICAgICAgICB0aGlzLmRyYWdDb2x1bW4oZ3JpZCwgeCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxNb3ZpbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnRcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlTW91c2VEb3duOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAoZ3JpZC5iZWhhdmlvci5pc0NvbHVtblJlb3JkZXJhYmxlKCkgJiYgIXRoaXMuaXNGaXhlZENvbHVtbihncmlkLCBldmVudCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzSGVhZGVyUm93KGdyaWQsIGV2ZW50KSAmJiBldmVudC5ncmlkQ2VsbC54ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZHJhZ0FybWVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnNvciA9IHRoaXMuZ2V0RHJhZ2dpbmdDdXJzb3JOYW1lKCk7XG4gICAgICAgICAgICAgICAgZ3JpZC5jbGVhclNlbGVjdGlvbnMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlTW91c2VEb3duKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbE1vdmluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudFxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVNb3VzZVVwOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICAvL3ZhciBjb2wgPSBldmVudC5ncmlkQ2VsbC54O1xuICAgICAgICBpZiAodGhpcy5kcmFnZ2luZykge1xuICAgICAgICAgICAgdGhpcy5jdXJzb3IgPSBudWxsO1xuICAgICAgICAgICAgLy9kZWxheSBoZXJlIHRvIGdpdmUgb3RoZXIgZXZlbnRzIGEgY2hhbmNlIHRvIGJlIGRyb3BwZWRcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuZW5kRHJhZ0NvbHVtbihncmlkKTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5hdHRhY2hDaGFpbigpO1xuICAgICAgICAgICAgfSwgMjAwKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRyYWdDb2wgPSAtMTtcbiAgICAgICAgdGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRyYWdBcm1lZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmN1cnNvciA9IG51bGw7XG4gICAgICAgIGdyaWQucmVwYWludCgpO1xuXG4gICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVNb3VzZVVwKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsTW92aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZU1vdXNlTW92ZTogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcblxuICAgICAgICBpZiAoIXRoaXMuZHJhZ2dpbmcgJiYgZXZlbnQubW91c2VQb2ludC55IDwgNSAmJiBldmVudC52aWV3UG9pbnQueSA9PT0gMCAmJiAhdGhpcy5pc0ZpeGVkQ29sdW1uKGdyaWQsIGV2ZW50KSkge1xuICAgICAgICAgICAgdGhpcy5jdXJzb3IgPSB0aGlzLmdldENhbkRyYWdDdXJzb3JOYW1lKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmN1cnNvciA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlTW91c2VNb3ZlKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmlzSGVhZGVyUm93KGdyaWQsIGV2ZW50KSAmJiB0aGlzLmRyYWdnaW5nKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnNvciA9IHRoaXMuZ2V0RHJhZ2dpbmdDdXJzb3JOYW1lKCk7IC8vbW92ZSc7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxNb3ZpbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgdGhpcyBpcyB0aGUgbWFpbiBldmVudCBoYW5kbGVyIHRoYXQgbWFuYWdlcyB0aGUgZHJhZ2dpbmcgb2YgdGhlIGNvbHVtblxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtib29sZWFufSBkcmFnZ2VkVG9UaGVSaWdodCAtIGFyZSB3ZSBtb3ZpbmcgdG8gdGhlIHJpZ2h0XG4gICAgICovXG4gICAgZmxvYXRDb2x1bW5UbzogZnVuY3Rpb24oZ3JpZCwgZHJhZ2dlZFRvVGhlUmlnaHQpIHtcbiAgICAgICAgdGhpcy5mbG9hdGluZ05vdyA9IHRydWU7XG5cbiAgICAgICAgdmFyIHJlbmRlcmVyID0gZ3JpZC5nZXRSZW5kZXJlcigpO1xuICAgICAgICB2YXIgY29sRWRnZXMgPSByZW5kZXJlci5nZXRDb2x1bW5FZGdlcygpO1xuICAgICAgICB2YXIgc2Nyb2xsTGVmdCA9IGdyaWQuZ2V0SFNjcm9sbFZhbHVlKCk7XG4gICAgICAgIHZhciBmbG9hdGVySW5kZXggPSBncmlkLnJlbmRlck92ZXJyaWRlc0NhY2hlLmZsb2F0ZXIuY29sdW1uSW5kZXg7XG4gICAgICAgIHZhciBkcmFnZ2VySW5kZXggPSBncmlkLnJlbmRlck92ZXJyaWRlc0NhY2hlLmRyYWdnZXIuY29sdW1uSW5kZXg7XG4gICAgICAgIHZhciBoZHBpcmF0aW8gPSBncmlkLnJlbmRlck92ZXJyaWRlc0NhY2hlLmRyYWdnZXIuaGRwaXJhdGlvO1xuXG4gICAgICAgIHZhciBkcmFnZ2VyU3RhcnRYO1xuICAgICAgICB2YXIgZmxvYXRlclN0YXJ0WDtcbiAgICAgICAgdmFyIGZpeGVkQ29sdW1uQ291bnQgPSBncmlkLmdldEZpeGVkQ29sdW1uQ291bnQoKTtcbiAgICAgICAgdmFyIGRyYWdnZXJXaWR0aCA9IGdyaWQuZ2V0Q29sdW1uV2lkdGgoZHJhZ2dlckluZGV4KTtcbiAgICAgICAgdmFyIGZsb2F0ZXJXaWR0aCA9IGdyaWQuZ2V0Q29sdW1uV2lkdGgoZmxvYXRlckluZGV4KTtcblxuICAgICAgICB2YXIgbWF4ID0gZ3JpZC5nZXRWaXNpYmxlQ29sdW1uc0NvdW50KCk7XG5cbiAgICAgICAgdmFyIGRvZmZzZXQgPSAwO1xuICAgICAgICB2YXIgZm9mZnNldCA9IDA7XG5cbiAgICAgICAgaWYgKGRyYWdnZXJJbmRleCA+PSBmaXhlZENvbHVtbkNvdW50KSB7XG4gICAgICAgICAgICBkb2Zmc2V0ID0gc2Nyb2xsTGVmdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmxvYXRlckluZGV4ID49IGZpeGVkQ29sdW1uQ291bnQpIHtcbiAgICAgICAgICAgIGZvZmZzZXQgPSBzY3JvbGxMZWZ0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRyYWdnZWRUb1RoZVJpZ2h0KSB7XG4gICAgICAgICAgICBkcmFnZ2VyU3RhcnRYID0gY29sRWRnZXNbTWF0aC5taW4obWF4LCBkcmFnZ2VySW5kZXggLSBkb2Zmc2V0KV07XG4gICAgICAgICAgICBmbG9hdGVyU3RhcnRYID0gY29sRWRnZXNbTWF0aC5taW4obWF4LCBmbG9hdGVySW5kZXggLSBmb2Zmc2V0KV07XG5cbiAgICAgICAgICAgIGdyaWQucmVuZGVyT3ZlcnJpZGVzQ2FjaGUuZHJhZ2dlci5zdGFydFggPSAoZHJhZ2dlclN0YXJ0WCArIGZsb2F0ZXJXaWR0aCkgKiBoZHBpcmF0aW87XG4gICAgICAgICAgICBncmlkLnJlbmRlck92ZXJyaWRlc0NhY2hlLmZsb2F0ZXIuc3RhcnRYID0gZHJhZ2dlclN0YXJ0WCAqIGhkcGlyYXRpbztcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZmxvYXRlclN0YXJ0WCA9IGNvbEVkZ2VzW01hdGgubWluKG1heCwgZmxvYXRlckluZGV4IC0gZm9mZnNldCldO1xuICAgICAgICAgICAgZHJhZ2dlclN0YXJ0WCA9IGZsb2F0ZXJTdGFydFggKyBkcmFnZ2VyV2lkdGg7XG5cbiAgICAgICAgICAgIGdyaWQucmVuZGVyT3ZlcnJpZGVzQ2FjaGUuZHJhZ2dlci5zdGFydFggPSBmbG9hdGVyU3RhcnRYICogaGRwaXJhdGlvO1xuICAgICAgICAgICAgZ3JpZC5yZW5kZXJPdmVycmlkZXNDYWNoZS5mbG9hdGVyLnN0YXJ0WCA9IGRyYWdnZXJTdGFydFggKiBoZHBpcmF0aW87XG4gICAgICAgIH1cbiAgICAgICAgZ3JpZC5zd2FwQ29sdW1ucyhkcmFnZ2VySW5kZXgsIGZsb2F0ZXJJbmRleCk7XG4gICAgICAgIGdyaWQucmVuZGVyT3ZlcnJpZGVzQ2FjaGUuZHJhZ2dlci5jb2x1bW5JbmRleCA9IGZsb2F0ZXJJbmRleDtcbiAgICAgICAgZ3JpZC5yZW5kZXJPdmVycmlkZXNDYWNoZS5mbG9hdGVyLmNvbHVtbkluZGV4ID0gZHJhZ2dlckluZGV4O1xuXG5cbiAgICAgICAgdGhpcy5mbG9hdGVyQW5pbWF0aW9uUXVldWUudW5zaGlmdCh0aGlzLmRvQ29sdW1uTW92ZUFuaW1hdGlvbihncmlkLCBmbG9hdGVyU3RhcnRYLCBkcmFnZ2VyU3RhcnRYKSk7XG5cbiAgICAgICAgdGhpcy5kb0Zsb2F0ZXJBbmltYXRpb24oZ3JpZCk7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxNb3ZpbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgbWFuaWZlc3QgdGhlIGNvbHVtbiBkcmFnIGFuZCBkcm9wIGFuaW1hdGlvblxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGZsb2F0ZXJTdGFydFggLSB0aGUgeCBzdGFydCBjb29yZGluYXRlIG9mIHRoZSBjb2x1bW4gdW5kZXJuZWF0aCB0aGF0IGZsb2F0cyBiZWhpbmQgdGhlIGRyYWdnZWQgY29sdW1uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRyYWdnZXJTdGFydFggLSB0aGUgeCBzdGFydCBjb29yZGluYXRlIG9mIHRoZSBkcmFnZ2VkIGNvbHVtblxuICAgICAqL1xuICAgIGRvQ29sdW1uTW92ZUFuaW1hdGlvbjogZnVuY3Rpb24oZ3JpZCwgZmxvYXRlclN0YXJ0WCwgZHJhZ2dlclN0YXJ0WCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBkID0gZmxvYXRDb2x1bW47XG4gICAgICAgICAgICBkLnN0eWxlLmRpc3BsYXkgPSAnaW5saW5lJztcbiAgICAgICAgICAgIHNlbGYuc2V0Q3Jvc3NCcm93c2VyUHJvcGVydHkoZCwgJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIGZsb2F0ZXJTdGFydFggKyAncHgsICcgKyAwICsgJ3B4KScpO1xuXG4gICAgICAgICAgICAvL2Quc3R5bGUud2Via2l0LXdlYmtpdC1UcmFuc2Zvcm0gPSAndHJhbnNsYXRlKCcgKyBmbG9hdGVyU3RhcnRYICsgJ3B4LCAnICsgMCArICdweCknO1xuICAgICAgICAgICAgLy9kLnN0eWxlLndlYmtpdC13ZWJraXQtVHJhbnNmb3JtID0gJ3RyYW5zbGF0ZSgnICsgZmxvYXRlclN0YXJ0WCArICdweCwgJyArIDAgKyAncHgpJztcblxuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHNlbGYuc2V0Q3Jvc3NCcm93c2VyUHJvcGVydHkoZCwgJ3RyYW5zaXRpb24nLCAoc2VsZi5pc1dlYmtpdCA/ICctd2Via2l0LScgOiAnJykgKyAndHJhbnNmb3JtICcgKyBjb2x1bW5BbmltYXRpb25UaW1lICsgJ21zIGVhc2UnKTtcbiAgICAgICAgICAgICAgICBzZWxmLnNldENyb3NzQnJvd3NlclByb3BlcnR5KGQsICd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyBkcmFnZ2VyU3RhcnRYICsgJ3B4LCAnICsgLTIgKyAncHgpJyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGdyaWQucmVwYWludCgpO1xuICAgICAgICAgICAgLy9uZWVkIHRvIGNoYW5nZSB0aGlzIHRvIGtleSBmcmFtZXNcblxuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnNldENyb3NzQnJvd3NlclByb3BlcnR5KGQsICd0cmFuc2l0aW9uJywgJycpO1xuICAgICAgICAgICAgICAgIGdyaWQucmVuZGVyT3ZlcnJpZGVzQ2FjaGUuZmxvYXRlciA9IG51bGw7XG4gICAgICAgICAgICAgICAgZ3JpZC5yZXBhaW50KCk7XG4gICAgICAgICAgICAgICAgc2VsZi5kb0Zsb2F0ZXJBbmltYXRpb24oZ3JpZCk7XG4gICAgICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBkLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuaXNGbG9hdGluZ05vdyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgY29sdW1uQW5pbWF0aW9uVGltZSArIDUwKTtcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxNb3ZpbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgbWFuaWZlc3QgdGhlIGZsb2F0ZXIgYW5pbWF0aW9uXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKi9cbiAgICBkb0Zsb2F0ZXJBbmltYXRpb246IGZ1bmN0aW9uKGdyaWQpIHtcbiAgICAgICAgaWYgKHRoaXMuZmxvYXRlckFuaW1hdGlvblF1ZXVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5mbG9hdGluZ05vdyA9IGZhbHNlO1xuICAgICAgICAgICAgZ3JpZC5yZXBhaW50KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFuaW1hdGlvbiA9IHRoaXMuZmxvYXRlckFuaW1hdGlvblF1ZXVlLnBvcCgpO1xuICAgICAgICBhbmltYXRpb24oKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxNb3ZpbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgY3JlYXRlIHRoZSBmbG9hdCBjb2x1bW4gYXQgY29sdW1uSW5kZXggdW5kZXJuZWF0aCB0aGUgZHJhZ2dlZCBjb2x1bW5cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2x1bW5JbmRleCAtIHRoZSBpbmRleCBvZiB0aGUgY29sdW1uIHRoYXQgd2lsbCBiZSBmbG9hdGluZ1xuICAgICAqL1xuICAgIGNyZWF0ZUZsb2F0Q29sdW1uOiBmdW5jdGlvbihncmlkLCBjb2x1bW5JbmRleCkge1xuXG4gICAgICAgIHZhciBmaXhlZENvbHVtbkNvdW50ID0gZ3JpZC5nZXRGaXhlZENvbHVtbkNvdW50KCk7XG4gICAgICAgIHZhciBzY3JvbGxMZWZ0ID0gZ3JpZC5nZXRIU2Nyb2xsVmFsdWUoKTtcblxuICAgICAgICBpZiAoY29sdW1uSW5kZXggPCBmaXhlZENvbHVtbkNvdW50KSB7XG4gICAgICAgICAgICBzY3JvbGxMZWZ0ID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZW5kZXJlciA9IGdyaWQuZ2V0UmVuZGVyZXIoKTtcbiAgICAgICAgdmFyIGNvbHVtbkVkZ2VzID0gcmVuZGVyZXIuZ2V0Q29sdW1uRWRnZXMoKTtcblxuICAgICAgICB2YXIgY29sdW1uV2lkdGggPSBncmlkLmdldENvbHVtbldpZHRoKGNvbHVtbkluZGV4KTtcbiAgICAgICAgdmFyIGNvbEhlaWdodCA9IGdyaWQuZGl2LmNsaWVudEhlaWdodDtcbiAgICAgICAgdmFyIGQgPSBmbG9hdENvbHVtbjtcbiAgICAgICAgdmFyIHN0eWxlID0gZC5zdHlsZTtcbiAgICAgICAgdmFyIGxvY2F0aW9uID0gZ3JpZC5kaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgICAgc3R5bGUudG9wID0gKGxvY2F0aW9uLnRvcCAtIDIpICsgJ3B4JztcbiAgICAgICAgc3R5bGUubGVmdCA9IGxvY2F0aW9uLmxlZnQgKyAncHgnO1xuICAgICAgICBzdHlsZS5wb3NpdGlvbiA9ICdmaXhlZCc7XG5cbiAgICAgICAgdmFyIGhkcGlSYXRpbyA9IGdyaWQuZ2V0SGlEUEkoZmxvYXRDb2x1bW5DVFgpO1xuXG4gICAgICAgIGQuc2V0QXR0cmlidXRlKCd3aWR0aCcsIE1hdGgucm91bmQoY29sdW1uV2lkdGggKiBoZHBpUmF0aW8pICsgJ3B4Jyk7XG4gICAgICAgIGQuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCBNYXRoLnJvdW5kKGNvbEhlaWdodCAqIGhkcGlSYXRpbykgKyAncHgnKTtcbiAgICAgICAgc3R5bGUuYm94U2hhZG93ID0gJzAgMTBweCAyMHB4IHJnYmEoMCwwLDAsMC4xOSksIDAgNnB4IDZweCByZ2JhKDAsMCwwLDAuMjMpJztcbiAgICAgICAgc3R5bGUud2lkdGggPSBjb2x1bW5XaWR0aCArICdweCc7IC8vTWF0aC5yb3VuZChjb2x1bW5XaWR0aCAvIGhkcGlSYXRpbykgKyAncHgnO1xuICAgICAgICBzdHlsZS5oZWlnaHQgPSBjb2xIZWlnaHQgKyAncHgnOyAvL01hdGgucm91bmQoY29sSGVpZ2h0IC8gaGRwaVJhdGlvKSArICdweCc7XG4gICAgICAgIHN0eWxlLmJvcmRlclRvcCA9ICcxcHggc29saWQgJyArIHJlbmRlcmVyLnJlc29sdmVQcm9wZXJ0eSgnbGluZUNvbG9yJyk7XG4gICAgICAgIHN0eWxlLmJhY2tncm91bmRDb2xvciA9IHJlbmRlcmVyLnJlc29sdmVQcm9wZXJ0eSgnYmFja2dyb3VuZENvbG9yJyk7XG5cbiAgICAgICAgdmFyIHN0YXJ0WCA9IGNvbHVtbkVkZ2VzW2NvbHVtbkluZGV4IC0gc2Nyb2xsTGVmdF07XG4gICAgICAgIHN0YXJ0WCA9IHN0YXJ0WCAqIGhkcGlSYXRpbztcblxuICAgICAgICBmbG9hdENvbHVtbkNUWC5zY2FsZShoZHBpUmF0aW8sIGhkcGlSYXRpbyk7XG5cbiAgICAgICAgZ3JpZC5yZW5kZXJPdmVycmlkZXNDYWNoZS5mbG9hdGVyID0ge1xuICAgICAgICAgICAgY29sdW1uSW5kZXg6IGNvbHVtbkluZGV4LFxuICAgICAgICAgICAgY3R4OiBmbG9hdENvbHVtbkNUWCxcbiAgICAgICAgICAgIHN0YXJ0WDogc3RhcnRYLFxuICAgICAgICAgICAgd2lkdGg6IGNvbHVtbldpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBjb2xIZWlnaHQsXG4gICAgICAgICAgICBoZHBpcmF0aW86IGhkcGlSYXRpb1xuICAgICAgICB9O1xuXG4gICAgICAgIHN0eWxlLnpJbmRleCA9ICc0JztcbiAgICAgICAgdGhpcy5zZXRDcm9zc0Jyb3dzZXJQcm9wZXJ0eShkLCAndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgc3RhcnRYICsgJ3B4LCAnICsgLTIgKyAncHgpJyk7XG4gICAgICAgIHN0eWxlLmN1cnNvciA9IHRoaXMuZ2V0RHJhZ2dpbmdDdXJzb3JOYW1lKCk7XG4gICAgICAgIGdyaWQucmVwYWludCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbE1vdmluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyB1dGlsaXR5IGZ1bmN0aW9uIGZvciBzZXR0aW5nIGNyb3NzIGJyb3dzZXIgY3NzIHByb3BlcnRpZXNcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IC0gZGVzY3JpcHRvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSAtIHRoZSBwcm9wZXJ0eVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSAtIHRoZSB2YWx1ZSB0byBhc3NpZ25cbiAgICAgKi9cbiAgICBzZXRDcm9zc0Jyb3dzZXJQcm9wZXJ0eTogZnVuY3Rpb24oZWxlbWVudCwgcHJvcGVydHksIHZhbHVlKSB7XG4gICAgICAgIHZhciB1UHJvcGVydHkgPSBwcm9wZXJ0eVswXS50b1VwcGVyQ2FzZSgpICsgcHJvcGVydHkuc3Vic3RyKDEpO1xuICAgICAgICB0aGlzLnNldFByb3AoZWxlbWVudCwgJ3dlYmtpdCcgKyB1UHJvcGVydHksIHZhbHVlKTtcbiAgICAgICAgdGhpcy5zZXRQcm9wKGVsZW1lbnQsICdNb3onICsgdVByb3BlcnR5LCB2YWx1ZSk7XG4gICAgICAgIHRoaXMuc2V0UHJvcChlbGVtZW50LCAnbXMnICsgdVByb3BlcnR5LCB2YWx1ZSk7XG4gICAgICAgIHRoaXMuc2V0UHJvcChlbGVtZW50LCAnTycgKyB1UHJvcGVydHksIHZhbHVlKTtcbiAgICAgICAgdGhpcy5zZXRQcm9wKGVsZW1lbnQsIHByb3BlcnR5LCB2YWx1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsTW92aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHV0aWxpdHkgZnVuY3Rpb24gZm9yIHNldHRpbmcgcHJvcGVydGllcyBvbiBIVE1MRWxlbWVudHNcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IC0gZGVzY3JpcHRvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSAtIHRoZSBwcm9wZXJ0eVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSAtIHRoZSB2YWx1ZSB0byBhc3NpZ25cbiAgICAgKi9cbiAgICBzZXRQcm9wOiBmdW5jdGlvbihlbGVtZW50LCBwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHByb3BlcnR5IGluIGVsZW1lbnQuc3R5bGUpIHtcbiAgICAgICAgICAgIGVsZW1lbnQuc3R5bGVbcHJvcGVydHldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxNb3ZpbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgY3JlYXRlIHRoZSBkcmFnZ2VkIGNvbHVtbiBhdCBjb2x1bW5JbmRleCBhYm92ZSB0aGUgZmxvYXRlZCBjb2x1bW5cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gdGhlIHN0YXJ0IHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbHVtbkluZGV4IC0gdGhlIGluZGV4IG9mIHRoZSBjb2x1bW4gdGhhdCB3aWxsIGJlIGZsb2F0aW5nXG4gICAgICovXG4gICAgY3JlYXRlRHJhZ0NvbHVtbjogZnVuY3Rpb24oZ3JpZCwgeCwgY29sdW1uSW5kZXgpIHtcblxuICAgICAgICB2YXIgZml4ZWRDb2x1bW5Db3VudCA9IGdyaWQuZ2V0Rml4ZWRDb2x1bW5Db3VudCgpO1xuICAgICAgICB2YXIgc2Nyb2xsTGVmdCA9IGdyaWQuZ2V0SFNjcm9sbFZhbHVlKCk7XG5cbiAgICAgICAgaWYgKGNvbHVtbkluZGV4IDwgZml4ZWRDb2x1bW5Db3VudCkge1xuICAgICAgICAgICAgc2Nyb2xsTGVmdCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVuZGVyZXIgPSBncmlkLmdldFJlbmRlcmVyKCk7XG4gICAgICAgIHZhciBjb2x1bW5FZGdlcyA9IHJlbmRlcmVyLmdldENvbHVtbkVkZ2VzKCk7XG4gICAgICAgIHZhciBoZHBpUmF0aW8gPSBncmlkLmdldEhpRFBJKGRyYWdnZXJDVFgpO1xuICAgICAgICB2YXIgY29sdW1uV2lkdGggPSBncmlkLmdldENvbHVtbldpZHRoKGNvbHVtbkluZGV4KTtcbiAgICAgICAgdmFyIGNvbEhlaWdodCA9IGdyaWQuZGl2LmNsaWVudEhlaWdodDtcbiAgICAgICAgdmFyIGQgPSBkcmFnZ2VyO1xuICAgICAgICB2YXIgbG9jYXRpb24gPSBncmlkLmRpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdmFyIHN0eWxlID0gZC5zdHlsZTtcblxuICAgICAgICBzdHlsZS50b3AgPSBsb2NhdGlvbi50b3AgKyAncHgnO1xuICAgICAgICBzdHlsZS5sZWZ0ID0gbG9jYXRpb24ubGVmdCArICdweCc7XG4gICAgICAgIHN0eWxlLnBvc2l0aW9uID0gJ2ZpeGVkJztcbiAgICAgICAgc3R5bGUub3BhY2l0eSA9IDAuODU7XG4gICAgICAgIHN0eWxlLmJveFNoYWRvdyA9ICcwIDE5cHggMzhweCByZ2JhKDAsMCwwLDAuMzApLCAwIDE1cHggMTJweCByZ2JhKDAsMCwwLDAuMjIpJztcbiAgICAgICAgLy9zdHlsZS56SW5kZXggPSAxMDA7XG4gICAgICAgIHN0eWxlLmJvcmRlclRvcCA9ICcxcHggc29saWQgJyArIHJlbmRlcmVyLnJlc29sdmVQcm9wZXJ0eSgnbGluZUNvbG9yJyk7XG4gICAgICAgIHN0eWxlLmJhY2tncm91bmRDb2xvciA9IGdyaWQucmVuZGVyZXIucmVzb2x2ZVByb3BlcnR5KCdiYWNrZ3JvdW5kQ29sb3InKTtcblxuICAgICAgICBkLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCBNYXRoLnJvdW5kKGNvbHVtbldpZHRoICogaGRwaVJhdGlvKSArICdweCcpO1xuICAgICAgICBkLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgTWF0aC5yb3VuZChjb2xIZWlnaHQgKiBoZHBpUmF0aW8pICsgJ3B4Jyk7XG5cbiAgICAgICAgc3R5bGUud2lkdGggPSBjb2x1bW5XaWR0aCArICdweCc7IC8vTWF0aC5yb3VuZChjb2x1bW5XaWR0aCAvIGhkcGlSYXRpbykgKyAncHgnO1xuICAgICAgICBzdHlsZS5oZWlnaHQgPSBjb2xIZWlnaHQgKyAncHgnOyAvL01hdGgucm91bmQoY29sSGVpZ2h0IC8gaGRwaVJhdGlvKSArICdweCc7XG5cbiAgICAgICAgdmFyIHN0YXJ0WCA9IGNvbHVtbkVkZ2VzW2NvbHVtbkluZGV4IC0gc2Nyb2xsTGVmdF07XG4gICAgICAgIHN0YXJ0WCA9IHN0YXJ0WCAqIGhkcGlSYXRpbztcblxuICAgICAgICBkcmFnZ2VyQ1RYLnNjYWxlKGhkcGlSYXRpbywgaGRwaVJhdGlvKTtcblxuICAgICAgICBncmlkLnJlbmRlck92ZXJyaWRlc0NhY2hlLmRyYWdnZXIgPSB7XG4gICAgICAgICAgICBjb2x1bW5JbmRleDogY29sdW1uSW5kZXgsXG4gICAgICAgICAgICBzdGFydEluZGV4OiBjb2x1bW5JbmRleCxcbiAgICAgICAgICAgIGN0eDogZHJhZ2dlckNUWCxcbiAgICAgICAgICAgIHN0YXJ0WDogc3RhcnRYLFxuICAgICAgICAgICAgd2lkdGg6IGNvbHVtbldpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBjb2xIZWlnaHQsXG4gICAgICAgICAgICBoZHBpcmF0aW86IGhkcGlSYXRpb1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuc2V0Q3Jvc3NCcm93c2VyUHJvcGVydHkoZCwgJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIHggKyAncHgsIC01cHgpJyk7XG4gICAgICAgIHN0eWxlLnpJbmRleCA9ICc1JztcbiAgICAgICAgc3R5bGUuY3Vyc29yID0gdGhpcy5nZXREcmFnZ2luZ0N1cnNvck5hbWUoKTtcbiAgICAgICAgZ3JpZC5yZXBhaW50KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsTW92aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHRoaXMgZnVuY3Rpb24gaXMgdGhlIG1haW4gZHJhZ2dpbmcgbG9naWNcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gdGhlIHN0YXJ0IHBvc2l0aW9uXG4gICAgICovXG4gICAgZHJhZ0NvbHVtbjogZnVuY3Rpb24oZ3JpZCwgeCkge1xuXG4gICAgICAgIC8vVE9ETzogdGhpcyBmdW5jdGlvbiBpcyBvdmVybHkgY29tcGxleCwgcmVmYWN0b3IgdGhpcyBpbiB0byBzb21ldGhpbmcgbW9yZSByZWFzb25hYmxlXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgLy92YXIgcmVuZGVyZXIgPSBncmlkLmdldFJlbmRlcmVyKCk7XG4gICAgICAgIC8vdmFyIGNvbHVtbkVkZ2VzID0gcmVuZGVyZXIuZ2V0Q29sdW1uRWRnZXMoKTtcblxuICAgICAgICB2YXIgYXV0b1Njcm9sbGluZ05vdyA9IHRoaXMuY29sdW1uRHJhZ0F1dG9TY3JvbGxpbmdSaWdodCB8fCB0aGlzLmNvbHVtbkRyYWdBdXRvU2Nyb2xsaW5nTGVmdDtcblxuICAgICAgICB2YXIgaGRwaVJhdGlvID0gZ3JpZC5nZXRIaURQSShkcmFnZ2VyQ1RYKTtcblxuICAgICAgICB2YXIgZHJhZ0NvbHVtbkluZGV4ID0gZ3JpZC5yZW5kZXJPdmVycmlkZXNDYWNoZS5kcmFnZ2VyLmNvbHVtbkluZGV4O1xuXG4gICAgICAgIHZhciBtaW5YID0gMDtcbiAgICAgICAgdmFyIG1heFggPSBncmlkLnJlbmRlcmVyLmdldEZpbmFsVmlzYWJsZUNvbHVtbkJvdW5kYXJ5KCk7XG4gICAgICAgIHggPSBNYXRoLm1pbih4LCBtYXhYICsgMTUpO1xuICAgICAgICB4ID0gTWF0aC5tYXgobWluWCAtIDE1LCB4KTtcblxuICAgICAgICAvL2FtIEkgYXQgbXkgbG93ZXIgYm91bmRcbiAgICAgICAgdmFyIGF0TWluID0geCA8IG1pblggJiYgZHJhZ0NvbHVtbkluZGV4ICE9PSAwO1xuXG4gICAgICAgIC8vYW0gSSBhdCBteSB1cHBlciBib3VuZFxuICAgICAgICB2YXIgYXRNYXggPSB4ID4gbWF4WDtcblxuICAgICAgICB2YXIgZCA9IGRyYWdnZXI7XG5cbiAgICAgICAgdGhpcy5zZXRDcm9zc0Jyb3dzZXJQcm9wZXJ0eShkLCAndHJhbnNpdGlvbicsIChzZWxmLmlzV2Via2l0ID8gJy13ZWJraXQtJyA6ICcnKSArICd0cmFuc2Zvcm0gJyArIDAgKyAnbXMgZWFzZSwgYm94LXNoYWRvdyAnICsgY29sdW1uQW5pbWF0aW9uVGltZSArICdtcyBlYXNlJyk7XG5cbiAgICAgICAgdGhpcy5zZXRDcm9zc0Jyb3dzZXJQcm9wZXJ0eShkLCAndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgeCArICdweCwgJyArIC0xMCArICdweCknKTtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZC5zdHlsZS5kaXNwbGF5ID0gJ2lubGluZSc7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBvdmVyQ29sID0gZ3JpZC5yZW5kZXJlci5nZXRDb2x1bW5Gcm9tUGl4ZWxYKHggKyAoZC53aWR0aCAvIDIgLyBoZHBpUmF0aW8pKTtcblxuICAgICAgICBpZiAoYXRNaW4pIHtcbiAgICAgICAgICAgIG92ZXJDb2wgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGF0TWF4KSB7XG4gICAgICAgICAgICBvdmVyQ29sID0gZ3JpZC5nZXRDb2x1bW5Db3VudCgpIC0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkb0FGbG9hdCA9IGRyYWdDb2x1bW5JbmRleCA+IG92ZXJDb2w7XG4gICAgICAgIGRvQUZsb2F0ID0gZG9BRmxvYXQgfHwgKG92ZXJDb2wgLSBkcmFnQ29sdW1uSW5kZXggPj0gMSk7XG5cbiAgICAgICAgaWYgKGRvQUZsb2F0ICYmICFhdE1heCAmJiAhYXV0b1Njcm9sbGluZ05vdykge1xuICAgICAgICAgICAgdmFyIGRyYWdnZWRUb1RoZVJpZ2h0ID0gZHJhZ0NvbHVtbkluZGV4IDwgb3ZlckNvbDtcbiAgICAgICAgICAgIC8vIGlmIChkcmFnZ2VkVG9UaGVSaWdodCkge1xuICAgICAgICAgICAgLy8gICAgIG92ZXJDb2wgPSBvdmVyQ29sIC0gMTtcbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmlzRmxvYXRpbmdOb3cpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuaXNGbG9hdGluZ05vdyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZUZsb2F0Q29sdW1uKGdyaWQsIG92ZXJDb2wpO1xuICAgICAgICAgICAgdGhpcy5mbG9hdENvbHVtblRvKGdyaWQsIGRyYWdnZWRUb1RoZVJpZ2h0KTtcbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgaWYgKHggPCBtaW5YIC0gMTApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoZWNrQXV0b1Njcm9sbFRvTGVmdChncmlkLCB4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh4ID4gbWluWCAtIDEwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb2x1bW5EcmFnQXV0b1Njcm9sbGluZ0xlZnQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vbGV0cyBjaGVjayBmb3IgYXV0b3Njcm9sbCB0byByaWdodCBpZiB3ZXJlIHVwIGFnYWluc3QgaXRcbiAgICAgICAgICAgIGlmIChhdE1heCB8fCB4ID4gbWF4WCArIDEwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGVja0F1dG9TY3JvbGxUb1JpZ2h0KGdyaWQsIHgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh4IDwgbWF4WCArIDEwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb2x1bW5EcmFnQXV0b1Njcm9sbGluZ1JpZ2h0ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxNb3ZpbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgYXV0b3Njcm9sbCB0byB0aGUgcmlnaHQgaWYgbmVjZXNzYXJ5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCAtIHRoZSBzdGFydCBwb3NpdGlvblxuICAgICAqL1xuICAgIGNoZWNrQXV0b1Njcm9sbFRvUmlnaHQ6IGZ1bmN0aW9uKGdyaWQsIHgpIHtcbiAgICAgICAgaWYgKHRoaXMuY29sdW1uRHJhZ0F1dG9TY3JvbGxpbmdSaWdodCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29sdW1uRHJhZ0F1dG9TY3JvbGxpbmdSaWdodCA9IHRydWU7XG4gICAgICAgIHRoaXMuX2NoZWNrQXV0b1Njcm9sbFRvUmlnaHQoZ3JpZCwgeCk7XG4gICAgfSxcblxuICAgIF9jaGVja0F1dG9TY3JvbGxUb1JpZ2h0OiBmdW5jdGlvbihncmlkLCB4KSB7XG4gICAgICAgIGlmICghdGhpcy5jb2x1bW5EcmFnQXV0b1Njcm9sbGluZ1JpZ2h0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNjcm9sbExlZnQgPSBncmlkLmdldEhTY3JvbGxWYWx1ZSgpO1xuICAgICAgICBpZiAoIWdyaWQuZHJhZ2dpbmcgfHwgc2Nyb2xsTGVmdCA+IChncmlkLnNiSFNjcm9sbGVyLnJhbmdlLm1heCAtIDIpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRyYWdnZWRJbmRleCA9IGdyaWQucmVuZGVyT3ZlcnJpZGVzQ2FjaGUuZHJhZ2dlci5jb2x1bW5JbmRleDtcbiAgICAgICAgZ3JpZC5zY3JvbGxCeSgxLCAwKTtcbiAgICAgICAgdmFyIG5ld0luZGV4ID0gZHJhZ2dlZEluZGV4ICsgMTtcbiAgICAgICAgY29uc29sZS5sb2cobmV3SW5kZXgsIGRyYWdnZWRJbmRleCk7XG4gICAgICAgIGdyaWQuc3dhcENvbHVtbnMobmV3SW5kZXgsIGRyYWdnZWRJbmRleCk7XG4gICAgICAgIGdyaWQucmVuZGVyT3ZlcnJpZGVzQ2FjaGUuZHJhZ2dlci5jb2x1bW5JbmRleCA9IG5ld0luZGV4O1xuXG4gICAgICAgIHNldFRpbWVvdXQodGhpcy5fY2hlY2tBdXRvU2Nyb2xsVG9SaWdodC5iaW5kKHRoaXMsIGdyaWQsIHgpLCAyNTApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbE1vdmluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBhdXRvc2Nyb2xsIHRvIHRoZSBsZWZ0IGlmIG5lY2Vzc2FyeVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSB0aGUgc3RhcnQgcG9zaXRpb25cbiAgICAgKi9cbiAgICBjaGVja0F1dG9TY3JvbGxUb0xlZnQ6IGZ1bmN0aW9uKGdyaWQsIHgpIHtcbiAgICAgICAgaWYgKHRoaXMuY29sdW1uRHJhZ0F1dG9TY3JvbGxpbmdMZWZ0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb2x1bW5EcmFnQXV0b1Njcm9sbGluZ0xlZnQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9jaGVja0F1dG9TY3JvbGxUb0xlZnQoZ3JpZCwgeCk7XG4gICAgfSxcblxuICAgIF9jaGVja0F1dG9TY3JvbGxUb0xlZnQ6IGZ1bmN0aW9uKGdyaWQsIHgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbHVtbkRyYWdBdXRvU2Nyb2xsaW5nTGVmdCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNjcm9sbExlZnQgPSBncmlkLmdldEhTY3JvbGxWYWx1ZSgpO1xuICAgICAgICBpZiAoIWdyaWQuZHJhZ2dpbmcgfHwgc2Nyb2xsTGVmdCA8IDEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZHJhZ2dlZEluZGV4ID0gZ3JpZC5yZW5kZXJPdmVycmlkZXNDYWNoZS5kcmFnZ2VyLmNvbHVtbkluZGV4O1xuICAgICAgICBncmlkLnN3YXBDb2x1bW5zKGRyYWdnZWRJbmRleCArIHNjcm9sbExlZnQsIGRyYWdnZWRJbmRleCArIHNjcm9sbExlZnQgLSAxKTtcbiAgICAgICAgZ3JpZC5zY3JvbGxCeSgtMSwgMCk7XG4gICAgICAgIHNldFRpbWVvdXQodGhpcy5fY2hlY2tBdXRvU2Nyb2xsVG9MZWZ0LmJpbmQodGhpcywgZ3JpZCwgeCksIDI1MCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsTW92aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGEgY29sdW1uIGRyYWcgaGFzIGNvbXBsZXRlZCwgdXBkYXRlIGRhdGEgYW5kIGNsZWFudXBcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqL1xuICAgIGVuZERyYWdDb2x1bW46IGZ1bmN0aW9uKGdyaWQpIHtcblxuICAgICAgICB2YXIgZml4ZWRDb2x1bW5Db3VudCA9IGdyaWQuZ2V0Rml4ZWRDb2x1bW5Db3VudCgpO1xuICAgICAgICB2YXIgc2Nyb2xsTGVmdCA9IGdyaWQuZ2V0SFNjcm9sbFZhbHVlKCk7XG5cbiAgICAgICAgdmFyIGNvbHVtbkluZGV4ID0gZ3JpZC5yZW5kZXJPdmVycmlkZXNDYWNoZS5kcmFnZ2VyLmNvbHVtbkluZGV4O1xuXG4gICAgICAgIGlmIChjb2x1bW5JbmRleCA8IGZpeGVkQ29sdW1uQ291bnQpIHtcbiAgICAgICAgICAgIHNjcm9sbExlZnQgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlbmRlcmVyID0gZ3JpZC5nZXRSZW5kZXJlcigpO1xuICAgICAgICB2YXIgY29sdW1uRWRnZXMgPSByZW5kZXJlci5nZXRDb2x1bW5FZGdlcygpO1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBzdGFydFggPSBjb2x1bW5FZGdlc1tjb2x1bW5JbmRleCAtIHNjcm9sbExlZnRdO1xuICAgICAgICB2YXIgZCA9IGRyYWdnZXI7XG4gICAgICAgIHZhciBjaGFuZ2VkID0gZ3JpZC5yZW5kZXJPdmVycmlkZXNDYWNoZS5kcmFnZ2VyLnN0YXJ0SW5kZXggIT09IGdyaWQucmVuZGVyT3ZlcnJpZGVzQ2FjaGUuZHJhZ2dlci5jb2x1bW5JbmRleDtcbiAgICAgICAgc2VsZi5zZXRDcm9zc0Jyb3dzZXJQcm9wZXJ0eShkLCAndHJhbnNpdGlvbicsIChzZWxmLmlzV2Via2l0ID8gJy13ZWJraXQtJyA6ICcnKSArICd0cmFuc2Zvcm0gJyArIGNvbHVtbkFuaW1hdGlvblRpbWUgKyAnbXMgZWFzZSwgYm94LXNoYWRvdyAnICsgY29sdW1uQW5pbWF0aW9uVGltZSArICdtcyBlYXNlJyk7XG4gICAgICAgIHNlbGYuc2V0Q3Jvc3NCcm93c2VyUHJvcGVydHkoZCwgJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIHN0YXJ0WCArICdweCwgJyArIC0xICsgJ3B4KScpO1xuICAgICAgICBkLnN0eWxlLmJveFNoYWRvdyA9ICcwcHggMHB4IDBweCAjODg4ODg4JztcblxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZ3JpZC5yZW5kZXJPdmVycmlkZXNDYWNoZS5kcmFnZ2VyID0gbnVsbDtcbiAgICAgICAgICAgIGdyaWQucmVwYWludCgpO1xuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgICAgICBncmlkLmVuZERyYWdDb2x1bW5Ob3RpZmljYXRpb24oKTsgLy9pbnRlcm5hbCBub3RpZmljYXRpb25cbiAgICAgICAgICAgICAgICBpZiAoY2hhbmdlZCl7XG4gICAgICAgICAgICAgICAgICAgIGdyaWQuZmlyZVN5bnRoZXRpY09uQ29sdW1uc0NoYW5nZWRFdmVudCgpOyAvL3B1YmxpYyBub3RpZmljYXRpb25cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgY29sdW1uQW5pbWF0aW9uVGltZSArIDUwKTtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbE1vdmluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudCBkb3duIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGlzSGVhZGVyUm93OiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICB2YXIgZ3JpZENlbGwgPSBldmVudC52aWV3UG9pbnQ7XG4gICAgICAgIHZhciBpc0ZpeGVkID0gZ3JpZENlbGwueSA9PT0gMDtcbiAgICAgICAgcmV0dXJuIGlzRml4ZWQ7XG4gICAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb2x1bW5Nb3Zpbmc7XG4iLCIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cbi8qIGdsb2JhbCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRmVhdHVyZSA9IHJlcXVpcmUoJy4vRmVhdHVyZS5qcycpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgRmVhdHVyZVxuICovXG52YXIgQ29sdW1uUGlja2VyID0gRmVhdHVyZS5leHRlbmQoJ0NvbHVtblBpY2tlcicsIHtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5QaWNrZXIucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnQgZG93biB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVLZXlVcDogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgdmFyIGtleSA9IGV2ZW50LmRldGFpbC5jaGFyLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHZhciBrZXlzID0gZ3JpZC5yZXNvbHZlUHJvcGVydHkoJ2VkaXRvckFjdGl2YXRpb25LZXlzJyk7XG4gICAgICAgIGlmIChrZXlzLmluZGV4T2Yoa2V5KSA+IC0xKSB7XG4gICAgICAgICAgIGdyaWQudG9nZ2xlRGlhbG9nKCdDb2x1bW5QaWNrZXInKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbHVtblBpY2tlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEZlYXR1cmUgPSByZXF1aXJlKCcuL0ZlYXR1cmUuanMnKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIEZlYXR1cmVcbiAqL1xudmFyIENvbHVtblJlc2l6aW5nID0gRmVhdHVyZS5leHRlbmQoJ0NvbHVtblJlc2l6aW5nJywge1xuXG4gICAgLyoqXG4gICAgICogdGhlIGluZGV4IG9mIHRoZSBjb2x1bW4gd2FsbCB3ZXJlIGN1cnJlbnRseSBkcmFnZ2luZ1xuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgLTJcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uUmVzaXppbmcucHJvdG90eXBlXG4gICAgICovXG4gICAgZHJhZ0luZGV4OiAtMixcblxuICAgIC8qKlxuICAgICAqIHRoZSBwaXhlbCBsb2NhdGlvbiBvZiB0aGUgd2hlcmUgdGhlIGRyYWcgd2FzIGluaXRpYXRlZFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgLTFcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uUmVzaXppbmcucHJvdG90eXBlXG4gICAgICovXG4gICAgZHJhZ1N0YXJ0OiAtMSxcblxuICAgIC8qKlxuICAgICAqIHRoZSBzdGFydGluZyB3aWR0aC9oZWlnaHQgb2YgdGhlIHJvdy9jb2x1bW4gd2UgYXJlIGRyYWdnaW5nXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAtMVxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5SZXNpemluZy5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBkcmFnSW5kZXhTdGFydGluZ1NpemU6IC0xLFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblJlc2l6aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGdldCB0aGUgbW91c2UgeCx5IGNvb3JkaW5hdGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZXZlbnQgLSB0aGUgbW91c2UgZXZlbnQgdG8gcXVlcnlcbiAgICAgKi9cbiAgICBnZXRNb3VzZVZhbHVlOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICByZXR1cm4gZXZlbnQucHJpbWl0aXZlRXZlbnQuZGV0YWlsLm1vdXNlLng7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5SZXNpemluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBnZXQgdGhlIGdyaWQgY2VsbCB4LHkgY29vcmRpbmF0ZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICogQHBhcmFtIHt3aW5kb3cuZmluLnJlY3Rhbmd1bGFyLlBvaW50fSBncmlkQ2VsbFxuICAgICAqL1xuICAgIGdldEdyaWRDZWxsVmFsdWU6IGZ1bmN0aW9uKGdyaWRDZWxsKSB7XG4gICAgICAgIHJldHVybiBncmlkQ2VsbC55O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uUmVzaXppbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgcmV0dXJuIHRoZSBncmlkcyB4LHkgc2Nyb2xsIHZhbHVlXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqL1xuICAgIGdldFNjcm9sbFZhbHVlOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIHJldHVybiBncmlkLmdldEhTY3JvbGxWYWx1ZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uUmVzaXppbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgcmV0dXJuIHRoZSB3aWR0aC9oZWlnaHQgb2YgdGhlIHJvdy9jb2x1bW4gb2YgaW50ZXJlc3RcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gdGhlIHJvdy9jb2x1bW4gaW5kZXggb2YgaW50ZXJlc3RcbiAgICAgKi9cbiAgICBnZXRBcmVhU2l6ZTogZnVuY3Rpb24oZ3JpZCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGdyaWQuZ2V0Q29sdW1uV2lkdGgoaW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uUmVzaXppbmcucHJvdG90eXBlXG4gICAgICogQGRlc2Mgc2V0IHRoZSB3aWR0aC9oZWlnaHQgb2YgdGhlIHJvdy9jb2x1bW4gYXQgaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gdGhlIHJvdy9jb2x1bW4gaW5kZXggb2YgaW50ZXJlc3RcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSB0aGUgd2lkdGgvaGVpZ2h0IHRvIHNldCB0b1xuICAgICAqL1xuICAgIHNldEFyZWFTaXplOiBmdW5jdGlvbihncmlkLCBpbmRleCwgdmFsdWUpIHtcbiAgICAgICAgZ3JpZC5zZXRDb2x1bW5XaWR0aChpbmRleCwgdmFsdWUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uUmVzaXppbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgcmV0dXJuIHRoZSByZWNlbnRseSByZW5kZXJlZCBhcmVhJ3Mgd2lkdGgvaGVpZ2h0XG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIHRoZSByb3cvY29sdW1uIGluZGV4IG9mIGludGVyZXN0XG4gICAgICovXG4gICAgZ2V0UHJldmlvdXNBYnNvbHV0ZVNpemU6IGZ1bmN0aW9uKGdyaWQsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBncmlkLmdldFJlbmRlcmVkV2lkdGgoaW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uUmVzaXppbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgcmV0dXJucyB0aGUgaW5kZXggb2Ygd2hpY2ggZGl2aWRlciBJJ20gb3ZlclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIG92ZXJBcmVhRGl2aWRlcjogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIGdyaWQub3ZlckNvbHVtbkRpdmlkZXIoZXZlbnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uUmVzaXppbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgYW0gSSBvdmVyIHRoZSBjb2x1bW4vcm93IGFyZWFcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaXNGaXJzdEZpeGVkT3RoZXJBcmVhOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc0ZpcnN0Rml4ZWRSb3coZ3JpZCwgZXZlbnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uUmVzaXppbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgcmV0dXJuIHRoZSBjdXJzb3IgbmFtZVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0Q3Vyc29yTmFtZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAnY29sLXJlc2l6ZSc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5SZXNpemluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudFxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVNb3VzZURyYWc6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmRyYWdJbmRleCA+IC0yKSB7XG4gICAgICAgICAgICAvL3ZhciBmaXhlZEFyZWFDb3VudCA9IHRoaXMuZ2V0Rml4ZWRBcmVhQ291bnQoZ3JpZCk7XG4gICAgICAgICAgICAvL3ZhciBvZmZzZXQgPSB0aGlzLmdldEZpeGVkQXJlYVNpemUoZ3JpZCwgZml4ZWRBcmVhQ291bnQgKyBhcmVhSW5kZXgpO1xuICAgICAgICAgICAgdmFyIG1vdXNlID0gdGhpcy5nZXRNb3VzZVZhbHVlKGV2ZW50KTtcbiAgICAgICAgICAgIHZhciBzY3JvbGxWYWx1ZSA9IHRoaXMuZ2V0U2Nyb2xsVmFsdWUoZ3JpZCk7XG4gICAgICAgICAgICBpZiAodGhpcy5kcmFnSW5kZXggPCB0aGlzLmdldEZpeGVkQXJlYUNvdW50KGdyaWQpKSB7XG4gICAgICAgICAgICAgICAgc2Nyb2xsVmFsdWUgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHByZXZpb3VzID0gdGhpcy5nZXRQcmV2aW91c0Fic29sdXRlU2l6ZShncmlkLCB0aGlzLmRyYWdJbmRleCAtIHNjcm9sbFZhbHVlKTtcbiAgICAgICAgICAgIHZhciBkaXN0YW5jZSA9IG1vdXNlIC0gcHJldmlvdXM7XG4gICAgICAgICAgICB0aGlzLnNldEFyZWFTaXplKGdyaWQsIHRoaXMuZHJhZ0luZGV4LCBkaXN0YW5jZSk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlTW91c2VEcmFnKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uUmVzaXppbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgZ2V0IHRoZSB3aWR0aC9oZWlnaHQgb2YgYSBzcGVjaWZpYyByb3cvY29sdW1uXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYXJlYUluZGV4IC0gdGhlIHJvdy9jb2x1bW4gaW5kZXggb2YgaW50ZXJlc3RcbiAgICAgKi9cbiAgICBnZXRTaXplOiBmdW5jdGlvbihncmlkLCBhcmVhSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QXJlYVNpemUoZ3JpZCwgYXJlYUluZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblJlc2l6aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHJldHVybiB0aGUgZml4ZWQgYXJlYSByb3dzL2NvbHVtbnMgY291bnRcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICovXG4gICAgZ2V0T3RoZXJGaXhlZEFyZWFDb3VudDogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICByZXR1cm4gZ3JpZC5nZXRGaXhlZFJvd0NvdW50KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5SZXNpemluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudCBkb3duIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZU1vdXNlRG93bjogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgdmFyIGlzRW5hYmxlZCA9IHRoaXMuaXNFbmFibGVkKGdyaWQpO1xuICAgICAgICB2YXIgb3ZlckFyZWEgPSB0aGlzLm92ZXJBcmVhRGl2aWRlcihncmlkLCBldmVudCk7XG4gICAgICAgIGlmIChpc0VuYWJsZWQgJiYgb3ZlckFyZWEgPiAtMSAmJiB0aGlzLmlzRmlyc3RGaXhlZE90aGVyQXJlYShncmlkLCBldmVudCkpIHtcbiAgICAgICAgICAgIHZhciBzY3JvbGxWYWx1ZSA9IHRoaXMuZ2V0U2Nyb2xsVmFsdWUoZ3JpZCk7XG4gICAgICAgICAgICBpZiAob3ZlckFyZWEgPCB0aGlzLmdldEZpeGVkQXJlYUNvdW50KGdyaWQpKSB7XG4gICAgICAgICAgICAgICAgc2Nyb2xsVmFsdWUgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kcmFnSW5kZXggPSBvdmVyQXJlYSAtIDEgKyBzY3JvbGxWYWx1ZTtcbiAgICAgICAgICAgIHRoaXMuZHJhZ1N0YXJ0ID0gdGhpcy5nZXRNb3VzZVZhbHVlKGV2ZW50KTtcbiAgICAgICAgICAgIHRoaXMuZHJhZ0luZGV4U3RhcnRpbmdTaXplID0gMDtcbiAgICAgICAgICAgIHRoaXMuZGV0YWNoQ2hhaW4oKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVNb3VzZURvd24oZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5SZXNpemluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudCBkb3duIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZU1vdXNlVXA6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIHZhciBpc0VuYWJsZWQgPSB0aGlzLmlzRW5hYmxlZChncmlkKTtcbiAgICAgICAgaWYgKGlzRW5hYmxlZCAmJiB0aGlzLmRyYWdJbmRleCA+IC0yKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnNvciA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmRyYWdJbmRleCA9IC0yO1xuXG4gICAgICAgICAgICBldmVudC5wcmltaXRpdmVFdmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIC8vZGVsYXkgaGVyZSB0byBnaXZlIG90aGVyIGV2ZW50cyBhIGNoYW5jZSB0byBiZSBkcm9wcGVkXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICBncmlkLnN5bmNocm9uaXplU2Nyb2xsaW5nQm91bmRyaWVzKCk7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHNlbGYuYXR0YWNoQ2hhaW4oKTtcbiAgICAgICAgICAgIH0sIDIwMCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlTW91c2VVcChncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblJlc2l6aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50IGRvd24gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlTW91c2VNb3ZlOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAodGhpcy5kcmFnSW5kZXggPiAtMikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3Vyc29yID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZU1vdXNlTW92ZShncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGVja0ZvckFyZWFSZXNpemVDdXJzb3JDaGFuZ2UoZ3JpZCwgZXZlbnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uUmVzaXppbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgZmlsbCB0aGlzIGluXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGNoZWNrRm9yQXJlYVJlc2l6ZUN1cnNvckNoYW5nZTogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgdmFyIGlzRW5hYmxlZCA9IHRoaXMuaXNFbmFibGVkKGdyaWQpO1xuICAgICAgICBpZiAoaXNFbmFibGVkICYmIHRoaXMub3ZlckFyZWFEaXZpZGVyKGdyaWQsIGV2ZW50KSA+IC0xICYmIHRoaXMuaXNGaXJzdEZpeGVkT3RoZXJBcmVhKGdyaWQsIGV2ZW50KSkge1xuICAgICAgICAgICAgdGhpcy5jdXJzb3IgPSB0aGlzLmdldEN1cnNvck5hbWUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY3Vyc29yID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAtMlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5SZXNpemluZy5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBnZXRGaXhlZEFyZWFDb3VudDogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICB2YXIgY291bnQgPSBncmlkLmdldEZpeGVkQ29sdW1uQ291bnQoKSArIChncmlkLmlzU2hvd1Jvd051bWJlcnMoKSA/IDEgOiAwKSArIChncmlkLmhhc0hpZXJhcmNoeUNvbHVtbigpID8gMSA6IDApO1xuICAgICAgICByZXR1cm4gY291bnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIGV2ZW50XG4gICAgICogQGRlZmF1bHQgLTJcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uUmVzaXppbmcucHJvdG90eXBlXG4gICAgICovXG4gICAgaGFuZGxlRG91YmxlQ2xpY2s6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIHZhciBpc0VuYWJsZWQgPSB0aGlzLmlzRW5hYmxlZChncmlkKTtcbiAgICAgICAgdmFyIGhhc0N1cnNvciA9IHRoaXMub3ZlckFyZWFEaXZpZGVyKGdyaWQsIGV2ZW50KSA+IC0xOyAvL3RoaXMuY3Vyc29yICE9PSBudWxsO1xuICAgICAgICB2YXIgaGVhZGVyUm93Q291bnQgPSBncmlkLmdldEhlYWRlclJvd0NvdW50KCk7XG4gICAgICAgIC8vdmFyIGhlYWRlckNvbENvdW50ID0gZ3JpZC5nZXRIZWFkZXJDb2x1bW5Db3VudCgpO1xuICAgICAgICB2YXIgZ3JpZENlbGwgPSBldmVudC5ncmlkQ2VsbDtcbiAgICAgICAgaWYgKGlzRW5hYmxlZCAmJiBoYXNDdXJzb3IgJiYgKGdyaWRDZWxsLnkgPD0gaGVhZGVyUm93Q291bnQpKSB7XG4gICAgICAgICAgICBncmlkLmF1dG9zaXplQ29sdW1uKGdyaWRDZWxsLnggLSAxKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVEb3VibGVDbGljayhncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdCAtMlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5SZXNpemluZy5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBpc0VuYWJsZWQ6IGZ1bmN0aW9uKGdyaWQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb2x1bW5SZXNpemluZztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEZlYXR1cmUgPSByZXF1aXJlKCcuL0ZlYXR1cmUuanMnKTtcblxuLyoqXG4gKiBFeHRyYSBtc2VjcyB0byBhdm9pZCByYWNlIGNvbmRpdGlvbiB3aXRoIGZpbmNhbnZhcydzIGRvdWJsZSBjbGljayB0aW1lci5cbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAZGVmYXVsdHZhbHVlIDUwXG4gKiBOT1RFOiA1MCBtc2VjcyBzZWVtcyB0byB3b3JrIHdlbGwuIDEwIGFuZCBldmVuIDI1IHByb3ZlZCBpbnN1ZmZpY2llbnQgaW4gQ2hyb21lLlxuICogQHByaXZhdGVcbiAqL1xudmFyIFJBQ0VfVElNRSA9IDUwO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgRmVhdHVyZVxuICovXG52YXIgQ29sdW1uU2VsZWN0aW9uID0gRmVhdHVyZS5leHRlbmQoJ0NvbHVtblNlbGVjdGlvbicsIHtcblxuICAgIC8qKlxuICAgICAqIFRoZSBwaXhlbCBsb2NhdGlvbiBvZiB0aGUgbW91c2UgcG9pbnRlciBkdXJpbmcgYSBkcmFnIG9wZXJhdGlvbi5cbiAgICAgKiBAdHlwZSB7d2luZG93LmZpbi5yZWN0YW5ndWxhci5Qb2ludH1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICogQG1lbWJlck9mIENvbHVtblNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBjdXJyZW50RHJhZzogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFRoZSBjZWxsIGNvb3JkaW5hdGVzIG9mIHRoZSB3aGVyZSB0aGUgbW91c2UgcG9pbnRlciBpcyBkdXJpbmcgYSBkcmFnIG9wZXJhdGlvbi5cbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGxhc3REcmFnQ2VsbDogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIGEgbWlsbGlzZWNvbmQgdmFsdWUgcmVwcmVzZW50aW5nIHRoZSBwcmV2aW91cyB0aW1lIGFuIGF1dG9zY3JvbGwgc3RhcnRlZFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5TZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICovXG4gICAgc2JMYXN0QXV0bzogMCxcblxuICAgIC8qKlxuICAgICAqIGEgbWlsbGlzZWNvbmQgdmFsdWUgcmVwcmVzZW50aW5nIHRoZSB0aW1lIHRoZSBjdXJyZW50IGF1dG9zY3JvbGwgc3RhcnRlZFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5TZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICovXG4gICAgc2JBdXRvU3RhcnQ6IDAsXG5cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5TZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgSGFuZGxlIHRoaXMgZXZlbnQgZG93biB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eS5cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlTW91c2VVcDogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuZHJhZ2dpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlTW91c2VVcChncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgaGFuZGxlRG91YmxlQ2xpY2s6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmRvdWJsZUNsaWNrVGltZXIpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmRvdWJsZUNsaWNrVGltZXIpOyAvLyBwcmV2ZW50IG1vdXNlRG93biBmcm9tIGNvbnRpbnVpbmdcbiAgICAgICAgICAgIHRoaXMuZG91YmxlQ2xpY2tUaW1lciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlRG91YmxlQ2xpY2soZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5TZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgKiBAZGVzYyBIYW5kbGUgdGhpcyBldmVudCBkb3duIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5LlxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVNb3VzZURvd246IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmRvdWJsZUNsaWNrVGltZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgoIWdyaWQuaXNDb2x1bW5TZWxlY3Rpb24oKSB8fCBldmVudC5tb3VzZVBvaW50LnkgPCA1KSAmJiB0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVNb3VzZURvd24oZ3JpZCwgZXZlbnQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGlzUmlnaHRDbGljayA9IGV2ZW50LnByaW1pdGl2ZUV2ZW50LmRldGFpbC5pc1JpZ2h0Q2xpY2s7XG4gICAgICAgIHZhciBjZWxsID0gZXZlbnQuZ3JpZENlbGw7XG4gICAgICAgIHZhciB2aWV3Q2VsbCA9IGV2ZW50LnZpZXdQb2ludDtcbiAgICAgICAgdmFyIGR4ID0gY2VsbC54O1xuICAgICAgICB2YXIgZHkgPSBjZWxsLnk7XG5cbiAgICAgICAgdmFyIGlzSGVhZGVyID0gZ3JpZC5pc1Nob3dIZWFkZXJSb3coKSAmJiBkeSA9PT0gMCAmJiBkeCAhPT0gLTE7XG5cbiAgICAgICAgaWYgKGlzUmlnaHRDbGljayB8fCAhaXNIZWFkZXIpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlTW91c2VEb3duKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEhPTEQgT0ZGIFdISUxFIFdBSVRJTkcgRk9SIERPVUJMRS1DTElDS1xuICAgICAgICAgICAgdGhpcy5kb3VibGVDbGlja1RpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRvdWJsZUNsaWNrVGltZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdmFyIG51bUZpeGVkQ29sdW1ucyA9IGdyaWQuZ2V0Rml4ZWRDb2x1bW5Db3VudCgpO1xuXG4gICAgICAgICAgICAgICAgLy9pZiB3ZSBhcmUgaW4gdGhlIGZpeGVkIGFyZWEgZG8gbm90IGFwcGx5IHRoZSBzY3JvbGwgdmFsdWVzXG4gICAgICAgICAgICAgICAgLy9jaGVjayBib3RoIHggYW5kIHkgdmFsdWVzIGluZGVwZW5kZW50bHlcbiAgICAgICAgICAgICAgICBpZiAodmlld0NlbGwueCA8IG51bUZpeGVkQ29sdW1ucykge1xuICAgICAgICAgICAgICAgICAgICBkeCA9IHZpZXdDZWxsLng7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGRDZWxsID0gZ3JpZC5uZXdQb2ludChkeCwgMCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgcHJpbUV2ZW50ID0gZXZlbnQucHJpbWl0aXZlRXZlbnQ7XG4gICAgICAgICAgICAgICAgdmFyIGtleXMgPSBwcmltRXZlbnQuZGV0YWlsLmtleXM7XG4gICAgICAgICAgICAgICAgdGhpcy5kcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5leHRlbmRTZWxlY3Rpb24oZ3JpZCwgZENlbGwsIGtleXMpO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpLCBncmlkLnJlc29sdmVQcm9wZXJ0eSgnZG91YmxlQ2xpY2tEZWxheScpICsgUkFDRV9USU1FKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50IGRvd24gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlTW91c2VEcmFnOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuXG4gICAgICAgIGlmICgoIWdyaWQuaXNDb2x1bW5TZWxlY3Rpb24oKSB8fCB0aGlzLmlzQ29sdW1uRHJhZ2dpbmcoZ3JpZCkpICYmIHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZU1vdXNlRHJhZyhncmlkLCBldmVudCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaXNSaWdodENsaWNrID0gZXZlbnQucHJpbWl0aXZlRXZlbnQuZGV0YWlsLmlzUmlnaHRDbGljaztcblxuICAgICAgICBpZiAoaXNSaWdodENsaWNrIHx8ICF0aGlzLmRyYWdnaW5nKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZU1vdXNlRHJhZyhncmlkLCBldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIHZhciBudW1GaXhlZENvbHVtbnMgPSBncmlkLmdldEZpeGVkQ29sdW1uQ291bnQoKTtcblxuICAgICAgICAgICAgdmFyIGNlbGwgPSBldmVudC5ncmlkQ2VsbDtcbiAgICAgICAgICAgIHZhciB2aWV3Q2VsbCA9IGV2ZW50LnZpZXdQb2ludDtcbiAgICAgICAgICAgIHZhciBkeCA9IGNlbGwueDtcbiAgICAgICAgICAgIHZhciBkeSA9IGNlbGwueTtcblxuICAgICAgICAgICAgLy9pZiB3ZSBhcmUgaW4gdGhlIGZpeGVkIGFyZWEgZG8gbm90IGFwcGx5IHRoZSBzY3JvbGwgdmFsdWVzXG4gICAgICAgICAgICAvL2NoZWNrIGJvdGggeCBhbmQgeSB2YWx1ZXMgaW5kZXBlbmRlbnRseVxuICAgICAgICAgICAgaWYgKHZpZXdDZWxsLnggPCBudW1GaXhlZENvbHVtbnMpIHtcbiAgICAgICAgICAgICAgICBkeCA9IHZpZXdDZWxsLng7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBkQ2VsbCA9IGdyaWQubmV3UG9pbnQoZHgsIGR5KTtcblxuICAgICAgICAgICAgdmFyIHByaW1FdmVudCA9IGV2ZW50LnByaW1pdGl2ZUV2ZW50O1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50RHJhZyA9IHByaW1FdmVudC5kZXRhaWwubW91c2U7XG4gICAgICAgICAgICB0aGlzLmxhc3REcmFnQ2VsbCA9IGRDZWxsO1xuXG4gICAgICAgICAgICB0aGlzLmNoZWNrRHJhZ1Njcm9sbChncmlkLCB0aGlzLmN1cnJlbnREcmFnKTtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlTW91c2VEcmFnQ2VsbFNlbGVjdGlvbihncmlkLCBkQ2VsbCwgcHJpbUV2ZW50LmRldGFpbC5rZXlzKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50IGRvd24gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlS2V5RG93bjogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgdmFyIGhhbmRsZXI7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGdyaWQuZ2V0TGFzdFNlbGVjdGlvblR5cGUoKSA9PT0gJ2NvbHVtbicgJiZcbiAgICAgICAgICAgIChoYW5kbGVyID0gdGhpc1snaGFuZGxlJyArIGV2ZW50LmRldGFpbC5jaGFyXSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgZ3JpZCwgZXZlbnQuZGV0YWlsKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVLZXlEb3duKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIEhhbmRsZSBhIG1vdXNlZHJhZyBzZWxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb3VzZSAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICogQHBhcmFtIHtBcnJheX0ga2V5cyAtIGFycmF5IG9mIHRoZSBrZXlzIHRoYXQgYXJlIGN1cnJlbnRseSBwcmVzc2VkIGRvd25cbiAgICAgKi9cbiAgICBoYW5kbGVNb3VzZURyYWdDZWxsU2VsZWN0aW9uOiBmdW5jdGlvbihncmlkLCBncmlkQ2VsbCwga2V5cykge1xuICAgICAgICB2YXIgeCA9IGdyaWRDZWxsLng7XG4gICAgICAgIC8vICAgICAgICAgICAgdmFyIHByZXZpb3VzRHJhZ0V4dGVudCA9IGdyaWQuZ2V0RHJhZ0V4dGVudCgpO1xuICAgICAgICB2YXIgbW91c2VEb3duID0gZ3JpZC5nZXRNb3VzZURvd24oKTtcblxuICAgICAgICB2YXIgbmV3WCA9IHggLSBtb3VzZURvd24ueDtcbiAgICAgICAgLy92YXIgbmV3WSA9IHkgLSBtb3VzZURvd24ueTtcblxuICAgICAgICAvLyBpZiAocHJldmlvdXNEcmFnRXh0ZW50LnggPT09IG5ld1ggJiYgcHJldmlvdXNEcmFnRXh0ZW50LnkgPT09IG5ld1kpIHtcbiAgICAgICAgLy8gICAgIHJldHVybjtcbiAgICAgICAgLy8gfVxuXG4gICAgICAgIGdyaWQuY2xlYXJNb3N0UmVjZW50Q29sdW1uU2VsZWN0aW9uKCk7XG5cbiAgICAgICAgZ3JpZC5zZWxlY3RDb2x1bW4obW91c2VEb3duLngsIHgpO1xuICAgICAgICBncmlkLnNldERyYWdFeHRlbnQoZ3JpZC5uZXdQb2ludChuZXdYLCAwKSk7XG5cbiAgICAgICAgZ3JpZC5yZXBhaW50KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5TZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgdGhpcyBjaGVja3Mgd2hpbGUgd2VyZSBkcmFnZ2luZyBpZiB3ZSBnbyBvdXRzaWRlIHRoZSB2aXNpYmxlIGJvdW5kcywgaWYgc28sIGtpY2sgb2ZmIHRoZSBleHRlcm5hbCBhdXRvc2Nyb2xsIGNoZWNrIGZ1bmN0aW9uIChhYm92ZSlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb3VzZSAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgY2hlY2tEcmFnU2Nyb2xsOiBmdW5jdGlvbihncmlkLCBtb3VzZSkge1xuICAgICAgICBpZiAoIWdyaWQucmVzb2x2ZVByb3BlcnR5KCdzY3JvbGxpbmdFbmFibGVkJykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYiA9IGdyaWQuZ2V0RGF0YUJvdW5kcygpO1xuICAgICAgICB2YXIgaW5zaWRlID0gYi5jb250YWlucyhtb3VzZSk7XG4gICAgICAgIGlmIChpbnNpZGUpIHtcbiAgICAgICAgICAgIGlmIChncmlkLmlzU2Nyb2xsaW5nTm93KCkpIHtcbiAgICAgICAgICAgICAgICBncmlkLnNldFNjcm9sbGluZ05vdyhmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIWdyaWQuaXNTY3JvbGxpbmdOb3coKSkge1xuICAgICAgICAgICAgZ3JpZC5zZXRTY3JvbGxpbmdOb3codHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbERyYWcoZ3JpZCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyB0aGlzIGZ1bmN0aW9uIG1ha2VzIHN1cmUgdGhhdCB3aGlsZSB3ZSBhcmUgZHJhZ2dpbmcgb3V0c2lkZSBvZiB0aGUgZ3JpZCB2aXNpYmxlIGJvdW5kcywgd2Ugc3Jjcm9sbCBhY2NvcmRpbmdseVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICovXG4gICAgc2Nyb2xsRHJhZzogZnVuY3Rpb24oZ3JpZCkge1xuXG4gICAgICAgIGlmICghZ3JpZC5pc1Njcm9sbGluZ05vdygpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGFzdERyYWdDZWxsID0gdGhpcy5sYXN0RHJhZ0NlbGw7XG4gICAgICAgIHZhciBiID0gZ3JpZC5nZXREYXRhQm91bmRzKCk7XG4gICAgICAgIHZhciB4T2Zmc2V0ID0gMDtcbiAgICAgICAgdmFyIHlPZmZzZXQgPSAwO1xuXG4gICAgICAgIHZhciBudW1GaXhlZENvbHVtbnMgPSBncmlkLmdldEZpeGVkQ29sdW1uQ291bnQoKTtcbiAgICAgICAgdmFyIG51bUZpeGVkUm93cyA9IGdyaWQuZ2V0Rml4ZWRSb3dDb3VudCgpO1xuXG4gICAgICAgIHZhciBkcmFnRW5kSW5GaXhlZEFyZWFYID0gbGFzdERyYWdDZWxsLnggPCBudW1GaXhlZENvbHVtbnM7XG4gICAgICAgIHZhciBkcmFnRW5kSW5GaXhlZEFyZWFZID0gbGFzdERyYWdDZWxsLnkgPCBudW1GaXhlZFJvd3M7XG5cbiAgICAgICAgaWYgKHRoaXMuY3VycmVudERyYWcueCA8IGIub3JpZ2luLngpIHtcbiAgICAgICAgICAgIHhPZmZzZXQgPSAtMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnREcmFnLnggPiBiLm9yaWdpbi54ICsgYi5leHRlbnQueCkge1xuICAgICAgICAgICAgeE9mZnNldCA9IDE7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZHJhZ0NlbGxPZmZzZXRYID0geE9mZnNldDtcbiAgICAgICAgdmFyIGRyYWdDZWxsT2Zmc2V0WSA9IHlPZmZzZXQ7XG5cbiAgICAgICAgaWYgKGRyYWdFbmRJbkZpeGVkQXJlYVgpIHtcbiAgICAgICAgICAgIGRyYWdDZWxsT2Zmc2V0WCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZHJhZ0VuZEluRml4ZWRBcmVhWSkge1xuICAgICAgICAgICAgZHJhZ0NlbGxPZmZzZXRZID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubGFzdERyYWdDZWxsID0gbGFzdERyYWdDZWxsLnBsdXNYWShkcmFnQ2VsbE9mZnNldFgsIGRyYWdDZWxsT2Zmc2V0WSk7XG4gICAgICAgIGdyaWQuc2Nyb2xsQnkoeE9mZnNldCwgeU9mZnNldCk7XG4gICAgICAgIHRoaXMuaGFuZGxlTW91c2VEcmFnQ2VsbFNlbGVjdGlvbihncmlkLCBsYXN0RHJhZ0NlbGwsIFtdKTsgLy8gdXBkYXRlIHRoZSBzZWxlY3Rpb25cbiAgICAgICAgZ3JpZC5yZXBhaW50KCk7XG4gICAgICAgIHNldFRpbWVvdXQodGhpcy5zY3JvbGxEcmFnLmJpbmQodGhpcywgZ3JpZCksIDI1KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBleHRlbmQgYSBzZWxlY3Rpb24gb3IgY3JlYXRlIG9uZSBpZiB0aGVyZSBpc250IHlldFxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGdyaWRDZWxsIC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBrZXlzIC0gYXJyYXkgb2YgdGhlIGtleXMgdGhhdCBhcmUgY3VycmVudGx5IHByZXNzZWQgZG93blxuICAgICAqL1xuICAgIGV4dGVuZFNlbGVjdGlvbjogZnVuY3Rpb24oZ3JpZCwgZ3JpZENlbGwsIGtleXMpIHtcbiAgICAgICAgZ3JpZC5zdG9wRWRpdGluZygpO1xuICAgICAgICAvL3ZhciBoYXNDVFJMID0ga2V5cy5pbmRleE9mKCdDVFJMJykgIT09IC0xO1xuICAgICAgICB2YXIgaGFzU0hJRlQgPSBrZXlzLmluZGV4T2YoJ1NISUZUJykgIT09IC0xO1xuXG4gICAgICAgIC8vIHZhciBzY3JvbGxUb3AgPSBncmlkLmdldFZTY3JvbGxWYWx1ZSgpO1xuICAgICAgICAvLyB2YXIgc2Nyb2xsTGVmdCA9IGdyaWQuZ2V0SFNjcm9sbFZhbHVlKCk7XG5cbiAgICAgICAgLy8gdmFyIG51bUZpeGVkQ29sdW1ucyA9IDA7Ly9ncmlkLmdldEZpeGVkQ29sdW1uQ291bnQoKTtcbiAgICAgICAgLy8gdmFyIG51bUZpeGVkUm93cyA9IDA7Ly9ncmlkLmdldEZpeGVkUm93Q291bnQoKTtcblxuICAgICAgICB2YXIgbW91c2VQb2ludCA9IGdyaWQuZ2V0TW91c2VEb3duKCk7XG4gICAgICAgIHZhciB4ID0gZ3JpZENlbGwueDsgLy8gLSBudW1GaXhlZENvbHVtbnMgKyBzY3JvbGxMZWZ0O1xuICAgICAgICB2YXIgeSA9IGdyaWRDZWxsLnk7IC8vIC0gbnVtRml4ZWRSb3dzICsgc2Nyb2xsVG9wO1xuXG4gICAgICAgIC8vd2VyZSBvdXRzaWRlIG9mIHRoZSBncmlkIGRvIG5vdGhpbmdcbiAgICAgICAgaWYgKHggPCAwIHx8IHkgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvL3dlIGhhdmUgcmVwZWF0ZWQgYSBjbGljayBpbiB0aGUgc2FtZSBzcG90IGRlc2xlY3QgdGhlIHZhbHVlIGZyb20gbGFzdCB0aW1lXG4gICAgICAgIC8vIGlmIChtb3VzZVBvaW50ICYmIHggPT09IG1vdXNlUG9pbnQueCAmJiB5ID09PSBtb3VzZVBvaW50LnkpIHtcbiAgICAgICAgLy8gICAgIGdyaWQuY2xlYXJTZWxlY3Rpb25zKCk7XG4gICAgICAgIC8vICAgICBncmlkLnBvcE1vdXNlRG93bigpO1xuICAgICAgICAvLyAgICAgZ3JpZC5yZXBhaW50KCk7XG4gICAgICAgIC8vICAgICByZXR1cm47XG4gICAgICAgIC8vIH1cblxuICAgICAgICAvLyBpZiAoIWhhc0NUUkwgJiYgIWhhc1NISUZUKSB7XG4gICAgICAgIC8vICAgICBncmlkLmNsZWFyU2VsZWN0aW9ucygpO1xuICAgICAgICAvLyB9XG5cbiAgICAgICAgaWYgKGhhc1NISUZUKSB7XG4gICAgICAgICAgICBncmlkLmNsZWFyTW9zdFJlY2VudENvbHVtblNlbGVjdGlvbigpO1xuICAgICAgICAgICAgZ3JpZC5zZWxlY3RDb2x1bW4oeCwgbW91c2VQb2ludC54KTtcbiAgICAgICAgICAgIGdyaWQuc2V0RHJhZ0V4dGVudChncmlkLm5ld1BvaW50KHggLSBtb3VzZVBvaW50LngsIDApKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdyaWQudG9nZ2xlU2VsZWN0Q29sdW1uKHgsIGtleXMpO1xuICAgICAgICAgICAgZ3JpZC5zZXRNb3VzZURvd24oZ3JpZC5uZXdQb2ludCh4LCB5KSk7XG4gICAgICAgICAgICBncmlkLnNldERyYWdFeHRlbnQoZ3JpZC5uZXdQb2ludCgwLCAwKSk7XG4gICAgICAgIH1cbiAgICAgICAgZ3JpZC5yZXBhaW50KCk7XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudFxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICovXG4gICAgaGFuZGxlRE9XTlNISUZUOiBmdW5jdGlvbihncmlkKSB7fSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5TZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnRcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlVVBTSElGVDogZnVuY3Rpb24oZ3JpZCkge30sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZUxFRlRTSElGVDogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICB0aGlzLm1vdmVTaGlmdFNlbGVjdChncmlkLCAtMSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5TZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnRcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlUklHSFRTSElGVDogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICB0aGlzLm1vdmVTaGlmdFNlbGVjdChncmlkLCAxKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudFxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVET1dOOiBmdW5jdGlvbihncmlkKSB7XG5cbiAgICAgICAgLy8gdmFyIG1vdXNlQ29ybmVyID0gZ3JpZC5nZXRNb3VzZURvd24oKS5wbHVzKGdyaWQuZ2V0RHJhZ0V4dGVudCgpKTtcbiAgICAgICAgLy8gdmFyIG1heFJvd3MgPSBncmlkLmdldFJvd0NvdW50KCkgLSAxO1xuXG4gICAgICAgIC8vIHZhciBuZXdYID0gbW91c2VDb3JuZXIueDtcbiAgICAgICAgLy8gdmFyIG5ld1kgPSBncmlkLmdldEhlYWRlclJvd0NvdW50KCkgKyBncmlkLmdldFZTY3JvbGxWYWx1ZSgpO1xuXG4gICAgICAgIC8vIG5ld1kgPSBNYXRoLm1pbihtYXhSb3dzLCBuZXdZKTtcblxuICAgICAgICAvLyBncmlkLmNsZWFyU2VsZWN0aW9ucygpO1xuICAgICAgICAvLyBncmlkLnNlbGVjdChuZXdYLCBuZXdZLCAwLCAwKTtcbiAgICAgICAgLy8gZ3JpZC5zZXRNb3VzZURvd24obmV3IGdyaWQucmVjdGFuZ3VsYXIuUG9pbnQobmV3WCwgbmV3WSkpO1xuICAgICAgICAvLyBncmlkLnNldERyYWdFeHRlbnQobmV3IGdyaWQucmVjdGFuZ3VsYXIuUG9pbnQoMCwgMCkpO1xuXG4gICAgICAgIC8vIGdyaWQucmVwYWludCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZVVQOiBmdW5jdGlvbihncmlkKSB7fSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5TZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnRcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlTEVGVDogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICB0aGlzLm1vdmVTaW5nbGVTZWxlY3QoZ3JpZCwgLTEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZVJJR0hUOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIHRoaXMubW92ZVNpbmdsZVNlbGVjdChncmlkLCAxKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBJZiB3ZSBhcmUgaG9sZGluZyBkb3duIHRoZSBzYW1lIG5hdmlnYXRpb24ga2V5LCBhY2NlbGVyYXRlIHRoZSBpbmNyZW1lbnQgd2Ugc2Nyb2xsXG4gICAgICogIyMjIyByZXR1cm5zOiBpbnRlZ2VyXG4gICAgICovXG4gICAgZ2V0QXV0b1Njcm9sbEFjY2VsZXJhdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjb3VudCA9IDE7XG4gICAgICAgIHZhciBlbGFwc2VkID0gdGhpcy5nZXRBdXRvU2Nyb2xsRHVyYXRpb24oKSAvIDIwMDA7XG4gICAgICAgIGNvdW50ID0gTWF0aC5tYXgoMSwgTWF0aC5mbG9vcihlbGFwc2VkICogZWxhcHNlZCAqIGVsYXBzZWQgKiBlbGFwc2VkKSk7XG4gICAgICAgIHJldHVybiBjb3VudDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBzZXQgdGhlIHN0YXJ0IHRpbWUgdG8gcmlnaHQgbm93IHdoZW4gd2UgaW5pdGlhdGUgYW4gYXV0byBzY3JvbGxcbiAgICAgKi9cbiAgICBzZXRBdXRvU2Nyb2xsU3RhcnRUaW1lOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5zYkF1dG9TdGFydCA9IERhdGUubm93KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5TZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgdXBkYXRlIHRoZSBhdXRvc2Nyb2xsIHN0YXJ0IHRpbWUgaWYgd2UgaGF2ZW4ndCBhdXRvc2Nyb2xsZWQgd2l0aGluIHRoZSBsYXN0IDUwMG1zIG90aGVyd2lzZSB1cGRhdGUgdGhlIGN1cnJlbnQgYXV0b3Njcm9sbCB0aW1lXG4gICAgICovXG4gICAgcGluZ0F1dG9TY3JvbGw6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgaWYgKG5vdyAtIHRoaXMuc2JMYXN0QXV0byA+IDUwMCkge1xuICAgICAgICAgICAgdGhpcy5zZXRBdXRvU2Nyb2xsU3RhcnRUaW1lKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zYkxhc3RBdXRvID0gRGF0ZS5ub3coKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBhbnN3ZXIgaG93IGxvbmcgd2UgaGF2ZSBiZWVuIGF1dG8gc2Nyb2xsaW5nXG4gICAgICogIyMjIyByZXR1cm5zOiBpbnRlZ2VyXG4gICAgICovXG4gICAgZ2V0QXV0b1Njcm9sbER1cmF0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKERhdGUubm93KCkgLSB0aGlzLnNiTGFzdEF1dG8gPiA1MDApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBEYXRlLm5vdygpIC0gdGhpcy5zYkF1dG9TdGFydDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBBdWdtZW50IHRoZSBtb3N0IHJlY2VudCBzZWxlY3Rpb24gZXh0ZW50IGJ5IChvZmZzZXRYLG9mZnNldFkpIGFuZCBzY3JvbGwgaWYgbmVjZXNzYXJ5LlxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFggLSB4IGNvb3JkaW5hdGUgdG8gc3RhcnQgYXRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0WSAtIHkgY29vcmRpbmF0ZSB0byBzdGFydCBhdFxuICAgICAqL1xuICAgIG1vdmVTaGlmdFNlbGVjdDogZnVuY3Rpb24oZ3JpZCwgb2Zmc2V0WCkge1xuXG4gICAgICAgIHZhciBtYXhDb2x1bW5zID0gZ3JpZC5nZXRDb2x1bW5Db3VudCgpIC0gMTtcblxuICAgICAgICB2YXIgbWF4Vmlld2FibGVDb2x1bW5zID0gZ3JpZC5nZXRWaXNpYmxlQ29sdW1ucygpIC0gMTtcblxuICAgICAgICBpZiAoIWdyaWQucmVzb2x2ZVByb3BlcnR5KCdzY3JvbGxpbmdFbmFibGVkJykpIHtcbiAgICAgICAgICAgIG1heENvbHVtbnMgPSBNYXRoLm1pbihtYXhDb2x1bW5zLCBtYXhWaWV3YWJsZUNvbHVtbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG9yaWdpbiA9IGdyaWQuZ2V0TW91c2VEb3duKCk7XG4gICAgICAgIHZhciBleHRlbnQgPSBncmlkLmdldERyYWdFeHRlbnQoKTtcblxuICAgICAgICB2YXIgbmV3WCA9IGV4dGVudC54ICsgb2Zmc2V0WDtcbiAgICAgICAgLy92YXIgbmV3WSA9IGdyaWQuZ2V0Um93Q291bnQoKTtcblxuICAgICAgICBuZXdYID0gTWF0aC5taW4obWF4Q29sdW1ucyAtIG9yaWdpbi54LCBNYXRoLm1heCgtb3JpZ2luLngsIG5ld1gpKTtcblxuICAgICAgICBncmlkLmNsZWFyTW9zdFJlY2VudENvbHVtblNlbGVjdGlvbigpO1xuICAgICAgICBncmlkLnNlbGVjdENvbHVtbihvcmlnaW4ueCwgb3JpZ2luLnggKyBuZXdYKTtcblxuICAgICAgICBncmlkLnNldERyYWdFeHRlbnQoZ3JpZC5uZXdQb2ludChuZXdYLCAwKSk7XG5cbiAgICAgICAgaWYgKGdyaWQuaW5zdXJlTW9kZWxDb2xJc1Zpc2libGUobmV3WCArIG9yaWdpbi54LCBvZmZzZXRYKSkge1xuICAgICAgICAgICAgdGhpcy5waW5nQXV0b1Njcm9sbCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZ3JpZC5yZXBhaW50KCk7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBSZXBsYWNlIHRoZSBtb3N0IHJlY2VudCBzZWxlY3Rpb24gd2l0aCBhIHNpbmdsZSBjZWxsIHNlbGVjdGlvbiB0aGF0IGlzIG1vdmVkIChvZmZzZXRYLG9mZnNldFkpIGZyb20gdGhlIHByZXZpb3VzIHNlbGVjdGlvbiBleHRlbnQuXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0WCAtIHggY29vcmRpbmF0ZSB0byBzdGFydCBhdFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRZIC0geSBjb29yZGluYXRlIHRvIHN0YXJ0IGF0XG4gICAgICovXG4gICAgbW92ZVNpbmdsZVNlbGVjdDogZnVuY3Rpb24oZ3JpZCwgb2Zmc2V0WCkge1xuXG4gICAgICAgIHZhciBtYXhDb2x1bW5zID0gZ3JpZC5nZXRDb2x1bW5Db3VudCgpIC0gMTtcblxuICAgICAgICB2YXIgbWF4Vmlld2FibGVDb2x1bW5zID0gZ3JpZC5nZXRWaXNpYmxlQ29sdW1uc0NvdW50KCkgLSAxO1xuXG4gICAgICAgIGlmICghZ3JpZC5yZXNvbHZlUHJvcGVydHkoJ3Njcm9sbGluZ0VuYWJsZWQnKSkge1xuICAgICAgICAgICAgbWF4Q29sdW1ucyA9IE1hdGgubWluKG1heENvbHVtbnMsIG1heFZpZXdhYmxlQ29sdW1ucyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbW91c2VDb3JuZXIgPSBncmlkLmdldE1vdXNlRG93bigpLnBsdXMoZ3JpZC5nZXREcmFnRXh0ZW50KCkpO1xuXG4gICAgICAgIHZhciBuZXdYID0gbW91c2VDb3JuZXIueCArIG9mZnNldFg7XG4gICAgICAgIC8vdmFyIG5ld1kgPSBncmlkLmdldFJvd0NvdW50KCk7XG5cbiAgICAgICAgbmV3WCA9IE1hdGgubWluKG1heENvbHVtbnMsIE1hdGgubWF4KDAsIG5ld1gpKTtcblxuICAgICAgICBncmlkLmNsZWFyU2VsZWN0aW9ucygpO1xuICAgICAgICBncmlkLnNlbGVjdENvbHVtbihuZXdYKTtcbiAgICAgICAgZ3JpZC5zZXRNb3VzZURvd24oZ3JpZC5uZXdQb2ludChuZXdYLCAwKSk7XG4gICAgICAgIGdyaWQuc2V0RHJhZ0V4dGVudChncmlkLm5ld1BvaW50KDAsIDApKTtcblxuICAgICAgICBpZiAoZ3JpZC5pbnN1cmVNb2RlbENvbElzVmlzaWJsZShuZXdYLCBvZmZzZXRYKSkge1xuICAgICAgICAgICAgdGhpcy5waW5nQXV0b1Njcm9sbCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZ3JpZC5yZXBhaW50KCk7XG5cbiAgICB9LFxuXG4gICAgaXNDb2x1bW5EcmFnZ2luZzogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICB2YXIgZHJhZ2dlciA9IGdyaWQubG9va3VwRmVhdHVyZSgnQ29sdW1uTW92aW5nJyk7XG4gICAgICAgIGlmICghZHJhZ2dlcikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpc0FjdGl2YXRlZCA9IGRyYWdnZXIuZHJhZ2dpbmcgJiYgIXRoaXMuZHJhZ2dpbmc7XG4gICAgICAgIHJldHVybiBpc0FjdGl2YXRlZDtcbiAgICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbHVtblNlbGVjdGlvbjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEZlYXR1cmUgPSByZXF1aXJlKCcuL0ZlYXR1cmUuanMnKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIEZlYXR1cmVcbiAqL1xudmFyIENvbHVtblNvcnRpbmcgPSBGZWF0dXJlLmV4dGVuZCgnQ29sdW1uU29ydGluZycsIHtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5Tb3J0aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIEhhbmRsZSB0aGlzIGV2ZW50IGRvd24gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHkuXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuXG4gICAgaGFuZGxlRG91YmxlQ2xpY2s6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIHZhciBncmlkQ2VsbCA9IGV2ZW50LmdyaWRDZWxsO1xuICAgICAgICBpZiAoZ3JpZC5pc1Nob3dIZWFkZXJSb3coKSAmJiBncmlkQ2VsbC55ID09PSAwICYmIGdyaWRDZWxsLnggIT09IC0xKSB7XG4gICAgICAgICAgICB2YXIga2V5cyA9IGV2ZW50LnByaW1pdGl2ZUV2ZW50LmRldGFpbC5rZXlzO1xuICAgICAgICAgICAgZ3JpZC50b2dnbGVTb3J0KGdyaWRDZWxsLngsIGtleXMpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZURvdWJsZUNsaWNrKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uU29ydGluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBIYW5kbGUgdGhpcyBldmVudCBkb3duIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5LlxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVNb3VzZU1vdmU6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIHZhciB5ID0gZXZlbnQuZ3JpZENlbGwueTtcbiAgICAgICAgaWYgKHRoaXMuaXNGaXhlZFJvdyhncmlkLCBldmVudCkgJiYgeSA8IDEpIHtcbiAgICAgICAgICAgIHRoaXMuY3Vyc29yID0gJ3BvaW50ZXInO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jdXJzb3IgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVNb3VzZU1vdmUoZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb2x1bW5Tb3J0aW5nO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQmFzZSA9IHJlcXVpcmUoJy4uL2xpYi9CYXNlJyk7XG5cbi8qKlxuICogSW5zdGFuY2VzIG9mIGZlYXR1cmVzIGFyZSBjb25uZWN0ZWQgdG8gb25lIGFub3RoZXIgdG8gbWFrZSBhIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5IGZvciBoYW5kbGluZyBhbGwgdGhlIGlucHV0IHRvIHRoZSBoeXBlcmdyaWQuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIEZlYXR1cmUgPSBCYXNlLmV4dGVuZCgnRmVhdHVyZScsIHtcblxuICAgIC8qKlxuICAgICAqIHRoZSBuZXh0IGZlYXR1cmUgdG8gYmUgZ2l2ZW4gYSBjaGFuY2UgdG8gaGFuZGxlIGluY29taW5nIGV2ZW50c1xuICAgICAqIEB0eXBlIHtGZWF0dXJlfVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKiBAbWVtYmVyT2YgRmVhdHVyZS5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBuZXh0OiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogYSB0ZW1wb3JhcnkgaG9sZGluZyBmaWVsZCBmb3IgbXkgbmV4dCBmZWF0dXJlIHdoZW4gSSdtIGluIGEgZGlzY29ubmVjdGVkIHN0YXRlXG4gICAgICogQHR5cGUge0ZlYXR1cmV9XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqIEBtZW1iZXJPZiBGZWF0dXJlLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGRldGFjaGVkOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogdGhlIGN1cnNvciBJIHdhbnQgdG8gYmUgZGlzcGxheWVkXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICogQG1lbWJlck9mIEZlYXR1cmUucHJvdG90eXBlXG4gICAgICovXG4gICAgY3Vyc29yOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogdGhlIGNlbGwgbG9jYXRpb24gd2hlcmUgdGhlIGN1cnNvciBpcyBjdXJyZW50bHlcbiAgICAgKiBAdHlwZSB7UG9pbnR9XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqIEBtZW1iZXJPZiBGZWF0dXJlLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGN1cnJlbnRIb3ZlckNlbGw6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRmVhdHVyZS5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBzZXQgbXkgbmV4dCBmaWVsZCwgb3IgaWYgaXQncyBwb3B1bGF0ZWQgZGVsZWdhdGUgdG8gdGhlIGZlYXR1cmUgaW4gbXkgbmV4dCBmaWVsZFxuICAgICAqIEBwYXJhbSB7RmVhdHVyZX0gbmV4dEZlYXR1cmUgLSB0aGlzIGlzIGhvdyB3ZSBidWlsZCB0aGUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHlcbiAgICAgKi9cbiAgICBzZXROZXh0OiBmdW5jdGlvbihuZXh0RmVhdHVyZSkge1xuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuc2V0TmV4dChuZXh0RmVhdHVyZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm5leHQgPSBuZXh0RmVhdHVyZTtcbiAgICAgICAgICAgIHRoaXMuZGV0YWNoZWQgPSBuZXh0RmVhdHVyZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRmVhdHVyZS5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBkaXNjb25uZWN0IG15IGNoaWxkXG4gICAgICovXG4gICAgZGV0YWNoQ2hhaW46IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLm5leHQgPSBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRmVhdHVyZS5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyByZWF0dGFjaCBteSBjaGlsZCBmcm9tIHRoZSBkZXRhY2hlZCByZWZlcmVuY2VcbiAgICAgKi9cbiAgICBhdHRhY2hDaGFpbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IHRoaXMuZGV0YWNoZWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBGZWF0dXJlLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSBtb3VzZSBtb3ZlIGRvd24gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlTW91c2VNb3ZlOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlTW91c2VNb3ZlKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRmVhdHVyZS5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudCBkb3duIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZU1vdXNlRXhpdDogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZU1vdXNlRXhpdChncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEZlYXR1cmUucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnQgZG93biB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVNb3VzZUVudGVyOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlTW91c2VFbnRlcihncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEZlYXR1cmUucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnQgZG93biB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVNb3VzZURvd246IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVNb3VzZURvd24oZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBGZWF0dXJlLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50IGRvd24gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlTW91c2VVcDogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZU1vdXNlVXAoZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBGZWF0dXJlLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50IGRvd24gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlS2V5RG93bjogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZUtleURvd24oZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBGZWF0dXJlLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50IGRvd24gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlS2V5VXA6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVLZXlVcChncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEZlYXR1cmUucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnQgZG93biB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVXaGVlbE1vdmVkOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlV2hlZWxNb3ZlZChncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEZlYXR1cmUucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnQgZG93biB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVEb3VibGVDbGljazogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZURvdWJsZUNsaWNrKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRmVhdHVyZS5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudCBkb3duIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZUNsaWNrOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlQ2xpY2soZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBGZWF0dXJlLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50IGRvd24gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlTW91c2VEcmFnOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlTW91c2VEcmFnKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRmVhdHVyZS5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudCBkb3duIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZUNvbnRleHRNZW51OiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlQ29udGV4dE1lbnUoZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBGZWF0dXJlLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHRvZ2dsZSB0aGUgY29sdW1uIHBpY2tlclxuICAgICAqL1xuXG4gICAgbW92ZVNpbmdsZVNlbGVjdDogZnVuY3Rpb24oZ3JpZCwgeCwgeSkge1xuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQubW92ZVNpbmdsZVNlbGVjdChncmlkLCB4LCB5KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRmVhdHVyZS5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudCBkb3duIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGlzRml4ZWRSb3c6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIHZhciBncmlkQ2VsbCA9IGV2ZW50LnZpZXdQb2ludDtcbiAgICAgICAgdmFyIGlzRml4ZWQgPSBncmlkQ2VsbC55IDwgZ3JpZC5nZXRGaXhlZFJvd0NvdW50KCk7XG4gICAgICAgIHJldHVybiBpc0ZpeGVkO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRmVhdHVyZS5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudCBkb3duIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGlzRmlyc3RGaXhlZFJvdzogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgdmFyIGdyaWRDZWxsID0gZXZlbnQudmlld1BvaW50O1xuICAgICAgICB2YXIgaXNGaXhlZCA9IGdyaWRDZWxsLnkgPCAxO1xuICAgICAgICByZXR1cm4gaXNGaXhlZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEZlYXR1cmUucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnQgZG93biB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBpc0ZpeGVkQ29sdW1uOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICB2YXIgZ3JpZENlbGwgPSBldmVudC52aWV3UG9pbnQ7XG4gICAgICAgIHZhciBpc0ZpeGVkID0gZ3JpZENlbGwueCA8IGdyaWQuZ2V0Rml4ZWRDb2x1bW5Db3VudCgpO1xuICAgICAgICByZXR1cm4gaXNGaXhlZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEZlYXR1cmUucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnQgZG93biB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBpc0ZpcnN0Rml4ZWRDb2x1bW46IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIHZhciBncmlkQ2VsbCA9IGV2ZW50LnZpZXdQb2ludDtcbiAgICAgICAgdmFyIGVkZ2UgPSBncmlkLmlzU2hvd1Jvd051bWJlcnMoKSA/IDAgOiAxO1xuICAgICAgICB2YXIgaXNGaXhlZCA9IGdyaWRDZWxsLnggPCBlZGdlO1xuICAgICAgICByZXR1cm4gaXNGaXhlZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEZlYXR1cmUucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnQgZG93biB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBpc1RvcExlZnQ6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIHZhciBpc1RvcExlZnQgPSB0aGlzLmlzRml4ZWRSb3coZ3JpZCwgZXZlbnQpICYmIHRoaXMuaXNGaXhlZENvbHVtbihncmlkLCBldmVudCk7XG4gICAgICAgIHJldHVybiBpc1RvcExlZnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBGZWF0dXJlLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50IGRvd24gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgc2V0Q3Vyc29yOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5zZXRDdXJzb3IoZ3JpZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY3Vyc29yKSB7XG4gICAgICAgICAgICBncmlkLmJlQ3Vyc29yKHRoaXMuY3Vyc29yKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRmVhdHVyZS5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudCBkb3duIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGluaXRpYWxpemVPbjogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaW5pdGlhbGl6ZU9uKGdyaWQpO1xuICAgICAgICB9XG4gICAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBGZWF0dXJlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRmVhdHVyZSA9IHJlcXVpcmUoJy4vRmVhdHVyZS5qcycpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgRmlsdGVycyA9IEZlYXR1cmUuZXh0ZW5kKCdGaWx0ZXJzJywge1xuXG4gICAgaGFuZGxlRG91YmxlQ2xpY2s6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmIChncmlkLmlzRmlsdGVyUm93KGV2ZW50LmdyaWRDZWxsLnkpKSB7XG4gICAgICAgICAgICBncmlkLm9uRWRpdG9yQWN0aXZhdGUoZXZlbnQpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZURvdWJsZUNsaWNrKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBoYW5kbGVDbGljazogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKGdyaWQuaXNGaWx0ZXJSb3coZXZlbnQuZ3JpZENlbGwueSkpIHtcbiAgICAgICAgICAgIGdyaWQub25FZGl0b3JBY3RpdmF0ZShldmVudCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlQ2xpY2soZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBGaWx0ZXJzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRmVhdHVyZSA9IHJlcXVpcmUoJy4vRmVhdHVyZS5qcycpO1xuXG52YXIgY29tbWFuZHMgPSB7XG4gICAgUEFHRURPV046IGZ1bmN0aW9uKGdyaWQpIHsgZ3JpZC5wYWdlRG93bigpOyB9LFxuICAgIFBBR0VVUDogZnVuY3Rpb24oZ3JpZCkgeyBncmlkLnBhZ2VVcCgpOyB9LFxuICAgIFBBR0VMRUZUOiBmdW5jdGlvbihncmlkKSB7IGdyaWQucGFnZUxlZnQoKTsgfSxcbiAgICBQQUdFUklHSFQ6IGZ1bmN0aW9uKGdyaWQpIHsgZ3JpZC5wYWdlUmlnaHQoKTsgfVxufTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIEtleVBhZ2luZyA9IEZlYXR1cmUuZXh0ZW5kKCdLZXlQYWdpbmcnLCB7XG5cbiAgICAvKipcbiAgICAgKiBAZGVzYyBIYW5kbGUgdGhpcyBldmVudCBkb3duIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5LlxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKiBAbWVtYmVyT2YgS2V5UGFnaW5nLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGhhbmRsZUtleURvd246IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIHZhciBmdW5jID0gY29tbWFuZHNbZXZlbnQuZGV0YWlsLmNoYXJdO1xuICAgICAgICBpZiAoZnVuYykge1xuICAgICAgICAgICAgZnVuYyhncmlkKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVLZXlEb3duKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gS2V5UGFnaW5nO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRmVhdHVyZSA9IHJlcXVpcmUoJy4vRmVhdHVyZS5qcycpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgT25Ib3ZlciA9IEZlYXR1cmUuZXh0ZW5kKCdPbkhvdmVyJywge1xuXG4gICAgLyoqXG4gICAgICogQGRlc2MgSGhhbmRsZSB0aGlzIGV2ZW50IGRvd24gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHkuXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqIEBtZW1iZXJPZiBPbkhvdmVyLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGhhbmRsZU1vdXNlTW92ZTogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRIb3ZlckNlbGwgPSBncmlkLmdldEhvdmVyQ2VsbCgpO1xuICAgICAgICBpZiAoIWV2ZW50LmdyaWRDZWxsLmVxdWFscyhjdXJyZW50SG92ZXJDZWxsKSkge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRIb3ZlckNlbGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZU1vdXNlRXhpdChncmlkLCBjdXJyZW50SG92ZXJDZWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaGFuZGxlTW91c2VFbnRlcihncmlkLCBldmVudCk7XG4gICAgICAgICAgICBncmlkLnNldEhvdmVyQ2VsbChldmVudC5ncmlkQ2VsbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZU1vdXNlTW92ZShncmlkLCBldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9uSG92ZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBDb2x1bW5SZXNpemluZyA9IHJlcXVpcmUoJy4vQ29sdW1uUmVzaXppbmcnKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIENvbHVtblJlc2l6aW5nXG4gKi9cbnZhciBSb3dSZXNpemluZyA9IENvbHVtblJlc2l6aW5nLmV4dGVuZCgnUm93UmVzaXppbmcnLCB7XG5cbiAgICAvKipcbiAgICAgKiB0aGUgaW5kZXggb2YgdGhlIHJvdy9jb2x1bW4gd2UgYXJlIGRyYWdnaW5nXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAtMVxuICAgICAqIEBtZW1iZXJPZiBSb3dSZXNpemluZy5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBkcmFnQXJlYTogLTEsXG5cbiAgICAvKipcbiAgICAgKiB0aGUgcGl4ZWwgbG9jYXRpb24gb2YgdGhlIHdoZXJlIHRoZSBkcmFnIHdhcyBpbml0aWF0ZWRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IC0xXG4gICAgICogQG1lbWJlck9mIFJvd1Jlc2l6aW5nLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGRyYWdTdGFydDogLTEsXG5cbiAgICAvKipcbiAgICAgKiB0aGUgc3RhcnRpbmcgd2lkdGgvaGVpZ2h0IG9mIHRoZSByb3cvY29sdW1uIHdlIGFyZSBkcmFnZ2luZ1xuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgLTFcbiAgICAgKiBAbWVtYmVyT2YgUm93UmVzaXppbmcucHJvdG90eXBlXG4gICAgICovXG4gICAgZHJhZ0FyZWFTdGFydGluZ1NpemU6IC0xLFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJvd1Jlc2l6aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGdldCB0aGUgbW91c2UgeCx5IGNvb3JkaW5hdGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZXZlbnQgLSB0aGUgbW91c2UgZXZlbnQgdG8gcXVlcnlcbiAgICAgKi9cbiAgICBnZXRNb3VzZVZhbHVlOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICByZXR1cm4gZXZlbnQucHJpbWl0aXZlRXZlbnQuZGV0YWlsLm1vdXNlLnk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJPZiBSb3dSZXNpemluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBnZXQgdGhlIGdyaWQgY2VsbCB4LHkgY29vcmRpbmF0ZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICogQHBhcmFtIHtQb2ludH0gZ3JpZENlbGxcbiAgICAgKi9cbiAgICBnZXRHcmlkQ2VsbFZhbHVlOiBmdW5jdGlvbihncmlkQ2VsbCkge1xuICAgICAgICByZXR1cm4gZ3JpZENlbGwueDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlck9mIFJvd1Jlc2l6aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHJldHVybiB0aGUgZ3JpZHMgeCx5IHNjcm9sbCB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKi9cbiAgICBnZXRTY3JvbGxWYWx1ZTogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICByZXR1cm4gZ3JpZC5nZXRWU2Nyb2xsVmFsdWUoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlck9mIFJvd1Jlc2l6aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHJldHVybiB0aGUgd2lkdGgvaGVpZ2h0IG9mIHRoZSByb3cvY29sdW1uIG9mIGludGVyZXN0XG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIHRoZSByb3cvY29sdW1uIGluZGV4IG9mIGludGVyZXN0XG4gICAgICovXG4gICAgZ2V0QXJlYVNpemU6IGZ1bmN0aW9uKGdyaWQsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBncmlkLmdldFJvd0hlaWdodChpbmRleCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJPZiBSb3dSZXNpemluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBzZXQgdGhlIHdpZHRoL2hlaWdodCBvZiB0aGUgcm93L2NvbHVtbiBhdCBpbmRleFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSB0aGUgcm93L2NvbHVtbiBpbmRleCBvZiBpbnRlcmVzdFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtIHRoZSB3aWR0aC9oZWlnaHQgdG8gc2V0IHRvXG4gICAgICovXG4gICAgc2V0QXJlYVNpemU6IGZ1bmN0aW9uKGdyaWQsIGluZGV4LCB2YWx1ZSkge1xuICAgICAgICBncmlkLnNldFJvd0hlaWdodChpbmRleCwgdmFsdWUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyT2YgUm93UmVzaXppbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgcmV0dXJucyB0aGUgaW5kZXggb2Ygd2hpY2ggZGl2aWRlciBJJ20gb3ZlclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIG92ZXJBcmVhRGl2aWRlcjogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIGdyaWQub3ZlclJvd0RpdmlkZXIoZXZlbnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyT2YgUm93UmVzaXppbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgYW0gSSBvdmVyIHRoZSBjb2x1bW4vcm93IGFyZWFcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaXNGaXJzdEZpeGVkT3RoZXJBcmVhOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc0ZpcnN0Rml4ZWRDb2x1bW4oZ3JpZCwgZXZlbnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyT2YgUm93UmVzaXppbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgcmV0dXJuIHRoZSBjdXJzb3IgbmFtZVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0Q3Vyc29yTmFtZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAncm93LXJlc2l6ZSc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJPZiBSb3dSZXNpemluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyByZXR1cm4gdGhlIHJlY2VudGx5IHJlbmRlcmVkIGFyZWEncyB3aWR0aC9oZWlnaHRcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gdGhlIHJvdy9jb2x1bW4gaW5kZXggb2YgaW50ZXJlc3RcbiAgICAgKi9cbiAgICBnZXRQcmV2aW91c0Fic29sdXRlU2l6ZTogZnVuY3Rpb24oZ3JpZCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGdyaWQuZ2V0UmVuZGVyZWRIZWlnaHQoaW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyT2YgUm93UmVzaXppbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgcmV0dXJuIHRoZSBmaXhlZCBhcmVhIHJvd3MvY29sdW1ucyBjb3VudFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKi9cbiAgICBnZXRPdGhlckZpeGVkQXJlYUNvdW50OiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIHJldHVybiBncmlkLmdldEZpeGVkQ29sdW1uQ291bnQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgLTJcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uUmVzaXppbmcucHJvdG90eXBlXG4gICAgICovXG4gICAgZ2V0Rml4ZWRBcmVhQ291bnQ6IGZ1bmN0aW9uKGdyaWQpIHtcbiAgICAgICAgcmV0dXJuIGdyaWQuZ2V0Rml4ZWRSb3dDb3VudCgpICsgZ3JpZC5nZXRIZWFkZXJSb3dDb3VudCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICogQGRlZmF1bHQgLTJcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uUmVzaXppbmcucHJvdG90eXBlXG4gICAgICovXG4gICAgaXNFbmFibGVkOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIHJldHVybiBncmlkLmlzUm93UmVzaXplYWJsZSgpO1xuICAgIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUm93UmVzaXppbmc7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBGZWF0dXJlID0gcmVxdWlyZSgnLi9GZWF0dXJlLmpzJyk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBSb3dTZWxlY3Rpb24gPSBGZWF0dXJlLmV4dGVuZCgnUm93U2VsZWN0aW9uJywge1xuXG4gICAgLyoqXG4gICAgICogVGhlIHBpeGVsIGxvY2F0aW9uIG9mIHRoZSBtb3VzZSBwb2ludGVyIGR1cmluZyBhIGRyYWcgb3BlcmF0aW9uLlxuICAgICAqIEB0eXBlIHtQb2ludH1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICogQG1lbWJlck9mIFJvd1NlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBjdXJyZW50RHJhZzogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFRoZSBjZWxsIGNvb3JkaW5hdGVzIG9mIHRoZSB3aGVyZSB0aGUgbW91c2UgcG9pbnRlciBpcyBkdXJpbmcgYSBkcmFnIG9wZXJhdGlvbi5cbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKiBAbWVtYmVyT2YgUm93U2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGxhc3REcmFnQ2VsbDogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIGEgbWlsbGlzZWNvbmQgdmFsdWUgcmVwcmVzZW50aW5nIHRoZSBwcmV2aW91cyB0aW1lIGFuIGF1dG9zY3JvbGwgc3RhcnRlZFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqIEBtZW1iZXJPZiBSb3dTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICovXG4gICAgc2JMYXN0QXV0bzogMCxcblxuICAgIC8qKlxuICAgICAqIGEgbWlsbGlzZWNvbmQgdmFsdWUgcmVwcmVzZW50aW5nIHRoZSB0aW1lIHRoZSBjdXJyZW50IGF1dG9zY3JvbGwgc3RhcnRlZFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqIEBtZW1iZXJPZiBSb3dTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICovXG4gICAgc2JBdXRvU3RhcnQ6IDAsXG5cbiAgICBkcmFnQXJtZWQ6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJvd1NlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBIYW5kbGUgdGhpcyBldmVudCBkb3duIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5LlxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVNb3VzZVVwOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAodGhpcy5kcmFnQXJtZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhZ0FybWVkID0gZmFsc2U7XG4gICAgICAgICAgICAvL2dsb2JhbCByb3cgc2VsZWN0aW9uXG4gICAgICAgICAgICBpZiAoZXZlbnQuZ3JpZENlbGwueCA9PT0gLTEgJiYgZXZlbnQuZ3JpZENlbGwueSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGdyaWQudG9nZ2xlU2VsZWN0QWxsUm93cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ3JpZC5maXJlU3ludGhldGljUm93U2VsZWN0aW9uQ2hhbmdlZEV2ZW50KCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5kcmFnZ2luZykge1xuICAgICAgICAgICAgdGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgZ3JpZC5maXJlU3ludGhldGljUm93U2VsZWN0aW9uQ2hhbmdlZEV2ZW50KCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlTW91c2VVcChncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJvd1NlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyAqIEBkZXNjIEhhbmRsZSB0aGlzIGV2ZW50IGRvd24gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHkuXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZU1vdXNlRG93bjogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcblxuICAgICAgICB2YXIgaXNSaWdodENsaWNrID0gZXZlbnQucHJpbWl0aXZlRXZlbnQuZGV0YWlsLmlzUmlnaHRDbGljaztcbiAgICAgICAgdmFyIGNlbGwgPSBldmVudC5ncmlkQ2VsbDtcbiAgICAgICAgdmFyIHZpZXdDZWxsID0gZXZlbnQudmlld1BvaW50O1xuICAgICAgICB2YXIgZHggPSBjZWxsLng7XG4gICAgICAgIHZhciBkeSA9IGNlbGwueTtcblxuXG4gICAgICAgIHZhciBpc0hlYWRlciA9IGdyaWQuaXNTaG93Um93TnVtYmVycygpICYmIGR4IDwgMDtcblxuICAgICAgICBpZiAoIWdyaWQuaXNSb3dTZWxlY3Rpb24oKSB8fCBpc1JpZ2h0Q2xpY2sgfHwgIWlzSGVhZGVyKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZU1vdXNlRG93bihncmlkLCBldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIHZhciBudW1GaXhlZFJvd3MgPSBncmlkLmdldEZpeGVkUm93Q291bnQoKTtcblxuICAgICAgICAgICAgLy9pZiB3ZSBhcmUgaW4gdGhlIGZpeGVkIGFyZWEgZG8gbm90IGFwcGx5IHRoZSBzY3JvbGwgdmFsdWVzXG4gICAgICAgICAgICAvL2NoZWNrIGJvdGggeCBhbmQgeSB2YWx1ZXMgaW5kZXBlbmRlbnRseVxuICAgICAgICAgICAgaWYgKHZpZXdDZWxsLnkgPCBudW1GaXhlZFJvd3MpIHtcbiAgICAgICAgICAgICAgICBkeSA9IHZpZXdDZWxsLnk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBkQ2VsbCA9IGdyaWQubmV3UG9pbnQoMCwgZHkpO1xuXG4gICAgICAgICAgICB2YXIgcHJpbUV2ZW50ID0gZXZlbnQucHJpbWl0aXZlRXZlbnQ7XG4gICAgICAgICAgICB2YXIga2V5cyA9IHByaW1FdmVudC5kZXRhaWwua2V5cztcbiAgICAgICAgICAgIHRoaXMuZHJhZ0FybWVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZXh0ZW5kU2VsZWN0aW9uKGdyaWQsIGRDZWxsLCBrZXlzKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUm93U2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50IGRvd24gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlTW91c2VEcmFnOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICB2YXIgaXNSaWdodENsaWNrID0gZXZlbnQucHJpbWl0aXZlRXZlbnQuZGV0YWlsLmlzUmlnaHRDbGljaztcblxuICAgICAgICBpZiAoIXRoaXMuZHJhZ0FybWVkIHx8ICFncmlkLmlzUm93U2VsZWN0aW9uKCkgfHwgaXNSaWdodENsaWNrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZU1vdXNlRHJhZyhncmlkLCBldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBudW1GaXhlZFJvd3MgPSBncmlkLmdldEZpeGVkUm93Q291bnQoKTtcblxuICAgICAgICAgICAgdmFyIGNlbGwgPSBldmVudC5ncmlkQ2VsbDtcbiAgICAgICAgICAgIHZhciB2aWV3Q2VsbCA9IGV2ZW50LnZpZXdQb2ludDtcbiAgICAgICAgICAgIC8vdmFyIGR4ID0gY2VsbC54O1xuICAgICAgICAgICAgdmFyIGR5ID0gY2VsbC55O1xuXG4gICAgICAgICAgICAvL2lmIHdlIGFyZSBpbiB0aGUgZml4ZWQgYXJlYSBkbyBub3QgYXBwbHkgdGhlIHNjcm9sbCB2YWx1ZXNcbiAgICAgICAgICAgIC8vY2hlY2sgYm90aCB4IGFuZCB5IHZhbHVlcyBpbmRlcGVuZGVudGx5XG4gICAgICAgICAgICBpZiAodmlld0NlbGwueSA8IG51bUZpeGVkUm93cykge1xuICAgICAgICAgICAgICAgIGR5ID0gdmlld0NlbGwueTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGRDZWxsID0gZ3JpZC5uZXdQb2ludCgwLCBkeSk7XG5cbiAgICAgICAgICAgIHZhciBwcmltRXZlbnQgPSBldmVudC5wcmltaXRpdmVFdmVudDtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudERyYWcgPSBwcmltRXZlbnQuZGV0YWlsLm1vdXNlO1xuICAgICAgICAgICAgdGhpcy5sYXN0RHJhZ0NlbGwgPSBkQ2VsbDtcblxuICAgICAgICAgICAgdGhpcy5jaGVja0RyYWdTY3JvbGwoZ3JpZCwgdGhpcy5jdXJyZW50RHJhZyk7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZU1vdXNlRHJhZ0NlbGxTZWxlY3Rpb24oZ3JpZCwgZENlbGwsIHByaW1FdmVudC5kZXRhaWwua2V5cyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJvd1NlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudCBkb3duIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZUtleURvd246IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIHZhciBoYW5kbGVyO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICBncmlkLmdldExhc3RTZWxlY3Rpb25UeXBlKCkgPT09ICdyb3cnICYmXG4gICAgICAgICAgICAoaGFuZGxlciA9IHRoaXNbJ2hhbmRsZScgKyBldmVudC5kZXRhaWwuY2hhcl0pXG4gICAgICAgICkge1xuICAgICAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGdyaWQsIGV2ZW50LmRldGFpbCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlS2V5RG93bihncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJvd1NlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBIYW5kbGUgYSBtb3VzZWRyYWcgc2VsZWN0aW9uXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbW91c2UgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGtleXMgLSBhcnJheSBvZiB0aGUga2V5cyB0aGF0IGFyZSBjdXJyZW50bHkgcHJlc3NlZCBkb3duXG4gICAgICovXG4gICAgaGFuZGxlTW91c2VEcmFnQ2VsbFNlbGVjdGlvbjogZnVuY3Rpb24oZ3JpZCwgZ3JpZENlbGwsIGtleXMpIHtcbiAgICAgICAgdmFyIHkgPSBncmlkQ2VsbC55O1xuICAgICAgICAvLyAgICAgICAgICAgIHZhciBwcmV2aW91c0RyYWdFeHRlbnQgPSBncmlkLmdldERyYWdFeHRlbnQoKTtcbiAgICAgICAgdmFyIG1vdXNlRG93biA9IGdyaWQuZ2V0TW91c2VEb3duKCk7XG5cbiAgICAgICAgdmFyIG5ld1kgPSB5IC0gbW91c2VEb3duLnk7XG4gICAgICAgIC8vdmFyIG5ld1kgPSB5IC0gbW91c2VEb3duLnk7XG5cbiAgICAgICAgLy8gaWYgKHByZXZpb3VzRHJhZ0V4dGVudC54ID09PSBuZXdYICYmIHByZXZpb3VzRHJhZ0V4dGVudC55ID09PSBuZXdZKSB7XG4gICAgICAgIC8vICAgICByZXR1cm47XG4gICAgICAgIC8vIH1cblxuICAgICAgICBncmlkLmNsZWFyTW9zdFJlY2VudFJvd1NlbGVjdGlvbigpO1xuXG4gICAgICAgIGdyaWQuc2VsZWN0Um93KG1vdXNlRG93bi55LCB5KTtcbiAgICAgICAgZ3JpZC5zZXREcmFnRXh0ZW50KGdyaWQubmV3UG9pbnQoMCwgbmV3WSkpO1xuXG4gICAgICAgIGdyaWQucmVwYWludCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUm93U2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHRoaXMgY2hlY2tzIHdoaWxlIHdlcmUgZHJhZ2dpbmcgaWYgd2UgZ28gb3V0c2lkZSB0aGUgdmlzaWJsZSBib3VuZHMsIGlmIHNvLCBraWNrIG9mZiB0aGUgZXh0ZXJuYWwgYXV0b3Njcm9sbCBjaGVjayBmdW5jdGlvbiAoYWJvdmUpXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbW91c2UgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGNoZWNrRHJhZ1Njcm9sbDogZnVuY3Rpb24oZ3JpZCwgbW91c2UpIHtcbiAgICAgICAgaWYgKCFncmlkLnJlc29sdmVQcm9wZXJ0eSgnc2Nyb2xsaW5nRW5hYmxlZCcpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGIgPSBncmlkLmdldERhdGFCb3VuZHMoKTtcbiAgICAgICAgdmFyIGluc2lkZSA9IGIuY29udGFpbnMobW91c2UpO1xuICAgICAgICBpZiAoaW5zaWRlKSB7XG4gICAgICAgICAgICBpZiAoZ3JpZC5pc1Njcm9sbGluZ05vdygpKSB7XG4gICAgICAgICAgICAgICAgZ3JpZC5zZXRTY3JvbGxpbmdOb3coZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCFncmlkLmlzU2Nyb2xsaW5nTm93KCkpIHtcbiAgICAgICAgICAgIGdyaWQuc2V0U2Nyb2xsaW5nTm93KHRydWUpO1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxEcmFnKGdyaWQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSb3dTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgdGhpcyBmdW5jdGlvbiBtYWtlcyBzdXJlIHRoYXQgd2hpbGUgd2UgYXJlIGRyYWdnaW5nIG91dHNpZGUgb2YgdGhlIGdyaWQgdmlzaWJsZSBib3VuZHMsIHdlIHNyY3JvbGwgYWNjb3JkaW5nbHlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqL1xuICAgIHNjcm9sbERyYWc6IGZ1bmN0aW9uKGdyaWQpIHtcbiAgICAgICAgaWYgKCFncmlkLmlzU2Nyb2xsaW5nTm93KCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsYXN0RHJhZ0NlbGwgPSB0aGlzLmxhc3REcmFnQ2VsbDtcbiAgICAgICAgdmFyIGIgPSBncmlkLmdldERhdGFCb3VuZHMoKTtcbiAgICAgICAgdmFyIHhPZmZzZXQgPSAwO1xuICAgICAgICB2YXIgeU9mZnNldCA9IDA7XG5cbiAgICAgICAgdmFyIG51bUZpeGVkQ29sdW1ucyA9IGdyaWQuZ2V0Rml4ZWRDb2x1bW5Db3VudCgpO1xuICAgICAgICB2YXIgbnVtRml4ZWRSb3dzID0gZ3JpZC5nZXRGaXhlZFJvd0NvdW50KCk7XG5cbiAgICAgICAgdmFyIGRyYWdFbmRJbkZpeGVkQXJlYVggPSBsYXN0RHJhZ0NlbGwueCA8IG51bUZpeGVkQ29sdW1ucztcbiAgICAgICAgdmFyIGRyYWdFbmRJbkZpeGVkQXJlYVkgPSBsYXN0RHJhZ0NlbGwueSA8IG51bUZpeGVkUm93cztcblxuICAgICAgICBpZiAodGhpcy5jdXJyZW50RHJhZy55IDwgYi5vcmlnaW4ueSkge1xuICAgICAgICAgICAgeU9mZnNldCA9IC0xO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuY3VycmVudERyYWcueSA+IGIub3JpZ2luLnkgKyBiLmV4dGVudC55KSB7XG4gICAgICAgICAgICB5T2Zmc2V0ID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkcmFnQ2VsbE9mZnNldFggPSB4T2Zmc2V0O1xuICAgICAgICB2YXIgZHJhZ0NlbGxPZmZzZXRZID0geU9mZnNldDtcblxuICAgICAgICBpZiAoZHJhZ0VuZEluRml4ZWRBcmVhWCkge1xuICAgICAgICAgICAgZHJhZ0NlbGxPZmZzZXRYID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkcmFnRW5kSW5GaXhlZEFyZWFZKSB7XG4gICAgICAgICAgICBkcmFnQ2VsbE9mZnNldFkgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5sYXN0RHJhZ0NlbGwgPSBsYXN0RHJhZ0NlbGwucGx1c1hZKGRyYWdDZWxsT2Zmc2V0WCwgZHJhZ0NlbGxPZmZzZXRZKTtcbiAgICAgICAgZ3JpZC5zY3JvbGxCeSh4T2Zmc2V0LCB5T2Zmc2V0KTtcbiAgICAgICAgdGhpcy5oYW5kbGVNb3VzZURyYWdDZWxsU2VsZWN0aW9uKGdyaWQsIGxhc3REcmFnQ2VsbCwgW10pOyAvLyB1cGRhdGUgdGhlIHNlbGVjdGlvblxuICAgICAgICBncmlkLnJlcGFpbnQoKTtcbiAgICAgICAgc2V0VGltZW91dCh0aGlzLnNjcm9sbERyYWcuYmluZCh0aGlzLCBncmlkKSwgMjUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUm93U2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGV4dGVuZCBhIHNlbGVjdGlvbiBvciBjcmVhdGUgb25lIGlmIHRoZXJlIGlzbnQgeWV0XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZ3JpZENlbGwgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGtleXMgLSBhcnJheSBvZiB0aGUga2V5cyB0aGF0IGFyZSBjdXJyZW50bHkgcHJlc3NlZCBkb3duXG4gICAgICovXG4gICAgZXh0ZW5kU2VsZWN0aW9uOiBmdW5jdGlvbihncmlkLCBncmlkQ2VsbCwga2V5cykge1xuICAgICAgICBncmlkLnN0b3BFZGl0aW5nKCk7XG4gICAgICAgIC8vdmFyIGhhc0NUUkwgPSBrZXlzLmluZGV4T2YoJ0NUUkwnKSAhPT0gLTE7XG4gICAgICAgIHZhciBoYXNTSElGVCA9IGtleXMuaW5kZXhPZignU0hJRlQnKSAhPT0gLTE7XG5cbiAgICAgICAgdmFyIG1vdXNlUG9pbnQgPSBncmlkLmdldE1vdXNlRG93bigpO1xuICAgICAgICB2YXIgeCA9IGdyaWRDZWxsLng7IC8vIC0gbnVtRml4ZWRDb2x1bW5zICsgc2Nyb2xsTGVmdDtcbiAgICAgICAgdmFyIHkgPSBncmlkQ2VsbC55OyAvLyAtIG51bUZpeGVkUm93cyArIHNjcm9sbFRvcDtcblxuICAgICAgICAvL3dlcmUgb3V0c2lkZSBvZiB0aGUgZ3JpZCBkbyBub3RoaW5nXG4gICAgICAgIGlmICh4IDwgMCB8fCB5IDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhc1NISUZUKSB7XG4gICAgICAgICAgICBncmlkLmNsZWFyTW9zdFJlY2VudFJvd1NlbGVjdGlvbigpO1xuICAgICAgICAgICAgZ3JpZC5zZWxlY3RSb3coeSwgbW91c2VQb2ludC55KTtcbiAgICAgICAgICAgIGdyaWQuc2V0RHJhZ0V4dGVudChncmlkLm5ld1BvaW50KDAsIHkgLSBtb3VzZVBvaW50LnkpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdyaWQudG9nZ2xlU2VsZWN0Um93KHksIGtleXMpO1xuICAgICAgICAgICAgZ3JpZC5zZXRNb3VzZURvd24oZ3JpZC5uZXdQb2ludCh4LCB5KSk7XG4gICAgICAgICAgICBncmlkLnNldERyYWdFeHRlbnQoZ3JpZC5uZXdQb2ludCgwLCAwKSk7XG4gICAgICAgIH1cbiAgICAgICAgZ3JpZC5yZXBhaW50KCk7XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJvd1NlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudFxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICovXG4gICAgaGFuZGxlRE9XTlNISUZUOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIHRoaXMubW92ZVNoaWZ0U2VsZWN0KGdyaWQsIDEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUm93U2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZVVQU0hJRlQ6IGZ1bmN0aW9uKGdyaWQpIHtcbiAgICAgICAgdGhpcy5tb3ZlU2hpZnRTZWxlY3QoZ3JpZCwgLTEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUm93U2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZUxFRlRTSElGVDogZnVuY3Rpb24oZ3JpZCkge30sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUm93U2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZVJJR0hUU0hJRlQ6IGZ1bmN0aW9uKGdyaWQpIHt9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJvd1NlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudFxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVET1dOOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIHRoaXMubW92ZVNpbmdsZVNlbGVjdChncmlkLCAxKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJvd1NlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudFxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVVUDogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICB0aGlzLm1vdmVTaW5nbGVTZWxlY3QoZ3JpZCwgLTEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUm93U2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZUxFRlQ6IGZ1bmN0aW9uKGdyaWQpIHt9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJvd1NlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudFxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVSSUdIVDogZnVuY3Rpb24oZ3JpZCkge1xuXG4gICAgICAgIHZhciBtb3VzZUNvcm5lciA9IGdyaWQuZ2V0TW91c2VEb3duKCkucGx1cyhncmlkLmdldERyYWdFeHRlbnQoKSk7XG4gICAgICAgIHZhciBtYXhDb2x1bW5zID0gZ3JpZC5nZXRDb2x1bW5Db3VudCgpIC0gMTtcblxuICAgICAgICB2YXIgbmV3WCA9IGdyaWQuZ2V0SGVhZGVyQ29sdW1uQ291bnQoKSArIGdyaWQuZ2V0SFNjcm9sbFZhbHVlKCk7XG4gICAgICAgIHZhciBuZXdZID0gbW91c2VDb3JuZXIueTtcblxuICAgICAgICBuZXdYID0gTWF0aC5taW4obWF4Q29sdW1ucywgbmV3WCk7XG5cbiAgICAgICAgZ3JpZC5jbGVhclNlbGVjdGlvbnMoKTtcbiAgICAgICAgZ3JpZC5zZWxlY3QobmV3WCwgbmV3WSwgMCwgMCk7XG4gICAgICAgIGdyaWQuc2V0TW91c2VEb3duKGdyaWQubmV3UG9pbnQobmV3WCwgbmV3WSkpO1xuICAgICAgICBncmlkLnNldERyYWdFeHRlbnQoZ3JpZC5uZXdQb2ludCgwLCAwKSk7XG5cbiAgICAgICAgZ3JpZC5yZXBhaW50KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSb3dTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgSWYgd2UgYXJlIGhvbGRpbmcgZG93biB0aGUgc2FtZSBuYXZpZ2F0aW9uIGtleSwgYWNjZWxlcmF0ZSB0aGUgaW5jcmVtZW50IHdlIHNjcm9sbFxuICAgICAqICMjIyMgcmV0dXJuczogaW50ZWdlclxuICAgICAqL1xuICAgIGdldEF1dG9TY3JvbGxBY2NlbGVyYXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY291bnQgPSAxO1xuICAgICAgICB2YXIgZWxhcHNlZCA9IHRoaXMuZ2V0QXV0b1Njcm9sbER1cmF0aW9uKCkgLyAyMDAwO1xuICAgICAgICBjb3VudCA9IE1hdGgubWF4KDEsIE1hdGguZmxvb3IoZWxhcHNlZCAqIGVsYXBzZWQgKiBlbGFwc2VkICogZWxhcHNlZCkpO1xuICAgICAgICByZXR1cm4gY291bnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSb3dTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2Mgc2V0IHRoZSBzdGFydCB0aW1lIHRvIHJpZ2h0IG5vdyB3aGVuIHdlIGluaXRpYXRlIGFuIGF1dG8gc2Nyb2xsXG4gICAgICovXG4gICAgc2V0QXV0b1Njcm9sbFN0YXJ0VGltZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc2JBdXRvU3RhcnQgPSBEYXRlLm5vdygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUm93U2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHVwZGF0ZSB0aGUgYXV0b3Njcm9sbCBzdGFydCB0aW1lIGlmIHdlIGhhdmVuJ3QgYXV0b3Njcm9sbGVkIHdpdGhpbiB0aGUgbGFzdCA1MDBtcyBvdGhlcndpc2UgdXBkYXRlIHRoZSBjdXJyZW50IGF1dG9zY3JvbGwgdGltZVxuICAgICAqL1xuICAgIHBpbmdBdXRvU2Nyb2xsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIGlmIChub3cgLSB0aGlzLnNiTGFzdEF1dG8gPiA1MDApIHtcbiAgICAgICAgICAgIHRoaXMuc2V0QXV0b1Njcm9sbFN0YXJ0VGltZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2JMYXN0QXV0byA9IERhdGUubm93KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSb3dTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgYW5zd2VyIGhvdyBsb25nIHdlIGhhdmUgYmVlbiBhdXRvIHNjcm9sbGluZ1xuICAgICAqICMjIyMgcmV0dXJuczogaW50ZWdlclxuICAgICAqL1xuICAgIGdldEF1dG9TY3JvbGxEdXJhdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChEYXRlLm5vdygpIC0gdGhpcy5zYkxhc3RBdXRvID4gNTAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRGF0ZS5ub3coKSAtIHRoaXMuc2JBdXRvU3RhcnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSb3dTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgQXVnbWVudCB0aGUgbW9zdCByZWNlbnQgc2VsZWN0aW9uIGV4dGVudCBieSAob2Zmc2V0WCxvZmZzZXRZKSBhbmQgc2Nyb2xsIGlmIG5lY2Vzc2FyeS5cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRYIC0geCBjb29yZGluYXRlIHRvIHN0YXJ0IGF0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFkgLSB5IGNvb3JkaW5hdGUgdG8gc3RhcnQgYXRcbiAgICAgKi9cbiAgICBtb3ZlU2hpZnRTZWxlY3Q6IGZ1bmN0aW9uKGdyaWQsIG9mZnNldFkpIHtcblxuICAgICAgICB2YXIgbWF4Um93cyA9IGdyaWQuZ2V0Um93Q291bnQoKSAtIDE7XG5cbiAgICAgICAgdmFyIG1heFZpZXdhYmxlUm93cyA9IGdyaWQuZ2V0VmlzaWJsZVJvd3MoKSAtIDE7XG5cbiAgICAgICAgaWYgKCFncmlkLnJlc29sdmVQcm9wZXJ0eSgnc2Nyb2xsaW5nRW5hYmxlZCcpKSB7XG4gICAgICAgICAgICBtYXhSb3dzID0gTWF0aC5taW4obWF4Um93cywgbWF4Vmlld2FibGVSb3dzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvcmlnaW4gPSBncmlkLmdldE1vdXNlRG93bigpO1xuICAgICAgICB2YXIgZXh0ZW50ID0gZ3JpZC5nZXREcmFnRXh0ZW50KCk7XG5cbiAgICAgICAgdmFyIG5ld1kgPSBleHRlbnQueSArIG9mZnNldFk7XG4gICAgICAgIC8vdmFyIG5ld1kgPSBncmlkLmdldFJvd0NvdW50KCk7XG5cbiAgICAgICAgbmV3WSA9IE1hdGgubWluKG1heFJvd3MgLSBvcmlnaW4ueSwgTWF0aC5tYXgoLW9yaWdpbi55LCBuZXdZKSk7XG5cbiAgICAgICAgZ3JpZC5jbGVhck1vc3RSZWNlbnRSb3dTZWxlY3Rpb24oKTtcbiAgICAgICAgZ3JpZC5zZWxlY3RSb3cob3JpZ2luLnksIG9yaWdpbi55ICsgbmV3WSk7XG5cbiAgICAgICAgZ3JpZC5zZXREcmFnRXh0ZW50KGdyaWQubmV3UG9pbnQoMCwgbmV3WSkpO1xuXG4gICAgICAgIGlmIChncmlkLmluc3VyZU1vZGVsUm93SXNWaXNpYmxlKG5ld1kgKyBvcmlnaW4ueSwgb2Zmc2V0WSkpIHtcbiAgICAgICAgICAgIHRoaXMucGluZ0F1dG9TY3JvbGwoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdyaWQuZmlyZVN5bnRoZXRpY1Jvd1NlbGVjdGlvbkNoYW5nZWRFdmVudCgpO1xuICAgICAgICBncmlkLnJlcGFpbnQoKTtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUm93U2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFJlcGxhY2UgdGhlIG1vc3QgcmVjZW50IHNlbGVjdGlvbiB3aXRoIGEgc2luZ2xlIGNlbGwgc2VsZWN0aW9uIHRoYXQgaXMgbW92ZWQgKG9mZnNldFgsb2Zmc2V0WSkgZnJvbSB0aGUgcHJldmlvdXMgc2VsZWN0aW9uIGV4dGVudC5cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRYIC0geCBjb29yZGluYXRlIHRvIHN0YXJ0IGF0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFkgLSB5IGNvb3JkaW5hdGUgdG8gc3RhcnQgYXRcbiAgICAgKi9cbiAgICBtb3ZlU2luZ2xlU2VsZWN0OiBmdW5jdGlvbihncmlkLCBvZmZzZXRZKSB7XG5cbiAgICAgICAgdmFyIG1heFJvd3MgPSBncmlkLmdldFJvd0NvdW50KCkgLSAxO1xuXG4gICAgICAgIHZhciBtYXhWaWV3YWJsZVJvd3MgPSBncmlkLmdldFZpc2libGVSb3dzQ291bnQoKSAtIDE7XG5cbiAgICAgICAgaWYgKCFncmlkLnJlc29sdmVQcm9wZXJ0eSgnc2Nyb2xsaW5nRW5hYmxlZCcpKSB7XG4gICAgICAgICAgICBtYXhSb3dzID0gTWF0aC5taW4obWF4Um93cywgbWF4Vmlld2FibGVSb3dzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtb3VzZUNvcm5lciA9IGdyaWQuZ2V0TW91c2VEb3duKCkucGx1cyhncmlkLmdldERyYWdFeHRlbnQoKSk7XG5cbiAgICAgICAgdmFyIG5ld1kgPSBtb3VzZUNvcm5lci55ICsgb2Zmc2V0WTtcbiAgICAgICAgLy92YXIgbmV3WSA9IGdyaWQuZ2V0Um93Q291bnQoKTtcblxuICAgICAgICBuZXdZID0gTWF0aC5taW4obWF4Um93cywgTWF0aC5tYXgoMCwgbmV3WSkpO1xuXG4gICAgICAgIGdyaWQuY2xlYXJTZWxlY3Rpb25zKCk7XG4gICAgICAgIGdyaWQuc2VsZWN0Um93KG5ld1kpO1xuICAgICAgICBncmlkLnNldE1vdXNlRG93bihncmlkLm5ld1BvaW50KDAsIG5ld1kpKTtcbiAgICAgICAgZ3JpZC5zZXREcmFnRXh0ZW50KGdyaWQubmV3UG9pbnQoMCwgMCkpO1xuXG4gICAgICAgIGlmIChncmlkLmluc3VyZU1vZGVsUm93SXNWaXNpYmxlKG5ld1ksIG9mZnNldFkpKSB7XG4gICAgICAgICAgICB0aGlzLnBpbmdBdXRvU2Nyb2xsKCk7XG4gICAgICAgIH1cblxuICAgICAgICBncmlkLmZpcmVTeW50aGV0aWNSb3dTZWxlY3Rpb25DaGFuZ2VkRXZlbnQoKTtcbiAgICAgICAgZ3JpZC5yZXBhaW50KCk7XG5cbiAgICB9LFxuXG4gICAgaXNTaW5nbGVSb3dTZWxlY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJvd1NlbGVjdGlvbjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEZlYXR1cmUgPSByZXF1aXJlKCcuL0ZlYXR1cmUuanMnKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIFRodW1id2hlZWxTY3JvbGxpbmcgPSBGZWF0dXJlLmV4dGVuZCgnVGh1bWJ3aGVlbFNjcm9sbGluZycsIHtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBUaHVtYndoZWVsU2Nyb2xsaW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50IGRvd24gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlV2hlZWxNb3ZlZDogZnVuY3Rpb24oZ3JpZCwgZSkge1xuICAgICAgICBpZiAoIWdyaWQucmVzb2x2ZVByb3BlcnR5KCdzY3JvbGxpbmdFbmFibGVkJykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwcmltRXZlbnQgPSBlLnByaW1pdGl2ZUV2ZW50LFxuICAgICAgICAgICAgZGVsdGFYID0gTWF0aC5zaWduKHByaW1FdmVudC53aGVlbERlbHRhWCB8fCAtcHJpbUV2ZW50LmRlbHRhWCksXG4gICAgICAgICAgICBkZWx0YVkgPSBNYXRoLnNpZ24ocHJpbUV2ZW50LndoZWVsRGVsdGFZIHx8IC1wcmltRXZlbnQuZGVsdGFZKTtcblxuICAgICAgICBpZiAoZGVsdGFYIHx8IGRlbHRhWSkge1xuICAgICAgICAgICAgZ3JpZC5zY3JvbGxCeShcbiAgICAgICAgICAgICAgICAtZGVsdGFYIHx8IDAsIC8vIDAgaWYgTmFOXG4gICAgICAgICAgICAgICAgLWRlbHRhWSB8fCAwXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuXG59KTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFRodW1id2hlZWxTY3JvbGxpbmc7XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIEZlYXR1cmU6IHJlcXVpcmUoJy4vRmVhdHVyZScpLCAvLyBhYnN0cmFjdCBiYXNlIGNsYXNzXG4gICAgQ2VsbENsaWNrOiByZXF1aXJlKCcuL0NlbGxDbGljaycpLFxuICAgIENlbGxFZGl0aW5nOiByZXF1aXJlKCcuL0NlbGxFZGl0aW5nJyksXG4gICAgQ2VsbFNlbGVjdGlvbjogcmVxdWlyZSgnLi9DZWxsU2VsZWN0aW9uJyksXG4gICAgQ29sdW1uQXV0b3NpemluZzogcmVxdWlyZSgnLi9Db2x1bW5BdXRvc2l6aW5nJyksXG4gICAgQ29sdW1uTW92aW5nOiByZXF1aXJlKCcuL0NvbHVtbk1vdmluZycpLFxuICAgIENvbHVtblJlc2l6aW5nOiByZXF1aXJlKCcuL0NvbHVtblJlc2l6aW5nJyksXG4gICAgQ29sdW1uU2VsZWN0aW9uOiByZXF1aXJlKCcuL0NvbHVtblNlbGVjdGlvbicpLFxuICAgIENvbHVtblNvcnRpbmc6IHJlcXVpcmUoJy4vQ29sdW1uU29ydGluZycpLFxuICAgIEZpbHRlcnM6IHJlcXVpcmUoJy4vRmlsdGVycycpLFxuICAgIEtleVBhZ2luZzogcmVxdWlyZSgnLi9LZXlQYWdpbmcnKSxcbiAgICBPbkhvdmVyOiByZXF1aXJlKCcuL09uSG92ZXInKSxcbiAgICBDb2x1bW5QaWNrZXI6IHJlcXVpcmUoJy4vQ29sdW1uUGlja2VyJyksXG4gICAgUm93UmVzaXppbmc6IHJlcXVpcmUoJy4vUm93UmVzaXppbmcnKSxcbiAgICBSb3dTZWxlY3Rpb246IHJlcXVpcmUoJy4vUm93U2VsZWN0aW9uJyksXG4gICAgVGh1bWJ3aGVlbFNjcm9sbGluZzogcmVxdWlyZSgnLi9UaHVtYndoZWVsU2Nyb2xsaW5nJylcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBwb3BNZW51ID0gcmVxdWlyZSgncG9wLW1lbnUnKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBzdW1tYXJ5IEJ1aWxkLCBvcmdhbml6ZSwgYW5kIHNvcnQgYSBjb2x1bW4gc2NoZW1hIGxpc3QgZnJvbSBhIGxpc3Qgb2YgY29sdW1ucy5cbiAqIEBkZXNjIEZpbHRlclRyZWUgcmVxdWlyZXMgYSBjb2x1bW4gc2NoZW1hLiBBcyBhIGZhbGxiYWNrIHdoZW4geW91IGRvbid0IGhhdmUgYSBjb2x1bW4gc2NoZW1hIG9mIHlvdXIgb3duLCB0aGUgc3RyaW5nIGFycmF5IHJldHVybmVkIGJ5IGJlaGF2aW9yLmRhdGFNb2RlbC5nZXRGaWVsZHMoKSB3b3VsZCB3b3JrIGFzIGlzLiBUaGlzIGZhY3Rvcnkgb2JqZWN0IHdpbGwgZG8gYSBsaXR0bGUgYmV0dGVyIHRoYW4gdGhhdCwgdGFraW5nIEh5cGVyZ3JpZCdzIGNvbHVtbiBhcnJheSBhbmQgY3JlYXRpbmcgYSBtb3JlIHRleHR1cmVkIGNvbHVtbiBzY2hlbWEsIGluY2x1ZGluZyBjb2x1bW4gYWxpYXNlcyBhbmQgdHlwZXMuXG4gKlxuICogQ0FWRUFUOiBTZXQgdXAgdGhlIHNjaGVtYSBjb21wbGV0ZWx5IGJlZm9yZSBpbnN0YW50aWF0aW5nIHlvdXIgZmlsdGVyIHN0YXRlLiBGaWx0ZXItdHJlZSB1c2VzIHRoZSBzY2hlbWEgKGluIHBhcnQpIHRvIGdlbmVyYXRlIGNvbHVtbiBzZWxlY3Rpb24gZHJvcC1kb3ducyBhcyBwYXJ0IG9mIGl0cyBcInF1ZXJ5IGJ1aWxkZXJcIiBVSS4gTm90ZSB0aGF0IHRoZSBVSSBpcyAqbm90KiBhdXRvbWF0aWNhbGx5IHVwZGF0ZWQgaWYgeW91IGNoYW5nZSB0aGUgc2NoZW1hIGxhdGVyLlxuICpcbiAqIEBwYXJhbSB7Q29sdW1uW119IGNvbHVtbnNcbiAqXG4gKiBAcHJvcGVydHkge21lbnVJdGVtW119IHNjaGVtYSAtIFRoaXMgaXMgdGhlIG91dHB1dCBwcm9kdWNlZCBieSB0aGUgZmFjdG9yeS5cbiAqL1xuZnVuY3Rpb24gQ29sdW1uU2NoZW1hRmFjdG9yeShjb2x1bW5zLCBmaW5kT3B0aW9ucykge1xuICAgIHRoaXMuc2NoZW1hID0gY29sdW1ucy5tYXAoZnVuY3Rpb24oY29sdW1uKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lOiBjb2x1bW4ubmFtZSxcbiAgICAgICAgICAgIGFsaWFzOiBjb2x1bW4uaGVhZGVyLFxuICAgICAgICAgICAgdHlwZTogY29sdW1uLmdldFR5cGUoKVxuICAgICAgICB9O1xuICAgIH0pO1xufVxuXG5Db2x1bW5TY2hlbWFGYWN0b3J5LnByb3RvdHlwZSA9IHtcblxuICAgIGNvbnN0cnVjdG9yOiBDb2x1bW5TY2hlbWFGYWN0b3J5LnByb3RvdHlwZS5jb25zdHJ1Y3RvcixcblxuICAgIC8qKlxuICAgICAqIE9yZ2FuaXplIHNjaGVtYSBpbnRvIHN1Ym1lbnVzLlxuICAgICAqIEBwYXJhbSB7UmVnRXhwfSBjb2x1bW5Hcm91cHNSZWdleCAtIFNjaGVtYSBuYW1lcyBvciBhbGlhc2VzIHRoYXQgbWF0Y2ggdGhpcyBhcmUgcHV0IGludG8gYSBzdWJtZW51LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5rZXk9J25hbWUnXSAtIE11c3QgYmUgZWl0aGVyICduYW1lJyBvciAnYWxpYXMnLlxuICAgICAqL1xuICAgIG9yZ2FuaXplOiBmdW5jdGlvbihjb2x1bW5Hcm91cHNSZWdleCwgb3B0aW9ucykge1xuICAgICAgICB2YXIga2V5ID0gb3B0aW9ucyAmJiBvcHRpb25zLmtleSB8fCAnbmFtZScsXG4gICAgICAgICAgICBzdWJtZW51cyA9IHt9LFxuICAgICAgICAgICAgbWVudSA9IFtdO1xuXG4gICAgICAgIHRoaXMuc2NoZW1hLmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gaXRlbVtrZXldLFxuICAgICAgICAgICAgICAgIGdyb3VwID0gdmFsdWUubWF0Y2goY29sdW1uR3JvdXBzUmVnZXgpO1xuICAgICAgICAgICAgaWYgKGdyb3VwKSB7XG4gICAgICAgICAgICAgICAgZ3JvdXAgPSBncm91cFswXTtcbiAgICAgICAgICAgICAgICBpZiAoIShncm91cCBpbiBzdWJtZW51cykpIHtcbiAgICAgICAgICAgICAgICAgICAgc3VibWVudXNbZ3JvdXBdID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGdyb3VwLnRvVXBwZXJDYXNlKCksXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJtZW51OiBbXVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdWJtZW51c1tncm91cF0uc3VibWVudS5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZW51LnB1c2goaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGZvciAodmFyIHN1Ym1lbnVOYW1lIGluIHN1Ym1lbnVzKSB7XG4gICAgICAgICAgICBtZW51LnB1c2goc3VibWVudXNbc3VibWVudU5hbWVdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2NoZW1hID0gbWVudTtcbiAgICB9LFxuXG4gICAgbG9va3VwOiBmdW5jdGlvbihmaW5kT3B0aW9ucywgdmFsdWUpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICByZXR1cm4gcG9wTWVudS5sb29rdXAuYXBwbHkodGhpcy5zY2hlbWEsIGFyZ3MpO1xuICAgIH0sXG5cbiAgICB3YWxrOiBmdW5jdGlvbihpdGVyYXRlZSkge1xuICAgICAgICByZXR1cm4gcG9wTWVudS53YWxrLmNhbGwodGhpcy5zY2hlbWEsIGl0ZXJhdGVlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgU29ydCB0aGUgc2NoZW1hLlxuICAgICAqIEBkZXNjIFdhbGsgdGhlIG1lbnUgc3RydWN0dXJlLCBzb3J0aW5nIGVhY2ggc3VibWVudSB1bnRpbCBmaW5hbGx5IHRoZSB0b3AtbGV2ZWwgbWVudSBpcyBzb3J0ZWQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtwcmVmaXg9JyddIC0gQSBzdWJtZW51IHNvcnQgcHJlZml4OlxuICAgICAqICogT21pdCB0byBnaXZlIG5vIHNwZWNpYWwgdHJlYXRtZW50IHRvIHN1Ym1lbnVzLlxuICAgICAqICogR2l2ZSBgJ1xcdTAwMDAnYCB0byBwbGFjZSBhbGwgdGhlIHN1Ym1lbnVzIGF0IHRoZSB0b3Agb2YgZWFjaCBlbmNsb3Npbmcgc3VibWVudS5cbiAgICAgKiAqIEdpdmUgYCdcXHVmZmZmJ2AgdG8gcGxhY2UgYWxsIHRoZSBzdWJtZW51cyBhdCB0aGUgYm90dG9tIG9mIGVhY2ggZW5jbG9zaW5nIHN1Ym1lbnUuXG4gICAgICovXG4gICAgc29ydDogZnVuY3Rpb24ocHJlZml4KSB7XG4gICAgICAgIHRoaXMuc2NoZW1hLnNvcnQoZnVuY3Rpb24gcmVjdXJzZShhLCBiKSB7XG4gICAgICAgICAgICBpZiAoYS5sYWJlbCAmJiAhYS5zb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICBhLnN1Ym1lbnUuc29ydChyZWN1cnNlKTtcbiAgICAgICAgICAgICAgICBhLnNvcnRlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhID0gYS5sYWJlbCA/IHByZWZpeCArIGEubGFiZWwgOiBhLmFsaWFzIHx8IGEubmFtZSB8fCBhO1xuICAgICAgICAgICAgYiA9IGIubGFiZWwgPyBwcmVmaXggKyBiLmxhYmVsIDogYi5hbGlhcyB8fCBiLm5hbWUgfHwgYjtcbiAgICAgICAgICAgIHJldHVybiBhIDwgYiA/IC0xIDogYSA+IGIgPyAxIDogMDtcbiAgICAgICAgfSk7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb2x1bW5TY2hlbWFGYWN0b3J5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgXyA9IHJlcXVpcmUoJ29iamVjdC1pdGVyYXRvcnMnKTtcblxudmFyIEZpbHRlclRyZWUgPSByZXF1aXJlKCcuLi9TaGFyZWQnKS5GaWx0ZXJUcmVlO1xudmFyIFBhcnNlckNRTCA9IHJlcXVpcmUoJy4vcGFyc2VyLUNRTCcpO1xuXG4vLyBBZGQgYSBwcm9wZXJ0eSBgbWVudU1vZGVzYCB0byB0aGUgdHJlZSwgZGVmYXVsdGluZyB0byBgb3BlcmF0b3JzYCBhcyB0aGUgb25seSBhY3RpdmUgbW9kZVxuRmlsdGVyVHJlZS5Ob2RlLm9wdGlvbnNTY2hlbWEubWVudU1vZGVzID0ge1xuICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgb3BlcmF0b3JzOiAxXG4gICAgfVxufTtcblxuZnVuY3Rpb24gcXVvdGUodGV4dCkge1xuICAgIHZhciBxdCA9IFBhcnNlckNRTC5xdDtcbiAgICByZXR1cm4gcXQgKyB0ZXh0LnJlcGxhY2UobmV3IFJlZ0V4cChxdCwgJ2cnKSwgcXQgKyBxdCkgKyBxdDtcbn1cblxudmFyIGxpa2VEcmVzc2VzID0gW1xuICAgIHsgcmVnZXg6IC9eKE5PVCApP0xJS0UgJSguKyklJC9pLCBvcGVyYXRvcjogJ2NvbnRhaW5zJyB9LFxuICAgIHsgcmVnZXg6IC9eKE5PVCApP0xJS0UgKC4rKSUkL2ksIG9wZXJhdG9yOiAnYmVnaW5zJyB9LFxuICAgIHsgcmVnZXg6IC9eKE5PVCApP0xJS0UgJSguKykkL2ksIG9wZXJhdG9yOiAnZW5kcycgfVxuXTtcbnZhciByZWdleEVzY2FwZWRMaWtlUGF0dGVybkNoYXJzID0gL1xcWyhbX1xcW1xcXSVdKVxcXS9nOyAvLyBjYXB0dXJlIGFsbCBfLCBbLCBdLCBhbmQgJSBjaGFycyBlbmNsb3NlZCBpbiBbXVxudmFyIHJlZ2V4TGlrZVBhdHRlcm5DaGFyID0gL1tfXFxbXFxdJV0vOyAvLyBmaW5kIGFueSBfLCBbLCBdLCBhbmQgJSBjaGFycyBOT1QgZW5jbG9zZWQgaW4gW11cblxuLy8gY29udmVydCBjZXJ0YWluIExJS0UgZXhwcmVzc2lvbnMgdG8gQkVHSU5TLCBFTkRTLCBDT05UQUlOU1xuZnVuY3Rpb24gY29udmVydExpa2VUb1BzZXVkb09wKHJlc3VsdCkge1xuICAgIGxpa2VEcmVzc2VzLmZpbmQoZnVuY3Rpb24oZHJlc3MpIHtcbiAgICAgICAgdmFyIG1hdGNoID0gcmVzdWx0Lm1hdGNoKGRyZXNzLnJlZ2V4KTtcblxuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIC8vIHVuZXNjYXBlIGFsbCBMSUtFIHBhdHRlcm4gY2hhcnMgZXNjYXBlZCB3aXRoIGJyYWNrZXRzXG4gICAgICAgICAgICB2YXIgbm90ID0gKG1hdGNoWzFdIHx8ICcnKS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgICAgICAgIG9wZXJhdG9yID0gZHJlc3Mub3BlcmF0b3IsXG4gICAgICAgICAgICAgICAgb3BlcmFuZCA9IG1hdGNoWzJdLFxuICAgICAgICAgICAgICAgIG9wZXJhbmRXaXRob3V0RXNjYXBlZENoYXJzID0gb3BlcmFuZC5yZXBsYWNlKHJlZ2V4RXNjYXBlZExpa2VQYXR0ZXJuQ2hhcnMsICcnKTtcblxuICAgICAgICAgICAgLy8gaWYgcmVzdWx0IGhhcyBubyBhY3R1YSByZW1haW5pbmcgTElLRSBwYXR0ZXJuIGNoYXJzLCBnbyB3aXRoIHRoZSBjb252ZXJzaW9uXG4gICAgICAgICAgICBpZiAoIXJlZ2V4TGlrZVBhdHRlcm5DaGFyLnRlc3Qob3BlcmFuZFdpdGhvdXRFc2NhcGVkQ2hhcnMpKSB7XG4gICAgICAgICAgICAgICAgb3BlcmFuZCA9IG9wZXJhbmQucmVwbGFjZShyZWdleEVzY2FwZWRMaWtlUGF0dGVybkNoYXJzLCAnJDEnKTsgLy8gdW5lc2NhcGUgdGhlIGVzY2FwZWQgY2hhcnNcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBub3QgKyBvcGVyYXRvciArICcgJyArIG9wZXJhbmQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBicmVhayBvdXQgb2YgbG9vcFxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG52YXIgY29uZGl0aW9uYWxzQ1FMID0gbmV3IEZpbHRlclRyZWUuQ29uZGl0aW9uYWxzKCk7XG5jb25kaXRpb25hbHNDUUwubWFrZUxJS0UgPSBmdW5jdGlvbihiZWcsIGVuZCwgb3AsIG9yaWdpbmFsT3AsIGMpIHtcbiAgICBvcCA9IG9yaWdpbmFsT3AudG9Mb3dlckNhc2UoKTtcbiAgICByZXR1cm4gb3AgKyAnICcgKyBxdW90ZShjLm9wZXJhbmQpO1xufTtcbmNvbmRpdGlvbmFsc0NRTC5tYWtlSU4gPSBmdW5jdGlvbihvcCwgYykge1xuICAgIHJldHVybiBvcC50b0xvd2VyQ2FzZSgpICsgJyAoJyArIGMub3BlcmFuZC5yZXBsYWNlKC9cXHMqLFxccyovZywgJywgJykgKyAnKSc7XG59O1xuY29uZGl0aW9uYWxzQ1FMLm1ha2UgPSBmdW5jdGlvbihvcCwgYykge1xuICAgIHZhciBudW1lcmljT3BlcmFuZDtcbiAgICBvcCA9IG9wLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKC9cXHcvLnRlc3Qob3ApKSB7IG9wICs9ICcgJzsgfVxuICAgIG9wICs9IGMuZ2V0VHlwZSgpID09PSAnbnVtYmVyJyAmJiAhaXNOYU4obnVtZXJpY09wZXJhbmQgPSBOdW1iZXIoYy5vcGVyYW5kKSlcbiAgICAgICAgPyBudW1lcmljT3BlcmFuZFxuICAgICAgICA6IHF1b3RlKGMub3BlcmFuZCk7XG4gICAgcmV0dXJuIG9wO1xufTtcblxuLy8gcmVwbGFjZSB0aGUgZGVmYXVsdCBmaWx0ZXIgdHJlZSB0ZXJtaW5hbCBub2RlIGNvbnN0cnVjdG9yIHdpdGggYW4gZXh0ZW5zaW9uIG9mIHNhbWVcbnZhciBDdXN0b21GaWx0ZXJMZWFmID0gRmlsdGVyVHJlZS5wcm90b3R5cGUuYWRkRWRpdG9yKHtcbiAgICBnZXRTdGF0ZTogZnVuY3Rpb24gZ2V0U3RhdGUob3B0aW9ucykge1xuICAgICAgICB2YXIgcmVzdWx0LFxuICAgICAgICAgICAgc3ludGF4ID0gb3B0aW9ucyAmJiBvcHRpb25zLnN5bnRheDtcblxuICAgICAgICBpZiAoc3ludGF4ID09PSAnQ1FMJykge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5nZXRTeW50YXgoY29uZGl0aW9uYWxzQ1FMKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IGNvbnZlcnRMaWtlVG9Qc2V1ZG9PcChyZXN1bHQpO1xuICAgICAgICAgICAgdmFyIGRlZmF1bHRPcCA9IHRoaXMuc2NoZW1hLmxvb2t1cCh0aGlzLmNvbHVtbikuZGVmYXVsdE9wIHx8IHRoaXMucm9vdC5wYXJzZXJDUUwuZGVmYXVsdE9wOyAvLyBtaW1pY3MgbG9naWMgaW4gcGFyc2VyLUNRTC5qcywgbGluZSAxMTBcbiAgICAgICAgICAgIGlmIChyZXN1bHQudG9VcHBlckNhc2UoKS5pbmRleE9mKGRlZmF1bHRPcCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuc3Vic3RyKGRlZmF1bHRPcC5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gRmlsdGVyVHJlZS5MZWFmLnByb3RvdHlwZS5nZXRTdGF0ZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59KTtcblxuRmlsdGVyVHJlZS5wcm90b3R5cGUuYWRkRWRpdG9yKCdDb2x1bW5zJyk7XG5cbi8vIEFkZCBzb21lIG5vZGUgdGVtcGxhdGVzIGJ5IHVwZGF0aW5nIHNoYXJlZCBpbnN0YW5jZSBvZiBGaWx0ZXJOb2RlJ3MgdGVtcGxhdGVzLiAoT0sgdG8gbXV0YXRlIHNoYXJlZCBpbnN0YW5jZTsgZmlsdGVyLXRyZWUgbm90IGJlaW5nIHVzZWQgZm9yIGFueXRoaW5nIGVsc2UgaGVyZS4gQWx0ZXJuYXRpdmVseSwgd2UgY291bGQgaGF2ZSBpbnN0YW50aWF0ZWQgYSBuZXcgVGVtcGxhdGVzIG9iamVjdCBmb3Igb3VyIERlZmF1bHRGaWx0ZXIgcHJvdG90eXBlLCBhbHRob3VnaCB0aGlzIHdvdWxkIG9ubHkgYWZmZWN0IHRyZWUgbm9kZXMsIG5vdCBsZWFmIG5vZGVzLCBidXQgdGhhdCB3b3VsZCBiZSBvayBpbiB0aGlzIGNhc2Ugc2luY2UgdGhlIGFkZGl0aW9ucyBiZWxvdyBhcmUgdHJlZSBub2RlIHRlbXBsYXRlcy4pXG5fKEZpbHRlclRyZWUuTm9kZS5wcm90b3R5cGUudGVtcGxhdGVzKS5leHRlbmRPd24oe1xuICAgIGNvbHVtbkZpbHRlcjogW1xuICAgICAgICAnPHNwYW4gY2xhc3M9XCJmaWx0ZXItdHJlZVwiPicsXG4gICAgICAgICcgICA8c3Ryb25nPjxzcGFuPnsyfSA8L3NwYW4+PC9zdHJvbmc+PGJyPicsXG4gICAgICAgICcgICBNYXRjaCcsXG4gICAgICAgICcgICA8bGFiZWw+PGlucHV0IHR5cGU9XCJyYWRpb1wiIGNsYXNzPVwiZmlsdGVyLXRyZWUtb3AtY2hvaWNlXCIgbmFtZT1cInRyZWVPcHsxfVwiIHZhbHVlPVwib3Atb3JcIj5hbnk8L2xhYmVsPicsXG4gICAgICAgICcgICA8bGFiZWw+PGlucHV0IHR5cGU9XCJyYWRpb1wiIGNsYXNzPVwiZmlsdGVyLXRyZWUtb3AtY2hvaWNlXCIgbmFtZT1cInRyZWVPcHsxfVwiIHZhbHVlPVwib3AtYW5kXCI+YWxsPC9sYWJlbD4nLFxuICAgICAgICAnICAgPGxhYmVsPjxpbnB1dCB0eXBlPVwicmFkaW9cIiBjbGFzcz1cImZpbHRlci10cmVlLW9wLWNob2ljZVwiIG5hbWU9XCJ0cmVlT3B7MX1cIiB2YWx1ZT1cIm9wLW5vclwiPm5vbmU8L2xhYmVsPicsXG4gICAgICAgICcgICBvZiB0aGUgZm9sbG93aW5nOicsXG4gICAgICAgICcgICA8c2VsZWN0PicsXG4gICAgICAgICcgICAgICAgPG9wdGlvbiB2YWx1ZT1cIlwiPk5ldyBleHByZXNzaW9uJmhlbGxpcDs8L29wdGlvbj4nLFxuICAgICAgICAnICAgPC9zZWxlY3Q+JyxcbiAgICAgICAgJyAgIDxvbD48L29sPicsXG4gICAgICAgICc8L3NwYW4+J1xuICAgIF1cbiAgICAgICAgLmpvaW4oJ1xcbicpLFxuXG4gICAgY29sdW1uRmlsdGVyczogW1xuICAgICAgICAnPHNwYW4gY2xhc3M9XCJmaWx0ZXItdHJlZSBmaWx0ZXItdHJlZS10eXBlLWNvbHVtbi1maWx0ZXJzXCI+JyxcbiAgICAgICAgJyAgIE1hdGNoIDxzdHJvbmc+YWxsPC9zdHJvbmc+IG9mIHRoZSBmb2xsb3dpbmcgY29sdW1uIGZpbHRlciBzdWJleHByZXNzaW9uczonLFxuICAgICAgICAnICAgPG9sPjwvb2w+JyxcbiAgICAgICAgJzwvc3Bhbj4nXG4gICAgXVxuICAgICAgICAuam9pbignXFxuJylcbn0pO1xuXG4vKiogQGNvbnN0cnVjdG9yXG4gKlxuICogQGRlc2MgVGhpcyBleHRlbnNpb24gb2YgRmlsdGVyVHJlZSBmb3JjZXMgYSBzcGVjaWZpYyB0cmVlIHN0cnVjdHVyZS5cbiAqIFNlZSB7QGxpbmsgbWFrZU5ld1Jvb3R9IGZvciBhIGRlc2NyaXB0aW9uLlxuICpcbiAqIFNlZSBhbHNvIHtAdHV0b3JpYWwgZmlsdGVyLWFwaX0uXG4gKlxuICogQHBhcmFtIHtGaWx0ZXJUcmVlT3B0aW9uc09iamVjdH0gb3B0aW9ucyAtIFlvdSBzaG91bGQgcHJvdmlkZSBhIGNvbHVtbiBzY2hlbWEuIFRoZSBlYXNpZXN0IGFwcHJvYWNoIGlzIHRvIHByb3ZpZGUgYSBzY2hlbWEgZm9yIHRoZSBlbnRpcmUgZmlsdGVyIHRyZWUgdGhyb3VnaCBgb3B0aW9ucy5zY2hlbWFgLlxuICpcbiAqIEFsdGhvdWdoIG5vdCByZWNvbW1lbmRlZCwgdGhlIGNvbHVtbiBzY2hlbWEgY2FuIGFsc28gYmUgZW1iZWRkZWQgaW4gdGhlIHN0YXRlIG9iamVjdCwgZWl0aGVyIGF0IHRoZSByb290LCBgb3B0aW9ucy5zdGF0ZS5zY2hlbWFgLCBvciBmb3IgYW55IGRlc2NlbmRhbnQgbm9kZS4gRm9yIGV4YW1wbGUsIGEgc2VwYXJhdGUgc2NoZW1hIGNvdWxkIGJlIHByb3ZpZGVkIGZvciBlYWNoIGV4cHJlc3Npb24gb3Igc3ViZXhwcmVzc2lvbiB0aGF0IG5lZWQgdG8gcmVuZGVyIGNvbHVtbiBsaXN0IGRyb3AtZG93bnMuXG4gKlxuICogTk9URTogSWYgYG9wdGlvbnMuc3RhdGVgIGlzIHVuZGVmaW5lZCwgaXQgaXMgZGVmaW5lZCBpbiBgcHJlSW5pdGlhbGl6ZSgpYCBhcyBhIG5ldyBlbXB0eSBzdGF0ZSBzY2FmZm9sZCAoc2VlIHtAbGluayBtYWtlTmV3Um9vdH0pIHdpdGggdGhlIHR3byB0cnVua3MgdG8gaG9sZCBhIHRhYmxlIGZpbHRlciBhbmQgY29sdW1uIGZpbHRlcnMuIEV4cHJlc3Npb25zIGFuZCBzdWJleHByZXNzaW9ucyBjYW4gYmUgYWRkZWQgdG8gdGhpcyBlbXB0eSBzY2FmZm9sZCBlaXRoZXIgcHJvZ3JhbW1hdGljYWxseSBvciB0aHJvdWdoIHRoZSBRdWVyeSBCdWlsZGVyIFVJLlxuICovXG5cbnZhciBEZWZhdWx0RmlsdGVyID0gRmlsdGVyVHJlZS5leHRlbmQoJ0RlZmF1bHRGaWx0ZXInLCB7XG4gICAgcHJlSW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICAvLyBTZXQgdXAgdGhlIGRlZmF1bHQgXCJIeXBlcmZpbHRlclwiIHByb2ZpbGUgKHNlZSBmdW5jdGlvbiBjb21tZW50cylcbiAgICAgICAgdmFyIHN0YXRlID0gb3B0aW9ucy5zdGF0ZSA9IG9wdGlvbnMuc3RhdGUgfHwgdGhpcy5tYWtlTmV3Um9vdCgpO1xuXG4gICAgICAgIC8vIFVwb24gY3JlYXRpb24gb2YgYSAnY29sdW1uRmlsdGVyJyBub2RlLCBmb3JjZSB0aGUgc2NoZW1hIHRvIHRoZSBvbmUgY29sdW1uXG4gICAgICAgIGlmICgob3B0aW9ucy50eXBlIHx8IHN0YXRlICYmIHN0YXRlLnR5cGUpID09PSAnY29sdW1uRmlsdGVyJykge1xuICAgICAgICAgICAgdGhpcy5zY2hlbWEgPSBbXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5wYXJlbnQucm9vdC5zY2hlbWEubG9va3VwKHN0YXRlLmNoaWxkcmVuWzBdLmNvbHVtbilcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW29wdGlvbnNdO1xuICAgIH0sXG5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuY2FjaGUgPSB7fTtcblxuICAgICAgICBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICB0aGlzLmV4dHJhY3RTdWJ0cmVlcygpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHBvc3RJbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIGlmICh0aGlzID09PSB0aGlzLnJvb3QgJiYgIXRoaXMucGFyc2VyQ1FMKSB7XG4gICAgICAgICAgICB0aGlzLnBhcnNlckNRTCA9IG5ldyBQYXJzZXJDUUwodGhpcy5jb25kaXRpb25hbHMub3BzLCB7XG4gICAgICAgICAgICAgICAgc2NoZW1hOiB0aGlzLnNjaGVtYSxcbiAgICAgICAgICAgICAgICBkZWZhdWx0T3A6IG9wdGlvbnMuZGVmYXVsdENvbHVtbkZpbHRlck9wZXJhdG9yXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdjb2x1bW5GaWx0ZXInKSB7XG4gICAgICAgICAgICB0aGlzLmRvbnRQZXJzaXN0LnNjaGVtYSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGNvbnZlbmllbmNlIHZhcnMgdG8gcmVmZXJlbmNlIHRoZSAyIHJvb3QgXCJIeXBlcmZpbHRlclwiIG5vZGVzXG4gICAgICogQG1lbWJlck9mIERlZmF1bHRGaWx0ZXIucHJvdG90eXBlXG4gICAgICovXG4gICAgZXh0cmFjdFN1YnRyZWVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJvb3ROb2RlcyA9IHRoaXMucm9vdC5jaGlsZHJlbjtcbiAgICAgICAgdGhpcy50YWJsZUZpbHRlciA9IHJvb3ROb2Rlc1swXTtcbiAgICAgICAgdGhpcy5jb2x1bW5GaWx0ZXJzID0gcm9vdE5vZGVzWzFdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBNYWtlIGEgbmV3IGVtcHR5IEh5cGVyZ3JpZCBmaWx0ZXIgdHJlZSBzdGF0ZSBvYmplY3QuXG4gICAgICogQGRlc2MgVGhpcyBmdW5jdGlvbiBtYWtlcyBhIG5ldyBkZWZhdWx0IHN0YXRlIG9iamVjdCBhcyB1c2VkIGJ5IEh5cGVyZ3JpZCwgYSByb290IHdpdGggZXhhY3RseSB0d28gXCJ0cnVua3MuXCJcbiAgICAgKlxuICAgICAqID4gKipEZWZpbml0aW9uOioqIEEgKnRydW5rKiBpcyBkZWZpbmVkIGFzIGEgY2hpbGQgbm9kZSB3aXRoIGEgdHJ1dGh5IGBrZWVwYCBwcm9wZXJ0eSwgbWFraW5nIHRoaXMgbm9kZSBpbW11bmUgdG8gdGhlIHVzdWFsIHBydW5pbmcgdGhhdCB3b3VsZCBvY2N1ciB3aGVuIGl0IGhhcyBubyBjaGlsZCBub2RlcyBvZiBpdHMgb3duLiBUbyBiZSBhIHRydWUgdHJ1bmssIGFsbCBhbmNlc3RvciBub2RlcyB0byBiZSB0cnVua3MgYXMgd2VsbC4gTm90ZSB0aGF0IHRoZSByb290IGlzIGEgbmF0dXJhbCB0cnVuazsgaXQgZG9lcyBub3QgcmVxdWlyZSBhIGBrZWVwYCBwcm9wZXJ0eS5cbiAgICAgKlxuICAgICAqIFRoZSB0d28gdHJ1bmtzIG9mIHRoZSBIeXBlcmdyaWQgZmlsdGVyIGFyZTpcbiAgICAgKiAqIFRoZSAqKlRhYmxlIEZpbHRlcioqIChsZWZ0IHRydW5rLCBvciBgY2hpbGRyZW5bMF1gKSwgYSBoaWVyYXJjaHkgb2YgZmlsdGVyIGV4cHJlc3Npb25zIGFuZCBzdWJleHByZXNzaW9ucy5cbiAgICAgKiAqIFRoZSAqKkNvbHVtbiBGaWx0ZXJzKiogKHJpZ2h0IHRydW5rLCBvciBgY2hpbGRyZW5bMV1gKSwgYSBzZXJpZXMgb2Ygc3ViZXhwcmVzc2lvbnMsIG9uZSBwZXIgYWN0aXZlIGNvbHVtbiBmaWx0ZXIuIEVhY2ggc3ViZXhwcmVzc2lvbiBjb250YWlucyBhbnkgbnVtYmVyIG9mIGV4cHJlc3Npb25zIGJvdW5kIHRvIHRoYXQgY29sdW1uIGJ1dCBubyBmdXJ0aGVyIHN1YmV4cHJlc3Npb25zLlxuICAgICAqXG4gICAgICogVGhlIGBvcGVyYXRvcmAgcHJvcGVydGllcyBmb3IgYWxsIHN1YmV4cHJlc3Npb25zIGRlZmF1bHQgdG8gYCdvcC1hbmQnYCwgd2hpY2ggbWVhbnM6XG4gICAgICogKiBBbGwgdGFibGUgZmlsdGVyIGV4cHJlc3Npb25zIGFuZCBzdWJleHByZXNzaW9ucyBhcmUgQU5EJ2QgdG9nZXRoZXIuIChUaGlzIGlzIGp1c3QgdGhlIGRlZmF1bHQgYW5kIG1heSBiZSBjaGFuZ2VkIGZyb20gdGhlIFVJLilcbiAgICAgKiAqIEFsbCBleHByZXNzaW9ucyB3aXRoaW4gYSBjb2x1bW4gZmlsdGVyIHN1YmV4cHJlc3Npb24gYXJlIEFORCdkIHRvZ2V0aGVyLiAoVGhpcyBpcyBqdXN0IHRoZSBkZWZhdWx0IGFuZCBtYXkgYmUgY2hhbmdlZCBmcm9tIHRoZSBVSS4pXG4gICAgICogKiBBbGwgY29sdW1uIEZpbHRlcnMgc3ViZXhwcmVzc2lvbnMgYXJlIEFORCdkIHRvZ2V0aGVyLiAoVGhpcyBtYXkgbm90IGJlIGNoYW5nZWQgZnJvbSBVSS4pXG4gICAgICogKiBGaW5hbGx5LCB0aGUgdGFibGUgZmlsdGVyIGFuZCBjb2x1bW4gZmlsdGVycyBhcmUgQU5EJ2QgdG9nZXRoZXIuIChUaGlzIG1heSBub3QgYmUgY2hhbmdlZCBmcm9tIFVJLilcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IEEgcGxhaW4gb2JqZWN0IHRvIHNlcnZlIGFzIGEgZmlsdGVyLXRyZWUgc3RhdGUgb2JqZWN0IHJlcHJlc2VudGluZyBhIG5ldyBIeXBlcmdyaWQgZmlsdGVyLlxuICAgICAqXG4gICAgICogQG1lbWJlck9mIERlZmF1bHRGaWx0ZXIucHJvdG90eXBlXG4gICAgICovXG4gICAgbWFrZU5ld1Jvb3Q6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRoaXMudGFibGVGaWx0ZXIgPSB7XG4gICAgICAgICAgICBrZWVwOiB0cnVlLFxuICAgICAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICAgICAgICAvLyB0YWJsZSBmaWx0ZXIgZXhwcmVzc2lvbnMgYW5kIHN1YmV4cHJlc3Npb25zIGdvIGhlcmVcbiAgICAgICAgICAgIF1cbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmNvbHVtbkZpbHRlcnMgPSB7XG4gICAgICAgICAgICBrZWVwOiB0cnVlLFxuICAgICAgICAgICAgdHlwZTogJ2NvbHVtbkZpbHRlcnMnLFxuICAgICAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICAgICAgICAvLyBzdWJleHByZXNzaW9ucyB3aXRoIHR5cGUgJ2NvbHVtbkZpbHRlcicgZ28gaGVyZSwgb25lIGZvciBlYWNoIGFjdGl2ZSBjb2x1bW4gZmlsdGVyXG4gICAgICAgICAgICBdXG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGZpbHRlciA9IHtcbiAgICAgICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICAgICAgdGhpcy50YWJsZUZpbHRlcixcbiAgICAgICAgICAgICAgICB0aGlzLmNvbHVtbkZpbHRlcnNcbiAgICAgICAgICAgIF1cbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gZmlsdGVyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBHZXQgdGhlIGNvbHVtbiBmaWx0ZXIgc3ViZXhwcmVzc2lvbiBub2RlLlxuICAgICAqIEBkZXNjIEVhY2ggY29sdW1uIGZpbHRlciBzdWJleHByZXNzaW9uIG5vZGUgaXMgYSBjaGlsZCBub2RlIG9mIHRoZSBgY29sdW1uRmlsdGVyc2AgdHJ1bmsgb2YgdGhlIEh5cGVyZ3JpZCBmaWx0ZXIgdHJlZS5cbiAgICAgKiBFYWNoIHN1Y2ggbm9kZSBjb250YWlucyBhbGwgdGhlIGNvbHVtbiBmaWx0ZXIgZXhwcmVzc2lvbnMgZm9yIHRoZSBuYW1lZCBjb2x1bW4uIEl0IHdpbGwgbmV2ZXIgYmUgZW1wdHk7IGlmIHRoZXJlIGlzIG5vIGNvbHVtbiBmaWx0ZXIgZm9yIHRoZSBuYW1lZCBjb2x1bW4sIGl0IHdvbid0IGV4aXN0IGluIGBjb2x1bW5GaWx0ZXJzYC5cbiAgICAgKlxuICAgICAqIENBVVRJT046IFRoaXMgaXMgdGhlIGFjdHVhbCBub2RlIG9iamVjdC4gRG8gbm90IGNvbmZ1c2UgaXQgd2l0aCB0aGUgY29sdW1uIGZpbHRlciBfc3RhdGVfIG9iamVjdCAoZm9yIHdoaWNoIHNlZSB0aGUge0BsaW5rIERlZmF1bHRGaWx0ZXIjZ2V0Q29sdW1uRmlsdGVyU3RhdGV8Z2V0Q29sdW1uRmlsdGVyU3RhdGUoKX0gbWV0aG9kKS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sdW1uTmFtZVxuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR8RGVmYXVsdEZpbHRlcn0gUmV0dXJucyBgdW5kZWZpbmVkYCBpZiB0aGUgY29sdW1uIGZpbHRlciBkb2VzIG5vdCBleGlzdC5cbiAgICAgKi9cbiAgICBnZXRDb2x1bW5GaWx0ZXI6IGZ1bmN0aW9uKGNvbHVtbk5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sdW1uRmlsdGVycy5jaGlsZHJlbi5maW5kKGZ1bmN0aW9uKGNvbHVtbkZpbHRlcikge1xuICAgICAgICAgICAgcmV0dXJuIGNvbHVtbkZpbHRlci5jaGlsZHJlbi5sZW5ndGggJiYgY29sdW1uRmlsdGVyLmNoaWxkcmVuWzBdLmNvbHVtbiA9PT0gY29sdW1uTmFtZTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKiBAdHlwZWRlZiB7b2JqZWN0fSBGaWx0ZXJUcmVlR2V0U3RhdGVPcHRpb25zT2JqZWN0XG4gICAgICogU2VlIHRoZSB7QGxpbmsgaHR0cDovL2pvbmVpdC5naXRodWIuaW8vZmlsdGVyLXRyZWUvZ2xvYmFsLmh0bWwjRmlsdGVyVHJlZUdldFN0YXRlT3B0aW9uc09iamVjdHx0eXBlIGRlZmluaXRpb259IGluIHRoZSBmaWx0ZXItdHJlZSBkb2N1bWVudGF0aW9uLlxuICAgICAqL1xuXG4gICAgLyoqIEB0eXBlZGVmIHtvYmplY3R9IEZpbHRlclRyZWVTZXRTdGF0ZU9wdGlvbnNPYmplY3RcbiAgICAgKiBTZWUgdGhlIHtAbGluayBodHRwOi8vam9uZWl0LmdpdGh1Yi5pby9maWx0ZXItdHJlZS9nbG9iYWwuaHRtbCNGaWx0ZXJUcmVlU2V0U3RhdGVPcHRpb25zT2JqZWN0fHR5cGUgZGVmaW5pdGlvbn0gaW4gdGhlIGZpbHRlci10cmVlIGRvY3VtZW50YXRpb24uXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBHZXQgYSBwYXJ0aWN1bGFyIGNvbHVtbiBmaWx0ZXIncyBzdGF0ZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcmF3Q29sdW1uTmFtZSAtIENvbHVtbiBuYW1lIGZvciBjYXNlIGFuZCBhbGlhcyBsb29rdXAuXG4gICAgICogQHBhcmFtIHtGaWx0ZXJUcmVlR2V0U3RhdGVPcHRpb25zT2JqZWN0fSBbb3B0aW9uc10gLSBQYXNzZWQgdG8gdGhlIGZpbHRlcidzIHtAbGluayBEZWZhdWx0RmlsdGVyI2dldFN0YXRlfGdldFN0YXRlfSBtZXRob2QuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5zeW50YXg9J0NRTCddIC0gVGhlIHN5bnRheCB0byB1c2UgdG8gZGVzY3JpYmUgdGhlIGZpbHRlciBzdGF0ZS4gTm90ZSB0aGF0IGBnZXRGaWx0ZXJgJ3MgZGVmYXVsdCBzeW50YXgsIGAnQ1FMJ2AsIGRpZmZlcnMgZnJvbSB0aGUgb3RoZXIgZ2V0IHN0YXRlIG1ldGhvZHMuXG4gICAgICogQHJldHVybnMge0ZpbHRlclRyZWVTdGF0ZU9iamVjdH1cbiAgICAgKiBAbWVtYmVyT2YgRGVmYXVsdEZpbHRlci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBnZXRDb2x1bW5GaWx0ZXJTdGF0ZTogZnVuY3Rpb24ocmF3Q29sdW1uTmFtZSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gJycsXG4gICAgICAgICAgICBjb2x1bW5TY2hlbWEgPSB0aGlzLnNjaGVtYS5sb29rdXAocmF3Q29sdW1uTmFtZSk7XG5cbiAgICAgICAgaWYgKGNvbHVtblNjaGVtYSkge1xuICAgICAgICAgICAgdmFyIHN1YmV4cHJlc3Npb24gPSB0aGlzLmdldENvbHVtbkZpbHRlcihjb2x1bW5TY2hlbWEubmFtZSk7XG5cbiAgICAgICAgICAgIGlmIChzdWJleHByZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEob3B0aW9ucyAmJiBvcHRpb25zLnN5bnRheCkpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuc3ludGF4ID0gJ0NRTCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHN1YmV4cHJlc3Npb24uZ2V0U3RhdGUob3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBTZXQgYSBwYXJ0aWN1bGFyIGNvbHVtbiBmaWx0ZXIncyBzdGF0ZS5cbiAgICAgKiBAZGVzYyBBZGRzIENRTCBzdXBwb3J0IHRvIHRoaXMuZ2V0U3RhdGUoKS4gVGhpcyBmdW5jdGlvbiB0aHJvd3MgcGFyc2VyIGVycm9ycy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2x1bW5OYW1lXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IFtzdGF0ZV0gLSBBIGZpbHRlciB0cmVlIG9iamVjdCBvciBhIEpTT04sIFNRTCwgb3IgQ1FMIHN1YmV4cHJlc3Npb24gc3RyaW5nIHRoYXQgZGVzY3JpYmVzIHRoZSBhIG5ldyBzdGF0ZSBmb3IgdGhlIG5hbWVkIGNvbHVtbiBmaWx0ZXIuIFRoZSBleGlzdGluZyBjb2x1bW4gZmlsdGVyIHN1YmV4cHJlc3Npb24gaXMgcmVwbGFjZWQgd2l0aCBhIG5ldyBub2RlIGJhc2VkIG9uIHRoaXMgc3RhdGUuIElmIGl0IGRvZXMgbm90IGV4aXN0LCB0aGUgbmV3IHN1YmV4cHJlc3Npb24gaXMgYWRkZWQgdG8gdGhlIGNvbHVtbiBmaWx0ZXJzIHN1YnRyZWUgKGB0aGlzLnJvb3QuY29sdW1uRmlsdGVyc2ApLlxuICAgICAqXG4gICAgICogSWYgdW5kZWZpbmVkLCByZW1vdmVzIHRoZSBlbnRpcmUgY29sdW1uIGZpbHRlciBzdWJleHByZXNzaW9uIGZyb20gdGhlIGNvbHVtbiBmaWx0ZXJzIHN1YnRyZWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcmF3Q29sdW1uTmFtZSAtIENvbHVtbiBuYW1lIGZvciBjYXNlIGFuZCBhbGlhcyBsb29rdXAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0ZpbHRlclRyZWVTZXRTdGF0ZU9wdGlvbnNPYmplY3R9IFtvcHRpb25zXSAtIFBhc3NlZCB0byB0aGUgZmlsdGVyJ3MgW3NldFN0YXRlXXtAbGluayBodHRwOi8vam9uZWl0LmdpdGh1Yi5pby9maWx0ZXItdHJlZS9GaWx0ZXJUcmVlLmh0bWwjc2V0U3RhdGV9IG1ldGhvZC4gWW91IG1heSBtaXggaW4gbWVtYmVycyBvZiB0aGUge0BsaW5rIGh0dHA6Ly9qb25laXQuZ2l0aHViLmlvL2ZpbHRlci10cmVlL2dsb2JhbC5odG1sI0ZpbHRlclRyZWVWYWxpZGF0aW9uT3B0aW9uc09iamVjdHxGaWx0ZXJUcmVlVmFsaWRhdGlvbk9wdGlvbnNPYmplY3R9XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnN5bnRheD0nQ1FMJ10gLSBUaGUgc3ludGF4IHRvIHVzZSB0byBkZXNjcmliZSB0aGUgZmlsdGVyIHN0YXRlLiBOb3RlIHRoYXQgYHNldENvbHVtbkZpbHRlclN0YXRlYCdzIGRlZmF1bHQgc3ludGF4LCBgJ0NRTCdgLCBkaWZmZXJzIGZyb20gdGhlIG90aGVyIGdldCBzdGF0ZSBtZXRob2RzLlxuICAgICAqXG4gICAgICogQG1lbWJlck9mIERlZmF1bHRGaWx0ZXIucHJvdG90eXBlXG4gICAgICovXG4gICAgc2V0Q29sdW1uRmlsdGVyU3RhdGU6IGZ1bmN0aW9uKHJhd0NvbHVtbk5hbWUsIHN0YXRlLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBlcnJvcixcbiAgICAgICAgICAgIHN1YmV4cHJlc3Npb247XG5cbiAgICAgICAgdmFyIGNvbHVtbk5hbWUgPSB0aGlzLnNjaGVtYS5sb29rdXAocmF3Q29sdW1uTmFtZSkubmFtZTtcblxuICAgICAgICBpZiAoIWNvbHVtbk5hbWUpIHtcbiAgICAgICAgICAgIHRocm93ICdVbmtub3duIGNvbHVtbiBuYW1lIFwiJyArIHJhd0NvbHVtbk5hbWUgKyAnXCInO1xuICAgICAgICB9XG5cbiAgICAgICAgc3ViZXhwcmVzc2lvbiA9IHRoaXMuZ2V0Q29sdW1uRmlsdGVyKGNvbHVtbk5hbWUpO1xuXG4gICAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IF8oe30pLmV4dGVuZChvcHRpb25zKTsgLy8gY2xvbmUgaXQgYmVjYXVzZSB3ZSBtYXkgbXV0YXRlIGl0IGJlbG93XG4gICAgICAgICAgICBvcHRpb25zLnN5bnRheCA9IG9wdGlvbnMuc3ludGF4IHx8ICdDUUwnO1xuXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zeW50YXggPT09ICdDUUwnKSB7XG4gICAgICAgICAgICAgICAgLy8gQ29udmVydCBzb21lIENRTCBzdGF0ZSBzeW50YXggaW50byBhIGZpbHRlciB0cmVlIHN0YXRlIG9iamVjdC5cbiAgICAgICAgICAgICAgICAvLyBUaGVyZSBtdXN0IGJlIGF0IGxlYXN0IG9uZSBjb21wbGV0ZSBleHByZXNzaW9uIG9yIGBzdGF0ZWAgd2lsbCBiZWNvbWUgdW5kZWZpbmVkLlxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlID0gdGhpcy5yb290LnBhcnNlckNRTC5wYXJzZShzdGF0ZSwgY29sdW1uTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5zeW50YXggPSAnb2JqZWN0JztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKCdEZWZhdWx0RmlsdGVyOiBObyBjb21wbGV0ZSBleHByZXNzaW9uLicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvciA9IGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWVycm9yKSB7IC8vIHBhcnNlIHN1Y2Nlc3NmdWxcbiAgICAgICAgICAgICAgICBpZiAoc3ViZXhwcmVzc2lvbikgeyAvLyBzdWJleHByZXNzaW9uIGFscmVhZHkgZXhpc3RzXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlcGxhY2Ugc3ViZXhwcmVzc2lvbiByZXByZXNlbnRpbmcgdGhpcyBjb2x1bW5cbiAgICAgICAgICAgICAgICAgICAgc3ViZXhwcmVzc2lvbi5zZXRTdGF0ZShzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYWRkIGEgbmV3IHN1YmV4cHJlc3Npb24gcmVwcmVzZW50aW5nIHRoaXMgY29sdW1uXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlID0gdGhpcy5wYXJzZVN0YXRlU3RyaW5nKHN0YXRlLCBvcHRpb25zKTsgLy8gYmVjYXVzZSAuYWRkKCkgb25seSB0YWtlcyBvYmplY3Qgc3ludGF4XG4gICAgICAgICAgICAgICAgICAgIHN1YmV4cHJlc3Npb24gPSB0aGlzLmNvbHVtbkZpbHRlcnMuYWRkKHN0YXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3B0aW9ucy50aHJvdyA9IHRydWU7XG4gICAgICAgICAgICAgICAgZXJyb3IgPSBzdWJleHByZXNzaW9uLmludmFsaWQob3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3ViZXhwcmVzc2lvbiAmJiAoIXN0YXRlIHx8IGVycm9yKSkge1xuICAgICAgICAgICAgLy8gcmVtb3ZlIHN1YmV4cHJlc3Npb24gcmVwcmVzZW50aW5nIHRoaXMgY29sdW1uXG4gICAgICAgICAgICBzdWJleHByZXNzaW9uLnJlbW92ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBHZXQgc3RhdGUgb2YgYWxsIGNvbHVtbiBmaWx0ZXJzLlxuICAgICAqIEBwYXJhbSB7RmlsdGVyVHJlZUdldFN0YXRlT3B0aW9uc09iamVjdH0gW29wdGlvbnNdIC0gUGFzc2VkIHRvIHRoZSBmaWx0ZXIncyB7QGxpbmsgRGVmYXVsdEZpbHRlciNnZXRTdGF0ZXxnZXRTdGF0ZX0gbWV0aG9kLlxuICAgICAqIEByZXR1cm5zIHtGaWx0ZXJUcmVlU3RhdGVPYmplY3R9XG4gICAgICogQG1lbWJlck9mIERlZmF1bHRGaWx0ZXIucHJvdG90eXBlXG4gICAgICovXG4gICAgZ2V0Q29sdW1uRmlsdGVyc1N0YXRlOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuc3ludGF4ID09PSAnQ1FMJykge1xuICAgICAgICAgICAgdGhyb3cgJ1RoZSBDUUwgc3ludGF4IGlzIGludGVuZGVkIGZvciB1c2Ugb24gYSBzaW5nbGUgY29sdW1uIGZpbHRlciBvbmx5LiBJdCBkb2VzIG5vdCBzdXBwb3J0IG11bHRpcGxlIGNvbHVtbnMgb3Igc3ViZXhwcmVzc2lvbnMuJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5yb290LmNvbHVtbkZpbHRlcnMuZ2V0U3RhdGUob3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IFNldCBzdGF0ZSBvZiBhbGwgY29sdW1uIGZpbHRlcnMuXG4gICAgICogQGRlc2MgTm90ZSB0aGF0IHRoZSBjb2x1bW4gZmlsdGVycyBpbXBsZW1lbnRhdGlvbiBkZXBlbmRzIG9uIHRoZSBub2RlcyBoYXZpbmcgY2VydGFpbiBtZXRhLWRhdGE7IHlvdSBzaG91bGQgbm90IGJlIGNhbGxpbmcgdGhpcyB3aXRob3V0IHRoZXNlIG1ldGEtZGF0YSBiZWluZyBpbiBwbGFjZS4gU3BlY2lmaWNhbGx5IGB0eXBlID0gJ2NvbHVtbkZpbHRlcnMnYCBhbmQgIGBrZWVwID0gdHJ1ZWAgZm9yIHRoZSBjb2x1bW4gZmlsdGVycyBzdWJ0cmVlIGFuZGB0eXBlID0gJ2NvbHVtbkZpbHRlcidgIGZvciBlYWNoIGluZGl2aWR1YWwgY29sdW1uIGZpbHRlciBzdWJleHByZXNzaW9uLiBJbiBhZGRpdGlvbiB0aGUgc3VidHJlZSBvcGVyYXRvcnMgc2hvdWxkIGFsd2F5cyBiZSBgJ29wLWFuZCdgLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdGF0ZVxuICAgICAqIEBwYXJhbSB7RmlsdGVyVHJlZVNldFN0YXRlT3B0aW9uc09iamVjdH0gW29wdGlvbnNdIC0gUGFzc2VkIHRvIHRoZSBmaWx0ZXIncyBbc2V0U3RhdGVde0BsaW5rIGh0dHA6Ly9qb25laXQuZ2l0aHViLmlvL2ZpbHRlci10cmVlL0ZpbHRlclRyZWUuaHRtbCNzZXRTdGF0ZX0gbWV0aG9kLiBZb3UgbWF5IG1peCBpbiBtZW1iZXJzIG9mIHRoZSB7QGxpbmsgaHR0cDovL2pvbmVpdC5naXRodWIuaW8vZmlsdGVyLXRyZWUvZ2xvYmFsLmh0bWwjRmlsdGVyVHJlZVZhbGlkYXRpb25PcHRpb25zT2JqZWN0fEZpbHRlclRyZWVWYWxpZGF0aW9uT3B0aW9uc09iamVjdH1cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR8RXJyb3J8c3RyaW5nfSBgdW5kZWZpbmVkYCBpbmRpY2F0ZXMgc3VjY2Vzcy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJPZiBEZWZhdWx0RmlsdGVyLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHNldENvbHVtbkZpbHRlcnNTdGF0ZTogZnVuY3Rpb24oc3RhdGUsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGVycm9yO1xuXG4gICAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5yb290LmNvbHVtbkZpbHRlcnMuc2V0U3RhdGUoc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgZXJyb3IgPSB0aGlzLnJvb3QuY29sdW1uRmlsdGVycy5pbnZhbGlkKG9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0ZpbHRlclRyZWVHZXRTdGF0ZU9wdGlvbnNPYmplY3R9IFtvcHRpb25zXSAtIFBhc3NlZCB0byB0aGUgZmlsdGVyJ3Mge0BsaW5rIERlZmF1bHRGaWx0ZXIjZ2V0U3RhdGV8Z2V0U3RhdGV9IG1ldGhvZC5cbiAgICAgKiBAcmV0dXJucyB7RmlsdGVyVHJlZVN0YXRlT2JqZWN0fVxuICAgICAqIEBtZW1iZXJPZiBEZWZhdWx0RmlsdGVyLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGdldFRhYmxlRmlsdGVyU3RhdGU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5zeW50YXggPT09ICdDUUwnKSB7XG4gICAgICAgICAgICB0aHJvdyAnVGhlIENRTCBzeW50YXggaXMgaW50ZW5kZWQgZm9yIHVzZSBvbiBhIHNpbmdsZSBjb2x1bW4gZmlsdGVyIG9ubHkuIEl0IGRvZXMgbm90IHN1cHBvcnQgbXVsdGlwbGUgY29sdW1ucyBvciBzdWJleHByZXNzaW9ucy4nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnJvb3QudGFibGVGaWx0ZXIuZ2V0U3RhdGUob3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdGF0ZVxuICAgICAqIEBwYXJhbSB7RmlsdGVyVHJlZVNldFN0YXRlT3B0aW9uc09iamVjdH0gW29wdGlvbnNdIC0gUGFzc2VkIHRvIHRoZSBmaWx0ZXIncyBbc2V0U3RhdGVde0BsaW5rIGh0dHA6Ly9qb25laXQuZ2l0aHViLmlvL2ZpbHRlci10cmVlL0ZpbHRlclRyZWUuaHRtbCNzZXRTdGF0ZX0gbWV0aG9kLiBZb3UgbWF5IG1peCBpbiBtZW1iZXJzIG9mIHRoZSB7QGxpbmsgaHR0cDovL2pvbmVpdC5naXRodWIuaW8vZmlsdGVyLXRyZWUvZ2xvYmFsLmh0bWwjRmlsdGVyVHJlZVZhbGlkYXRpb25PcHRpb25zT2JqZWN0fEZpbHRlclRyZWVWYWxpZGF0aW9uT3B0aW9uc09iamVjdH1cbiAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfEVycm9yfHN0cmluZ30gYHVuZGVmaW5lZGAgaW5kaWNhdGVzIHN1Y2Nlc3MuXG4gICAgICogQG1lbWJlck9mIERlZmF1bHRGaWx0ZXIucHJvdG90eXBlXG4gICAgICovXG4gICAgc2V0VGFibGVGaWx0ZXJTdGF0ZTogZnVuY3Rpb24oc3RhdGUsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGVycm9yO1xuXG4gICAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5yb290LnRhYmxlRmlsdGVyLnNldFN0YXRlKHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGVycm9yID0gdGhpcy5yb290LnRhYmxlRmlsdGVyLmludmFsaWQob3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJvb3QudGFibGVGaWx0ZXIuY2hpbGRyZW4ubGVuZ3RoID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlcnJvcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGRlc2MgVGhlIENRTCBzeW50YXggc2hvdWxkIG9ubHkgYmUgcmVxdWVzdGVkIGZvciBhIHN1YnRyZWUgY29udGFpbmluZyBob21vZ2VuZW91cyBjb2x1bW4gbmFtZXMgYW5kIG5vIHN1YmV4cHJlc3Npb25zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnN5bnRheD0nb2JqZWN0J10gLSBJZiBgJ0NRTCdgLCB3YWxrcyB0aGUgdHJlZSwgcmV0dXJuaW5nIGEgc3RyaW5nIHN1aXRhYmxlIGZvciBhIEh5cGVyZ3JpZCBmaWx0ZXIgY2VsbC4gQWxsIG90aGVyIHZhbHVlcyBhcmUgZm9yd2FyZGVkIHRvIHRoZSBwcm90b3R5cGUncyBgZ2V0U3RhdGVgIG1ldGhvZCBmb3IgZnVydGhlciBpbnRlcnByZXRhdGlvbi5cbiAgICAgKlxuICAgICAqIE5PVEU6IENRTCBpcyBub3QgaW50ZW5kZWQgdG8gYmUgdXNlZCBvdXRzaWRlIHRoZSBjb250ZXh0IG9mIGEgYGNvbHVtbkZpbHRlcnNgIHN1YmV4cHJlc3Npb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7RmlsdGVyVHJlZVN0YXRlT2JqZWN0fVxuICAgICAqXG4gICAgICogQG1lbWJlck9mIERlZmF1bHRGaWx0ZXIucHJvdG90eXBlXG4gICAgICovXG4gICAgZ2V0U3RhdGU6IGZ1bmN0aW9uIGdldFN0YXRlKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHJlc3VsdCxcbiAgICAgICAgICAgIHN5bnRheCA9IG9wdGlvbnMgJiYgb3B0aW9ucy5zeW50YXg7XG5cbiAgICAgICAgaWYgKHN5bnRheCA9PT0gJ0NRTCcpIHtcbiAgICAgICAgICAgIHZhciBvcGVyYXRvciA9IHRoaXMub3BlcmF0b3Iuc3Vic3RyKDMpOyAvLyByZW1vdmUgdGhlICdvcC0nIHByZWZpeFxuICAgICAgICAgICAgcmVzdWx0ID0gJyc7XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24oY2hpbGQsIGlkeCkge1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBDdXN0b21GaWx0ZXJMZWFmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaWR4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICcgJyArIG9wZXJhdG9yICsgJyAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IGNoaWxkLmdldFN0YXRlKG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoaWxkLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWZhdWx0RmlsdGVyOiBFeHBlY3RlZCBhIGNvbmRpdGlvbmFsIGJ1dCBmb3VuZCBhIHN1YmV4cHJlc3Npb24uIFN1YmV4cHJlc3Npb25zIGFyZSBub3Qgc3VwcG9ydGVkIGluIENRTCAoQ29sdW1uIFF1ZXJ5IExhbmd1YWdlLCB0aGUgZmlsdGVyIGNlbGwgc3ludGF4KS4nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gRmlsdGVyVHJlZS5wcm90b3R5cGUuZ2V0U3RhdGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIGxvYWRDb2x1bW5Qcm9wZXJ0aWVzRnJvbVNjaGVtYTogZnVuY3Rpb24oY29sdW1ucykge1xuICAgICAgICB0aGlzLnJvb3Quc2NoZW1hLndhbGsoZnVuY3Rpb24oY29sdW1uU2NoZW1hKSB7XG4gICAgICAgICAgICB2YXIgY29sdW1uID0gY29sdW1ucy5maW5kKGZ1bmN0aW9uKHRoaXNDb2x1bW4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc0NvbHVtbi5uYW1lID09PSBjb2x1bW5TY2hlbWEubmFtZSB8fCBjb2x1bW5TY2hlbWE7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChjb2x1bW4pIHtcbiAgICAgICAgICAgICAgICBjb2x1bW4udHlwZSA9IGNvbHVtblNjaGVtYS50eXBlIHx8IGNvbHVtbi50eXBlO1xuICAgICAgICAgICAgICAgIGNvbHVtbi5oZWFkZXIgPSBjb2x1bW5TY2hlbWEuYWxpYXMgfHwgY29sdW1uLmhlYWRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBEZWZhdWx0RmlsdGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgXyA9IHJlcXVpcmUoJ29iamVjdC1pdGVyYXRvcnMnKTtcblxudmFyIFJFR0VYUF9CT09MUyA9IC9cXGIoQU5EfE9SfE5PUilcXGIvZ2ksXG4gICAgRVhQID0gJyguKj8pJywgQlIgPSAnXFxcXGInLFxuICAgIFBSRUZJWCA9ICdeJyArIEVYUCArIEJSLFxuICAgIElORklYID0gQlIgKyBFWFAgKyBCUixcbiAgICBQT1NURklYID0gQlIgKyBFWFAgKyAnJCc7XG5cbmZ1bmN0aW9uIFBhcnNlckNxbEVycm9yKG1lc3NhZ2UpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xufVxuUGFyc2VyQ3FsRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuUGFyc2VyQ3FsRXJyb3IucHJvdG90eXBlLm5hbWUgPSAnUGFyc2VyQ3FsRXJyb3InO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICpcbiAqIEBzdW1tYXJ5IENvbHVtbiBRdWVyeSBMYW5ndWFnZSAoQ1FMKSBwYXJzZXJcbiAqXG4gKiBAYXV0aG9yIEpvbmF0aGFuIEVpdGVuIGpvbmF0aGFuQG9wZW5maW4uY29tXG4gKlxuICogQGRlc2MgU2VlIHtAdHV0b3JpYWwgQ1FMfSBmb3IgdGhlIGdyYW1tYXIuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG9wZXJhdG9yc0hhc2ggLSBIYXNoIG9mIHZhbGlkIG9wZXJhdG9ycy4gRWFjaCBpcyBhbiBvYmplY3QsIHRoZSBvbmx5IHByb3BlcnR5IG9mIGludGVyZXN0IGJlaW5nIGBjb21wbGV4YCB3aGljaCBpZiB0cnV0aHkgbWVhbnMgb3BlcmFuZCBtYXkgYmUgYSBsaXN0IG9mIG11bHRpcGxlIG9wZXJhbmRzLlxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHttZW51SXRlbVtdfSBbb3B0aW9ucy5zY2hlbWFdIC0gQ29sdW1uIHNjaGVtYSBmb3IgY29sdW1uIG5hbWUvYWxpYXMgdmFsaWRhdGlvbi4gVGhyb3dzIGFuIGVycm9yIGlmIG5hbWUgZmFpbHMgdmFsaWRhdGlvbiAoYnV0IHNlZSBgcmVzb2x2ZUFsaWFzZXNgKS4gT21pdCB0byBza2lwIGNvbHVtbiBuYW1lIHZhbGlkYXRpb24uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmRlZmF1bHRPcD0nPSddIC0gRGVmYXVsdCBvcGVyYXRvciBmb3IgY29sdW1uIHdoZW4gbm90IGRlZmluZWQgaW4gY29sdW1uIHNjaGVtYS5cbiAqL1xuZnVuY3Rpb24gUGFyc2VyQ1FMKG9wZXJhdG9yc0hhc2gsIG9wdGlvbnMpIHtcbiAgICB2YXIgb3BlcmF0b3JzID0gW107XG5cbiAgICB0aGlzLnNjaGVtYSA9IG9wdGlvbnMgJiYgb3B0aW9ucy5zY2hlbWE7XG4gICAgdGhpcy5kZWZhdWx0T3AgPSAob3B0aW9ucyAmJiBvcHRpb25zLmRlZmF1bHRPcCB8fCAnPScpLnRvVXBwZXJDYXNlKCk7XG5cbiAgICBfKG9wZXJhdG9yc0hhc2gpLmVhY2goZnVuY3Rpb24ocHJvcHMsIG9wKSB7XG4gICAgICAgIGlmIChvcCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIG9wZXJhdG9ycy5wdXNoKG9wKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gUHV0IGxhcmdlciBvbmVzIGZpcnN0IHNvIHRoYXQgaW4gY2FzZSBhIHNtYWxsZXIgb25lIGlzIGEgc3Vic3RyaW5nIG9mIGEgbGFyZ2VyIG9uZSAoc3VjaCBhcyAnPCcgaXMgdG8gJzw9JyksIGxhcmdlciBvbmUgd2lsbCBiZSBtYXRjaGVkIGZpcnN0LlxuICAgIG9wZXJhdG9ycyA9IG9wZXJhdG9ycy5zb3J0KGRlc2NlbmRpbmdCeUxlbmd0aCk7XG5cbiAgICAvLyBFc2NhcGUgYWxsIHN5bWJvbGljIChub24gYWxwaGEpIG9wZXJhdG9ycy5cbiAgICBvcGVyYXRvcnMgPSBvcGVyYXRvcnMubWFwKGZ1bmN0aW9uKG9wKSB7IHJldHVybiAvW15cXHddLy50ZXN0KG9wKSA/ICdcXFxcJyArIG9wLnNwbGl0KCcnKS5qb2luKCdcXFxcJykgOiBvcDsgfSk7XG5cbiAgICB2YXIgc3ltYm9saWNPcGVyYXRvcnMgPSBvcGVyYXRvcnMuZmlsdGVyKGZ1bmN0aW9uKG9wKSB7IHJldHVybiBvcFswXSA9PT0gJ1xcXFwnOyB9KSxcbiAgICAgICAgYWxwaGFPcGVyYXRvcnMgPSBvcGVyYXRvcnMuZmlsdGVyKGZ1bmN0aW9uKG9wKSB7IHJldHVybiBvcFswXSAhPT0gJ1xcXFwnOyB9KS5qb2luKCd8Jyk7XG5cbiAgICBpZiAoYWxwaGFPcGVyYXRvcnMpIHtcbiAgICAgICAgYWxwaGFPcGVyYXRvcnMgPSAnXFxcXGIoJyArIGFscGhhT3BlcmF0b3JzICsgJylcXFxcYic7XG4gICAgfVxuICAgIC8qKiBAc3VtbWFyeSBSZWdleCB0byBtYXRjaCBhbnkgb3BlcmF0b3IuXG4gICAgICogQGRlc2MgTWF0Y2hlcyBzeW1ib2xpYyBvcGVyYXRvcnMgKG1hZGUgdXAgb2Ygbm9uLWFscGhhIGNoYXJhY3RlcnMpIG9yIGlkZW50aWZpZXIgb3BlcmF0b3JzICh3b3JkLWJvdW5kYXJ5LWlzb2xhdGVkIHJ1bnMgb2YgYWxwaGFudW1lcmljIGNoYXJhY3RlcnMpLlxuICAgICAqIEB0eXBlIHtSZWdFeHB9XG4gICAgICovXG4gICAgdGhpcy5SRUdFWF9PUEVSQVRPUiA9IG5ldyBSZWdFeHAoc3ltYm9saWNPcGVyYXRvcnMuY29uY2F0KGFscGhhT3BlcmF0b3JzKS5qb2luKCd8JyksICdpZycpO1xuXG4gICAgb3BlcmF0b3JzID0gb3BlcmF0b3JzLmpvaW4oJ3wnKSAvLyBwaXBlIHRoZW1cbiAgICAgICAgLnJlcGxhY2UoL1xccysvZywgJ1xcXFxzKycpOyAvLyBhcmJpdHJhcnkgc3RyaW5nIG9mIHdoaXRlc3BhY2UgY2hhcnMgLT4gd2hpdGVzcGFjZSByZWdleCBtYXRjaGVyXG5cbiAgICAvKiogQHN1bW1hcnkgUmVnZXggdG8gbWF0Y2ggYW4gb3BlcmF0b3IgKyBvcHRpb25hbCBvcGVyYXRvclxuICAgICAqIEBkZXNjIFRIZSBvcGVyYXRvciBpcyBvcHRpb25hbC4gVGhlIG9wZXJhbmQgbWF5IChvciBtYXkgbm90KSBiZSBlbmNsb3NlZCBpbiBwYXJlbnRoZXNlcy5cbiAgICAgKiBAZGVzYyBNYXRjaCBsaXN0OlxuICAgICAqIDAuIF9pbnB1dCBzdHJpbmdfXG4gICAgICogMS4gb3BlcmF0b3JcbiAgICAgKiAyLiBvdXRlciBvcGVyYW5kIChtYXkgaW5jbHVkZSBwYXJlbnRoZXNlcylcbiAgICAgKiAzLiBpbm5lciBvcGVyYW5kIHdpdGhvdXQgcGFyZW50aGVzZXMgKHdoZW4gYW4gb3BlcmFuZCB3YXMgZ2l2ZW4gd2l0aCBwYXJlbnRoZXNlcylcbiAgICAgKiA0LiBpbm5lciBvcGVyYW5kICh3aGVuIGFuIG9wZXJhbmQgd2FzIGdpdmVuIHdpdGhvdXQgcGFyZW50aGVzZXMpXG4gICAgICogQHR5cGUge1JlZ0V4cH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBtZW1iZXJPZiBQYXJzZXJDUUwucHJvdG90eXBlXG4gICAgICovXG4gICAgdGhpcy5SRUdFWF9FWFBSRVNTSU9OID0gbmV3IFJlZ0V4cCgnXlxcXFxzKignICsgb3BlcmF0b3JzICsgJyk/XFxcXHMqKFxcXFwoXFxcXHMqKC4rPylcXFxccypcXFxcKXwoLis/KSlcXFxccyokJywgJ2knKTtcblxuICAgIHRoaXMuUkVHRVhfTElURVJBTF9UT0tFTlMgPSBuZXcgUmVnRXhwKCdcXFxcJyArIFBhcnNlckNRTC5xdCArICcoXFxcXGQrKScgKyAnXFxcXCcgKyBQYXJzZXJDUUwucXQsICdnJyk7XG5cbn1cblxuLyoqIEBzdW1tYXJ5IE9wZXJhbmQgcXVvdGF0aW9uIG1hcmsgY2hhcmFjdGVyLlxuICogQGRlc2MgU2hvdWxkIGJlIGEgc2luZ2xlIGNoYXJhY3RlciAobGVuZ3RoID09PSAxKS5cbiAqIEBkZWZhdWx0ICdcIidcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cblBhcnNlckNRTC5xdCA9ICdcIic7XG5cblBhcnNlckNRTC5wcm90b3R5cGUgPSB7XG5cbiAgICBjb25zdHJ1Y3RvcjogUGFyc2VyQ1FMLnByb3RvdHlwZS5jb25zdHJ1Y3RvcixcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IEV4dHJhY3QgdGhlIGJvb2xlYW4gb3BlcmF0b3JzIGZyb20gYW4gZXhwcmVzc2lvbiBjaGFpbi5cbiAgICAgKiBAZGVzYyBSZXR1cm5zIGxpc3Qgb2YgaG9tb2dlbmVvdXMgb3BlcmF0b3JzIHRyYW5zZm9ybWVkIHRvIGxvd2VyIGNhc2UuXG4gICAgICpcbiAgICAgKiBUaHJvd3MgYW4gZXJyb3IgaWYgYWxsIHRoZSBib29sZWFuIG9wZXJhdG9ycyBpbiB0aGUgY2hhaW4gYXJlIG5vdCBpZGVudGljYWwuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNxbFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmdbXX1cbiAgICAgKi9cbiAgICBjYXB0dXJlQm9vbGVhbnM6IGZ1bmN0aW9uKGNxbCkge1xuICAgICAgICB2YXIgYm9vbGVhbnMgPSBjcWwubWF0Y2goUkVHRVhQX0JPT0xTKTtcblxuICAgICAgICBpZiAoYm9vbGVhbnMpIHtcbiAgICAgICAgICAgIHZhciBoZXRlcm9nZW5lb3VzT3BlcmF0b3IgPSBib29sZWFucy5maW5kKGZ1bmN0aW9uKG9wLCBpKSB7XG4gICAgICAgICAgICAgICAgYm9vbGVhbnNbaV0gPSBvcC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBib29sZWFuc1tpXSAhPT0gYm9vbGVhbnNbMF07XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKGhldGVyb2dlbmVvdXNPcGVyYXRvcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBQYXJzZXJDcWxFcnJvcignRXhwZWN0ZWQgaG9tb2dlbmVvdXMgYm9vbGVhbiBvcGVyYXRvcnMuIFlvdSBjYW5ub3QgbWl4IEFORCwgT1IsIGFuZCBOT1Igb3BlcmF0b3JzIGhlcmUgYmVjYXVzZSB0aGUgb3JkZXIgb2Ygb3BlcmF0aW9ucyBpcyBhbWJpZ3VvdXMuIEV2ZXJ5dGhpbmcgYWZ0ZXIgeW91ciAnICsgaGV0ZXJvZ2VuZW91c09wZXJhdG9yLnRvVXBwZXJDYXNlKCkgKyAnIHdhcyBpZ25vcmVkLiBUaXA6IFlvdSBjYW4gZ3JvdXAgb3BlcmF0aW9ucyB3aXRoIHN1YmV4cHJlc3Npb25zIGJ1dCBvbmx5IGluIHRoZSBRdWVyeUJ1aWxkZXIgb3IgYnkgdXNpbmcgcGFyZW50aGVzZXMgaW4gU1FMLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGJvb2xlYW5zO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBCcmVhayBhbiBleHByZXNzaW9uIGNoYWluIGludG8gYSBsaXN0IG9mIGV4cHJlc3Npb25zLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjcWxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBib29sZWFuc1xuICAgICAqIEByZXR1cm5zIHtzdHJpbmdbXX1cbiAgICAgKi9cbiAgICBjYXB0dXJlRXhwcmVzc2lvbnM6IGZ1bmN0aW9uKGNxbCwgYm9vbGVhbnMpIHtcbiAgICAgICAgdmFyIGV4cHJlc3Npb25zLCByZTtcblxuICAgICAgICBpZiAoYm9vbGVhbnMpIHtcbiAgICAgICAgICAgIHJlID0gbmV3IFJlZ0V4cChQUkVGSVggKyBib29sZWFucy5qb2luKElORklYKSArIFBPU1RGSVgsICdpJyk7XG4gICAgICAgICAgICBleHByZXNzaW9ucyA9IGNxbC5tYXRjaChyZSk7XG4gICAgICAgICAgICBleHByZXNzaW9ucy5zaGlmdCgpOyAvLyBkaXNjYXJkIFswXSAoaW5wdXQpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBleHByZXNzaW9ucyA9IFtjcWxdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGV4cHJlc3Npb25zO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBNYWtlIGEgbGlzdCBvZiBjaGlsZHJlbiBvdXQgb2YgYSBsaXN0IG9mIGV4cHJlc3Npb25zLlxuICAgICAqIEBkZXNjIFVzZXMgb25seSBfY29tcGxldGVfIGV4cHJlc3Npb25zIChhIHZhbHVlIE9SIGFuIG9wZXJhdG9yICsgYSB2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBJZ25vcmVzIF9pbmNvbXBsZXRlXyBleHByZXNzaW9ucyAoZW1wdHkgc3RyaW5nIE9SIGFuIG9wZXJhdG9yIC0gYSB2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sdW1uTmFtZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IGV4cHJlc3Npb25zXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gbGl0ZXJhbHMgLSBsaXN0IG9mIGxpdGVyYWxzIGluZGV4ZWQgYnkgdG9rZW5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtleHByZXNzaW9uU3RhdGVbXX0gd2hlcmUgYGV4cHJlc3Npb25TdGF0ZWAgaXMgb25lIG9mOlxuICAgICAqICogYHtjb2x1bW46IHN0cmluZywgb3BlcmF0b3I6IHN0cmluZywgb3BlcmFuZDogc3RyaW5nfWBcbiAgICAgKiAqIGB7Y29sdW1uOiBzdHJpbmcsIG9wZXJhdG9yOiBzdHJpbmcsIG9wZXJhbmQ6IHN0cmluZywgZWRpdG9yOiAnQ29sdW1ucyd9YFxuICAgICAqL1xuICAgIG1ha2VDaGlsZHJlbjogZnVuY3Rpb24oY29sdW1uTmFtZSwgZXhwcmVzc2lvbnMsIGxpdGVyYWxzKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGV4cHJlc3Npb25zLnJlZHVjZShmdW5jdGlvbihjaGlsZHJlbiwgZXhwKSB7XG4gICAgICAgICAgICBpZiAoZXhwKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcnRzID0gZXhwLm1hdGNoKHNlbGYuUkVHRVhfRVhQUkVTU0lPTik7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvcCA9IHBhcnRzWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0ZXJMaXRlcmFsID0gcGFydHNbMl0sXG4gICAgICAgICAgICAgICAgICAgICAgICBpbm5lckxpdGVyYWwgPSBwYXJ0cy5zbGljZSgzKS5maW5kKGZ1bmN0aW9uKHBhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFydCAhPT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgb3AgPSAob3AgfHwgJycpLnJlcGxhY2UoL1xccysvZywgJyAnKS50cmltKCkudG9VcHBlckNhc2UoKTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyZW50aGVzaXplZCA9IC9eXFwoLipcXCkkLy50ZXN0KG91dGVyTGl0ZXJhbCksXG4gICAgICAgICAgICAgICAgICAgICAgICBpbm5lck9wZXJhdG9ycyA9IGlubmVyTGl0ZXJhbC5tYXRjaChzZWxmLlJFR0VYX09QRVJBVE9SKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcmVudGhlc2l6ZWQgJiYgaW5uZXJPcGVyYXRvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcCA9PT0gJycgJiYgb3V0ZXJMaXRlcmFsID09PSBpbm5lck9wZXJhdG9yc1swXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBQYXJzZXJDcWxFcnJvcignRXhwZWN0ZWQgYW4gb3BlcmFuZC4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFBhcnNlckNxbEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdFeHBlY3RlZCBvcGVyYW5kIGJ1dCBmb3VuZCBhZGRpdGlvbmFsIG9wZXJhdG9yKHMpOiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbm5lck9wZXJhdG9yc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAudG9TdHJpbmcoKSAvLyBjb252ZXJ0IHRvIGNvbW1hLXNlcGFyYXRlZCBsaXN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50b1VwcGVyQ2FzZSgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8sL2csICcsICcpIC8vIGFkZCBzcGFjZXMgYWZ0ZXIgdGhlIGNvbW1hc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXihbXixdKyksIChbXixdKykkLywgJyQxIGFuZCAkMicpIC8vIHJlcGxhY2Ugb25seSBjb21tYSB3aXRoIFwiYW5kXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyguKywuKyksIChbXixdKykkLywgJyQxLCBhbmQgJDInKSAvLyBhZGQgXCJhbmRcIiBhZnRlciBsYXN0IG9mIHNldmVyYWwgY29tbWFzXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgb3AgPSBvcCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5zY2hlbWEgJiYgc2VsZi5zY2hlbWEubG9va3VwKGNvbHVtbk5hbWUpLmRlZmF1bHRPcCB8fCAvLyBjb2x1bW4ncyBkZWZhdWx0IG9wZXJhdG9yIGZyb20gc2NoZW1hXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmRlZmF1bHRPcDsgLy8gZ3JpZCdzIGRlZmF1bHQgb3BlcmF0b3JcblxuICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW46IGNvbHVtbk5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvcjogb3BcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgZmllbGROYW1lID0gc2VsZi5zY2hlbWEgJiYgc2VsZi5zY2hlbWEubG9va3VwKGlubmVyTGl0ZXJhbCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaWVsZE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkLm9wZXJhbmQgPSBmaWVsZE5hbWUubmFtZSB8fCBmaWVsZE5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZC5lZGl0b3IgPSAnQ29sdW1ucyc7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGaW5kIGFuZCBleHBhbmQgYWxsIGNvbGxhcHNlZCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkLm9wZXJhbmQgPSBpbm5lckxpdGVyYWwucmVwbGFjZShzZWxmLlJFR0VYX0xJVEVSQUxfVE9LRU5TLCBmdW5jdGlvbihtYXRjaCwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGl0ZXJhbHNbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGRyZW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIFtdKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgTWFrZSBhIFwibG9ja2VkXCIgc3ViZXhwcmVzc2lvbiBkZWZpbml0aW9uIG9iamVjdCBmcm9tIGFuIGV4cHJlc3Npb24gY2hhaW4uXG4gICAgICogQGRlc2MgX0xvY2tlZF8gbWVhbnMgaXQgaXMgbG9ja2VkIHRvIGEgc2luZ2xlIGZpZWxkLlxuICAgICAqXG4gICAgICogV2hlbiB0aGVyZSBpcyBvbmx5IGEgc2luZ2xlIGV4cHJlc3Npb24gaW4gdGhlIGNoYWluLCB0aGUgYG9wZXJhdG9yYCBpcyBvbWl0dGVkIChkZWZhdWx0cyB0byBgJ29wLWFuZCdgKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjcWwgLSBBIGNvbXBvdW5kIENRTCBleHByZXNzaW9uLCBjb25zaXN0aW5nIG9mIG9uZSBvciBtb3JlIHNpbXBsZSBleHByZXNzaW9ucyBhbGwgc2VwYXJhdGVkIGJ5IHRoZSBzYW1lIGxvZ2ljYWwgb3BlcmF0b3IpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbHVtbk5hbWVcblxuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR8e29wZXJhdG9yOiBzdHJpbmcsIGNoaWxkcmVuOiBzdHJpbmdbXSwgc2NoZW1hOiBzdHJpbmdbXX19XG4gICAgICogYHVuZGVmaW5lZGAgd2hlbiB0aGVyZSBhcmUgbm8gY29tcGxldGUgZXhwcmVzc2lvbnNcbiAgICAgKlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6Q1FMXG4gICAgICovXG4gICAgcGFyc2U6IGZ1bmN0aW9uKGNxbCwgY29sdW1uTmFtZSkge1xuICAgICAgICAvLyByZWR1Y2UgYWxsIHJ1bnMgb2Ygd2hpdGUgc3BhY2UgdG8gYSBzaW5nbGUgc3BhY2U7IHRoZW4gdHJpbVxuICAgICAgICBjcWwgPSBjcWwucmVwbGFjZSgvXFxzXFxzKy9nLCAnICcpLnRyaW0oKTtcblxuICAgICAgICB2YXIgbGl0ZXJhbHMgPSBbXTtcbiAgICAgICAgY3FsID0gdG9rZW5pemVMaXRlcmFscyhjcWwsIFBhcnNlckNRTC5xdCwgbGl0ZXJhbHMpO1xuXG4gICAgICAgIHZhciBib29sZWFucyA9IHRoaXMuY2FwdHVyZUJvb2xlYW5zKGNxbCksXG4gICAgICAgICAgICBleHByZXNzaW9ucyA9IHRoaXMuY2FwdHVyZUV4cHJlc3Npb25zKGNxbCwgYm9vbGVhbnMpLFxuICAgICAgICAgICAgY2hpbGRyZW4gPSB0aGlzLm1ha2VDaGlsZHJlbihjb2x1bW5OYW1lLCBleHByZXNzaW9ucywgbGl0ZXJhbHMpLFxuICAgICAgICAgICAgb3BlcmF0b3IgPSBib29sZWFucyAmJiBib29sZWFuc1swXSxcbiAgICAgICAgICAgIHN0YXRlO1xuXG4gICAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHN0YXRlID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdjb2x1bW5GaWx0ZXInLFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBjaGlsZHJlblxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKG9wZXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUub3BlcmF0b3IgPSAnb3AtJyArIG9wZXJhdG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbn07XG5cbmZ1bmN0aW9uIGRlc2NlbmRpbmdCeUxlbmd0aChhLCBiKSB7XG4gICAgcmV0dXJuIGIubGVuZ3RoIC0gYS5sZW5ndGg7XG59XG5cbi8qKlxuICogQHN1bW1hcnkgQ29sbGFwc2UgbGl0ZXJhbHMuXG4gKiBAZGVzYyBBbGxvd3MgcmVzZXJ2ZWQgd29yZHMgdG8gZXhpc3QgaW5zaWRlIGEgcXVvdGVkIHN0cmluZy5cbiAqIExpdGVyYWxzIGFyZSBjb2xsYXBzZWQgdG8gYSBxdW90ZWQgbnVtZXJpY2FsIGluZGV4IGludG8gdGhlIGBsaXRlcmFsc2AgYXJyYXkuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICogQHBhcmFtIHtzdHJpbmd9IHF0XG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBsaXRlcmFscyAtIEVtcHR5IGFycmF5IGluIHdoaWNoIHRvIHJldHVybiBleHRyYWN0ZWQgbGl0ZXJhbHMuXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiB0b2tlbml6ZUxpdGVyYWxzKHRleHQsIHF0LCBsaXRlcmFscykge1xuICAgIGxpdGVyYWxzLmxlbmd0aCA9IDA7XG5cbiAgICBmb3IgKFxuICAgICAgICB2YXIgaSA9IDAsIGogPSAwLCBrLCBpbm5lckxpdGVyYWw7XG4gICAgICAgIChqID0gdGV4dC5pbmRleE9mKHF0LCBqKSkgPj0gMDtcbiAgICAgICAgaiA9IGogKyAxICsgKGkgKyAnJykubGVuZ3RoICsgMSwgaSsrXG4gICAgKSB7XG4gICAgICAgIGsgPSBqO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBrID0gdGV4dC5pbmRleE9mKHF0LCBrICsgMSk7XG4gICAgICAgICAgICBpZiAoayA8IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VyQ3FsRXJyb3IoJ1F1b3RhdGlvbiBtYXJrcyBtdXN0IGJlIHBhaXJlZDsgbmVzdGVkIHF1b3RhdGlvbiBtYXJrcyBtdXN0IGJlIGRvdWJsZWQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKHRleHRbKytrXSA9PT0gcXQpO1xuXG4gICAgICAgIGlubmVyTGl0ZXJhbCA9IHRleHRcbiAgICAgICAgICAgIC5zbGljZSgrK2osIC0taykgLy8gZXh0cmFjdFxuICAgICAgICAgICAgLnJlcGxhY2UobmV3IFJlZ0V4cChxdCArIHF0LCAnZycpLCBxdCk7IC8vIHVuZXNjYXBlIGVzY2FwZWQgcXVvdGF0aW9uIG1hcmtzXG5cbiAgICAgICAgbGl0ZXJhbHMucHVzaChpbm5lckxpdGVyYWwpO1xuXG4gICAgICAgIHRleHQgPSB0ZXh0LnN1YnN0cigwLCBqKSArIGkgKyB0ZXh0LnN1YnN0cihrKTsgLy8gY29sbGFwc2VcbiAgICB9XG5cbiAgICByZXR1cm4gdGV4dDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQYXJzZXJDUUw7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBkZXByZWNhdGVkID0gcmVxdWlyZSgnLi9kZXByZWNhdGVkJyk7XG52YXIgQmFzZSA9IHJlcXVpcmUoJ2V4dGVuZC1tZScpLkJhc2U7XG5cbkJhc2UucHJvdG90eXBlLmRlcHJlY2F0ZWQgPSBkZXByZWNhdGVkO1xuQmFzZS5wcm90b3R5cGUuSHlwZXJncmlkRXJyb3IgPSBIeXBlcmdyaWRFcnJvcjtcblxuXG5mdW5jdGlvbiBIeXBlcmdyaWRFcnJvcihtZXNzYWdlKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbn1cbkh5cGVyZ3JpZEVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcbkh5cGVyZ3JpZEVycm9yLnByb3RvdHlwZS5uYW1lID0gJ0h5cGVyZ3JpZEVycm9yJztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEJhc2U7XG4iLCIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuLyoqXG4gKiBAbW9kdWxlIGxvY2FsaXphdGlvblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEJhc2UgPSByZXF1aXJlKCcuL0Jhc2UnKTtcbnZhciBkZXByZWNhdGVkID0gcmVxdWlyZSgnLi9kZXByZWNhdGVkJyk7XG5cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gZGVmYXVsdExvY2FsZVxuICogQHBhcmFtIHtzdHJpbmd9IFtsb2NhbGU9ZGVmYXVsdGxvY2FsZV1cbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgRm9ybWF0dGVyID0gQmFzZS5leHRlbmQoe1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKGRlZmF1bHRMb2NhbGUsIGxvY2FsZSwgb3B0aW9ucykge1xuICAgICAgICBpZiAodHlwZW9mIGxvY2FsZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBsb2NhbGU7XG4gICAgICAgICAgICBsb2NhbGUgPSBkZWZhdWx0TG9jYWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5sb2NhbGUgPSBsb2NhbGU7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5pbnZhbGlkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnZhbGlkID0gb3B0aW9ucy5pbnZhbGlkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5leHBlY3RhdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0YXRpb24gPSBvcHRpb25zLmV4cGVjdGF0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufSk7XG5cbi8qKlxuICogQHN1bW1hcnkgQ3JlYXRlIGEgbnVtYmVyIGxvY2FsaXplci5cbiAqIEBpbXBsZW1lbnRzIGxvY2FsaXplckludGVyZmFjZVxuICogQGRlc2MgQ3JlYXRlIGFuIG9iamVjdCBjb25mb3JtaW5nIHRvIHtAbGluayBsb2NhbGl6ZXJJbnRlcmZhY2V9IGZvciBudW1iZXJzLCB1c2luZyB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTnVtYmVyRm9ybWF0fEludGwuTnVtYmVyRm9ybWF0fS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkZWZhdWx0TG9jYWxlXG4gKiBAcGFyYW0ge3N0cmluZ30gW2xvY2FsZT1kZWZhdWx0TG9jYWxlXSAtIFBhc3NlZCB0byB0aGUge0BsaW5rIEludGwuTnVtYmVyRm9ybWF0fGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL051bWJlckZvcm1hdH0gY29uc3RydWN0b3IuXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIC0gUGFzc2VkIHRvIHRoZSBgSW50bC5OdW1iZXJGb3JtYXRgIGNvbnN0cnVjdG9yLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5hY2NlcHRTdGFuZGFyZERpZ2l0cz1mYWxzZV0gLSBBY2NlcHQgc3RhbmRhcmQgZGlnaXRzIGFuZCBkZWNpbWFsIHBvaW50IGludGVyY2hhbmdlYWJseSB3aXRoIGxvY2FsaXplZCBkaWdpdHMgYW5kIGRlY2ltYWwgcG9pbnQuIChUaGlzIG9wdGlvbiBpcyBpbnRlcnByZXRlZCBoZXJlOyBpdCBpcyBub3QgdXNlZCBieSBgSW50bC5OdW1iZXJGb3JtYXRgLilcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgRm9ybWF0dGVyXG4gKiBAdHV0b3JpYWwgbG9jYWxpemF0aW9uXG4gKi9cbnZhciBOdW1iZXJGb3JtYXR0ZXIgPSBGb3JtYXR0ZXIuZXh0ZW5kKCdOdW1iZXJGb3JtYXR0ZXInLCB7XG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oZGVmYXVsdExvY2FsZSwgbG9jYWxlLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbG9jYWxlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgb3B0aW9ucyA9IGxvY2FsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIHRoaXMuZm9ybWF0ID0gbmV3IEludGwuTnVtYmVyRm9ybWF0KHRoaXMubG9jYWxlLCBvcHRpb25zKS5mb3JtYXQ7XG5cbiAgICAgICAgdmFyIG1hcHBlck9wdGlvbnMgPSB7IHVzZUdyb3VwaW5nOiBmYWxzZSB9LFxuICAgICAgICAgICAgbWFwcGVyID0gbmV3IEludGwuTnVtYmVyRm9ybWF0KHRoaXMubG9jYWxlLCBtYXBwZXJPcHRpb25zKS5mb3JtYXQ7XG5cbiAgICAgICAgdGhpcy5kZW1hcHBlciA9IGRlbWFwLmJpbmQodGhpcyk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBzdW1tYXJ5IEEgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIHZhbGlkIGNoYXJhY3RlcnMuXG4gICAgICAgICAqIEBkZXNjIENvbnRhaW5zIGFsbCBsb2NhbGl6ZWQgZGlnaXRzICsgbG9jYWxpemVkIGRlY2ltYWwgcG9pbnQuXG4gICAgICAgICAqIElmIHdlJ3JlIGFjY2VwdGluZyBzdGFuZGFyZCBkaWdpdHMsIHdpbGwgYWxzbyBjb250YWluIGFsbCB0aGUgc3RhbmRhcmQgZGlnaXRzICsgc3RhbmRhcmQgZGVjaW1hbCBwb2ludCAoaWYgZGlmZmVyZW50IHRoYW4gbG9jYWxpemVkIHZlcnNpb25zKS5cbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQGRlc2MgTG9jYWxpemVkIGRpZ2l0cyBhbmQgZGVjaW1hbCBwb2ludC4gV2lsbCBhbHNvIGluY2x1ZGUgc3RhbmRhcmRpemVkIGRpZ2l0cyBhbmQgZGVjaW1hbCBwb2ludCBpZiBgb3B0aW9ucy5hY2NlcHRTdGFuZGFyZERpZ2l0c2AgaXMgdHJ1dGh5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgaW50ZXJuYWwgdXNlIGJ5IHRoZSB7QGxpbmsgTnVtYmVyRm9ybWF0dGVyI3N0YW5kYXJkaXplfHN0YW5kYXJkaXplfSBtZXRob2QuXG4gICAgICAgICAqIEBtZW1iZXJPZiBOdW1iZXJGb3JtYXR0ZXIucHJvdG90eXBlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1hcCA9IG1hcHBlcigxMDEyMzQ1Njc4OS41KS5zdWJzdHIoMSwgMTEpOyAvLyBsb2NhbGl6ZWQgJzAxMjM0NTY3ODkuJ1xuXG4gICAgICAgIGlmIChvcHRpb25zLmFjY2VwdFN0YW5kYXJkRGlnaXRzICYmIHRoaXMubWFwICE9PSAnMDEyMzQ1Njc4OS4nKSB7XG4gICAgICAgICAgICB0aGlzLm1hcCArPSAnMDEyMzQ1Njc4OS4nOyAgLy8gc3RhbmRhcmQgJzAxMjM0NTY3ODkuJ1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqIEBzdW1tYXJ5IEEgcmVnZXggdGhhdCB0ZXN0cyBgdHJ1ZWAgb24gZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIuXG4gICAgICAgICAqIEB0eXBlIHtSZWdFeHB9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBkZXNjIFZhbGlkIGNoYXJhY3RlcnMgaW5jbHVkZTpcbiAgICAgICAgICpcbiAgICAgICAgICogKiBMb2NhbGl6ZWQgZGlnaXRzXG4gICAgICAgICAqICogTG9jYWxpemVkIGRlY2ltYWwgcG9pbnRcbiAgICAgICAgICogKiBTdGFuZGFyZCBkaWdpdHMgKHdoZW4gYG9wdGlvbnMuYWNjZXB0U3RhbmRhcmREaWdpdHNgIGlzIHRydXRoeSlcbiAgICAgICAgICogKiBTdGFuZGFyZCBkZWNpbWFsIHBvaW50ICh3aGVuIGBvcHRpb25zLmFjY2VwdFN0YW5kYXJkRGlnaXRzYCBpcyB0cnV0aHkpXG4gICAgICAgICAqICogQ29zbWV0aWMgY2hhcmFjdGVycyBhZGRlZCBieSBmb3JtYXR0ZXIgYXMgcGVyIGBvcHRpb25zYCAoZm9yIGh1bWFuLWZyaWVuZGx5IHJlYWRhYmlsaXR5KS5cbiAgICAgICAgICpcbiAgICAgICAgICogQW55IGNoYXJhY3RlcnMgb3V0c2lkZSB0aGlzIHNldCBhcmUgY29uc2lkZXJlZCBpbnZhbGlkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZXQgYnkgdGhlIGNvbnN0cnVjdG9yOyBjb25zdW1lZCBieSB0aGUge0BsaW5rIG1vZHVsZTpsb2NhbGl6YXRpb25+TnVtYmVyRm9ybWF0dGVyI2ludmFsaWR8aW52YWxpZH0gbWV0aG9kLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUZXN0aW5nIGEgc3RyaW5nIGFnYWluc3QgdGhpcyBwYXR0ZXJuIHlpZWxkcyBgdHJ1ZWAgaWYgYXQgbGVhc3Qgb25lIGludmFsaWQgY2hhcmFjdGVyIG9yIGBmYWxzZWAgaWYgYWxsIGNoYXJhY3RlcnMgYXJlIHZhbGlkLlxuICAgICAgICAgKiBAbWVtYmVyT2YgTnVtYmVyRm9ybWF0dGVyLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pbnZhbGlkcyA9IG5ldyBSZWdFeHAoXG4gICAgICAgICAgICAnW14nICtcbiAgICAgICAgICAgIHRoaXMuZm9ybWF0KDExMTExKS5yZXBsYWNlKHRoaXMubWFwWzFdLCAnJykgKyAvLyB0aG91c2FuZHMgc2VwYXJhdG9yIGlmIGluIHVzZVxuICAgICAgICAgICAgdGhpcy5tYXAgKyAvLyBkaWdpdHMgKyBkZWNpbWFsIHBvaW50XG4gICAgICAgICAgICAnXSdcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqIEBzdW1tYXJ5IFRlc3RzIGZvciBpbnZhbGlkIGNoYXJhY3RlcnMuXG4gICAgICogQGRlc2MgVGVzdHMgYSBsb2NhbGl6ZWQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgbnVtYmVyIHRoYXQgaXQgY29udGFpbnMgYW55IGludmFsaWQgY2hhcmFjdGVycy5cbiAgICAgKlxuICAgICAqIFRoZSBudW1iZXIgbWF5IGJlIHVuZm9ybWF0dGVkIG9yIGl0IG1heSBiZSBmb3JtYXR0ZWQgd2l0aCBhbnkgb2YgdGhlIHBlcm1pdHRlZCBmb3JtYXR0aW5nIGNoYXJhY3RlcnMsIGFzIGltcGxpZWQgYnkgdGhlIGNvbnN0cnVjdG9yJ3MgYG9wdGlvbnNgIChwYXNzZWQgdG8gYEludGwuTnVtYmVyRm9ybWF0YCkuIEFueSBvdGhlciBjaGFyYWN0ZXJzIGFyZSBjb25zaWRlcmVkIGludmFsaWQuXG4gICAgICpcbiAgICAgKiBIb3dldmVyLCBzdGFuZGFyZCBkaWdpdHMgYW5kIHRoZSBzdGFuZGFyZCBkZWNpbWFsIHBvaW50IGFyZSBjb25zaWRlcmVkIHZhbGlkIGlmIHRoZSB2YWx1ZSBvZiBgb3B0aW9ucy5hY2NlcHRTdGFuZGFyZERpZ2l0c2AgYXMgcHJvdmlkZWQgdG8gdGhlIGNvbnN0cnVjdG9yIHdhcyB0cnV0aHkuIChPZiBjb3Vyc2UsIHRoZXNlIGFyZSBhbHdheXMgdmFsaWQgZm9yIGxvY2FsZXMgdGhhdCB1c2UgdGhlbS4pXG4gICAgICpcbiAgICAgKiBVc2UgdGhpcyBtZXRob2QgdG86XG4gICAgICogMS4gRmlsdGVyIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgb24gYSBgb25rZXlkb3duYCBldmVudDsgb3JcbiAgICAgKiAyLiBUZXN0IGFuIGVkaXRlZCBzdHJpbmcgcHJpb3IgdG8gY2FsbGluZyB0aGUge0BsaW5rIG1vZHVsZTpsb2NhbGl6YXRpb25+TnVtYmVyRm9ybWF0dGVyI3N0YW5kYXJkaXplfHN0YW5kYXJkaXplfS5cbiAgICAgKlxuICAgICAqIE5PVEU6IFRoaXMgbWV0aG9kIGRvZXMgbm90IGNoZWNrIGdyYW1tYXRpY2FsIHN5bnRheDsgaXQgb25seSBjaGVja3MgZm9yIGludmFsaWQgY2hhcmFjdGVycy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBudW1iZXJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbnxzdHJpbmd9IEZhbHN5IG1lYW5zIHZhbGlkIHdoaWNoIGluIHRoaXMgY2FzZSBtZWFucyBjb250YWlucyBvbmx5IHZhbGlkIGNoYXJhY3RlcnMuXG4gICAgICogQG1lbWJlck9mIE51bWJlckZvcm1hdHRlci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBpbnZhbGlkOiBmdW5jdGlvbihudW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW52YWxpZHMudGVzdChudW1iZXIpO1xuICAgIH0sXG5cbiAgICBleHBlY3RhdGlvbjpcbiAgICAgICAgJ0V4cGVjdGVkIGEgbnVtYmVyIHdpdGggb3B0aW9uYWwgY29tbWFzICh0aG91c2FuZHMgZ3JvdXBpbmcgc2VwYXJhdG9yKSwgb3B0aW9uYWwgZGVjaW1hbCBwb2ludCwgYW5kIGFuIG9wdGlvbmFsIGZyYWN0aW9uYWwgcGFydC5cXG4nICtcbiAgICAgICAgJ0NvbW1hIHNlcGFyYXRvcnMgYXJlIHBhcnQgb2YgdGhlIGZvcm1hdCBhbmQgd2lsbCBhbHdheXMgYmUgZGlzcGxheWVkIGZvciB2YWx1ZXMgPj0gMTAwMC5cXG4nICtcbiAgICAgICAgJ0VkaXRlZCB2YWx1ZXMgYXJlIGFsd2F5cyBzYXZlZCBpbiB0aGVpciBlbnRpcmV0eSBldmVuIHRob3VnaCB0aGUgZm9ybWF0dGVkIHZhbHVlIGlzIHJvdW5kZWQgdG8gdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMuJyxcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHdpbGw6XG4gICAgICogKiBDb252ZXJ0IGxvY2FsaXplZCBkaWdpdHMgYW5kIGRlY2ltYWwgcG9pbnQgY2hhcmFjdGVycyB0byBzdGFuZGFyZCBkaWdpdHMgYW5kIGRlY2ltYWwgcG9pbnQgY2hhcmFjdGVycy5cbiAgICAgKiAqIFwiQ2xlYW5cIiB0aGUgc3RyaW5nIGJ5IGlnbm9yaW5nIGFsbCBvdGhlciBjaGFyYWN0ZXJzLlxuICAgICAqICogQ29lcmNlIHRoZSBzdHJpbmcgdG8gYSBudW1iZXIgcHJpbWl0aXZlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmb3JtYXR0ZWRMb2NhbGl6ZWROdW1iZXIgLSBNYXkgb3IgbWF5IG5vdCBiZSBmb3JtYXR0ZWQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gTnVtYmVyIHByaW1pdGl2ZS5cbiAgICAgKiBAdGhyb3dzIHtzdHJpbmd9IEludmFsaWQgbnVtYmVyLlxuICAgICAqIEBtZW1iZXJPZiBOdW1iZXJGb3JtYXR0ZXIucHJvdG90eXBlXG4gICAgICovXG4gICAgcGFyc2U6IGZ1bmN0aW9uKGZvcm1hdHRlZExvY2FsaXplZE51bWJlcikge1xuICAgICAgICB2YXIgbnVtYmVyID0gTnVtYmVyKFxuICAgICAgICAgICAgZm9ybWF0dGVkTG9jYWxpemVkTnVtYmVyLnNwbGl0KCcnKS5tYXAodGhpcy5kZW1hcHBlcikuam9pbignJylcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAoaXNOYU4obnVtYmVyKSkge1xuICAgICAgICAgICAgdGhyb3cgJ0ludmFsaWQgTnVtYmVyJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudW1iZXI7XG4gICAgfVxufSk7XG5cbmZ1bmN0aW9uIGRlbWFwKGMpIHtcbiAgICB2YXIgZCA9IHRoaXMubWFwLmluZGV4T2YoYykgJSAxMTtcbiAgICByZXR1cm4gZCA8IDAgPyAnJyA6IGQgPCAxMCA/IGQgOiAnLic7XG59XG5cbi8qKlxuICogQGltcGxlbWVudHMgbG9jYWxpemVySW50ZXJmYWNlXG4gKiBAcGFyYW0ge3N0cmluZ30gZGVmYXVsdExvY2FsZVxuICogQHBhcmFtIHtzdHJpbmd9IFtsb2NhbGU9ZGVmYXVsdGxvY2FsZV0gLSBQYXNzZWQgdG8gdGhlIHtAbGluayBJbnRsLkRhdGVGb3JtYXR8aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRGF0ZUZvcm1hdH0gY29uc3RydWN0b3IuXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIC0gUGFzc2VkIHRvIHRoZSBgSW50bC5EYXRlRm9ybWF0YCBjb25zdHJ1Y3Rvci5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgRm9ybWF0dGVyXG4gKi9cbnZhciBEYXRlRm9ybWF0dGVyID0gRm9ybWF0dGVyLmV4dGVuZCgnRGF0ZUZvcm1hdHRlcicsIHtcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihkZWZhdWx0TG9jYWxlLCBsb2NhbGUsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBsb2NhbGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gbG9jYWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgLyoqIEBzdW1tYXJ5IFRyYW5zZm9ybSBhIGRhdGUgb2JqZWN0IGludG8gaHVtYW4tZnJpZW5kbHkgc3RyaW5nIHJlcHJlc2VudGF0aW9uLlxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZvcm1hdCA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KHRoaXMubG9jYWxlLCBvcHRpb25zKS5mb3JtYXQ7XG5cbiAgICAgICAgLy8gR2V0IGRpZ2l0cyBiZWNhdXNlIG1heSBiZSBjaGluZXNlIG9yIFwicmVhbCBBcmFiaWNcIiBudW1lcmFscy5cbiAgICAgICAgdmFyIHRlc3RPcHRpb25zID0geyB1c2VHcm91cGluZzogZmFsc2UsIHN0eWxlOiAnZGVjaW1hbCcgfSxcbiAgICAgICAgICAgIGxvY2FsaXplTnVtYmVyID0gbmV3IEludGwuTnVtYmVyRm9ybWF0KHRoaXMubG9jYWxlLCB0ZXN0T3B0aW9ucykuZm9ybWF0LFxuICAgICAgICAgICAgbG9jYWxpemVkRGlnaXRzID0gdGhpcy5sb2NhbGl6ZWREaWdpdHMgPSBsb2NhbGl6ZU51bWJlcigxMDEyMzQ1Njc4OSkuc3Vic3RyKDEsIDEwKTsgLy8gYWxsIGxvY2FsaXplZCBkaWdpdHMgaW4gbnVtZXJpY2FsIG9yZGVyXG5cbiAgICAgICAgdGhpcy5kaWdpdEZvcm1hdHRlciA9IGZvcm1hdERpZ2l0LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZGlnaXRQYXJzZXIgPSBwYXJzZURpZ2l0LmJpbmQodGhpcyk7XG5cbiAgICAgICAgLy8gTG9jYWxpemUgYSB0ZXN0IGRhdGUgd2l0aCB0aGUgZGVmYXVsdCBudW1lcmljIHBhcnRzIHRvIGZpbmQgb3V0IHRoZSByZXN1bHRpbmcgb3JkZXIgb2YgdGhlc2UgcGFydHMuXG4gICAgICAgIHZhciB5eSA9IDE5ODcsXG4gICAgICAgICAgICBtbSA9IDEyLFxuICAgICAgICAgICAgZGQgPSAzMCxcbiAgICAgICAgICAgIFlZID0gdGhpcy50cmFuc2Zvcm1OdW1iZXIodGhpcy5kaWdpdEZvcm1hdHRlciwgeXkpLFxuICAgICAgICAgICAgTU0gPSB0aGlzLnRyYW5zZm9ybU51bWJlcih0aGlzLmRpZ2l0Rm9ybWF0dGVyLCBtbSksXG4gICAgICAgICAgICBERCA9IHRoaXMudHJhbnNmb3JtTnVtYmVyKHRoaXMuZGlnaXRGb3JtYXR0ZXIsIGRkKSxcbiAgICAgICAgICAgIHRlc3REYXRlID0gbmV3IERhdGUoeXksIG1tIC0gMSwgZGQpLFxuICAgICAgICAgICAgbG9jYWxpemVEYXRlID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQodGhpcy5sb2NhbGUpLmZvcm1hdCxcbiAgICAgICAgICAgIGxvY2FsaXplZERhdGUgPSBsb2NhbGl6ZURhdGUodGVzdERhdGUpLCAvLyBhbGwgbG9jYWxpemVkIGRpZ2l0cyArIGxvY2FsaXplZCBwdW5jdHVhdGlvblxuICAgICAgICAgICAgbWlzc2luZ0RpZ2l0cyA9IG5ldyBJbnRsLk51bWJlckZvcm1hdCh0aGlzLmxvY2FsZSkuZm9ybWF0KDQ1NiksXG4gICAgICAgICAgICBsb2NhbGl6ZWROdW1iZXJQYXR0ZXJuID0gdGhpcy5sb2NhbGl6ZWROdW1iZXJQYXR0ZXJuID0gbmV3IFJlZ0V4cCgnWycgKyBsb2NhbGl6ZWREaWdpdHMgKyAnXSsnLCAnZycpLFxuICAgICAgICAgICAgcGFydHMgPSBsb2NhbGl6ZWREYXRlLm1hdGNoKGxvY2FsaXplZE51bWJlclBhdHRlcm4pO1xuXG4gICAgICAgIHRoaXMucGFydHNNYXAgPSB7XG4gICAgICAgICAgICB5eTogcGFydHMuaW5kZXhPZihZWSksXG4gICAgICAgICAgICBtbTogcGFydHMuaW5kZXhPZihNTSksXG4gICAgICAgICAgICBkZDogcGFydHMuaW5kZXhPZihERClcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAob3B0aW9ucy5hY2NlcHRTdGFuZGFyZERpZ2l0cykge1xuICAgICAgICAgICAgbWlzc2luZ0RpZ2l0cyArPSAnMTIzNDU2Nzg5MCc7XG4gICAgICAgIH1cblxuICAgICAgICAvKiogQHN1bW1hcnkgQSByZWdleCB0aGF0IHRlc3RzIGB0cnVlYCBvbiBmaXJzdCBpbnZhbGlkIGNoYXJhY3Rlci5cbiAgICAgICAgICogQHR5cGUge1JlZ0V4cH1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQGRlc2MgVmFsaWQgY2hhcmFjdGVycyBpbmNsdWRlOlxuICAgICAgICAgKlxuICAgICAgICAgKiAqIExvY2FsaXplZCBkaWdpdHNcbiAgICAgICAgICogKiBTdGFuZGFyZCBkaWdpdHMgKHdoZW4gYG9wdGlvbnMuYWNjZXB0U3RhbmRhcmREaWdpdHNgIGlzIHRydXRoeSlcbiAgICAgICAgICogKiBMb2NhbGl6ZWQgcHVuY3R1YXRpb24gdG8gZGVsaW1pdCBkYXRlIHBhcnRzXG4gICAgICAgICAqXG4gICAgICAgICAqIEFueSBjaGFyYWN0ZXJzIG91dHNpZGUgdGhpcyBzZXQgYXJlIGNvbnNpZGVyZWQgaW52YWxpZC4gTm90ZSB0aGF0IHRoaXMgb25seSBjdXJyZW50bHkgaW1wbGVtZW50ZWQgd2hlbiBhbGwgdGhyZWUgZGF0ZSBwYXJ0cyBhcmUgbnVtZXJpY1xuICAgICAgICAgKlxuICAgICAgICAgKiBTZXQgYnkgdGhlIGNvbnN0cnVjdG9yOyBjb25zdW1lZCBieSB0aGUge0BsaW5rIE51bWJlckZvcm1hdHRlciN2YWxpZHx2YWxpZH0gbWV0aG9kLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUZXN0aW5nIGEgc3RyaW5nIGFnYWluc3QgdGhpcyBwYXR0ZXJuIHlpZWxkcyBgdHJ1ZWAgaWYgYXQgbGVhc3Qgb25lIGludmFsaWQgY2hhcmFjdGVyIG9yIGBmYWxzZWAgaWYgYWxsIGNoYXJhY3RlcnMgYXJlIHZhbGlkLlxuICAgICAgICAgKiBAbWVtYmVyT2YgRGF0ZUZvcm1hdHRlci5wcm90b3R5cGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaW52YWxpZHMgPSBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgJ1teJyArXG4gICAgICAgICAgICBsb2NhbGl6ZWREYXRlICtcbiAgICAgICAgICAgIG1pc3NpbmdEaWdpdHMgK1xuICAgICAgICAgICAgJ10nXG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIC8qKiBAc3VtbWFyeSBUZXN0cyBmb3IgaW52YWxpZCBjaGFyYWN0ZXJzLlxuICAgICAqIEBkZXNjIFRlc3RzIGEgbG9jYWxpemVkIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIG51bWJlciB0aGF0IGl0IGNvbnRhaW5zIGFueSBpbnZhbGlkIGNoYXJhY3RlcnMuXG4gICAgICpcbiAgICAgKiBUaGUgZGF0ZSBpcyBhc3N1bWVkIHRvIGNvbnRhaW4gbG9jYWxpemVkIGRpZ2l0cyBhbmQgcHVuY3R1YXRpb24gYXMgd291bGQgYmUgcmV0dXJuZWQgYnkgYEludGwuRGF0ZUZvcm1hdGAgd2l0aCB0aGUgZ2l2ZW4gYGxvY2FsZWAgYW5kIGBvcHRpb25zYC4gQW55IG90aGVyIGNoYXJhY3RlcnMgYXJlIGNvbnNpZGVyZWQgaW52YWxpZC5cbiAgICAgKlxuICAgICAqIEhvd2V2ZXIsIHN0YW5kYXJkIGRpZ2l0cyBhbmQgdGhlIHN0YW5kYXJkIGRlY2ltYWwgcG9pbnQgYXJlIGFsc28gY29uc2lkZXJlZCB2YWxpZCBpZiB0aGUgdmFsdWUgb2YgYG9wdGlvbnMuYWNjZXB0U3RhbmRhcmREaWdpdHNgIGFzIHByb3ZpZGVkIHRvIHRoZSBjb25zdHJ1Y3RvciB3YXMgdHJ1dGh5LiAoT2YgY291cnNlLCB0aGVzZSBhcmUgYWx3YXlzIHZhbGlkIGZvciBsb2NhbGVzIHRoYXQgdXNlIHRoZW0uKVxuICAgICAqXG4gICAgICogVXNlIHRoaXMgbWV0aG9kIHRvOlxuICAgICAqIDEuIEZpbHRlciBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIG9uIGEgYG9ua2V5ZG93bmAgZXZlbnQ7IG9yXG4gICAgICogMi4gVGVzdCBhbiBlZGl0ZWQgc3RyaW5nIHByaW9yIHRvIGNhbGxpbmcgdGhlIHtAbGluayBtb2R1bGU6bG9jYWxpemF0aW9ufkRhdGVGb3JtYXR0ZXIjc3RhbmRhcmRpemV8c3RhbmRhcmRpemV9LlxuICAgICAqXG4gICAgICogTk9URTogVGhlIGN1cnJlbnQgaW1wbGVtZW50YXRpb24gb25seSBzdXBwb3J0cyBkYXRlIGZvcm1hdHMgdXNpbmcgYWxsIG51bWVyaWNzICh3aGljaCBpcyB0aGUgZGVmYXVsdCBmb3IgYEludGwuRGF0ZUZvcm1hdGApLlxuICAgICAqXG4gICAgICogTk9URTogVGhpcyBtZXRob2QgZG9lcyBub3QgY2hlY2sgZ3JhbW1hdGljYWwgc3ludGF4OyBpdCBvbmx5IGNoZWNrcyBmb3IgaW52YWxpZCBjaGFyYWN0ZXJzLlxuICAgICAqXG4gICAgICogQHBhcmFtIG51bWJlclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBDb250YWlucyBvbmx5IHZhbGlkIGNoYXJhY3RlcnMuXG4gICAgICogQG1lbWJlck9mIERhdGVGb3JtYXR0ZXIucHJvdG90eXBlXG4gICAgICovXG4gICAgaW52YWxpZDogZnVuY3Rpb24obnVtYmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludmFsaWRzLnRlc3QobnVtYmVyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2Qgd2lsbDpcbiAgICAgKiAqIENvbnZlcnQgbG9jYWxpemVkIGRhdGUgdG8gRGF0ZSBvYmplY3QuXG4gICAgICogKiBcIkNsZWFuXCIgdGhlIHN0cmluZyBieSBpZ25vcmluZyBhbGwgb3RoZXIgY2hhcmFjdGVycy5cbiAgICAgKiAqIENvZXJjZSB0aGUgc3RyaW5nIHRvIGEgbnVtYmVyIHByaW1pdGl2ZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbG9jYWxpemVkRGF0ZVxuICAgICAqIEByZXR1cm5zIHtEYXRlfVxuICAgICAqIEB0aHJvd3Mge3N0cmluZ30gSW52YWxpZCBkYXRlLlxuICAgICAqIEBtZW1iZXJPZiBEYXRlRm9ybWF0dGVyLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHBhcnNlOiBmdW5jdGlvbihsb2NhbGl6ZWREYXRlKSB7XG4gICAgICAgIHZhciBkYXRlLFxuICAgICAgICAgICAgcGFydHMgPSBsb2NhbGl6ZWREYXRlLm1hdGNoKHRoaXMubG9jYWxpemVkTnVtYmVyUGF0dGVybik7XG5cbiAgICAgICAgaWYgKHBhcnRzICYmIHBhcnRzLmxlbmd0aCA9PT0gMykge1xuICAgICAgICAgICAgdmFyIHkgPSB0aGlzLnRyYW5zZm9ybU51bWJlcih0aGlzLmRpZ2l0UGFyc2VyLCBwYXJ0c1t0aGlzLnBhcnRzTWFwLnl5XSksXG4gICAgICAgICAgICAgICAgbSA9IHRoaXMudHJhbnNmb3JtTnVtYmVyKHRoaXMuZGlnaXRQYXJzZXIsIHBhcnRzW3RoaXMucGFydHNNYXAubW1dKSAtIDEsXG4gICAgICAgICAgICAgICAgZCA9IHRoaXMudHJhbnNmb3JtTnVtYmVyKHRoaXMuZGlnaXRQYXJzZXIsIHBhcnRzW3RoaXMucGFydHNNYXAuZGRdKTtcblxuICAgICAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKHksIG0sIGQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgJ0ludmFsaWQgRGF0ZSc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtIGEgbnVtYmVyIHRvIG9yIGZyb20gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gd2l0aCBsb2NhbGl6ZWQgZGlnaXRzLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGRpZ2l0VHJhbnNmb3JtZXIgLSBBIGZ1bmN0aW9uIGJvdW5kIHRvIGB0aGlzYC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBtZW1iZXJPZiBEYXRlRm9ybWF0dGVyLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHRyYW5zZm9ybU51bWJlcjogZnVuY3Rpb24oZGlnaXRUcmFuc2Zvcm1lciwgbnVtYmVyKSB7XG4gICAgICAgIHJldHVybiBudW1iZXIudG9TdHJpbmcoKS5zcGxpdCgnJykubWFwKGRpZ2l0VHJhbnNmb3JtZXIpLmpvaW4oJycpO1xuICAgIH1cbn0pO1xuXG5mdW5jdGlvbiBmb3JtYXREaWdpdChkKSB7XG4gICAgcmV0dXJuIHRoaXMubG9jYWxpemVkRGlnaXRzW2RdO1xufVxuXG5mdW5jdGlvbiBwYXJzZURpZ2l0KGMpIHtcbiAgICB2YXIgZCA9IHRoaXMubG9jYWxpemVkRGlnaXRzLmluZGV4T2YoYyk7XG4gICAgaWYgKGQgPCAwKSB7IGQgPSAnJzsgfVxuICAgIHJldHVybiBkO1xufVxuXG4vKipcbiAqIEFsbCBtZW1iZXJzIGFyZSBsb2NhbGl6ZXJzIChjb25mb3JtIHRvIHtAbGluayBsb2NhbGl6ZXJJbnRlcmZhY2V9KSB3aXRoIGV4Y2VwdGlvbiBvZiBgZ2V0YCwgYHNldGAsIGFuZCBsb2NhbGl6ZXIgY29uc3RydWN0b3JzIHdoaWNoIGFyZSBuYW1lZCAoYnkgY29udmVudGlvbikgZW5kaW5nIGluIFwiRm9ybW1hdHRlclwiLlxuICpcbiAqIFRoZSBhcHBsaWNhdGlvbiBkZXZlbG9wZXIgaXMgZnJlZSB0byBhZGQgbG9jYWxpemVycyBhbmQgbG9jYWxpemVyIGZhY3RvcnkgbWV0aG9kcy4gU2VlIHRoZSB7QGxpbmsgTG9jYWxpemF0aW9uI2NvbnN0cnVjdHxjb25zdHJ1Y3R9IGNvbnZlbmllbmNlIG1ldGhvZCB3aGljaCBtYXkgYmUgaGVscGZ1bCBpbiB0aGlzIHJlZ2FyZC5cbiAqIEBwYXJhbSBsb2NhbGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBbbnVtYmVyT3B0aW9uc11cbiAqIEBwYXJhbSB7b2JqZWN0fSBbZGF0ZU9wdGlvbnNdXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gTG9jYWxpemF0aW9uKGxvY2FsZSwgbnVtYmVyT3B0aW9ucywgZGF0ZU9wdGlvbnMpIHtcbiAgICB0aGlzLmxvY2FsZSA9IGxvY2FsZTtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIG51bWJlclxuICAgICAqIEBzZWUgVGhlIHtAbGluayBOdW1iZXJGb3JtYXR0ZXJ8TnVtYmVyRm9ybWF0dGVyfSBjbGFzc1xuICAgICAqIEBtZW1iZXJPZiBMb2NhbGl6YXRpb24ucHJvdG90eXBlXG4gICAgICovXG4gICAgdGhpcy5pbnQgPSB0aGlzLmZsb2F0ID0gdGhpcy5jb25zdHJ1Y3QoJ251bWJlcicsIE51bWJlckZvcm1hdHRlciwgbnVtYmVyT3B0aW9ucyk7XG5cbiAgICAvKipcbiAgICAgKiBAc2VlIFRoZSB7QGxpbmsgRGF0ZUZvcm1hdHRlcnxEYXRlRm9ybWF0dGVyfSBjbGFzc1xuICAgICAqIEBtZW1iZXJPZiBMb2NhbGl6YXRpb24ucHJvdG90eXBlXG4gICAgICovXG4gICAgdGhpcy5jb25zdHJ1Y3QoJ2RhdGUnLCBEYXRlRm9ybWF0dGVyLCBkYXRlT3B0aW9ucyk7XG59XG5cbkxvY2FsaXphdGlvbi5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IExvY2FsaXphdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IsXG5cbiAgICAvKiogQHN1bW1hcnkgQ3JlYXRlcyBhIGxvY2FsaXplciBmcm9tIGEgbG9jYWxpemVyIGZhY3Rvcnkgb2JqZWN0IHVzaW5nIHRoZSBkZWZhdWx0IGxvY2FsZS5cbiAgICAgKiBAZGVzYyBQZXJmb3JtcyB0aGUgZm9sbG93aW5nIGFjdGlvbnM6XG4gICAgICogMS4gQmluZHMgYENvbnN0cnVjdG9yYCB0byBgbG9jYWxlYC5cbiAgICAgKiAyLiBBZGRzIHRoZSBuZXdseSBib3VuZCBjb25zdHJ1Y3RvciB0byB0aGlzIG9iamVjdCAoZm9yIGZ1dHVyZSByZWZlcmVuY2UpIHdpdGggdGhlIGtleSBcIk5hbWVGb3JtYXR0ZXJcIiAod2hlcmUgXCJOYW1lXCIgaXMgdGhlIGxvY2FsaXplciBuYW1lLCBhbGwgbG93ZXIgY2FzZSBidXQgd2l0aCBhbiBpbml0aWFsIGNhcGl0YWwpLlxuICAgICAqIDMuIFVzZXMgdGhlIG5ld2x5IGJvdW5kIGNvbnN0cnVjdG9yIHRvIGNyZWF0ZSBhIG5ldyBsb2NhbGl6ZWQgbG9jYWxpemVyIHdpdGggdGhlIHByb3ZpZGVkIG9wdGlvbnMuXG4gICAgICogNC4gQWRkcyBuZXcgbG9jYWxpemVyIHRvIHRoaXMgb2JqZWN0IHZpYSB7QGxpbmsgTG9jYWxpemF0aW9uI2FkZHxhZGR9LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGxvY2FsaXplck5hbWVcbiAgICAgKiBAcGFyYW0ge0NvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHtmYWN0b3J5T3B0aW9uc31cbiAgICAgKiBAcmV0dXJucyB7bG9jYWxpemVJbmVyZmFjZX0gVGhlIG5ldyBsb2NhbGl6ZXIuXG4gICAgICovXG4gICAgY29uc3RydWN0OiBmdW5jdGlvbihsb2NhbGl6ZXJOYW1lLCBDb25zdHJ1Y3RvciwgZmFjdG9yeU9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGNvbnN0cnVjdG9yTmFtZSA9IGxvY2FsaXplck5hbWVbMF0udG9VcHBlckNhc2UoKSArIGxvY2FsaXplck5hbWUuc3Vic3RyKDEpLnRvTG93ZXJDYXNlKCkgKyAnRm9ybWF0dGVyJyxcbiAgICAgICAgICAgIEJvdW5kQ29uc3RydWN0b3IgPSBDb25zdHJ1Y3Rvci5iaW5kKG51bGwsIHRoaXMubG9jYWxlKSxcbiAgICAgICAgICAgIGxvY2FsaXplciA9IG5ldyBCb3VuZENvbnN0cnVjdG9yKGZhY3RvcnlPcHRpb25zKTtcblxuICAgICAgICB0aGlzW2NvbnN0cnVjdG9yTmFtZV0gPSBCb3VuZENvbnN0cnVjdG9yO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmFkZChsb2NhbGl6ZXJOYW1lLCBsb2NhbGl6ZXIpO1xuICAgIH0sXG5cbiAgICAvKiogQHN1bW1hcnkgUmVnaXN0ZXIgYSBsb2NhbGl6ZXIuXG4gICAgICogQGRlc2MgQ2hlY2tzIHRoZSBwcm92aWRlZCBsb2NhbGl6ZXIgdGhhdCBpdCBjb25mb3JtcyB0byB7QGxpbmsgbG9jYWxpemVySW50ZXJmYWNlfVxuICAgICAqIGFuZCBhZGRzIGl0IHRvIHRoZSBvYmplY3QgdXNpbmcgbG9jYWxpemVyTmFtZSBhbGwgbG93ZXIgY2FzZSBhcyB0aGUga2V5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHtsb2NhbGl6ZXJJbnRlcmZhY2V9IGxvY2FsaXplclxuICAgICAqIEBtZW1iZXJPZiBMb2NhbGl6YXRpb24ucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge2xvY2FsaXplSW5lcmZhY2V9IFRoZSBwcm92aWRlZCBsb2NhbGl6ZXIuXG4gICAgICovXG4gICAgYWRkOiBmdW5jdGlvbihuYW1lLCBsb2NhbGl6ZXIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgbG9jYWxpemVyID0gbmFtZTtcbiAgICAgICAgICAgIG5hbWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXG4gICAgICAgICAgICB0eXBlb2YgbG9jYWxpemVyICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICAgICAgdHlwZW9mIGxvY2FsaXplci5mb3JtYXQgIT09ICdmdW5jdGlvbicgfHxcbiAgICAgICAgICAgIHR5cGVvZiBsb2NhbGl6ZXIucGFyc2UgIT09ICdmdW5jdGlvbicgfHxcbiAgICAgICAgICAgIGxvY2FsaXplci5pbnZhbGlkICYmIHR5cGVvZiBsb2NhbGl6ZXIuaW52YWxpZCAhPT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgICAgICAgbG9jYWxpemVyLmV4cGVjdGF0aW9uICYmIHR5cGVvZiBsb2NhbGl6ZXIuZXhwZWN0YXRpb24gIT09ICdzdHJpbmcnXG4gICAgICAgICkge1xuICAgICAgICAgICAgdGhyb3cgJ0V4cGVjdGVkIGxvY2FsaXplciBvYmplY3QgdG8gY29uZm9ybSB0byBpbnRlcmZhY2UuJztcbiAgICAgICAgfVxuXG4gICAgICAgIG5hbWUgPSBuYW1lIHx8IGxvY2FsaXplci5uYW1lO1xuICAgICAgICBuYW1lID0gbmFtZSAmJiBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHRoaXNbbmFtZV0gPSBsb2NhbGl6ZXI7XG5cbiAgICAgICAgcmV0dXJuIGxvY2FsaXplcjtcbiAgICB9LFxuICAgIGRlcHJlY2F0ZWQ6IGRlcHJlY2F0ZWQsXG4gICAgc2V0OiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlcHJlY2F0ZWQoJ3NldChuYW1lLCBsb2NhbGl6ZXIpJywgJ2FkZChuYW1lLCBsb2NhbGl6ZXIpJywgJzEuMC42JywgYXJndW1lbnRzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbG9jYWxpemVyTmFtZVxuICAgICAqIEByZXR1cm5zIHtsb2NhbGl6ZXJJbnRlcmZhY2V9XG4gICAgICogQG1lbWJlck9mIExvY2FsaXphdGlvbi5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbbmFtZSAmJiBuYW1lLnRvTG93ZXJDYXNlKCldIHx8IHRoaXMuc3RyaW5nO1xuICAgIH0sXG5cbiAgICAvLy8gIC8vLyAgLy8vICAvLy8gIC8vLyAgICBMT0NBTElaRVJTICAgIC8vLyAgLy8vICAvLy8gIC8vLyAgLy8vXG5cbiAgICAvLyBTcGVjaWFsIGxvY2FsaXplciBmb3IgdXNlIGJ5IENocm9tZSdzIGRhdGUgaW5wdXQgY29udHJvbC5cbiAgICBjaHJvbWVEYXRlOiB7XG4gICAgICAgIGZvcm1hdDogZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgICAgICAgaWYgKGRhdGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0ZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKGRhdGUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciB5eSA9IGRhdGUuZ2V0RnVsbFllYXIoKSxcbiAgICAgICAgICAgICAgICAgICAgbSA9IGRhdGUuZ2V0TW9udGgoKSArIDEsIG1tID0gbSA8IDEwID8gJzAnICsgbSA6IG0sXG4gICAgICAgICAgICAgICAgICAgIGQgPSBkYXRlLmdldERhdGUoKSwgZGQgPSBkIDwgMTAgPyAnMCcgKyBkIDogZDtcblxuICAgICAgICAgICAgICAgIGRhdGUgPSB5eSArICctJyArIG1tICsgJy0nICsgZGQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRhdGUgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgICAgIH0sXG4gICAgICAgIHBhcnNlOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgICAgIHZhciBkYXRlLFxuICAgICAgICAgICAgICAgIHBhcnRzID0gc3RyLnNwbGl0KCctJyk7XG4gICAgICAgICAgICBpZiAocGFydHMgJiYgcGFydHMubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKHBhcnRzWzBdLCBwYXJ0c1sxXSAtIDEsIHBhcnRzWzJdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGF0ZSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBudWxsOiB7XG4gICAgICAgIGZvcm1hdDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgcGFyc2U6IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBzdHJpbmc6IHtcbiAgICAgICAgZm9ybWF0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlICsgJyc7XG4gICAgICAgIH0sXG4gICAgICAgIHBhcnNlOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHIgKyAnJztcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTG9jYWxpemF0aW9uO1xuIiwiLyogZXNsaW50LWVudiBicm93c2VyICovXG4vKiBnbG9iYWwgcmVxdWVzdEFuaW1hdGlvbkZyYW1lICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF8gPSByZXF1aXJlKCdvYmplY3QtaXRlcmF0b3JzJyk7XG5cbnZhciBCYXNlID0gcmVxdWlyZSgnLi9CYXNlJyk7XG52YXIgaW1hZ2VzID0gcmVxdWlyZSgnLi4vLi4vaW1hZ2VzJyk7XG5cbi8qKiBAdHlwZWRlZiB7b2JqZWN0fSBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkRcbiAqIEBzZWUgW0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRClcbiAqL1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGRlc2MgZmluLWh5cGVyZ3JpZC1yZW5kZXJlciBpcyB0aGUgY2FudmFzIGVuYWJsZWQgdG9wIGxldmVsIHN1YiBjb21wb25lbnQgdGhhdCBoYW5kbGVzIHRoZSByZW5kZXJlcmluZyBvZiB0aGUgR3JpZC5cbiAqXG4gKiBJdCByZWxpZXMgb24gdHdvIG90aGVyIGV4dGVybmFsIHN1YnByb2plY3RzXG4gKlxuICogMS4gZmluLWNhbnZhczogYSB3cmFwcGVyIHRvIHByb3ZpZGUgYSBzaW1wbGVyIGludGVyZmFjZSB0byB0aGUgSFRNTDUgY2FudmFzIGNvbXBvbmVudFxuICogMi4gcmVjdGFuZ3VsYXI6IGEgc21hbGwgbnBtIG1vZHVsZSBwcm92aWRpbmcgUG9pbnQgYW5kIFJlY3RhbmdsZSBvYmplY3RzXG4gKlxuICogVGhlIGZpbi1oeXBlcmdyaWQtcmVuZGVyZXIgaXMgaW4gYSB1bmlxdWUgcG9zaXRpb24gdG8gcHJvdmlkZSBjcml0aWNhbCBmdW5jdGlvbmFsaXR5IHRvIHRoZSBmaW4taHlwZXJncmlkIGluIGEgaGlnaHRseSBwZXJmb3JtYW50IG1hbm5lci5cbiAqIEJlY2F1c2UgaXQgTVVTVCBpdGVyYXRlIG92ZXIgYWxsIHRoZSB2aXNpYmxlIGNlbGxzIGl0IGNhbiBzdG9yZSB2YXJpb3VzIGJpdHMgb2YgaW5mb3JtYXRpb24gdGhhdCBjYW4gYmUgZW5jYXBzdWxhdGVkIGFzIGEgc2VydmljZSBmb3IgY29uc3VtcHRpb24gYnkgdGhlIGZpbi1oeXBlcmdyaWQgY29tcG9uZW50LlxuICpcbiAqIEluc3RhbmNlcyBvZiB0aGlzIG9iamVjdCBoYXZlIGJhc2ljYWxseSBmb3VyIG1haW4gZnVuY3Rpb25zLlxuICpcbiAqIDEuIHJlbmRlciBmaXhlZCByb3cgaGVhZGVyc1xuICogMi4gcmVuZGVyIGZpeGVkIGNvbCBoZWFkZXJzXG4gKiAzLiByZW5kZXIgbWFpbiBkYXRhIGNlbGxzXG4gKiA0LiByZW5kZXIgZ3JpZCBsaW5lc1xuICpcbiAqIFNhbWUgcGFyYW1ldGVycyBhcyB7QGxpbmsgUmVuZGVyZXIjaW5pdGlhbGl6ZXxpbml0aWFsaXplfSwgd2hpY2ggaXMgY2FsbGVkIGJ5IHRoaXMgY29uc3RydWN0b3IuXG4gKlxuICovXG52YXIgUmVuZGVyZXIgPSBCYXNlLmV4dGVuZCgnUmVuZGVyZXInLCB7XG5cbiAgICAvL3RoZSBzaGFyZWQgc2luZ2xlIGl0ZW0gXCJwb29sZWRcIiBjZWxsIG9iamVjdCBmb3IgZHJhd2luZyBlYWNoIGNlbGxcbiAgICBjZWxsOiB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDAsXG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBoZWlnaHQ6IDBcbiAgICB9LFxuXG4gICAgc2Nyb2xsSGVpZ2h0OiAwLFxuXG4gICAgdmlld0hlaWdodDogMCxcblxuICAgIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5ib3VuZHMgPSB7XG4gICAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICAgIGhlaWdodDogMFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNvbHVtbkVkZ2VzID0gW107XG4gICAgICAgIHRoaXMuY29sdW1uRWRnZXNJbmRleE1hcCA9IFtdO1xuICAgICAgICB0aGlzLnJlbmRlcmVkQ29sdW1uTWluV2lkdGhzID0gW107XG4gICAgICAgIHRoaXMucm93RWRnZXMgPSBbXTtcbiAgICAgICAgdGhpcy5yb3dFZGdlc0luZGV4TWFwID0gW107XG4gICAgICAgIHRoaXMudmlzaWJsZUNvbHVtbnMgPSBbXTtcbiAgICAgICAgdGhpcy52aXNpYmxlUm93cyA9IFtdO1xuICAgICAgICB0aGlzLmluc2VydGlvbkJvdW5kcyA9IFtdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBDb25zdHJ1Y3RvciBsb2dpY1xuICAgICAqIEBkZXNjIFRoaXMgbWV0aG9kIHdpbGwgYmUgY2FsbGVkIHVwb24gaW5zdGFudGlhdGlvbiBvZiB0aGlzIGNsYXNzIG9yIG9mIGFueSBjbGFzcyB0aGF0IGV4dGVuZHMgZnJvbSB0aGlzIGNsYXNzLlxuICAgICAqID4gQWxsIGBpbml0aWFsaXplKClgIG1ldGhvZHMgaW4gdGhlIGluaGVyaXRhbmNlIGNoYWluIGFyZSBjYWxsZWQsIGluIHR1cm4sIGVhY2ggd2l0aCB0aGUgc2FtZSBwYXJhbWV0ZXJzIHRoYXQgd2VyZSBwYXNzZWQgdG8gdGhlIGNvbnN0cnVjdG9yLCBiZWdpbm5pbmcgd2l0aCB0aGF0IG9mIHRoZSBtb3N0IFwic2VuaW9yXCIgY2xhc3MgdGhyb3VnaCB0aGF0IG9mIHRoZSBjbGFzcyBvZiB0aGUgbmV3IGluc3RhbmNlLlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIHRoaXMuZ3JpZCA9IGdyaWQ7XG4gICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICB9LFxuXG4gICAgLy90aGlzIGZ1bmN0aW9uIGNvbXB1dGVzIHRoZSBncmlkIGNvb3JkaW5hdGVzIHVzZWQgZm9yIGV4dHJlbWVseSBmYXN0IGl0ZXJhdGlvbiBvdmVyXG4gICAgLy9wYWludGluZyB0aGUgZ3JpZCBjZWxscy4gdGhpcyBmdW5jdGlvbiBpcyB2ZXJ5IGZhc3QsIGZvciB0aG91c2FuZCByb3dzIFggMTAwIGNvbHVtbnNcbiAgICAvL29uIGEgbW9kZXN0IG1hY2hpbmUgdGFraW5nIHVzdWFsbHkgMG1zIGFuZCBubyBtb3JlIHRoYXQgMyBtcy5cbiAgICBjb21wdXRlQ2VsbHNCb3VuZHM6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIC8vdmFyIHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG5cbiAgICAgICAgdmFyIHNjcm9sbFRvcCA9IHRoaXMuZ2V0U2Nyb2xsVG9wKCksXG4gICAgICAgICAgICBzY3JvbGxMZWZ0ID0gdGhpcy5nZXRTY3JvbGxMZWZ0KCksXG5cbiAgICAgICAgICAgIG51bUNvbHVtbnMgPSB0aGlzLmdldENvbHVtbkNvdW50KCksXG4gICAgICAgICAgICBudW1GaXhlZENvbHVtbnMgPSB0aGlzLmdldEZpeGVkQ29sdW1uQ291bnQoKSxcblxuICAgICAgICAgICAgbnVtUm93cyA9IHRoaXMuZ2V0Um93Q291bnQoKSxcbiAgICAgICAgICAgIG51bUZpeGVkUm93cyA9IHRoaXMuZ2V0Rml4ZWRSb3dDb3VudCgpLFxuXG4gICAgICAgICAgICBib3VuZHMgPSB0aGlzLmdldEJvdW5kcygpLFxuICAgICAgICAgICAgZ3JpZCA9IHRoaXMuZ3JpZCxcbiAgICAgICAgICAgIG51bWJlck9mQm90dG9tVG90YWxzUm93cyA9IGdyaWQuYmVoYXZpb3IuZGF0YU1vZGVsLmdldEJvdHRvbVRvdGFscygpLmxlbmd0aCxcbiAgICAgICAgICAgIHZpZXdXaWR0aCA9IGJvdW5kcy53aWR0aCB8fCBncmlkLmNhbnZhcy53aWR0aCwgLy8gaWYgMCwgd2UgbXVzdCBiZSBpbiBib290c3RyYXBcbiAgICAgICAgICAgIHZpZXdIZWlnaHQgPSBib3VuZHMuaGVpZ2h0IC0gbnVtYmVyT2ZCb3R0b21Ub3RhbHNSb3dzICogZ3JpZC5iZWhhdmlvci5nZXREZWZhdWx0Um93SGVpZ2h0KCksXG5cbiAgICAgICAgICAgIGluc2VydGlvbkJvdW5kc0N1cnNvciA9IDAsXG4gICAgICAgICAgICBwcmV2aW91c0luc2VydGlvbkJvdW5kc0N1cnNvclZhbHVlID0gMCxcblxuICAgICAgICAgICAgc3RhcnQgPSAwLFxuICAgICAgICAgICAgeCA9IDAsIHkgPSAwLFxuICAgICAgICAgICAgYywgcixcbiAgICAgICAgICAgIHZ4LCB2eSxcbiAgICAgICAgICAgIHdpZHRoLCBoZWlnaHQsXG4gICAgICAgICAgICBmaXJzdFZYLCBsYXN0VlgsXG4gICAgICAgICAgICBmaXJzdFZZLCBsYXN0Vlk7XG5cbiAgICAgICAgdGhpcy5nZXRDb2x1bW5FZGdlcygpLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMucm93RWRnZXMubGVuZ3RoID0gMDtcblxuICAgICAgICB0aGlzLmNvbHVtbkVkZ2VzWzBdID0gMDtcbiAgICAgICAgdGhpcy5yb3dFZGdlc1swXSA9IDA7XG4gICAgICAgIHRoaXMuc2Nyb2xsSGVpZ2h0ID0gMDtcblxuICAgICAgICB0aGlzLnZpc2libGVDb2x1bW5zLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMudmlzaWJsZVJvd3MubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5jb2x1bW5FZGdlc0luZGV4TWFwID0gW107XG4gICAgICAgIHRoaXMucm93RWRnZXNJbmRleE1hcCA9IFtdO1xuXG4gICAgICAgIHRoaXMuaW5zZXJ0aW9uQm91bmRzID0gW107XG5cbiAgICAgICAgaWYgKHRoaXMuZ3JpZC5pc1Nob3dSb3dOdW1iZXJzKCkpIHtcbiAgICAgICAgICAgIHN0YXJ0LS07XG4gICAgICAgICAgICB0aGlzLmNvbHVtbkVkZ2VzWy0xXSA9IC0xO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjID0gc3RhcnQ7IGMgPCBudW1Db2x1bW5zOyBjKyspIHtcbiAgICAgICAgICAgIHZ4ID0gYztcbiAgICAgICAgICAgIGlmIChjID49IG51bUZpeGVkQ29sdW1ucykge1xuICAgICAgICAgICAgICAgIHZ4ID0gdnggKyBzY3JvbGxMZWZ0O1xuICAgICAgICAgICAgICAgIGlmIChmaXJzdFZYID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RWWCA9IHZ4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsYXN0VlggPSB2eDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh4ID4gdmlld1dpZHRoIHx8IG51bUNvbHVtbnMgPD0gdngpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdpZHRoID0gZ3JpZC5nZXRDb2x1bW5XaWR0aCh2eCk7XG4gICAgICAgICAgICB4ID0geCArIHdpZHRoO1xuICAgICAgICAgICAgdGhpcy5jb2x1bW5FZGdlc1tjICsgMV0gPSBNYXRoLnJvdW5kKHgpO1xuICAgICAgICAgICAgdGhpcy52aXNpYmxlQ29sdW1uc1tjXSA9IHZ4O1xuICAgICAgICAgICAgdGhpcy5jb2x1bW5FZGdlc0luZGV4TWFwW3Z4XSA9IGM7XG5cbiAgICAgICAgICAgIGluc2VydGlvbkJvdW5kc0N1cnNvciA9IGluc2VydGlvbkJvdW5kc0N1cnNvciArIE1hdGgucm91bmQod2lkdGggLyAyKSArIHByZXZpb3VzSW5zZXJ0aW9uQm91bmRzQ3Vyc29yVmFsdWU7XG4gICAgICAgICAgICB0aGlzLmluc2VydGlvbkJvdW5kcy5wdXNoKGluc2VydGlvbkJvdW5kc0N1cnNvcik7XG4gICAgICAgICAgICBwcmV2aW91c0luc2VydGlvbkJvdW5kc0N1cnNvclZhbHVlID0gTWF0aC5yb3VuZCh3aWR0aCAvIDIpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChyID0gMDsgciA8IG51bVJvd3M7IHIrKykge1xuICAgICAgICAgICAgdnkgPSByO1xuICAgICAgICAgICAgaWYgKHIgPj0gbnVtRml4ZWRSb3dzKSB7XG4gICAgICAgICAgICAgICAgdnkgPSB2eSArIHNjcm9sbFRvcDtcbiAgICAgICAgICAgICAgICBpZiAoZmlyc3RWWSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0VlkgPSB2eTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGFzdFZZID0gdnk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeSA+IHZpZXdIZWlnaHQgfHwgbnVtUm93cyA8PSB2eSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGVpZ2h0ID0gZ3JpZC5nZXRSb3dIZWlnaHQodnkpO1xuICAgICAgICAgICAgeSA9IHkgKyBoZWlnaHQ7XG4gICAgICAgICAgICB0aGlzLnJvd0VkZ2VzW3IgKyAxXSA9IE1hdGgucm91bmQoeSk7XG4gICAgICAgICAgICB0aGlzLnZpc2libGVSb3dzW3JdID0gdnk7XG4gICAgICAgICAgICB0aGlzLnJvd0VkZ2VzSW5kZXhNYXBbdnldID0gcjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZpZXdIZWlnaHQgPSB2aWV3SGVpZ2h0O1xuICAgICAgICB0aGlzLmRhdGFXaW5kb3cgPSB0aGlzLmdyaWQubmV3UmVjdGFuZ2xlKGZpcnN0VlgsIGZpcnN0VlksIGxhc3RWWCAtIGZpcnN0VlgsIGxhc3RWWSAtIGZpcnN0VlkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge09iamVjdH0gYSBwcm9wZXJ0eSB2YWx1ZSBhdCBhIGtleSwgZGVsZWdhdGVzIHRvIHRoZSBncmlkXG4gICAgICovXG4gICAgcmVzb2x2ZVByb3BlcnR5OiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JpZC5yZXNvbHZlUHJvcGVydHkoa2V5KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEBzdW1tYXJ5IE5vdGlmeSB0aGUgZmluLWh5cGVyZ3JpZCBldmVyeXRpbWUgd2UndmUgcmVwYWludGVkLlxuICAgICAqIEBkZXNjIFRoaXMgaXMgdGhlIGVudHJ5IHBvaW50IGZyb20gZmluLWNhbnZhcy5cbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gZ2NcbiAgICAgKi9cbiAgICBwYWludDogZnVuY3Rpb24oZ2MpIHtcbiAgICAgICAgaWYgKHRoaXMuZ3JpZCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmhhc0RhdGEoKSkge1xuICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlID0gdGhpcy5ncmlkLnJlc29sdmVQcm9wZXJ0eSgnbm9EYXRhTWVzc2FnZScpO1xuICAgICAgICAgICAgICAgIGdjLmZvbnQgPSAnMjBweCBBcmlhbCc7XG4gICAgICAgICAgICAgICAgZ2MuZmlsbFRleHQobWVzc2FnZSwgMjAsIDMwKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJHcmlkKGdjKTtcbiAgICAgICAgICAgICAgICB0aGlzLmdyaWQuZ3JpZFJlbmRlcmVkTm90aWZpY2F0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgaGFzRGF0YTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5ncmlkLmJlaGF2aW9yLmdldERhdGEoKTtcbiAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhLmxlbmd0aCA+IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge251bWJlcn0gQW5zd2VyIGhvdyBtYW55IHJvd3Mgd2UgcmVuZGVyZWRcbiAgICAgKi9cbiAgICBnZXRWaXNpYmxlUm93c0NvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaWJsZVJvd3MubGVuZ3RoIC0gMTtcbiAgICB9LFxuXG4gICAgZ2V0VmlzaWJsZVNjcm9sbEhlaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdIZWlnaHQgLSB0aGlzLmdyaWQuZ2V0Rml4ZWRSb3dzSGVpZ2h0KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyW119IFJvd3Mgd2UganVzdCByZW5kZXJlZC5cbiAgICAgKi9cbiAgICBnZXRWaXNpYmxlUm93czogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2libGVSb3dzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge251bWJlcn0gTnVtZXIgb2YgY29sdW1ucyB3ZSBqdXN0IHJlbmRlcmVkLlxuICAgICAqL1xuICAgIGdldFZpc2libGVDb2x1bW5zQ291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpYmxlQ29sdW1ucy5sZW5ndGggLSAxO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge251bWJlcn0gQ29sdW1ucyB3ZSBqdXN0IHJlbmRlcmVkLlxuICAgICAqL1xuICAgIGdldFZpc2libGVDb2x1bW5zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaWJsZUNvbHVtbnM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgY29sdW1uIGluZGV4IHdobmUgdGhlIG1vdXNlRXZlbnQgY29vcmRpbmF0ZXMgYXJlIG92ZXIgYSBjb2x1bW4gZGl2aWRlci5cbiAgICAgKi9cbiAgICBvdmVyQ29sdW1uRGl2aWRlcjogZnVuY3Rpb24oeCkge1xuICAgICAgICB4ID0gTWF0aC5yb3VuZCh4KTtcbiAgICAgICAgdmFyIGVkZ2VzID0gdGhpcy5nZXRDb2x1bW5FZGdlcygpO1xuICAgICAgICB2YXIgd2hpY2hDb2wgPSBlZGdlcy5pbmRleE9mKHggLSAxKTtcbiAgICAgICAgaWYgKHdoaWNoQ29sIDwgMCkge1xuICAgICAgICAgICAgd2hpY2hDb2wgPSBlZGdlcy5pbmRleE9mKHgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3aGljaENvbCA8IDApIHtcbiAgICAgICAgICAgIHdoaWNoQ29sID0gZWRnZXMuaW5kZXhPZih4IC0gMik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdoaWNoQ29sIDwgMCkge1xuICAgICAgICAgICAgd2hpY2hDb2wgPSBlZGdlcy5pbmRleE9mKHggKyAxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAod2hpY2hDb2wgPCAwKSB7XG4gICAgICAgICAgICB3aGljaENvbCA9IGVkZ2VzLmluZGV4T2YoeCAtIDMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHdoaWNoQ29sO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge251bWJlcn0gVGhlIHJvdyBpbmRleCB3aGVuIHRoZSBtb3VzZUV2ZW50IGNvb3JkaW5hdGVzIGFyZSBvdmVyIGEgcm93IGRpdmlkZXIuXG4gICAgICovXG4gICAgb3ZlclJvd0RpdmlkZXI6IGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgeSA9IE1hdGgucm91bmQoeSk7XG4gICAgICAgIHZhciB3aGljaCA9IHRoaXMucm93RWRnZXMuaW5kZXhPZih5ICsgMSk7XG4gICAgICAgIGlmICh3aGljaCA8IDApIHtcbiAgICAgICAgICAgIHdoaWNoID0gdGhpcy5yb3dFZGdlcy5pbmRleE9mKHkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3aGljaCA8IDApIHtcbiAgICAgICAgICAgIHdoaWNoID0gdGhpcy5yb3dFZGdlcy5pbmRleE9mKHkgLSAxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd2hpY2g7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge1BvaW50fSBjZWxsXG4gICAgICogQHJldHVybnMge1JlY3RhbmdsZX0gQm91bmRpbmcgcmVjdCBvZiB0aGUgZ2l2ZW4gYGNlbGxgLlxuICAgICAqL1xuICAgIGdldEJvdW5kc09mQ2VsbDogZnVuY3Rpb24oY2VsbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0Qm91bmRzT2ZDZWxsKGNlbGwueCwgY2VsbC55KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjIC0gVGhlIGhvcml6b250YWwgY29vcmRpbmF0ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gciAtIFRoZSB2ZXJ0aWNhbCBjb29yZGluYXRlLlxuICAgICAqIEByZXR1cm5zIHtSZWN0YW5nbGV9IEJvdW5kaW5nIHJlY3Qgb2YgY2VsbCB3aXRoIHRoZSBnaXZlbiBjb29yZGluYXRlcy5cbiAgICAgKi9cbiAgICBfZ2V0Qm91bmRzT2ZDZWxsOiBmdW5jdGlvbihjLCByKSB7XG4gICAgICAgIHZhciB4T3V0c2lkZSA9IGZhbHNlLFxuICAgICAgICAgICAgeU91dHNpZGUgPSBmYWxzZSxcbiAgICAgICAgICAgIGNlbGwgPSB0aGlzLmNlbGw7XG5cbiAgICAgICAgdmFyIHksIHggPSB0aGlzLmNvbHVtbkVkZ2VzSW5kZXhNYXBbY107XG4gICAgICAgIGlmICh4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHggPSB0aGlzLmNvbHVtbkVkZ2VzSW5kZXhNYXBbYyAtIDFdO1xuICAgICAgICAgICAgeE91dHNpZGUgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG95LCBveCA9IHRoaXMuY29sdW1uRWRnZXNbeF0sXG4gICAgICAgICAgICBjeSwgY3ggPSB0aGlzLmNvbHVtbkVkZ2VzW3ggKyAxXSxcbiAgICAgICAgICAgIGV5LCBleCA9IGN4IC0gb3g7XG5cbiAgICAgICAgY2VsbC54ID0geE91dHNpZGUgPyBjeCA6IG94O1xuICAgICAgICBjZWxsLndpZHRoID0geE91dHNpZGUgPyAwIDogZXg7XG5cbiAgICAgICAgaWYgKHIgPCAwKSB7IC8vIGJvdHRvbSB0b3RhbHMgcm93c1xuICAgICAgICAgICAgdmFyIGJlaGF2aW9yID0gdGhpcy5ncmlkLmJlaGF2aW9yLFxuICAgICAgICAgICAgICAgIGJvdW5kcyA9IHRoaXMuZ2V0Qm91bmRzKCk7XG5cbiAgICAgICAgICAgIGV5ID0gYmVoYXZpb3IuZ2V0RGVmYXVsdFJvd0hlaWdodCgpO1xuICAgICAgICAgICAgb3kgPSBib3VuZHMuaGVpZ2h0ICsgciAqIGV5O1xuICAgICAgICAgICAgY3kgPSBveSArIGV5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeSA9IHRoaXMucm93RWRnZXNJbmRleE1hcFtyXTtcbiAgICAgICAgICAgIGlmICh5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB5ID0gdGhpcy5yb3dFZGdlc0luZGV4TWFwW3IgLSAxXTtcbiAgICAgICAgICAgICAgICB5T3V0c2lkZSA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG95ID0gdGhpcy5yb3dFZGdlc1t5XTtcbiAgICAgICAgICAgIGN5ID0gdGhpcy5yb3dFZGdlc1t5ICsgMV07XG4gICAgICAgICAgICBleSA9IGN5IC0gb3k7XG4gICAgICAgIH1cblxuICAgICAgICBjZWxsLnkgPSB5T3V0c2lkZSA/IGN5IDogb3k7XG4gICAgICAgIGNlbGwuaGVpZ2h0ID0geU91dHNpZGUgPyAwIDogZXk7XG5cbiAgICAgICAgcmV0dXJuIGNlbGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBhbnN3ZXIgdGhlIGNvbHVtbiBpbmRleCB1bmRlciB0aGUgY29vcmRpbmF0ZSBhdCBwaXhlbFhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxYIC0gVGhlIGhvcml6b250YWwgY29vcmRpbmF0ZS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgY29sdW1uIGluZGV4IHVuZGVyIHRoZSBjb29yZGluYXRlIGF0IHBpeGVsWC5cbiAgICAgKi9cbiAgICBnZXRDb2x1bW5Gcm9tUGl4ZWxYOiBmdW5jdGlvbihwaXhlbFgpIHtcbiAgICAgICAgdmFyIHdpZHRoID0gMCxcbiAgICAgICAgICAgIGZpeGVkQ29sdW1uQ291bnQgPSB0aGlzLmdldEZpeGVkQ29sdW1uQ291bnQoKSxcbiAgICAgICAgICAgIHNjcm9sbExlZnQgPSB0aGlzLmdyaWQuZ2V0SFNjcm9sbFZhbHVlKCksXG4gICAgICAgICAgICBlZGdlcyA9IHRoaXMuZ2V0Q29sdW1uRWRnZXMoKTtcblxuICAgICAgICBmb3IgKHZhciBjID0gMTsgYyA8IGVkZ2VzLmxlbmd0aCAtIDE7IGMrKykge1xuICAgICAgICAgICAgd2lkdGggPSBlZGdlc1tjXSAtIChlZGdlc1tjXSAtIGVkZ2VzW2MgLSAxXSkgLyAyO1xuICAgICAgICAgICAgaWYgKHBpeGVsWCA8IHdpZHRoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGMgPiBmaXhlZENvbHVtbkNvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGMgPSBjICsgc2Nyb2xsTGVmdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGMgLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjID4gZml4ZWRDb2x1bW5Db3VudCkge1xuICAgICAgICAgICAgYyA9IGMgKyBzY3JvbGxMZWZ0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjIC0gMTtcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQGRlc2MgQW5zd2VyIHNwZWNpZmljIGRhdGEgY2VsbCBjb29yZGluYXRlcyBnaXZlbiBtb3VzZSBjb29yZGluYXRlcyBpbiBwaXhlbHMuXG4gICAgICogQHBhcmFtIHtQb2ludH0gcG9pbnRcbiAgICAgKiBAcmV0dXJucyB7UG9pbnR9IENlbGwgY29vcmRpbmF0ZXNcbiAgICAgKi9cbiAgICBnZXRHcmlkQ2VsbEZyb21Nb3VzZVBvaW50OiBmdW5jdGlvbihwb2ludCkge1xuXG4gICAgICAgIHZhciBiZWhhdmlvciA9IHRoaXMuZ3JpZC5iZWhhdmlvcjtcbiAgICAgICAgdmFyIHdpZHRoID0gMDtcbiAgICAgICAgdmFyIGhlaWdodCA9IDA7XG4gICAgICAgIHZhciB4LCB5LCBjLCByO1xuICAgICAgICB2YXIgcHJldmlvdXMgPSAwO1xuICAgICAgICB2YXIgY29sdW1uRWRnZXMgPSB0aGlzLmdldENvbHVtbkVkZ2VzKCk7XG4gICAgICAgIHZhciBmaXhlZENvbHVtbkNvdW50ID0gdGhpcy5nZXRGaXhlZENvbHVtbkNvdW50KCk7IC8vICsgZ3JpZFNpemU7XG4gICAgICAgIHZhciBmaXhlZFJvd0NvdW50ID0gdGhpcy5nZXRGaXhlZFJvd0NvdW50KCk7XG5cbiAgICAgICAgLy8gdmFyIGZpeGVkQ29sdW1uQ291bnQgPSB0aGlzLmdldEZpeGVkQ29sdW1uQ291bnQoKTtcbiAgICAgICAgLy8gdmFyIGZpeGVkUm93Q291bnQgPSB0aGlzLmdldEZpeGVkUm93Q291bnQoKTtcbiAgICAgICAgdmFyIHNjcm9sbFggPSB0aGlzLmdldFNjcm9sbExlZnQoKTtcbiAgICAgICAgdmFyIHNjcm9sbFkgPSB0aGlzLmdldFNjcm9sbFRvcCgpO1xuXG4gICAgICAgIGZvciAoYyA9IDA7IGMgPCBjb2x1bW5FZGdlcy5sZW5ndGg7IGMrKykge1xuICAgICAgICAgICAgd2lkdGggPSBjb2x1bW5FZGdlc1tjXTtcbiAgICAgICAgICAgIGlmIChwb2ludC54IDwgd2lkdGgpIHtcbiAgICAgICAgICAgICAgICB4ID0gTWF0aC5tYXgoMCwgcG9pbnQueCAtIHByZXZpb3VzIC0gMik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2aW91cyA9IHdpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGMtLTtcbiAgICAgICAgcHJldmlvdXMgPSAwO1xuICAgICAgICBmb3IgKHIgPSAwOyByIDwgdGhpcy5yb3dFZGdlcy5sZW5ndGg7IHIrKykge1xuICAgICAgICAgICAgaGVpZ2h0ID0gdGhpcy5yb3dFZGdlc1tyXTtcbiAgICAgICAgICAgIGlmIChwb2ludC55IDwgaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgeSA9IE1hdGgubWF4KDAsIHBvaW50LnkgLSBwcmV2aW91cyAtIDIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJldmlvdXMgPSBoZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgci0tO1xuICAgICAgICBpZiAocG9pbnQueCA8IDApIHtcbiAgICAgICAgICAgIGMgPSAtMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9pbnQueSA8IDApIHtcbiAgICAgICAgICAgIHIgPSAtMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB2aWV3UG9pbnQgPSB0aGlzLmdyaWQubmV3UG9pbnQoYywgcik7XG5cbiAgICAgICAgLy9jb21wZW5zYXRlIGlmIHdlIGFyZSBzY3JvbGxlZFxuICAgICAgICBpZiAoYyA+PSBmaXhlZENvbHVtbkNvdW50KSB7XG4gICAgICAgICAgICBjID0gYyArIHNjcm9sbFg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHIgPj0gZml4ZWRSb3dDb3VudCkge1xuICAgICAgICAgICAgciA9IHIgKyBzY3JvbGxZO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRyYW5zbGF0ZWRJbmRleCA9IC0xO1xuXG4gICAgICAgIHZhciBjb2x1bW4gPSBiZWhhdmlvci5nZXRBY3RpdmVDb2x1bW4oYyk7XG4gICAgICAgIGlmIChjb2x1bW4pIHtcbiAgICAgICAgICAgIHRyYW5zbGF0ZWRJbmRleCA9IGNvbHVtbi5pbmRleDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBncmlkQ2VsbDogdGhpcy5ncmlkLm5ld1BvaW50KGMsIHIpLFxuICAgICAgICAgICAgbW91c2VQb2ludDogdGhpcy5ncmlkLm5ld1BvaW50KHgsIHkpLFxuICAgICAgICAgICAgdmlld1BvaW50OiB2aWV3UG9pbnQsXG4gICAgICAgICAgICBkYXRhQ2VsbDogdGhpcy5ncmlkLm5ld1BvaW50KHRyYW5zbGF0ZWRJbmRleCwgciksXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAc3VtbWFyeSBEZXRlcm1pbmVzIGlmIGEgY29sdW1uIGlzIHZpc2libGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbEluZGV4IC0gdGhlIGNvbHVtbiBpbmRleCpcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVGhlIGdpdmVuIGNvbHVtbiBpcyBmdWxseSB2aXNpYmxlLlxuICAgICAqL1xuICAgIGlzQ29sdW1uVmlzaWJsZTogZnVuY3Rpb24oY29sSW5kZXgpIHtcbiAgICAgICAgdmFyIGlzVmlzaWJsZSA9IHRoaXMudmlzaWJsZUNvbHVtbnMuaW5kZXhPZihjb2xJbmRleCkgIT09IC0xO1xuICAgICAgICByZXR1cm4gaXNWaXNpYmxlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge251bWJlcn0gVGhlIHdpZHRoIHggY29vcmRpbmF0ZSBvZiB0aGUgbGFzdCByZW5kZXJlZCBjb2x1bW5cbiAgICAgKi9cbiAgICBnZXRGaW5hbFZpc2FibGVDb2x1bW5Cb3VuZGFyeTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpc01heFggPSB0aGlzLmlzTGFzdENvbHVtblZpc2libGUoKTtcbiAgICAgICAgdmFyIGNob3AgPSBpc01heFggPyAyIDogMTtcbiAgICAgICAgdmFyIGNvbFdhbGwgPSB0aGlzLmdldENvbHVtbkVkZ2VzKClbdGhpcy5nZXRDb2x1bW5FZGdlcygpLmxlbmd0aCAtIGNob3BdO1xuICAgICAgICB2YXIgcmVzdWx0ID0gTWF0aC5taW4oY29sV2FsbCwgdGhpcy5nZXRCb3VuZHMoKS53aWR0aCAtIDIwMCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAc3VtbWFyeSBEZXRlcm1pbmVzIHZpc2liaWxpdHkgb2YgYSByb3cuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJvd0luZGV4IC0gdGhlIHJvdyBpbmRleFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUaGUgZ2l2ZW4gcm93IGlzIGZ1bGx5IHZpc2libGUuXG4gICAgICovXG4gICAgaXNSb3dWaXNpYmxlOiBmdW5jdGlvbihyb3dJbmRleCkge1xuICAgICAgICB2YXIgaXNWaXNpYmxlID0gdGhpcy52aXNpYmxlUm93cy5pbmRleE9mKHJvd0luZGV4KSAhPT0gLTE7XG4gICAgICAgIHJldHVybiBpc1Zpc2libGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAc3VtbWFyeSBEZXRlcm1pbmVzIGlmIGEgY2VsbCBpcyBzZWxlY3RlZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCAtIHRoZSB4IGNlbGwgY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gdGhlIHkgY2VsbCBjb29yZGluYXRlKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUaGUgZ2l2ZW4gY2VsbCBpcyBmdWxseSB2aXNpYmxlLlxuICAgICAqL1xuICAgIGlzU2VsZWN0ZWQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JpZC5pc1NlbGVjdGVkKHgsIHkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQGRlc2MgVGhpcyBpcyB0aGUgbWFpbiBmb3JraW5nIG9mIHRoZSByZW5kZXJlcmluZyB0YXNrLlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBnY1xuICAgICAqL1xuICAgIHJlbmRlckdyaWQ6IGZ1bmN0aW9uKGdjKSB7XG4gICAgICAgIGdjLmJlZ2luUGF0aCgpO1xuXG4gICAgICAgIHRoaXMucGFpbnRDZWxscyhnYyk7XG4gICAgICAgIHRoaXMucGFpbnRHcmlkbGluZXMoZ2MpO1xuICAgICAgICB0aGlzLnJlbmRlck92ZXJyaWRlcyhnYyk7XG4gICAgICAgIHRoaXMucmVuZGVyTGFzdFNlbGVjdGlvbihnYyk7XG4gICAgICAgIGdjLmNsb3NlUGF0aCgpO1xuICAgIH0sXG5cbiAgICByZW5kZXJMYXN0U2VsZWN0aW9uOiBmdW5jdGlvbihnYykge1xuICAgICAgICBnYy5iZWdpblBhdGgoKTtcbiAgICAgICAgdGhpcy5fcmVuZGVyTGFzdFNlbGVjdGlvbihnYyk7XG4gICAgICAgIGdjLmNsb3NlUGF0aCgpO1xuICAgIH0sXG5cbiAgICBfcmVuZGVyTGFzdFNlbGVjdGlvbjogZnVuY3Rpb24oZ2MpIHtcblxuICAgICAgICAvKlxuXG4gICAgICAgICAgICBDb21wdXRlIHRoZSBCb3VuZHMgb2YgdGhlIExhc3QgU2VsZWN0aW9uIHRoYXQgaXMgdmlzaWJsZVxuXG4gICAgICAgICAqL1xuXG4gICAgICAgIHZhciBzZWxlY3Rpb25zID0gdGhpcy5ncmlkLnNlbGVjdGlvbk1vZGVsLmdldFNlbGVjdGlvbnMoKTtcbiAgICAgICAgaWYgKCFzZWxlY3Rpb25zIHx8IHNlbGVjdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNlbGVjdGlvbiA9IHRoaXMuZ3JpZC5zZWxlY3Rpb25Nb2RlbC5nZXRMYXN0U2VsZWN0aW9uKCk7XG4gICAgICAgIHZhciBtb3VzZURvd24gPSBzZWxlY3Rpb24ub3JpZ2luO1xuICAgICAgICBpZiAobW91c2VEb3duLnggPT09IC0xKSB7XG4gICAgICAgICAgICAvL25vIHNlbGVjdGVkIGFyZWEsIGxldHMgZXhpdFxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHZpc2libGVDb2x1bW5zID0gdGhpcy5nZXRWaXNpYmxlQ29sdW1ucygpO1xuICAgICAgICB2YXIgdmlzaWJsZVJvd3MgPSB0aGlzLmdldFZpc2libGVSb3dzKCk7XG4gICAgICAgIHZhciBsYXN0VmlzaWJsZUNvbHVtbiA9IHZpc2libGVDb2x1bW5zW3Zpc2libGVDb2x1bW5zLmxlbmd0aCAtIDFdO1xuICAgICAgICB2YXIgbGFzdFZpc2libGVSb3cgPSB2aXNpYmxlUm93c1t2aXNpYmxlUm93cy5sZW5ndGggLSAxXTtcblxuICAgICAgICB2YXIgZXh0ZW50ID0gc2VsZWN0aW9uLmV4dGVudDtcblxuICAgICAgICB2YXIgZHBPWCA9IE1hdGgubWluKG1vdXNlRG93bi54LCBtb3VzZURvd24ueCArIGV4dGVudC54KTtcbiAgICAgICAgdmFyIGRwT1kgPSBNYXRoLm1pbihtb3VzZURvd24ueSwgbW91c2VEb3duLnkgKyBleHRlbnQueSk7XG5cbiAgICAgICAgLy9sZXRzIGNoZWNrIGlmIG91ciBzZWxlY3Rpb24gcmVjdGFuZ2xlIGlzIHNjcm9sbGVkIG91dHNpZGUgb2YgdGhlIHZpc2libGUgYXJlYVxuICAgICAgICBpZiAoZHBPWCA+IGxhc3RWaXNpYmxlQ29sdW1uKSB7XG4gICAgICAgICAgICByZXR1cm47IC8vdGhlIHRvcCBvZiBvdXIgcmVjdGFuZ2xlIGlzIGJlbG93IHZpc2libGVcbiAgICAgICAgfVxuICAgICAgICBpZiAoZHBPWSA+IGxhc3RWaXNpYmxlUm93KSB7XG4gICAgICAgICAgICByZXR1cm47IC8vdGhlIGxlZnQgb2Ygb3VyIHJlY3RhbmdsZSBpcyB0byB0aGUgcmlnaHQgb2YgYmVpbmcgdmlzaWJsZVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRwRVggPSBNYXRoLm1heChtb3VzZURvd24ueCwgbW91c2VEb3duLnggKyBleHRlbnQueCkgKyAxO1xuICAgICAgICBkcEVYID0gTWF0aC5taW4oZHBFWCwgMSArIGxhc3RWaXNpYmxlQ29sdW1uKTtcblxuICAgICAgICB2YXIgZHBFWSA9IE1hdGgubWF4KG1vdXNlRG93bi55LCBtb3VzZURvd24ueSArIGV4dGVudC55KSArIDE7XG4gICAgICAgIGRwRVkgPSBNYXRoLm1pbihkcEVZLCAxICsgbGFzdFZpc2libGVSb3cpO1xuXG4gICAgICAgIHZhciBvID0gdGhpcy5fZ2V0Qm91bmRzT2ZDZWxsKGRwT1gsIGRwT1kpO1xuICAgICAgICB2YXIgb3ggPSBNYXRoLnJvdW5kKChvLnggPT09IHVuZGVmaW5lZCkgPyB0aGlzLmdyaWQuZ2V0Rml4ZWRDb2x1bW5zV2lkdGgoKSA6IG8ueCk7XG4gICAgICAgIHZhciBveSA9IE1hdGgucm91bmQoKG8ueSA9PT0gdW5kZWZpbmVkKSA/IHRoaXMuZ3JpZC5nZXRGaXhlZFJvd3NIZWlnaHQoKSA6IG8ueSk7XG4gICAgICAgIC8vIHZhciBvdyA9IG8ud2lkdGg7XG4gICAgICAgIC8vIHZhciBvaCA9IG8uaGVpZ2h0O1xuICAgICAgICB2YXIgZSA9IHRoaXMuX2dldEJvdW5kc09mQ2VsbChkcEVYLCBkcEVZKTtcbiAgICAgICAgdmFyIGV4ID0gTWF0aC5yb3VuZCgoZS54ID09PSB1bmRlZmluZWQpID8gdGhpcy5ncmlkLmdldEZpeGVkQ29sdW1uc1dpZHRoKCkgOiBlLngpO1xuICAgICAgICB2YXIgZXkgPSBNYXRoLnJvdW5kKChlLnkgPT09IHVuZGVmaW5lZCkgPyB0aGlzLmdyaWQuZ2V0Rml4ZWRSb3dzSGVpZ2h0KCkgOiBlLnkpO1xuICAgICAgICAvLyB2YXIgZXcgPSBlLndpZHRoO1xuICAgICAgICAvLyB2YXIgZWggPSBlLmhlaWdodDtcbiAgICAgICAgdmFyIHggPSBNYXRoLm1pbihveCwgZXgpO1xuICAgICAgICB2YXIgeSA9IE1hdGgubWluKG95LCBleSk7XG4gICAgICAgIHZhciB3aWR0aCA9IDEgKyBleCAtIG94O1xuICAgICAgICB2YXIgaGVpZ2h0ID0gMSArIGV5IC0gb3k7XG4gICAgICAgIGlmICh4ID09PSBleCkge1xuICAgICAgICAgICAgd2lkdGggPSBveCAtIGV4O1xuICAgICAgICB9XG4gICAgICAgIGlmICh5ID09PSBleSkge1xuICAgICAgICAgICAgaGVpZ2h0ID0gb3kgLSBleTtcbiAgICAgICAgfVxuICAgICAgICBpZiAod2lkdGggKiBoZWlnaHQgPCAxKSB7XG4gICAgICAgICAgICAvL2lmIHdlIGFyZSBvbmx5IGEgc2tpbm55IGxpbmUsIGRvbid0IHJlbmRlciBhbnl0aGluZ1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLypcblxuICAgICAgICAgIFJlbmRlciB0aGUgc2VsZWN0aW9uIG1vZGVsIGFyb3VuZCB0aGUgYm91bmRzXG5cbiAgICAgICAgICovXG5cbiAgICAgICAgdmFyIGNvbmZpZyA9IHtcbiAgICAgICAgICAgIGJvdW5kczoge1xuICAgICAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZWxlY3Rpb25SZWdpb25PdmVybGF5Q29sb3I6IHRoaXMuZ3JpZC5yZXNvbHZlUHJvcGVydHkoJ3NlbGVjdGlvblJlZ2lvbk92ZXJsYXlDb2xvcicpLFxuICAgICAgICAgICAgc2VsZWN0aW9uUmVnaW9uT3V0bGluZUNvbG9yOiB0aGlzLmdyaWQucmVzb2x2ZVByb3BlcnR5KCdzZWxlY3Rpb25SZWdpb25PdXRsaW5lQ29sb3InKVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdyaWQuY2VsbFJlbmRlcmVycy5nZXQoJ2xhc3RzZWxlY3Rpb24nKS5wYWludChnYywgY29uZmlnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGl0ZXJhdGUgdGhlIHJlbmRlcmVyaW5nIG92ZXJyaWRlcyBhbmQgbWFuaWZlc3QgZWFjaFxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBnY1xuICAgICAqL1xuICAgIHJlbmRlck92ZXJyaWRlczogZnVuY3Rpb24oZ2MpIHtcbiAgICAgICAgdmFyIGNhY2hlID0gdGhpcy5ncmlkLnJlbmRlck92ZXJyaWRlc0NhY2hlO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gY2FjaGUpIHtcbiAgICAgICAgICAgIGlmIChjYWNoZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgdmFyIG92ZXJyaWRlID0gY2FjaGVba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAob3ZlcnJpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJPdmVycmlkZShnYywgb3ZlcnJpZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQGRlc2MgY29weSBlYWNoIG92ZXJyaWRlcyBzcGVjaWZpZWQgYXJlYSB0byBpdCdzIHRhcmdldCBhbmQgYmxhbmsgb3V0IHRoZSBzb3VyY2UgYXJlYVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBnY1xuICAgICAqIEBwYXJhbSB7T3ZlcnJpZGVPYmplY3R9IG92ZXJyaWRlIC0gYW4gb2JqZWN0IHdpdGggZGV0YWlscyBjb250YWluIGFuIGFyZWEgYW5kIGEgdGFyZ2V0IGNvbnRleHRcbiAgICAgKi9cbiAgICByZW5kZXJPdmVycmlkZTogZnVuY3Rpb24oZ2MsIG92ZXJyaWRlKSB7XG4gICAgICAgIC8vbGV0cyBibGFuayBvdXQgdGhlIGRyYWcgcm93XG4gICAgICAgIHZhciBoZHBpUmF0aW8gPSBvdmVycmlkZS5oZHBpcmF0aW87XG4gICAgICAgIC8vdmFyIGVkZ2VzID0gdGhpcy5nZXRDb2x1bW5FZGdlcygpO1xuICAgICAgICB2YXIgc3RhcnRYID0gb3ZlcnJpZGUuc3RhcnRYOyAvL2hkcGlSYXRpbyAqIGVkZ2VzW292ZXJyaWRlLmNvbHVtbkluZGV4XTtcbiAgICAgICAgdmFyIHdpZHRoID0gb3ZlcnJpZGUud2lkdGggKyAxO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gb3ZlcnJpZGUuaGVpZ2h0O1xuICAgICAgICB2YXIgdGFyZ2V0Q1RYID0gb3ZlcnJpZGUuY3R4O1xuICAgICAgICB2YXIgaW1nRGF0YSA9IGdjLmdldEltYWdlRGF0YShzdGFydFgsIDAsIE1hdGgucm91bmQod2lkdGggKiBoZHBpUmF0aW8pLCBNYXRoLnJvdW5kKGhlaWdodCAqIGhkcGlSYXRpbykpO1xuICAgICAgICB0YXJnZXRDVFgucHV0SW1hZ2VEYXRhKGltZ0RhdGEsIDAsIDApO1xuICAgICAgICBnYy5maWxsU3R5bGUgPSB0aGlzLnJlc29sdmVQcm9wZXJ0eSgnYmFja2dyb3VuZENvbG9yMicpO1xuICAgICAgICBnYy5maWxsUmVjdChNYXRoLnJvdW5kKHN0YXJ0WCAvIGhkcGlSYXRpbyksIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge251bWJlcn0gQ3VycmVudCB2ZXJ0aWNhbCBzY3JvbGwgdmFsdWUuXG4gICAgICovXG4gICAgZ2V0U2Nyb2xsVG9wOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JpZC5nZXRWU2Nyb2xsVmFsdWUoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IEN1cnJlbnQgaG9yaXpvbnRhbCBzY3JvbGwgdmFsdWUuXG4gICAgICovXG4gICAgZ2V0U2Nyb2xsTGVmdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyaWQuZ2V0SFNjcm9sbFZhbHVlKCk7XG4gICAgfSxcblxuICAgIGdldENvbHVtbkVkZ2VzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sdW1uRWRnZXM7XG4gICAgfSxcblxuICAgIGdldFJvd0VkZ2VzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm93RWRnZXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVGhlIGxhc3QgY29sIHdhcyByZW5kZXJlZCAoaXMgdmlzaWJsZSlcbiAgICAgKi9cbiAgICBpc0xhc3RDb2x1bW5WaXNpYmxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGxhc3RDb2x1bW5JbmRleCA9IHRoaXMuZ2V0Q29sdW1uQ291bnQoKSAtIDE7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2libGVDb2x1bW5zLmluZGV4T2YobGFzdENvbHVtbkluZGV4KSAhPT0gLTE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgcmVuZGVyZWQgY29sdW1uIHdpZHRoIGF0IGluZGV4XG4gICAgICovXG4gICAgZ2V0UmVuZGVyZWRXaWR0aDogZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29sdW1uRWRnZXMoKVtpbmRleF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgcmVuZGVyZWQgcm93IGhlaWdodCBhdCBpbmRleFxuICAgICAqL1xuICAgIGdldFJlbmRlcmVkSGVpZ2h0OiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb3dFZGdlc1tpbmRleF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7ZmluLWNhbnZhc30gbXkgW2Zpbi1jYW52YXNdKGh0dHBzOi8vZ2l0aHViLmNvbS9zdGV2ZXdpcnRzL2Zpbi1jYW52YXMpXG4gICAgICovXG4gICAgZ2V0Q2FudmFzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JpZC5nZXRDYW52YXMoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBVc2VyIGlzIGN1cnJlbnRseSBkcmFnZ2luZyBhIGNvbHVtbiBmb3IgcmVvcmRlcmluZy5cbiAgICAgKi9cbiAgICBpc0RyYWdnaW5nQ29sdW1uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JpZC5pc0RyYWdnaW5nQ29sdW1uKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgcm93IHRvIGdvdG8gZm9yIGEgcGFnZSB1cC5cbiAgICAgKi9cbiAgICBnZXRQYWdlVXBSb3c6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZ3JpZCA9IHRoaXMuZ3JpZCxcbiAgICAgICAgICAgIHNjcm9sbEhlaWdodCA9IHRoaXMuZ2V0VmlzaWJsZVNjcm9sbEhlaWdodCgpLFxuICAgICAgICAgICAgaGVhZGVyUm93cyA9IHRoaXMuZ3JpZC5nZXRGaXhlZFJvd0NvdW50KCksXG4gICAgICAgICAgICB0b3AgPSB0aGlzLmRhdGFXaW5kb3cub3JpZ2luLnkgLSBoZWFkZXJSb3dzLFxuICAgICAgICAgICAgc2NhbkhlaWdodCA9IDA7XG4gICAgICAgIHdoaWxlIChzY2FuSGVpZ2h0IDwgc2Nyb2xsSGVpZ2h0ICYmIHRvcCA+IC0xKSB7XG4gICAgICAgICAgICBzY2FuSGVpZ2h0ID0gc2NhbkhlaWdodCArIGdyaWQuZ2V0Um93SGVpZ2h0KHRvcCk7XG4gICAgICAgICAgICB0b3AtLTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9wICsgMTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSByb3cgdG8gZ290byBmb3IgYSBwYWdlIGRvd24uXG4gICAgICovXG4gICAgZ2V0UGFnZURvd25Sb3c6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaGVhZGVyUm93cyA9IHRoaXMuZ3JpZC5nZXRGaXhlZFJvd0NvdW50KCk7XG4gICAgICAgIHZhciByb3dOdW0gPSB0aGlzLmRhdGFXaW5kb3cuY29ybmVyLnkgLSBoZWFkZXJSb3dzIC0gMTtcbiAgICAgICAgcmV0dXJuIHJvd051bTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgY29sdW1ucy5cbiAgICAgKi9cbiAgICBnZXRDb2x1bW5Db3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyaWQuZ2V0Q29sdW1uQ291bnQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBudW1iZXIgb2Ygcm93cy5cbiAgICAgKi9cbiAgICBnZXRSb3dDb3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyaWQuZ2V0Um93Q291bnQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgZml4ZWQgY29sdW1ucy5cbiAgICAgKi9cbiAgICBnZXRGaXhlZENvbHVtbkNvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JpZC5nZXRGaXhlZENvbHVtbkNvdW50KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGZpeGVkIHJvd3MuXG4gICAgICovXG4gICAgZ2V0Rml4ZWRSb3dDb3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyaWQuZ2V0Rml4ZWRSb3dDb3VudCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge251bWJlcn0gVGhlIG51bWJlciBvZiBoZWFkZXIgcm93cy5cbiAgICAgKi9cbiAgICBnZXRIZWFkZXJSb3dDb3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyaWQuZ2V0SGVhZGVyUm93Q291bnQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgaGVhZGVyIGNvbHVtbnMuXG4gICAgICovXG4gICAgZ2V0SGVhZGVyQ29sdW1uQ291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ncmlkLmdldEhlYWRlckNvbHVtbkNvdW50KCk7XG4gICAgfSxcblxuICAgIC8qKiBAc3VtbWFyeSBTbWFydCByZW5kZXIgdGhlIGdyaWQuXG4gICAgICogQGRlc2MgUGFpbnQgYWxsIHRoZSBjZWxscyBvZiBhIGdyaWQsIGluY2x1ZGluZyBhbGwgXCJmaXhlZFwiIGNvbHVtbnMgYW5kIHJvd3MuXG4gICAgICogV2Ugc25hcHNob3QgdGhlIGNvbnRleHQgdG8gaW5zdXJlIGFnYWluc3QgaXRzIHBvbGx1dGlvbi5cbiAgICAgKiBgdHJ5Li4uY2F0Y2hgIHN1cnJvdW5kcyBlYWNoIGNlbGwgcGFpbnQgaW4gY2FzZSBhIGNlbGwgZWRpdG9yIHRocm93cyBhbiBlcnJvci5cbiAgICAgKiBUaGUgZXJyb3IgbWVzc2FnZSBpcyBlcnJvci1sb2dnZWQgdG8gY29uc29sZSBBTkQgZGlzcGxheWVkIGluIGNlbGwuXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBnY1xuICAgICAqL1xuICAgIHBhaW50Q2VsbHM6IGZ1bmN0aW9uKGdjKSB7XG4gICAgICAgIHZhciBtZXNzYWdlLFxuICAgICAgICAgICAgY29uZmlnID0ge30sXG4gICAgICAgICAgICB4LCB5LFxuICAgICAgICAgICAgYywgcixcblxuICAgICAgICAgICAgY29sdW1uRWRnZXMgPSB0aGlzLmdldENvbHVtbkVkZ2VzKCksXG4gICAgICAgICAgICByb3dFZGdlcyA9IHRoaXMucm93RWRnZXMsXG5cbiAgICAgICAgICAgIHZpc2libGVDb2xzID0gdGhpcy5nZXRWaXNpYmxlQ29sdW1ucygpLFxuICAgICAgICAgICAgdmlzaWJsZVJvd3MgPSB0aGlzLmdldFZpc2libGVSb3dzKCksXG5cbiAgICAgICAgICAgIGJlaGF2aW9yID0gdGhpcy5ncmlkLmJlaGF2aW9yLFxuXG4gICAgICAgICAgICBjbGlwWCA9IDAsXG4gICAgICAgICAgICBjbGlwWSA9IDAsXG4gICAgICAgICAgICBjbGlwV2lkdGgsXG4gICAgICAgICAgICBjbGlwSGVpZ2h0ID0gdGhpcy5nZXRCb3VuZHMoKS5oZWlnaHQsXG5cbiAgICAgICAgICAgIGxvb3BTdGFydCA9IHRoaXMuZ3JpZC5pc1Nob3dSb3dOdW1iZXJzKCkgPyAtMSA6IDAsXG4gICAgICAgICAgICBsb29wTGVuZ3RoID0gdmlzaWJsZUNvbHMubGVuZ3RoOyAvLyByZWdhcmRsZXNzIG9mIGxvb3BTdGFydCwgZHVlIHRvIGRlZmluaXRpb24gb2YgLmxlbmd0aFxuXG4gICAgICAgIHRoaXMuYnV0dG9uQ2VsbHMgPSB7fTtcblxuICAgICAgICBpZiAobG9vcExlbmd0aCkgeyAvLyB0aGlzIGlmIHByZXZlbnRzIHBhaW50aW5nIGp1c3QgdGhlIGZpeGVkIGNvbHVtbnMgd2hlbiB0aGVyZSBhcmUgbm8gdmlzaWJsZSBjb2x1bW5zXG5cbiAgICAgICAgICAgIC8vIEZvciBlYWNoIGNvbHVtbi4uLlxuICAgICAgICAgICAgZm9yICh4ID0gbG9vcFN0YXJ0OyB4IDwgbG9vcExlbmd0aDsgeCsrLCBjbGlwWCArPSBjbGlwV2lkdGgpIHtcblxuICAgICAgICAgICAgICAgIGMgPSB2aXNpYmxlQ29sc1t4XTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVkQ29sdW1uTWluV2lkdGhzW2NdID0gMDtcblxuICAgICAgICAgICAgICAgIGdjLnNhdmUoKTtcblxuICAgICAgICAgICAgICAgIC8vIENsaXAgdG8gdmlzaWJsZSBwb3J0aW9uIG9mIGNvbHVtbiB0byBwcmV2ZW50IG92ZXJmbG93IHRvIHJpZ2h0LiBQcmV2aW91c2x5IHdlIGNsaXBwZWQgdG8gZW50aXJlIHZpc2libGUgZ3JpZCBhbmQgZGVhbHQgd2l0aCBvdmVyZmxvdyBieSBvdmVycGFpbnRpbmcgd2l0aCBuZXh0IGNvbHVtbi4gSG93ZXZlciwgdGhpcyBzdHJhdGVneSBmYWlscyB3aGVuIHRyYW5zcGFyZW50IGJhY2tncm91bmQgKG5vIGJhY2tncm91bmQgY29sb3IpLlxuICAgICAgICAgICAgICAgIC8vIFRPRE86IGlmIGV4dHJhIGNsaXAoKSBjYWxscyBwZXIgY29sdW1uIGFmZmVjdCBwZXJmb3JtYW5jZSAobm90IHRoZSBjbGlwcGluZyBpdHNlbGYgd2hpY2ggd2FzIGhhcHBlbmluZyBhbnl3YXksIGJ1dCB0aGUgY2xpcCBjYWxscyB3aGljaCBzZXQgdXAgdGhlIGNsaXBwaW5nKSwgdXNlIHByZXZpb3VzIHN0cmF0ZWd5IHdoZW4gdGhlcmUgaXMgYSBiYWNrZ3JvdW5kIGNvbG9yXG4gICAgICAgICAgICAgICAgY2xpcFdpZHRoID0gY29sdW1uRWRnZXNbeCArIDFdIC0gY2xpcFg7XG4gICAgICAgICAgICAgICAgZ2MuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgZ2MucmVjdChjbGlwWCwgY2xpcFksIGNsaXBXaWR0aCwgY2xpcEhlaWdodCk7XG4gICAgICAgICAgICAgICAgZ2MuY2xpcCgpO1xuXG4gICAgICAgICAgICAgICAgLy8gRm9yIGVhY2ggcm93IChvZiBlYWNoIGNvbHVtbikuLi5cbiAgICAgICAgICAgICAgICBmb3IgKHkgPSAwOyB5IDwgdmlzaWJsZVJvd3MubGVuZ3RoOyB5KyspIHtcblxuICAgICAgICAgICAgICAgICAgICByID0gdmlzaWJsZVJvd3NbeV07XG5cbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFpbnRDZWxsKGdjLCBjLCByKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy9pZiAociA9PT0gOSAmJiBjID09PSAyKSB7IHRocm93IEVycm9yKCdTaGUgc2VsbHMgc2VhIHNoZWxscyBieSB0aGUgc2VhIHNob3JlLicpOyB9XG5cbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gZSAmJiAoZS5tZXNzYWdlIHx8IGUpIHx8ICdVbmtub3duIGVycm9yLic7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByYXdHYyA9IGdjLmdjIHx8IGdjLCAvLyBEb24ndCBsb2cgdGhlc2UgY2FudmFzIGNhbGxzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyWSA9IHJvd0VkZ2VzW3ldLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVyckhlaWdodCA9IHJvd0VkZ2VzW3kgKyAxXSAtIGVyclk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJhd0djLnNhdmUoKTsgLy8gZGVmaW5lIGNsaXBwaW5nIHJlZ2lvblxuICAgICAgICAgICAgICAgICAgICAgICAgcmF3R2MuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByYXdHYy5yZWN0KGNsaXBYLCBlcnJZLCBjbGlwV2lkdGgsIGVyckhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByYXdHYy5jbGlwKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWcgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm91bmRzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IGVyclksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IGNsaXBYLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGVyckhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGNsaXBXaWR0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ3JpZC5jZWxsUmVuZGVyZXJzLmdldCgnZXJyb3JjZWxsJykucGFpbnQocmF3R2MsIGNvbmZpZywgbWVzc2FnZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJhd0djLnJlc3RvcmUoKTsgLy8gZGlzY2FyZCBjbGlwcGluZyByZWdpb25cblxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQm90dG9tIHRvdGFscyByb3dzLi4uXG4gICAgICAgICAgICAgICAgZm9yICh5ID0gLWJlaGF2aW9yLmRhdGFNb2RlbC5nZXRCb3R0b21Ub3RhbHMoKS5sZW5ndGg7IHk7IHkrKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYWludENlbGwoZ2MsIGMsIHkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGdjLnJlc3RvcmUoKTsgLy8gUmVtb3ZlIGNvbHVtbidzIGNsaXAgcmVnaW9uIChhbmQgYW55dGhpbmcgZWxzZSByZW5kZXJDZWxsRXJyb3IoKSBtaWdodCBoYXZlIHNldClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHNldE51bWJlckNvbHVtbldpZHRoKGdjLCBiZWhhdmlvciwgdGhpcy5ncmlkLmdldFJvd0NvdW50KCkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQGRlc2MgV2Ugb3B0ZWQgdG8gbm90IHBhaW50IGJvcmRlcnMgZm9yIGVhY2ggY2VsbCBhcyB0aGF0IHdhcyBleHRyZW1lbHkgZXhwZW5zaXZlLiBJbnN0ZWFkIHdlIGRyYXcgZ3JpZGxpbmVzIGhlcmUuIEFsc28gd2UgcmVjb3JkIHRoZSB3aWR0aHMgYW5kIGhlaWdodHMgZm9yIGxhdGVyLlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBnY1xuICAgICAqL1xuICAgIHBhaW50R3JpZGxpbmVzOiBmdW5jdGlvbihnYykge1xuICAgICAgICB2YXIgeCwgeSwgYywgciA9IDA7XG5cbiAgICAgICAgdmFyIGNvbFdpZHRocyA9IHRoaXMuZ2V0Q29sdW1uRWRnZXMoKTtcbiAgICAgICAgdmFyIHJvd0hlaWdodHMgPSB0aGlzLnJvd0VkZ2VzO1xuICAgICAgICB2YXIgdmlld0hlaWdodDtcbiAgICAgICAgdmFyIHZpZXdXaWR0aCA9IGNvbFdpZHRoc1tjb2xXaWR0aHMubGVuZ3RoIC0gMV07XG4gICAgICAgIHZhciBkcmF3VGhlbUggPSB0aGlzLnJlc29sdmVQcm9wZXJ0eSgnZ3JpZExpbmVzSCcpO1xuICAgICAgICB2YXIgZHJhd1RoZW1WT3ZlcmZsb3cgPSB0aGlzLnJlc29sdmVQcm9wZXJ0eSgnZ3JpZExpbmVzVk92ZXJmbG93Jyk7XG4gICAgICAgIHZhciBkcmF3VGhlbVYgPSB0aGlzLnJlc29sdmVQcm9wZXJ0eSgnZ3JpZExpbmVzVicpO1xuICAgICAgICB2YXIgbGluZUNvbG9yID0gdGhpcy5yZXNvbHZlUHJvcGVydHkoJ2xpbmVDb2xvcicpO1xuICAgICAgICBpZiAoZHJhd1RoZW1WT3ZlcmZsb3cpe1xuICAgICAgICAgICAgdmlld0hlaWdodCA9IHRoaXMuZ2V0Qm91bmRzKCkuaGVpZ2h0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmlld0hlaWdodCA9IHJvd0hlaWdodHNbcm93SGVpZ2h0cy5sZW5ndGggLSAxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdjLmJlZ2luUGF0aCgpO1xuXG4gICAgICAgIGlmIChkcmF3VGhlbVYpIHtcbiAgICAgICAgICAgIGZvciAoYyA9IDA7IGMgPCBjb2xXaWR0aHMubGVuZ3RoICsgMTsgYysrKSB7XG4gICAgICAgICAgICAgICAgeCA9IGNvbFdpZHRoc1tjXSArIDAuNTtcbiAgICAgICAgICAgICAgICBnYy5tb3ZlVG8oeCwgMCk7XG4gICAgICAgICAgICAgICAgZ2MubGluZVRvKHgsIHZpZXdIZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRyYXdUaGVtSCkge1xuICAgICAgICAgICAgZm9yIChyID0gMDsgciA8IHJvd0hlaWdodHMubGVuZ3RoIC0gMTsgcisrKSB7XG4gICAgICAgICAgICAgICAgeSA9IHJvd0hlaWdodHNbcl0gKyAwLjU7XG4gICAgICAgICAgICAgICAgZ2MubW92ZVRvKDAsIHkpO1xuICAgICAgICAgICAgICAgIGdjLmxpbmVUbyh2aWV3V2lkdGgsIHkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBCb3R0b20gdG90YWxzIHJvd3MuLi5cbiAgICAgICAgICAgIHZhciBiZWhhdmlvciA9IHRoaXMuZ3JpZC5iZWhhdmlvcixcbiAgICAgICAgICAgICAgICByb3dIZWlnaHQgPSBiZWhhdmlvci5nZXREZWZhdWx0Um93SGVpZ2h0KCk7XG4gICAgICAgICAgICBmb3IgKHIgPSAtYmVoYXZpb3IuZGF0YU1vZGVsLmdldEJvdHRvbVRvdGFscygpLmxlbmd0aCwgeSA9IHRoaXMuZ2V0Qm91bmRzKCkuaGVpZ2h0OyByOyByKyspIHtcbiAgICAgICAgICAgICAgICB5IC09IHJvd0hlaWdodDtcbiAgICAgICAgICAgICAgICBnYy5tb3ZlVG8oMCwgeSk7XG4gICAgICAgICAgICAgICAgZ2MubGluZVRvKHZpZXdXaWR0aCwgeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBnYy5jbG9zZVBhdGgoKTtcblxuICAgICAgICBnYy5zdHJva2VTdHlsZSA9IGxpbmVDb2xvcjtcbiAgICAgICAgZ2MubGluZVdpZHRoID0gdGhpcy5yZXNvbHZlUHJvcGVydHkoJ2xpbmVXaWR0aCcpO1xuICAgICAgICBnYy5zdHJva2UoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBnY1xuICAgICAqIEBwYXJhbSB4XG4gICAgICogQHBhcmFtIHlcbiAgICAgKi9cbiAgICBwYWludENlbGw6IGZ1bmN0aW9uKGdjLCB4LCB5KSB7XG4gICAgICAgIGdjLm1vdmVUbygwLCAwKTtcblxuICAgICAgICB2YXIgYyA9IHRoaXMuZ2V0VmlzaWJsZUNvbHVtbnMoKVt4XSxcbiAgICAgICAgICAgIHIgPSB0aGlzLmdldFZpc2libGVSb3dzKClbeV07XG5cbiAgICAgICAgaWYgKGMpIHsgLy9zb21ldGhpbmcgaXMgYmVpbmcgdmlld2VkIGF0IGF0IHRoZSBtb21lbnQgKG90aGVyd2lzZSByZXR1cm5zIHVuZGVmaW5lZClcbiAgICAgICAgICAgIHRoaXMuX3BhaW50Q2VsbChnYywgYywgcik7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX3BhaW50Q2VsbDogZnVuY3Rpb24oZ2MsIGMsIHIpIHtcblxuICAgICAgICB2YXIgZ3JpZCA9IHRoaXMuZ3JpZCxcbiAgICAgICAgICAgIGJlaGF2aW9yID0gZ3JpZC5iZWhhdmlvcixcbiAgICAgICAgICAgIGJhc2VQcm9wZXJ0aWVzID0gYmVoYXZpb3IuZ2V0Q29sdW1uUHJvcGVydGllcyhjKTtcblxuICAgICAgICBpZiAoYmFzZVByb3BlcnRpZXMuaXNOdWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY29sdW1uUHJvcGVydGllcyA9IGJhc2VQcm9wZXJ0aWVzLFxuXG4gICAgICAgICAgICBoZWFkZXJSb3dDb3VudCA9IGJlaGF2aW9yLmdldEhlYWRlclJvd0NvdW50KCksXG4gICAgICAgICAgICBpc0dyaWRSb3cgPSByID49IGhlYWRlclJvd0NvdW50LFxuICAgICAgICAgICAgaXNGb290ZXJSb3cgPSByIDwgMCxcbiAgICAgICAgICAgIGlzSGVhZGVyUm93ID0gIWlzR3JpZFJvdyAmJiAhaXNGb290ZXJSb3csXG4gICAgICAgICAgICBpc0ZpbHRlclJvdyA9IGdyaWQuaXNGaWx0ZXJSb3cociksXG5cbiAgICAgICAgICAgIGhlYWRlckNvbHVtbkNvdW50ID0gYmVoYXZpb3IuZ2V0SGVhZGVyQ29sdW1uQ291bnQoKSxcbiAgICAgICAgICAgIGlzR3JpZENvbHVtbiA9IGMgPj0gaGVhZGVyQ29sdW1uQ291bnQsXG4gICAgICAgICAgICBpc1Nob3dSb3dOdW1iZXJzID0gZ3JpZC5pc1Nob3dSb3dOdW1iZXJzKCksXG4gICAgICAgICAgICBpc0hpZXJhcmNoeUNvbHVtbiA9IGdyaWQuaXNIaWVyYXJjaHlDb2x1bW4oYyksXG5cbiAgICAgICAgICAgIGlzUm93U2VsZWN0ZWQgPSBncmlkLmlzUm93U2VsZWN0ZWQociksXG4gICAgICAgICAgICBpc0NvbHVtblNlbGVjdGVkID0gZ3JpZC5pc0NvbHVtblNlbGVjdGVkKGMpLFxuICAgICAgICAgICAgaXNDZWxsU2VsZWN0ZWQgPSBncmlkLmlzQ2VsbFNlbGVjdGVkKGMsIHIpLFxuICAgICAgICAgICAgaXNDZWxsU2VsZWN0ZWRJbkNvbHVtbiA9IGdyaWQuaXNDZWxsU2VsZWN0ZWRJbkNvbHVtbihjKSxcbiAgICAgICAgICAgIGlzQ2VsbFNlbGVjdGVkSW5Sb3cgPSBncmlkLmlzQ2VsbFNlbGVjdGVkSW5Sb3cociksXG4gICAgICAgICAgICBhcmVBbGxSb3dzU2VsZWN0ZWQgPSBncmlkLmFyZUFsbFJvd3NTZWxlY3RlZCgpLFxuICAgICAgICAgICAgY2VsbFByb3BlcnRpZXM7XG5cbiAgICAgICAgaWYgKChpc1Nob3dSb3dOdW1iZXJzICYmIGMgPT09IC0xKSB8fCBpc0hpZXJhcmNoeUNvbHVtbikge1xuICAgICAgICAgICAgaWYgKGlzUm93U2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICBjZWxsUHJvcGVydGllcyA9IE9iamVjdC5jcmVhdGUoYmFzZVByb3BlcnRpZXMucm93SGVhZGVyUm93U2VsZWN0aW9uKTtcbiAgICAgICAgICAgICAgICBjZWxsUHJvcGVydGllcy5pc1NlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2VsbFByb3BlcnRpZXMgPSBPYmplY3QuY3JlYXRlKGJhc2VQcm9wZXJ0aWVzLnJvd0hlYWRlcik7XG4gICAgICAgICAgICAgICAgY2VsbFByb3BlcnRpZXMuaXNTZWxlY3RlZCA9IGlzQ2VsbFNlbGVjdGVkSW5Sb3c7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjZWxsUHJvcGVydGllcy5pc1VzZXJEYXRhQXJlYSA9IGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKGlzSGVhZGVyUm93IHx8IGlzRm9vdGVyUm93KSB7XG4gICAgICAgICAgICBpZiAoaXNGaWx0ZXJSb3cpIHtcbiAgICAgICAgICAgICAgICBjZWxsUHJvcGVydGllcyA9IE9iamVjdC5jcmVhdGUoYmFzZVByb3BlcnRpZXMuZmlsdGVyUHJvcGVydGllcyk7XG4gICAgICAgICAgICAgICAgY2VsbFByb3BlcnRpZXMuaXNTZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc0NvbHVtblNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgY2VsbFByb3BlcnRpZXMgPSBPYmplY3QuY3JlYXRlKGJhc2VQcm9wZXJ0aWVzLmNvbHVtbkhlYWRlckNvbHVtblNlbGVjdGlvbik7XG4gICAgICAgICAgICAgICAgY2VsbFByb3BlcnRpZXMuaXNTZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNlbGxQcm9wZXJ0aWVzID0gT2JqZWN0LmNyZWF0ZShiYXNlUHJvcGVydGllcy5jb2x1bW5IZWFkZXIpO1xuICAgICAgICAgICAgICAgIGNlbGxQcm9wZXJ0aWVzLmlzU2VsZWN0ZWQgPSBpc0NlbGxTZWxlY3RlZEluQ29sdW1uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2VsbFByb3BlcnRpZXMuaXNVc2VyRGF0YUFyZWEgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0hpZXJhcmNoeUNvbHVtbikge1xuICAgICAgICAgICAgY2VsbFByb3BlcnRpZXMgPSBPYmplY3QuY3JlYXRlKGJhc2VQcm9wZXJ0aWVzLnJvd0hlYWRlcik7XG4gICAgICAgICAgICBjZWxsUHJvcGVydGllcy5pc1NlbGVjdGVkID0gaXNDZWxsU2VsZWN0ZWRJblJvdztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNlbGxQcm9wZXJ0aWVzID0gT2JqZWN0LmNyZWF0ZShiYXNlUHJvcGVydGllcyk7XG4gICAgICAgICAgICBjZWxsUHJvcGVydGllcy5pc1NlbGVjdGVkID0gaXNDZWxsU2VsZWN0ZWQgfHwgaXNSb3dTZWxlY3RlZCB8fCBpc0NvbHVtblNlbGVjdGVkO1xuICAgICAgICAgICAgY2VsbFByb3BlcnRpZXMuaXNVc2VyRGF0YUFyZWEgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJvd051bSA9IHIgLSBoZWFkZXJSb3dDb3VudCArIDE7XG5cbiAgICAgICAgaWYgKGMgPT09IC0xKSB7XG4gICAgICAgICAgICBpZiAociA9PT0gMCkgeyAvLyBoZWFkZXIgcm93IGdldHMgXCJtYXN0ZXJcIiBjaGVja2JveFxuICAgICAgICAgICAgICAgIGNlbGxQcm9wZXJ0aWVzLnZhbHVlID0gW2ltYWdlcy5jaGVja2JveChhcmVBbGxSb3dzU2VsZWN0ZWQpLCAnJywgbnVsbF07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzRmlsdGVyUm93KSB7IC8vIG5vIGNoZWNrYm94IGJ1dCBzaG93IGZpbHRlciBpY29uXG4gICAgICAgICAgICAgICAgY2VsbFByb3BlcnRpZXMudmFsdWUgPSBbaW1hZ2VzLmZpbHRlcihmYWxzZSksICcnLCBudWxsXTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNIZWFkZXJSb3cgfHwgaXNGb290ZXJSb3cpIHsgLy8gbm8gY2hlY2tib3ggb24gXCJ0b3RhbHNcIiByb3dzXG4gICAgICAgICAgICAgICAgY2VsbFByb3BlcnRpZXMudmFsdWUgPSAnJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2VsbFByb3BlcnRpZXMudmFsdWUgPSBbaW1hZ2VzLmNoZWNrYm94KGlzUm93U2VsZWN0ZWQpLCByb3dOdW0sIG51bGxdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2VsbFByb3BlcnRpZXMuaGFsaWduID0gJ3JpZ2h0JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHNldCBkYXRhUm93IGFuZCBjb2x1bW5OYW1lIHVzZWQgYnkgdmFsT3JGdW5jIChuZWVkZWQgd2hlbiBmdW5jKVxuICAgICAgICAgICAgdmFyIGNvbHVtbiA9IGJlaGF2aW9yLmdldEFjdGl2ZUNvbHVtbihjKTtcbiAgICAgICAgICAgIGNlbGxQcm9wZXJ0aWVzLmRhdGFSb3cgPSBncmlkLmdldFJvdyhyKTtcbiAgICAgICAgICAgIGNlbGxQcm9wZXJ0aWVzLmNvbHVtbk5hbWUgPSBjb2x1bW4ubmFtZTtcblxuICAgICAgICAgICAgY2VsbFByb3BlcnRpZXMudmFsdWUgPSBncmlkLmdldFZhbHVlKGMsIHIpO1xuICAgICAgICAgICAgY2VsbFByb3BlcnRpZXMuaGFsaWduID0gZ3JpZC5nZXRDb2x1bW5BbGlnbm1lbnQoYyk7XG4gICAgICAgIH1cblxuICAgICAgICBjZWxsUHJvcGVydGllcy5pc0dyaWRDb2x1bW4gPSBpc0dyaWRDb2x1bW47XG4gICAgICAgIGNlbGxQcm9wZXJ0aWVzLmlzR3JpZFJvdyA9IGlzR3JpZFJvdztcbiAgICAgICAgY2VsbFByb3BlcnRpZXMuaXNDb2x1bW5Ib3ZlcmVkID0gZ3JpZC5pc0NvbHVtbkhvdmVyZWQoYykgJiYgaXNHcmlkQ29sdW1uO1xuICAgICAgICBjZWxsUHJvcGVydGllcy5pc1Jvd0hvdmVyZWQgPSBncmlkLmlzUm93SG92ZXJlZChyKSAmJiBpc0dyaWRSb3c7XG4gICAgICAgIGNlbGxQcm9wZXJ0aWVzLmlzQ2VsbEhvdmVyZWQgPSBncmlkLmlzSG92ZXJlZChjLCByKSAmJiBpc0dyaWRDb2x1bW4gJiYgaXNHcmlkUm93O1xuICAgICAgICBjZWxsUHJvcGVydGllcy5ib3VuZHMgPSB0aGlzLl9nZXRCb3VuZHNPZkNlbGwoYywgcik7XG4gICAgICAgIGNlbGxQcm9wZXJ0aWVzLmlzQ2VsbFNlbGVjdGVkID0gaXNDZWxsU2VsZWN0ZWQ7XG4gICAgICAgIGNlbGxQcm9wZXJ0aWVzLmlzUm93U2VsZWN0ZWQgPSBpc1Jvd1NlbGVjdGVkO1xuICAgICAgICBjZWxsUHJvcGVydGllcy5pc0NvbHVtblNlbGVjdGVkID0gaXNDb2x1bW5TZWxlY3RlZDtcbiAgICAgICAgY2VsbFByb3BlcnRpZXMuaXNJbkN1cnJlbnRTZWxlY3Rpb25SZWN0YW5nbGUgPSBncmlkLmlzSW5DdXJyZW50U2VsZWN0aW9uUmVjdGFuZ2xlKGMsIHIpO1xuXG4gICAgICAgIGlmIChncmlkLm1vdXNlRG93blN0YXRlKSB7XG4gICAgICAgICAgICB2YXIgcG9pbnQgPSBncmlkLm1vdXNlRG93blN0YXRlLmdyaWRDZWxsO1xuICAgICAgICAgICAgY2VsbFByb3BlcnRpZXMubW91c2VEb3duID0gcG9pbnQueCA9PT0gYyAmJiBwb2ludC55ID09PSByO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNlbGwgPSBiZWhhdmlvci5nZXRDZWxsUmVuZGVyZXIoY2VsbFByb3BlcnRpZXMsIGMsIHIpO1xuXG4gICAgICAgIGJlaGF2aW9yLmNlbGxQcm9wZXJ0aWVzUHJlUGFpbnROb3RpZmljYXRpb24oY2VsbFByb3BlcnRpZXMpO1xuXG4gICAgICAgIC8vZGVjbGFyYXRpdmUgY2VsbCBwcm9wZXJ0aWVzXG4gICAgICAgIGlmIChpc0dyaWRSb3cgJiYgaXNHcmlkQ29sdW1uKSB7XG4gICAgICAgICAgICB2YXIgb3ZlcnJpZGVzID0gYmVoYXZpb3IuZ2V0Q2VsbFByb3BlcnRpZXMoY29sdW1uLmluZGV4LCByKTtcbiAgICAgICAgICAgIF8oY2VsbFByb3BlcnRpZXMpLmV4dGVuZE93bihvdmVycmlkZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9hbGxvdyB0aGUgcmVuZGVyZXIgdG8gaWRlbnRpZnkgaXRzZWxmIGlmIGl0J3MgYSBidXR0b25cbiAgICAgICAgY2VsbFByb3BlcnRpZXMuYnV0dG9uQ2VsbHMgPSB0aGlzLmJ1dHRvbkNlbGxzO1xuXG4gICAgICAgIGNlbGxQcm9wZXJ0aWVzLmZvcm1hdFZhbHVlID0gZ3JpZC5nZXRGb3JtYXR0ZXIoY2VsbFByb3BlcnRpZXMuaXNVc2VyRGF0YUFyZWEgJiYgY2VsbFByb3BlcnRpZXMuZm9ybWF0KTtcbiAgICAgICAgY2VsbC5wYWludChnYywgY2VsbFByb3BlcnRpZXMpO1xuXG4gICAgICAgIHRoaXMucmVuZGVyZWRDb2x1bW5NaW5XaWR0aHNbY10gPSBNYXRoLm1heChjZWxsUHJvcGVydGllcy5taW5XaWR0aCB8fCAwLCB0aGlzLnJlbmRlcmVkQ29sdW1uTWluV2lkdGhzW2NdKTtcbiAgICAgICAgY29sdW1uUHJvcGVydGllcy5wcmVmZXJyZWRXaWR0aCA9IHRoaXMucmVuZGVyZWRDb2x1bW5NaW5XaWR0aHNbY107XG4gICAgfSxcblxuICAgIGlzVmlld2FibGVCdXR0b246IGZ1bmN0aW9uKGMsIHIpIHtcbiAgICAgICAgdmFyIGtleSA9IGMgKyAnLCcgKyByO1xuICAgICAgICByZXR1cm4gdGhpcy5idXR0b25DZWxsc1trZXldID09PSB0cnVlO1xuICAgIH0sXG5cbiAgICBnZXRSb3dOdW1iZXJzV2lkdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY29sRWRnZXMgPSB0aGlzLmdldENvbHVtbkVkZ2VzKCk7XG4gICAgICAgIGlmIChjb2xFZGdlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2xFZGdlc1swXTtcbiAgICB9LFxuXG4gICAgc3RhcnRBbmltYXRvcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uIGFuaW1hdGUoKSB7XG4gICAgICAgICAgICBzZWxmLmFuaW1hdGUoKTtcbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShhbmltYXRlKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIGFuaW1hdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY3R4ID0gdGhpcy5nZXRDYW52YXMoKS5jYW52YXNDVFg7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgdGhpcy5yZW5kZXJMYXN0U2VsZWN0aW9uKGN0eCk7XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICB9LFxuXG4gICAgZ2V0Qm91bmRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYm91bmRzO1xuICAgIH0sXG5cbiAgICBzZXRCb3VuZHM6IGZ1bmN0aW9uKGJvdW5kcykge1xuICAgICAgICByZXR1cm4gKHRoaXMuYm91bmRzID0gYm91bmRzKTtcbiAgICB9XG5cbn0pO1xuXG5mdW5jdGlvbiBzZXROdW1iZXJDb2x1bW5XaWR0aChnYywgYmVoYXZpb3IsIG1heFJvdykge1xuICAgIHZhciBjb2x1bW5Qcm9wZXJ0aWVzID0gYmVoYXZpb3IuZ2V0Q29sdW1uUHJvcGVydGllcygtMSksXG4gICAgICAgIGNlbGxQcm9wZXJ0aWVzID0gY29sdW1uUHJvcGVydGllcy5yb3dIZWFkZXIsXG4gICAgICAgIGljb24gPSBpbWFnZXMuY2hlY2tlZDtcblxuICAgIGdjLmZvbnQgPSBjZWxsUHJvcGVydGllcy5mb250O1xuXG4gICAgY29sdW1uUHJvcGVydGllcy5wcmVmZXJyZWRXaWR0aCA9IGljb24ud2lkdGggKyA3ICsgY2VsbFByb3BlcnRpZXMuZ2V0VGV4dFdpZHRoKGdjLCBtYXhSb3cgKyAxKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZW5kZXJlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFJhbmdlU2VsZWN0aW9uTW9kZWwgPSByZXF1aXJlKCdzcGFyc2UtYm9vbGVhbi1hcnJheScpO1xuXG4vKipcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBkZXNjIFdlIHJlcHJlc2VudCBzZWxlY3Rpb25zIGFzIGEgbGlzdCBvZiByZWN0YW5nbGVzIGJlY2F1c2UgbGFyZ2UgYXJlYXMgY2FuIGJlIHJlcHJlc2VudGVkIGFuZCB0ZXN0ZWQgYWdhaW5zdCBxdWlja2x5IHdpdGggYSBtaW5pbWFsIGFtb3VudCBvZiBtZW1vcnkgdXNhZ2UuIEFsc28gd2UgbmVlZCB0byBtYWludGFpbiB0aGUgc2VsZWN0aW9uIHJlY3RhbmdsZXMgZmxhdHRlbmVkIGNvdW50ZXIgcGFydHMgc28gd2UgY2FuIHRlc3QgZm9yIHNpbmdsZSBkaW1lbnNpb24gY29udGFpbnMuIFRoaXMgaXMgaG93IHdlIGtub3cgdG8gaGlnaGxpZ2h0IHRoZSBmaXhlZCByZWdpb25zIG9uIHRoZSBlZGdlcyBvZiB0aGUgZ3JpZC5cbiAqL1xuXG5mdW5jdGlvbiBTZWxlY3Rpb25Nb2RlbChncmlkKSB7XG5cbiAgICB0aGlzLmdyaWQgPSBncmlkO1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgc2VsZWN0aW9uc1xuICAgICAqIEB0eXBlIHtSZWN0YW5nbGVbXX1cbiAgICAgKiBAc3VtbWFyeSBUaGUgc2VsZWN0aW9uIHJlY3RhbmdsZXMuXG4gICAgICogQGRlc2MgQ3JlYXRlZCBhcyBhbiBlbXB0eSBhcnJheSB1cG9uIGluc3RhbnRpYXRpb24gYnkgdGhlIHtAbGluayBTZWxlY3Rpb25Nb2RlbHxjb25zdHJ1Y3Rvcn0uXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHRoaXMuc2VsZWN0aW9ucyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgZmxhdHRlbmVkWFxuICAgICAqIEB0eXBlIHtSZWN0YW5nbGVbXX1cbiAgICAgKiBAc3VtbWFyeSBUaGUgc2VsZWN0aW9uIHJlY3RhbmdsZXMgZmxhdHRlbmVkIGluIHRoZSBob3Jpem9udGFsIGRpcmVjdGlvbiAobm8gd2lkdGgpLlxuICAgICAqIEBkZXNjIENyZWF0ZWQgYXMgYW4gZW1wdHkgYXJyYXkgdXBvbiBpbnN0YW50aWF0aW9uIGJ5IHRoZSB7QGxpbmsgU2VsZWN0aW9uTW9kZWx8Y29uc3RydWN0b3J9LlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICB0aGlzLmZsYXR0ZW5lZFggPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIGZsYXR0ZW5lZFlcbiAgICAgKiBAdHlwZSB7UmVjdGFuZ2xlW119XG4gICAgICogQHN1bW1hcnkgVGhlIHNlbGVjdGlvbiByZWN0YW5nbGVzIGZsYXR0ZW5lZCBpbiB0aGUgdmVydGljYWwgZGlyZWN0aW9uIChubyBoZWlnaHQpLlxuICAgICAqIEBkZXNjIENyZWF0ZWQgYXMgYW4gZW1wdHkgYXJyYXkgdXBvbiBpbnN0YW50aWF0aW9uIGJ5IHRoZSB7QGxpbmsgU2VsZWN0aW9uTW9kZWx8Y29uc3RydWN0b3J9LlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICB0aGlzLmZsYXR0ZW5lZFkgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIHJvd1NlbGVjdGlvbk1vZGVsXG4gICAgICogQHR5cGUge1JhbmdlU2VsZWN0aW9uTW9kZWx9XG4gICAgICogQHN1bW1hcnkgVGhlIHNlbGVjdGlvbiByZWN0YW5nbGVzLlxuICAgICAqIEBkZXNjIENyZWF0ZWQgYXMgYSBuZXcgUmFuZ2VTZWxlY3Rpb25Nb2RlbCB1cG9uIGluc3RhbnRpYXRpb24gYnkgdGhlIHtAbGluayBTZWxlY3Rpb25Nb2RlbHxjb25zdHJ1Y3Rvcn0uXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHRoaXMucm93U2VsZWN0aW9uTW9kZWwgPSBuZXcgUmFuZ2VTZWxlY3Rpb25Nb2RlbCgpO1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgY29sdW1uU2VsZWN0aW9uTW9kZWxcbiAgICAgKiBAdHlwZSB7UmFuZ2VTZWxlY3Rpb25Nb2RlbH1cbiAgICAgKiBAc3VtbWFyeSBUaGUgc2VsZWN0aW9uIHJlY3RhbmdsZXMuXG4gICAgICogQGRlc2MgQ3JlYXRlZCBhcyBhIG5ldyBSYW5nZVNlbGVjdGlvbk1vZGVsIHVwb24gaW5zdGFudGlhdGlvbiBieSB0aGUge0BsaW5rIFNlbGVjdGlvbk1vZGVsfGNvbnN0cnVjdG9yfS5cbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICovXG4gICAgdGhpcy5jb2x1bW5TZWxlY3Rpb25Nb2RlbCA9IG5ldyBSYW5nZVNlbGVjdGlvbk1vZGVsKCk7XG5cbiAgICB0aGlzLnNldExhc3RTZWxlY3Rpb25UeXBlKCcnKTtcbn1cblxuU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlID0ge1xuXG4gICAgY29uc3RydWN0b3I6IFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZS5jb25zdHJ1Y3RvcixcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBhbGxSb3dzU2VsZWN0ZWQ6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGdldExhc3RTZWxlY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VscyA9IHRoaXMuc2VsZWN0aW9ucztcbiAgICAgICAgdmFyIHNlbCA9IHNlbHNbc2Vscy5sZW5ndGggLSAxXTtcbiAgICAgICAgcmV0dXJuIHNlbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGdldExhc3RTZWxlY3Rpb25UeXBlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGFzdFNlbGVjdGlvblR5cGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB0eXBlXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHNldExhc3RTZWxlY3Rpb25UeXBlOiBmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgIHRoaXMubGFzdFNlbGVjdGlvblR5cGUgPSB0eXBlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICogQGRlc2NyaXB0aW9uIFNlbGVjdCB0aGUgcmVnaW9uIGRlc2NyaWJlZCBieSB0aGUgZ2l2ZW4gY29vcmRpbmF0ZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb3ggLSBvcmlnaW4geCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG95IC0gb3JpZ2luIHkgY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBleCAtIGV4dGVudCB4IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZXkgLSBleHRlbnQgeSBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBzaWxlbnQgLSB3aGV0aGVyIHRvIGZpcmUgc2VsZWN0aW9uIGNoYW5nZWQgZXZlbnRcbiAgICAgKi9cbiAgICBzZWxlY3Q6IGZ1bmN0aW9uKG94LCBveSwgZXgsIGV5LCBzaWxlbnQpIHtcbiAgICAgICAgdmFyIG5ld1NlbGVjdGlvbiA9IHRoaXMuZ3JpZC5uZXdSZWN0YW5nbGUob3gsIG95LCBleCwgZXkpO1xuICAgICAgICBuZXdTZWxlY3Rpb24uZmlyc3RTZWxlY3RlZENlbGwgPSB0aGlzLmdyaWQubmV3UG9pbnQob3gsIG95KTsgLy9DYWNoZSB0aGUgZmlyc3Qgc2VsZWN0ZWQgY2VsbCBiZWZvcmUgaXQgZ2V0cyBub3JtYWxpemVkIHRvIHRvcC1sZWZ0IG9yaWdpblxuICAgICAgICBuZXdTZWxlY3Rpb24ubGFzdFNlbGVjdGVkQ2VsbCA9IChcbiAgICAgICAgICAgIChuZXdTZWxlY3Rpb24uZmlyc3RTZWxlY3RlZENlbGwueCA9PT0gbmV3U2VsZWN0aW9uLm9yaWdpbi54ICYmIG5ld1NlbGVjdGlvbi5maXJzdFNlbGVjdGVkQ2VsbC55ID09PSBuZXdTZWxlY3Rpb24ub3JpZ2luLnkpXG4gICAgICAgICAgICA/XG4gICAgICAgICAgICAgICAgbmV3U2VsZWN0aW9uLmNvcm5lclxuICAgICAgICAgICAgICAgIDpcbiAgICAgICAgICAgICAgICBuZXdTZWxlY3Rpb24ub3JpZ2luXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9ucy5wdXNoKG5ld1NlbGVjdGlvbik7XG4gICAgICAgIHRoaXMuZmxhdHRlbmVkWC5wdXNoKG5ld1NlbGVjdGlvbi5mbGF0dGVuWEF0KDApKTtcbiAgICAgICAgdGhpcy5mbGF0dGVuZWRZLnB1c2gobmV3U2VsZWN0aW9uLmZsYXR0ZW5ZQXQoMCkpO1xuICAgICAgICB0aGlzLnNldExhc3RTZWxlY3Rpb25UeXBlKCdjZWxsJyk7XG4gICAgICAgIGlmICghc2lsZW50KSB7dGhpcy5ncmlkLnNlbGVjdGlvbkNoYW5nZWQoKTt9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb3ggLSBvcmlnaW4geCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG95IC0gb3JpZ2luIHkgY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBleCAtIGV4dGVudCB4IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZXkgLSBleHRlbnQgeSBjb29yZGluYXRlXG4gICAgICovXG4gICAgdG9nZ2xlU2VsZWN0OiBmdW5jdGlvbihveCwgb3ksIGV4LCBleSkge1xuXG4gICAgICAgIHZhciBzZWxlY3RlZCwgaW5kZXg7XG5cbiAgICAgICAgc2VsZWN0ZWQgPSB0aGlzLnNlbGVjdGlvbnMuZmluZChmdW5jdGlvbihzZWxlY3Rpb24sIGlkeCkge1xuICAgICAgICAgICAgaW5kZXggPSBpZHg7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIHNlbGVjdGlvbi5vcmlnaW4ueCA9PT0gb3ggJiYgc2VsZWN0aW9uLm9yaWdpbi55ID09PSBveSAmJlxuICAgICAgICAgICAgICAgIHNlbGVjdGlvbi5leHRlbnQueCA9PT0gZXggJiYgc2VsZWN0aW9uLmV4dGVudC55ID09PSBleVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHNlbGVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIHRoaXMuZmxhdHRlbmVkWC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgdGhpcy5mbGF0dGVuZWRZLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB0aGlzLmdyaWQuc2VsZWN0aW9uQ2hhbmdlZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Qob3gsIG95LCBleCwgZXkpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBSZW1vdmUgdGhlIGxhc3Qgc2VsZWN0aW9uIHRoYXQgd2FzIGNyZWF0ZWQuXG4gICAgICovXG4gICAgY2xlYXJNb3N0UmVjZW50U2VsZWN0aW9uOiBmdW5jdGlvbihkb250Q2xlYXJSb3dTZWxlY3Rpb25zKSB7XG4gICAgICAgIGRvbnRDbGVhclJvd1NlbGVjdGlvbnMgPSBkb250Q2xlYXJSb3dTZWxlY3Rpb25zID09PSB0cnVlO1xuICAgICAgICBpZiAoIWRvbnRDbGVhclJvd1NlbGVjdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0QWxsUm93c1NlbGVjdGVkKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb25zLmxlbmd0aCkgeyAtLXRoaXMuc2VsZWN0aW9ucy5sZW5ndGg7IH1cbiAgICAgICAgaWYgKHRoaXMuZmxhdHRlbmVkWC5sZW5ndGgpIHsgLS10aGlzLmZsYXR0ZW5lZFgubGVuZ3RoOyB9XG4gICAgICAgIGlmICh0aGlzLmZsYXR0ZW5lZFkubGVuZ3RoKSB7IC0tdGhpcy5mbGF0dGVuZWRZLmxlbmd0aDsgfVxuICAgICAgICAvL3RoaXMuZ2V0R3JpZCgpLnNlbGVjdGlvbkNoYW5nZWQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGNsZWFyTW9zdFJlY2VudENvbHVtblNlbGVjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuY29sdW1uU2VsZWN0aW9uTW9kZWwuY2xlYXJNb3N0UmVjZW50U2VsZWN0aW9uKCk7XG4gICAgICAgIHRoaXMuc2V0TGFzdFNlbGVjdGlvblR5cGUoJ2NvbHVtbicpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICovXG4gICAgY2xlYXJNb3N0UmVjZW50Um93U2VsZWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5yb3dTZWxlY3Rpb25Nb2RlbC5jbGVhck1vc3RSZWNlbnRTZWxlY3Rpb24oKTtcbiAgICAgICAgdGhpcy5zZXRMYXN0U2VsZWN0aW9uVHlwZSgncm93Jyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBjbGVhclJvd1NlbGVjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMucm93U2VsZWN0aW9uTW9kZWwuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5zZXRMYXN0U2VsZWN0aW9uVHlwZSgncm93Jyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBnZXRTZWxlY3Rpb25zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9ucztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUaGVyZSBhcmUgYWN0aXZlIHNlbGVjdGlvbihzKS5cbiAgICAgKi9cbiAgICBoYXNTZWxlY3Rpb25zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9ucy5sZW5ndGggIT09IDA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBoYXNSb3dTZWxlY3Rpb25zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLnJvd1NlbGVjdGlvbk1vZGVsLmlzRW1wdHkoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGhhc0NvbHVtblNlbGVjdGlvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuY29sdW1uU2VsZWN0aW9uTW9kZWwuaXNFbXB0eSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gU2VsZWN0aW9uIGNvdmVycyBhIHNwZWNpZmljIGNvbHVtbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqL1xuICAgIGlzQ2VsbFNlbGVjdGVkSW5Sb3c6IGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzQ2VsbFNlbGVjdGVkKHRoaXMuZmxhdHRlbmVkWCwgMCwgeSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyBTZWxlY3Rpb24gY292ZXJzIGEgc3BlY2lmaWMgcm93LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICovXG4gICAgaXNDZWxsU2VsZWN0ZWRJbkNvbHVtbjogZnVuY3Rpb24oeCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNDZWxsU2VsZWN0ZWQodGhpcy5mbGF0dGVuZWRZLCB4LCAwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqIEBzdW1tYXJ5IFNlbGVjdGlvbiBxdWVyeSBmdW5jdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVGhlIGdpdmVuIGNlbGwgaXMgc2VsZWN0ZWQgKHBhcnQgb2YgYW4gYWN0aXZlIHNlbGVjdGlvbikuXG4gICAgICogQHBhcmFtIHtSZWN0YW5nbGVbXX0gc2VsZWN0aW9ucyAtIFNlbGVjdGlvbiByZWN0YW5nbGVzIHRvIHNlYXJjaCB0aHJvdWdoLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKi9cbiAgICBpc1NlbGVjdGVkOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0aGlzLmlzQ29sdW1uU2VsZWN0ZWQoeCkgfHxcbiAgICAgICAgICAgIHRoaXMuaXNSb3dTZWxlY3RlZCh5KSB8fFxuICAgICAgICAgICAgdGhpcy5faXNDZWxsU2VsZWN0ZWQodGhpcy5zZWxlY3Rpb25zLCB4LCB5KVxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHhcbiAgICAgKiBAcGFyYW0geVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGlzQ2VsbFNlbGVjdGVkOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc0NlbGxTZWxlY3RlZCh0aGlzLnNlbGVjdGlvbnMsIHgsIHkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHNlbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0geFxuICAgICAqIEBwYXJhbSB5XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaXNDZWxsU2VsZWN0ZWQ6IGZ1bmN0aW9uKHNlbGVjdGlvbnMsIHgsIHkpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICByZXR1cm4gISFzZWxlY3Rpb25zLmZpbmQoZnVuY3Rpb24oc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5yZWN0YW5nbGVDb250YWlucyhzZWxlY3Rpb24sIHgsIHkpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGVtcHR5IG91dCBhbGwgb3VyIHN0YXRlXG4gICAgICpcbiAgICAgKi9cbiAgICBjbGVhcjogZnVuY3Rpb24oZG9udENsZWFyUm93U2VsZWN0aW9ucykge1xuICAgICAgICBkb250Q2xlYXJSb3dTZWxlY3Rpb25zID0gZG9udENsZWFyUm93U2VsZWN0aW9ucyA9PT0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25zLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuZmxhdHRlbmVkWC5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLmZsYXR0ZW5lZFkubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5jb2x1bW5TZWxlY3Rpb25Nb2RlbC5jbGVhcigpO1xuICAgICAgICBpZiAoIWRvbnRDbGVhclJvd1NlbGVjdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0QWxsUm93c1NlbGVjdGVkKGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMucm93U2VsZWN0aW9uTW9kZWwuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgICAgICAvL3RoaXMuZ2V0R3JpZCgpLnNlbGVjdGlvbkNoYW5nZWQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBveCAtIG9yaWdpbiB4IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb3kgLSBvcmlnaW4geSBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGV4IC0gZXh0ZW50IHggY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBleSAtIGV4dGVudCB5IGNvb3JkaW5hdGVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc1JlY3RhbmdsZVNlbGVjdGVkOiBmdW5jdGlvbihveCwgb3ksIGV4LCBleSkge1xuICAgICAgICByZXR1cm4gISF0aGlzLnNlbGVjdGlvbnMuZmluZChmdW5jdGlvbihzZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uLm9yaWdpbi54ID09PSBveCAmJiBzZWxlY3Rpb24ub3JpZ2luLnkgPT09IG95ICYmXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uLmV4dGVudC54ID09PSBleCAmJiBzZWxlY3Rpb24uZXh0ZW50LnkgPT09IGV5XG4gICAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB4XG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgaXNDb2x1bW5TZWxlY3RlZDogZnVuY3Rpb24oeCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2x1bW5TZWxlY3Rpb25Nb2RlbC5pc1NlbGVjdGVkKHgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHlcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbnwqfVxuICAgICAqL1xuICAgIGlzUm93U2VsZWN0ZWQ6IGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWxsUm93c1NlbGVjdGVkIHx8IHRoaXMucm93U2VsZWN0aW9uTW9kZWwuaXNTZWxlY3RlZCh5KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB4MVxuICAgICAqIEBwYXJhbSB4MlxuICAgICAqL1xuICAgIHNlbGVjdENvbHVtbjogZnVuY3Rpb24oeDEsIHgyKSB7XG4gICAgICAgIHRoaXMuY29sdW1uU2VsZWN0aW9uTW9kZWwuc2VsZWN0KHgxLCB4Mik7XG4gICAgICAgIHRoaXMuc2V0TGFzdFNlbGVjdGlvblR5cGUoJ2NvbHVtbicpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICovXG4gICAgc2VsZWN0QWxsUm93czogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5zZXRBbGxSb3dzU2VsZWN0ZWQodHJ1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cblxuICAgIHNldEFsbFJvd3NTZWxlY3RlZDogZnVuY3Rpb24oaXNJdCkge1xuICAgICAgICB0aGlzLmFsbFJvd3NTZWxlY3RlZCA9IGlzSXQ7XG4gICAgfSxcblxuICAgIGFyZUFsbFJvd3NTZWxlY3RlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFsbFJvd3NTZWxlY3RlZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB5MVxuICAgICAqIEBwYXJhbSB5MlxuICAgICAqL1xuICAgIHNlbGVjdFJvdzogZnVuY3Rpb24oeTEsIHkyKSB7XG4gICAgICAgIHRoaXMucm93U2VsZWN0aW9uTW9kZWwuc2VsZWN0KHkxLCB5Mik7XG4gICAgICAgIHRoaXMuc2V0TGFzdFNlbGVjdGlvblR5cGUoJ3JvdycpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHgxXG4gICAgICogQHBhcmFtIHgyXG4gICAgICovXG4gICAgZGVzZWxlY3RDb2x1bW46IGZ1bmN0aW9uKHgxLCB4Mikge1xuICAgICAgICB0aGlzLmNvbHVtblNlbGVjdGlvbk1vZGVsLmRlc2VsZWN0KHgxLCB4Mik7XG4gICAgICAgIHRoaXMuc2V0TGFzdFNlbGVjdGlvblR5cGUoJ2NvbHVtbicpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHkxXG4gICAgICogQHBhcmFtIHkyXG4gICAgICovXG4gICAgZGVzZWxlY3RSb3c6IGZ1bmN0aW9uKHkxLCB5Mikge1xuICAgICAgICB0aGlzLnJvd1NlbGVjdGlvbk1vZGVsLmRlc2VsZWN0KHkxLCB5Mik7XG4gICAgICAgIHRoaXMuc2V0TGFzdFNlbGVjdGlvblR5cGUoJ3JvdycpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZ2V0U2VsZWN0ZWRSb3dzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuYXJlQWxsUm93c1NlbGVjdGVkKCkpIHtcbiAgICAgICAgICAgIHZhciBoZWFkZXJSb3dzID0gdGhpcy5ncmlkLmdldEhlYWRlclJvd0NvdW50KCk7XG4gICAgICAgICAgICB2YXIgcm93Q291bnQgPSB0aGlzLmdyaWQuZ2V0Um93Q291bnQoKSAtIGhlYWRlclJvd3M7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IEFycmF5KHJvd0NvdW50KTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcm93Q291bnQ7IGkrKykge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtpXSA9IGkgKyBoZWFkZXJSb3dzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5yb3dTZWxlY3Rpb25Nb2RlbC5nZXRTZWxlY3Rpb25zKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7KnxBcnJheS5BcnJheS5udW1iZXJ9XG4gICAgICovXG4gICAgZ2V0U2VsZWN0ZWRDb2x1bW5zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sdW1uU2VsZWN0aW9uTW9kZWwuZ2V0U2VsZWN0aW9ucygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgIGlzQ29sdW1uT3JSb3dTZWxlY3RlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5jb2x1bW5TZWxlY3Rpb25Nb2RlbC5pc0VtcHR5KCkgfHwgIXRoaXMucm93U2VsZWN0aW9uTW9kZWwuaXNFbXB0eSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuICAgIGdldEZsYXR0ZW5lZFlzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICB2YXIgc2V0ID0ge307XG4gICAgICAgIHRoaXMuc2VsZWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKHNlbGVjdGlvbikge1xuICAgICAgICAgICAgdmFyIHRvcCA9IHNlbGVjdGlvbi5vcmlnaW4ueTtcbiAgICAgICAgICAgIHZhciBzaXplID0gc2VsZWN0aW9uLmV4dGVudC55ICsgMTtcbiAgICAgICAgICAgIGZvciAodmFyIHIgPSAwOyByIDwgc2l6ZTsgcisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRpID0gciArIHRvcDtcbiAgICAgICAgICAgICAgICBpZiAoIXNldFt0aV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGkpO1xuICAgICAgICAgICAgICAgICAgICBzZXRbdGldID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXN1bHQuc29ydChmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgICAgICByZXR1cm4geCAtIHk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICogQHBhcmFtIG9mZnNldFxuICAgICAqL1xuICAgIHNlbGVjdFJvd3NGcm9tQ2VsbHM6IGZ1bmN0aW9uKG9mZnNldCwgZG9udENsZWFyUm93U2VsZWN0aW9ucykge1xuICAgICAgICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcbiAgICAgICAgZG9udENsZWFyUm93U2VsZWN0aW9ucyA9IGRvbnRDbGVhclJvd1NlbGVjdGlvbnMgPT09IHRydWU7XG5cbiAgICAgICAgdmFyIHNtID0gdGhpcy5yb3dTZWxlY3Rpb25Nb2RlbDtcblxuICAgICAgICBpZiAoIWRvbnRDbGVhclJvd1NlbGVjdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0QWxsUm93c1NlbGVjdGVkKGZhbHNlKTtcbiAgICAgICAgICAgIHNtLmNsZWFyKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNlbGVjdGlvbnMuZm9yRWFjaChmdW5jdGlvbihzZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciB0b3AgPSBzZWxlY3Rpb24ub3JpZ2luLnksXG4gICAgICAgICAgICAgICAgZXh0ZW50ID0gc2VsZWN0aW9uLmV4dGVudC55O1xuICAgICAgICAgICAgdG9wICs9IG9mZnNldDtcbiAgICAgICAgICAgIHNtLnNlbGVjdCh0b3AsIHRvcCArIGV4dGVudCk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICogQHBhcmFtIG9mZnNldFxuICAgICAqL1xuICAgIHNlbGVjdENvbHVtbnNGcm9tQ2VsbHM6IGZ1bmN0aW9uKG9mZnNldCkge1xuICAgICAgICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcblxuICAgICAgICB2YXIgc20gPSB0aGlzLmNvbHVtblNlbGVjdGlvbk1vZGVsO1xuICAgICAgICBzbS5jbGVhcigpO1xuXG4gICAgICAgIHRoaXMuc2VsZWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKHNlbGVjdGlvbikge1xuICAgICAgICAgICAgdmFyIGxlZnQgPSBzZWxlY3Rpb24ub3JpZ2luLngsXG4gICAgICAgICAgICAgICAgZXh0ZW50ID0gc2VsZWN0aW9uLmV4dGVudC54O1xuICAgICAgICAgICAgbGVmdCArPSBvZmZzZXQ7XG4gICAgICAgICAgICBzbS5zZWxlY3QobGVmdCwgbGVmdCArIGV4dGVudCk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHhcbiAgICAgKiBAcGFyYW0geVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGlzSW5DdXJyZW50U2VsZWN0aW9uUmVjdGFuZ2xlOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHZhciBsYXN0ID0gdGhpcy5zZWxlY3Rpb25zW3RoaXMuc2VsZWN0aW9ucy5sZW5ndGggLSAxXTtcbiAgICAgICAgcmV0dXJuIGxhc3QgJiYgdGhpcy5yZWN0YW5nbGVDb250YWlucyhsYXN0LCB4LCB5KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSByZWN0XG4gICAgICogQHBhcmFtIHhcbiAgICAgKiBAcGFyYW0geVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIHJlY3RhbmdsZUNvbnRhaW5zOiBmdW5jdGlvbihyZWN0LCB4LCB5KSB7IC8vVE9ETzogZXhwbG9yZSB3aHkgdGhpcyB3b3JrcyBhbmQgY29udGFpbnMgb24gcmVjdGFuZ2x1bGFyIGRvZXMgbm90XG4gICAgICAgIHZhciBtaW5YID0gcmVjdC5vcmlnaW4ueDtcbiAgICAgICAgdmFyIG1pblkgPSByZWN0Lm9yaWdpbi55O1xuICAgICAgICB2YXIgbWF4WCA9IG1pblggKyByZWN0LmV4dGVudC54O1xuICAgICAgICB2YXIgbWF4WSA9IG1pblkgKyByZWN0LmV4dGVudC55O1xuXG4gICAgICAgIGlmIChyZWN0LmV4dGVudC54IDwgMCkge1xuICAgICAgICAgICAgbWluWCA9IG1heFg7XG4gICAgICAgICAgICBtYXhYID0gcmVjdC5vcmlnaW4ueDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZWN0LmV4dGVudC55IDwgMCkge1xuICAgICAgICAgICAgbWluWSA9IG1heFk7XG4gICAgICAgICAgICBtYXhZID0gcmVjdC5vcmlnaW4ueTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXN1bHQgPVxuICAgICAgICAgICAgeCA+PSBtaW5YICYmXG4gICAgICAgICAgICB5ID49IG1pblkgJiZcbiAgICAgICAgICAgIHggPD0gbWF4WCAmJlxuICAgICAgICAgICAgeSA8PSBtYXhZO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTZWxlY3Rpb25Nb2RlbDtcbiIsIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICpcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IFtjb250YWluaW5nRWw9ZG9jdW1lbnRdXG4gKiBAcGFyYW0ge3N0cmluZ30gW3ByZWZpeD0nJ11cbiAqIEBwYXJhbSB7c3RyaW5nfSBbc2VwYXJhdG9yPScnXVxuICogQHBhcmFtIHtzdHJpbmd9IFtzdWZmaXg9JyddXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbdHJhbnNmb3JtZXI9bXVsdGlMaW5lVHJpbV0gLSBGdW5jdGlvbiB0byB0cmFuc2Zvcm0gZWFjaCBpbnB1dCBjb250cm9sJ3MgdGV4dCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gY29weUFsbChjb250YWluaW5nRWwsIHByZWZpeCwgc2VwYXJhdG9yLCBzdWZmaXgsIHRyYW5zZm9ybWVyKSB7XG4gICAgdmFyIHRleHRzID0gW10sIGxhc3RUZXh0RWwsIHRleHQ7XG5cbiAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKChjb250YWluaW5nRWwgfHwgZG9jdW1lbnQpLnF1ZXJ5U2VsZWN0b3JBbGwoY29weUFsbC5zZWxlY3RvciksIGZ1bmN0aW9uKHRleHRFbCkge1xuICAgICAgICB0ZXh0ID0gKHRyYW5zZm9ybWVyIHx8IG11bHRpTGluZVRyaW0pKHRleHRFbC52YWx1ZSk7XG4gICAgICAgIGlmICh0ZXh0KSB7IHRleHRzLnB1c2godGV4dCk7IH1cbiAgICAgICAgbGFzdFRleHRFbCA9IHRleHRFbDtcbiAgICB9KTtcblxuICAgIGlmIChsYXN0VGV4dEVsKSB7XG4gICAgICAgIGNvcHkobGFzdFRleHRFbCwgKHByZWZpeCB8fCAnJykgKyB0ZXh0cy5qb2luKHNlcGFyYXRvciB8fCAnJykgKyAoc3VmZml4IHx8ICcnKSk7XG4gICAgfVxufVxuXG4vKipcbiAqIDEuIFRyaW0gdGhlIHRleHQgaW4gdGhlIGdpdmVuIGlucHV0IGVsZW1lbnRcbiAqIDIuIHNlbGVjdCBpdFxuICogMy4gY29weSBpdCB0byB0aGUgY2xpcGJvYXJkXG4gKiA0LiBkZXNlbGVjdCBpdFxuICogNS4gcmV0dXJuIGl0XG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fEhUTUxUZXh0QXJlYUVsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge3N0cmluZ30gW3RleHQ9ZWwudmFsdWVdIC0gVGV4dCB0byBjb3B5LlxuICogQHJldHVybnMge3VuZGVmaW5lZHxzdHJpbmd9IFRyaW1tZWQgdGV4dCBpbiBlbGVtZW50IG9yIHVuZGVmaW5lZCBpZiB1bmFibGUgdG8gY29weS5cbiAqL1xuZnVuY3Rpb24gY29weShlbCwgdGV4dCkge1xuICAgIHZhciByZXN1bHQsIHRleHRXYXM7XG5cbiAgICBpZiAodGV4dCkge1xuICAgICAgICB0ZXh0V2FzID0gZWwudmFsdWU7XG4gICAgICAgIGVsLnZhbHVlID0gdGV4dDtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0ZXh0ID0gZWwudmFsdWU7XG4gICAgfVxuXG4gICAgZWwudmFsdWUgPSBtdWx0aUxpbmVUcmltKHRleHQpO1xuXG4gICAgdHJ5IHtcbiAgICAgICAgZWwuc2VsZWN0KCk7XG4gICAgICAgIHJlc3VsdCA9IGRvY3VtZW50LmV4ZWNDb21tYW5kKCdjb3B5Jyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmICh0ZXh0V2FzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGVsLnZhbHVlID0gdGV4dFdhcztcbiAgICAgICAgfVxuICAgICAgICBlbC5ibHVyKCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIG11bHRpTGluZVRyaW0ocykge1xuICAgIHJldHVybiBzLnJlcGxhY2UoL15cXHMqKC4qPylcXHMqJC8sICckMScpO1xufVxuXG5jb3B5LmFsbCA9IGNvcHlBbGw7XG5jb3B5Lm11bHRpTGluZVRyaW0gPSBtdWx0aUxpbmVUcmltO1xuY29weS5zZWxlY3RvclRleHRDb250cm9scyA9ICdpbnB1dDpub3QoW3R5cGVdKSwgaW5wdXRbdHlwZT10ZXh0XSwgdGV4dGFyZWEnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcHk7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIGNvbnNvbGUud2FybiBwb2x5ZmlsbCBhcyBuZWVkZWRcbi8vIHVzZWQgZm9yIGRlcHJlY2F0aW9uIHdhcm5pbmdzXG5pZiAoIWNvbnNvbGUud2Fybikge1xuICAgIGNvbnNvbGUud2FybiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBbJ1dBUk5JTkc6J10uY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbiAgICB9O1xufVxuXG52YXIgd2FybmVkID0ge307XG5cbnZhciByZWdleElzTWV0aG9kID0gL1xcKSQvO1xuXG4vKipcbiAqIFVzZXIgaXMgd2FybmVkIGFuZCBuZXcgcHJvcGVydHkgaXMgcmV0dXJuZWQgb3IgbmV3IG1ldGhvZCBpcyBjYWxsZWQgYW5kIHRoZSByZXN1bHQgaXMgcmV0dXJuZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kTmFtZSAtIERlcHJlY2F0ZWQgbWV0aG9kIG5hbWUgd2l0aCBwYXJlbnRoZXNlcyAocmVxdWlyZWQpIGNvbnRhaW5pbmcgYXJndW1lbnQgbGlzdCAob3B0aW9uYWwpLlxuICogQHBhcmFtIHtzdHJpbmd9IGRvdFByb3BzIC0gRG90LXNlcGFyYXRlZCBuZXcgcHJvcGVydHkgbmFtZSB0byBpbnZva2Ugb3IgbWV0aG9kIG5hbWUgdG8gY2FsbC4gTWV0aG9kIG5hbWVzIGFyZSBpbmRpY2F0ZWQgYnkgaW5jbHVkaW5nIHBhcmVudGhlc2VzIHdpdGggb3B0aW9uYWwgYXJndW1lbnQgbGlzdC4gVGhlIGFyZ3VtZW50cyBpbiBlYWNoIGxpc3QgYXJlIGRyYXduIGZyb20gdGhlIGFyZ3VtZW50cyBwcmVzZW50ZWQgaW4gdGhlIGBtZXRob2ROYW1lYCBwYXJhbWV0ZXIuXG4gKiBAcGFyYW0ge3N0cmluZ30gc2luY2UgLSBWZXJzaW9uIGluIHdoaWNoIHRoZSBuYW1lIHdhcyBkZXByZWNhdGVkLlxuICogQHBhcmFtIHtBcmd1bWVudHN8QXJyYXl9IFthcmdzXSAtIEFjdHVhbCBhcmd1bWVudHMuIE9ubHkgbmVlZGVkIHdoZW4gYXJndW1lbnRzIGFyZSBsaXN0ZWQgaW4gYG1ldGhvZE5hbWVgLiBUaGUgb3JkZXIgb2YgdGhlIGFyZ3VtZW50cyBtdXN0IG1hdGNoLlxuICogQHBhcmFtIHtzdHJpbmd9IFtub3Rlc10gLSBOb3RlcyB0byBhZGQgdG8gbWVzc2FnZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm4gdmFsdWUgb2YgbmV3IHByb3BlcnR5IG9yIG1ldGhvZCBjYWxsLlxuICovXG52YXIgZGVwcmVjYXRlZCA9IGZ1bmN0aW9uKG1ldGhvZE5hbWUsIGRvdFByb3BzLCBzaW5jZSwgYXJncywgbm90ZXMpIHtcbiAgICBpZiAoIXJlZ2V4SXNNZXRob2QudGVzdChtZXRob2ROYW1lKSkge1xuICAgICAgICB0aHJvdyAnRXhwZWN0ZWQgbWV0aG9kIG5hbWUgdG8gaGF2ZSBwYXJlbnRoZXNlcy4nO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgYXJncyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gYGFyZ3NgIG9taXR0ZWRcbiAgICAgICAgbm90ZXMgPSBhcmdzO1xuICAgICAgICBhcmdzID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHZhciBjaGFpbiA9IGRvdFByb3BzLnNwbGl0KCcuJyksXG4gICAgICAgIGZvcm1hbEFyZ0xpc3QgPSBhcmdMaXN0KG1ldGhvZE5hbWUpLFxuICAgICAgICByZXN1bHQgPSB0aGlzO1xuXG4gICAgaWYgKCEobWV0aG9kTmFtZSBpbiB3YXJuZWQpKSB7XG4gICAgICAgIHdhcm5lZFttZXRob2ROYW1lXSA9IGRlcHJlY2F0ZWQud2FybmluZ3M7XG4gICAgfVxuICAgIGlmICh3YXJuZWRbbWV0aG9kTmFtZV0pIHtcbiAgICAgICAgdmFyIG1lbWJlclR5cGUgPSByZWdleElzTWV0aG9kLnRlc3QoZG90UHJvcHMpID8gJ21ldGhvZCcgOiAncHJvcGVydHknO1xuICAgICAgICB2YXIgd2FybmluZyA9ICdUaGUgLicgKyBtZXRob2ROYW1lICsgJyBtZXRob2QgaXMgZGVwcmVjYXRlZCBhcyBvZiB2JyArIHNpbmNlICtcbiAgICAgICAgICAgICcgaW4gZmF2b3Igb2YgdGhlIC4nICsgY2hhaW4uam9pbignLicpICsgJyAnICsgbWVtYmVyVHlwZSArICcuJyArXG4gICAgICAgICAgICAnIChXaWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgcmVsZWFzZS4pJztcblxuICAgICAgICBpZiAobm90ZXMpIHtcbiAgICAgICAgICAgIHdhcm5pbmcgKz0gJyAnICsgbm90ZXM7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zb2xlLndhcm4od2FybmluZyk7XG5cbiAgICAgICAgLS13YXJuZWRbbWV0aG9kTmFtZV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFwVG9Gb3JtYWxBcmcoYXJnTmFtZSkge1xuICAgICAgICB2YXIgaW5kZXggPSBmb3JtYWxBcmdMaXN0LmluZGV4T2YoYXJnTmFtZSk7XG4gICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRocm93ICdBY3R1YWwgYXJnIFwiJyArIGFyZ05hbWUgKyAnXCIgbm90IGZvdW5kIGluIGZvcm1hbCBhcmcgbGlzdCAnICsgZm9ybWFsQXJnTGlzdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJnc1tpbmRleF07XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxhc3QgPSBjaGFpbi5sZW5ndGggLSAxOyBpIDw9IGxhc3Q7ICsraSkge1xuICAgICAgICB2YXIgbGluayA9IGNoYWluW2ldLFxuICAgICAgICAgICAgYWN0dWFsQXJnTGlzdCA9IHJlZ2V4SXNNZXRob2QudGVzdChsaW5rKSA/IGFyZ0xpc3QobGluaykgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBhY3R1YWxBcmdzID0gW107XG5cbiAgICAgICAgaWYgKGFjdHVhbEFyZ0xpc3QpIHtcbiAgICAgICAgICAgIGFjdHVhbEFyZ3MgPSBhY3R1YWxBcmdMaXN0Lm1hcChtYXBUb0Zvcm1hbEFyZyk7XG4gICAgICAgICAgICBsaW5rID0gbGluay5tYXRjaCgvKFxcdyspLylbMV07XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHRbbGlua10uYXBwbHkocmVzdWx0LCBhY3R1YWxBcmdzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdFtsaW5rXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG5kZXByZWNhdGVkLndhcm5pbmdzID0gNTsgLy8ganVzdCBlbm91Z2ggdG8gYmUgYW5ub3lpbmdcblxuZnVuY3Rpb24gYXJnTGlzdChzKSB7XG4gICAgcmV0dXJuIHMubWF0Y2goL15cXHcrXFwoKC4qKVxcKSQvKVsxXS5tYXRjaCgvKFxcdyspL2cpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGRlcHJlY2F0ZWQ7XG4iLCIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuLyoqIEBtb2R1bGUgZWZmZWN0cyAqL1xuXG4vKiogQHR5cGVkZWYge2Z1bmN0aW9ufSBlZmZlY3RGdW5jdGlvblxuICogQGRlc2MgRWxlbWVudCB0byBwZXJmb3JtIHRyYW5zaXRpb25zIHVwb24gaXMgYG9wdGlvbnMuZWxgIGlmIGRlZmluZWQgb3IgYHRoaXMuZWxgLlxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gW29wdGlvbnMuZWw9dGhpcy5lbF1cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXSBGdW5jdGlvbiB0byBjYWxsIGF0IGNvbmNsdXNpb24gb2YgdHJhbnNpdGlvbnMuXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZHVyYXRpb249JzAuMDY1cyddIC0gRHVyYXRpb24gb2YgZWFjaCB0cmFuc2l0aW9uLlxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zLnN0eWxlcz1kZWZhdWx0R2xvd2VyU3R5bGVzXSAtIEhhc2ggb2YgQ1NTIHN0eWxlcyBhbmQgdmFsdWVzIHRvIHRyYW5zaXRpb24uIChGb3Ige0BsaW5rIGVmZmVjdHN+Z2xvd2VyfGdsb3dlcn0gb25seS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogU2hha2UgZWxlbWVudCBiYWNrIGFuZCBmb3VydGggYSBmZXcgdGltZXMgYXMgaWYgdG8gc2F5LCBcIk5vcGUhXCJcbiAqIEB0eXBlIHtlZmZlY3RGdW5jdGlvbn1cbiAqIEBtZW1iZXJPZiBtb2R1bGU6ZWZmZWN0c1xuICovXG5leHBvcnRzLnNoYWtlciA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgY29udGV4dCA9IHRoaXMsXG4gICAgICAgIGVsID0gb3B0aW9ucy5lbCB8fCBjb250ZXh0LmVsLFxuICAgICAgICBkdXJhdGlvbiA9IG9wdGlvbnMuZHVyYXRpb24gfHwgJzAuMDY1cycsXG4gICAgICAgIGNvbXB1dGVkU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCksXG4gICAgICAgIHRyYW5zaXRpb25zID0gY29tcHV0ZWRTdHlsZS50cmFuc2l0aW9uLnNwbGl0KCcsJyksXG4gICAgICAgIHBvc2l0aW9uID0gY29tcHV0ZWRTdHlsZS5wb3NpdGlvbixcbiAgICAgICAgeCA9IHBhcnNlSW50KGNvbXB1dGVkU3R5bGUubGVmdCksXG4gICAgICAgIGR4ID0gLTMsXG4gICAgICAgIHNoYWtlcyA9IDY7XG5cbiAgICB0cmFuc2l0aW9ucy5wdXNoKCdsZWZ0ICcgKyBkdXJhdGlvbik7XG4gICAgZWwuc3R5bGUudHJhbnNpdGlvbiA9IHRyYW5zaXRpb25zLmpvaW4oJywnKTtcbiAgICBlbC5hZGRFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgc2hha2VyKTtcbiAgICBzaGFrZXIoKTtcbiAgICBmdW5jdGlvbiBzaGFrZXIoZXZlbnQpIHtcbiAgICAgICAgaWYgKCFldmVudCB8fCBldmVudC5wcm9wZXJ0eU5hbWUgPT09ICdsZWZ0Jykge1xuICAgICAgICAgICAgZWwuc3R5bGUubGVmdCA9IHggKyBkeCArICdweCc7XG4gICAgICAgICAgICBpZiAoIXNoYWtlcy0tKSB7XG4gICAgICAgICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIHNoYWtlcik7XG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbnMucG9wKCk7XG4gICAgICAgICAgICAgICAgZWwuc3R5bGUudHJhbnNpdGlvbiA9IHRyYW5zaXRpb25zLmpvaW4oJywnKTtcbiAgICAgICAgICAgICAgICBlbC5zdHlsZS5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuY2FsbGJhY2suY2FsbChjb250ZXh0LCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkeCA9IHNoYWtlcyA/IC1keCA6IDA7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG52YXIgZGVmYXVsdEdsb3dlclN0eWxlcyA9IHtcbiAgICAnYmFja2dyb3VuZC1jb2xvcic6ICd5ZWxsb3cnLFxuICAgICdib3gtc2hhZG93JzogJzAgMCAxMHB4IHJlZCdcbn07XG5cbi8qKlxuICogVHJhbnNpdGlvbiBzdHlsZXMgb24gZWxlbWVudCBmb3IgYSBtb21lbnQgYW5kIHJldmVydCBhcyBpZiB0byBzYXksIFwiV2hvYSEuXCJcbiAqIEB0eXBlIHtlZmZlY3RGdW5jdGlvbn1cbiAqIEBtZW1iZXJPZiBtb2R1bGU6ZWZmZWN0c1xuICovXG5leHBvcnRzLmdsb3dlciA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgY29udGV4dCA9IHRoaXMsXG4gICAgICAgIGVsID0gb3B0aW9ucy5lbCB8fCBjb250ZXh0LmVsLFxuICAgICAgICBkdXJhdGlvbiA9IG9wdGlvbnMuZHVyYXRpb24gfHwgJzAuMjVzJyxcbiAgICAgICAgc3R5bGVzID0gb3B0aW9ucy5zdHlsZXMgfHwgZGVmYXVsdEdsb3dlclN0eWxlcyxcbiAgICAgICAgdmFsdWVzID0gc3R5bGVzLmxlbmd0aCxcbiAgICAgICAgY29tcHV0ZWRTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKSxcbiAgICAgICAgc3R5bGVXYXMgPSB7fSxcbiAgICAgICAgdHJhbnNpdGlvbiA9IGNvbXB1dGVkU3R5bGUudHJhbnNpdGlvbixcbiAgICAgICAgdHJhbnNpdGlvbnMgPSB0cmFuc2l0aW9uLnNwbGl0KCcsJyk7XG5cbiAgICBPYmplY3Qua2V5cyhzdHlsZXMpLmZvckVhY2goZnVuY3Rpb24oc3R5bGUpIHtcbiAgICAgICAgc3R5bGVXYXNbc3R5bGVdID0ge1xuICAgICAgICAgICAgc3R5bGU6IGNvbXB1dGVkU3R5bGVbc3R5bGVdLFxuICAgICAgICAgICAgdW5kbzogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICB0cmFuc2l0aW9ucy5wdXNoKHN0eWxlICsgJyAnICsgZHVyYXRpb24pO1xuICAgIH0pO1xuXG4gICAgZWwuc3R5bGUudHJhbnNpdGlvbiA9IHRyYW5zaXRpb25zLmpvaW4oJywnKTtcbiAgICBlbC5hZGRFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgZ2xvd2VyKTtcbiAgICBPYmplY3Qua2V5cyhzdHlsZXMpLmZvckVhY2goZnVuY3Rpb24oc3R5bGUpIHtcbiAgICAgICAgZWwuc3R5bGVbc3R5bGVdID0gc3R5bGVzW3N0eWxlXTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGdsb3dlcihldmVudCkge1xuICAgICAgICB2YXIgd2FzID0gc3R5bGVXYXNbZXZlbnQucHJvcGVydHlOYW1lXTtcbiAgICAgICAgaWYgKHdhcy51bmRvKSB7XG4gICAgICAgICAgICBlbC5zdHlsZVtldmVudC5wcm9wZXJ0eU5hbWVdID0gd2FzLnN0eWxlO1xuICAgICAgICAgICAgd2FzLnVuZG8gPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmICghLS12YWx1ZXMpIHtcbiAgICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCBnbG93ZXIpO1xuICAgICAgICAgICAgZWwuc3R5bGUudHJhbnNpdGlvbiA9IHRyYW5zaXRpb247XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5jYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuY2FsbGJhY2suY2FsbChjb250ZXh0LCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG4iLCIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cy5lYWNoID0gZnVuY3Rpb24oc2VsZWN0b3IsIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwoKGNvbnRleHQgfHwgZG9jdW1lbnQpLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpLCBpdGVyYXRlZSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5maW5kID0gZnVuY3Rpb24oc2VsZWN0b3IsIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5maW5kLmNhbGwoKGNvbnRleHQgfHwgZG9jdW1lbnQpLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpLCBpdGVyYXRlZSk7XG59O1xuIiwiLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEhUVFBfU1RBVEVfRE9ORSA9IDQsXG4gICAgSFRUUF9TVEFUVVNfT0sgPSAyMDA7XG5cbm1vZHVsZS5leHBvcnRzLmdldCA9IGZ1bmN0aW9uKHVybCwgY2FsbGJhY2spIHtcbiAgICB2YXIgaHR0cFJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuICAgIGh0dHBSZXF1ZXN0Lm9wZW4oJ0dFVCcsIHVybCwgdHJ1ZSk7XG5cbiAgICBodHRwUmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgaHR0cFJlcXVlc3QucmVhZHlTdGF0ZSA9PT0gSFRUUF9TVEFURV9ET05FICYmXG4gICAgICAgICAgICBodHRwUmVxdWVzdC5zdGF0dXMgPT09IEhUVFBfU1RBVFVTX09LXG4gICAgICAgICkge1xuICAgICAgICAgICAgY2FsbGJhY2soSlNPTi5wYXJzZShodHRwUmVxdWVzdC5yZXNwb25zZVRleHQpKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBodHRwUmVxdWVzdC5zZW5kKG51bGwpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuTWF0aC5zaWduID0gTWF0aC5zaWduIHx8IGZ1bmN0aW9uKHgpIHtcbiAgICB4ID0gK3g7IC8vIGNvbnZlcnQgdG8gYSBudW1iZXJcbiAgICBpZiAoeCA9PT0gMCB8fCBpc05hTih4KSkge1xuICAgICAgICByZXR1cm4geDtcbiAgICB9XG4gICAgcmV0dXJuIHggPiAwID8gMSA6IC0xO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gUXVldWVsZXNzKGVsZW1lbnQsIGNvbnRleHQpIHtcbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy50cmFuc2l0aW9uaW5nID0gZmFsc2U7XG59XG5cblF1ZXVlbGVzcy5wcm90b3R5cGUuYmVnaW4gPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHRoaXMudHJhbnNpdGlvbmluZyA9IHRydWU7XG5cbiAgICB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIGZ1bmN0aW9uIGVuZCh0cmFuc0V2ZW50KSB7XG4gICAgICAgIHNlbGYuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgZW5kKTtcblxuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwodGhpcywgdHJhbnNFdmVudCwgc2VsZik7XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLnRyYW5zaXRpb25pbmcgPSBmYWxzZTtcbiAgICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUXVldWVsZXNzO1xuIiwiLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGF1dG9tYXQgPSByZXF1aXJlKCdhdXRvbWF0Jyk7XG5cbnZhciBjc3MgPSByZXF1aXJlKCcuLi8uLi9jc3MnKTtcblxuLy8gbm90ZSB0aGUgcG9zaXRpb24gb2YgdGhlICBmaXJzdCBcIm5hdHVyYWxcIiBzdHlsZXNoZWV0LiBXZSB3aWxsIGluc2VydCBvdXIgc3R5bGVzaGVldHMgYmVmb3JlIHRoaXMgbm9kZS5cbnZhciBoZWFkID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignaGVhZCcpO1xudmFyIHJlZk5vZGUgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChoZWFkLmNoaWxkcmVuKS5maW5kKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgcmV0dXJuIGNoaWxkLnRhZ05hbWUgPT09ICdTVFlMRScgfHxcbiAgICAgICAgY2hpbGQudGFnTmFtZSA9PT0gJ0xJTksnICYmXG4gICAgICAgIGNoaWxkLmdldEF0dHJpYnV0ZSgncmVsJykgPT09ICdzdHlsZXNoZWV0JyAmJlxuICAgICAgICBjaGlsZC5nZXRBdHRyaWJ1dGUoJ3R5cGUnKSA9PT0gJ3RleHQvY3NzJztcbn0pO1xuXG5leHBvcnRzLnByZWZpeCA9ICdpbmplY3RlZC1zdHlsZXNoZWV0LSc7XG5cbmV4cG9ydHMuaW5qZWN0ID0gZnVuY3Rpb24oaWQsIHJlcGxhY2VtZW50cykge1xuICAgIHZhciBzdHlsZXNoZWV0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignIycgKyB0aGlzLnByZWZpeCArIGlkKTtcblxuICAgIGlmICghc3R5bGVzaGVldCkge1xuICAgICAgICBzdHlsZXNoZWV0ID0gY3NzW2lkXTtcbiAgICAgICAgc3R5bGVzaGVldCA9ICc8c3R5bGU+XFxuJyArIHN0eWxlc2hlZXQgKyAnXFxuPC9zdHlsZT5cXG4nO1xuICAgICAgICB2YXIgYXJncyA9IFtzdHlsZXNoZWV0LCBoZWFkLCByZWZOb2RlXS5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG4gICAgICAgIHN0eWxlc2hlZXQgPSBhdXRvbWF0LmFwcGVuZC5hcHBseShudWxsLCBhcmdzKVswXTtcbiAgICAgICAgc3R5bGVzaGVldC5pZCA9IHRoaXMucHJlZml4ICsgaWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0eWxlc2hlZXQ7XG59O1xuIl19
